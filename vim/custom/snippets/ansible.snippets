priority 50

# THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DON'T MODIFY BY HAND

snippet play "Execute an ansible play"
- hosts: ${1:host_group}
	remote_user: ${2:remote_user}
	tasks:
	$0
endsnippet

snippet elb_instance "De-registers or registers instances from EC2 ELBs" b
- name: $1
	elb_instance:
		instance_id: ${2:# EC2 Instance ID}
		state: ${3:present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# wait_timeout: ${9:0}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${11:yes|no}
		# validate_certs: ${12:#yes|no}
		# enable_availability_zone: ${13:yes|no}
		# ec2_elbs: ${14:# List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.}
$0
endsnippet

snippet elb_classic_lb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	elb_classic_lb_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# names: ${7:# List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet elb_classic_lb "Creates or destroys Amazon ELB." b
- name: $1
	elb_classic_lb:
		name: ${2:# The name of the ELB}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# subnets: ${5:# A list of VPC subnets to use when creating ELB. Zones should be empty if using this.}
		# health_check: ${6:# An associative array of health check configuration settings (see example)}
		# tags: ${7:# An associative array of tags. To delete all tags, supply an empty dict.}
		# purge_subnets: ${8:no}
		# aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# instance_ids: ${10:no}
		# zones: ${11:# List of availability zones to enable on this ELB}
		# idle_timeout: ${12:# ELB connections from clients and to servers are timed out after this amount of time}
		# wait_timeout: ${13:60}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# cross_az_load_balancing: ${15:yes|#no}
		# security_group_ids: ${16:# A list of security groups to apply to the elb}
		# purge_zones: ${17:no}
		# wait: ${18:yes|no}
		# aws_secret_key: ${19:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# purge_instance_ids: ${20:no}
		# connection_draining_timeout: ${21:# Wait a specified timeout allowing connections to drain before terminating an instance}
		# security_token: ${22:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${23:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# listeners: ${24:# List of ports/protocols for this ELB to listen on (see example)}
		# access_logs: ${25:# An associative array of access logs configuration settings (see example)}
		# security_group_names: ${26:# A list of security group names to apply to the elb}
		# purge_listeners: ${27:yes}
		# scheme: ${28:internal|#internet-facing}
		# validate_certs: ${29:#yes|no}
		# stickiness: ${30:# An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )}
$0
endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
- name: $1
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# dns_servers: ${3:# A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)}
		# tags: ${4:# Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)}
		# ntp_servers: ${5:# List of hosts to advertise as NTP servers for the VPC.}
		# netbios_node_type: ${6:# NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# inherit_existing: ${8:no}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# domain_name: ${12:# The domain name to set in the DHCP option sets}
		# delete_old: ${13:yes}
		# state: ${14:absent|#present}
		# vpc_id: ${15:# VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.}
		# validate_certs: ${16:#yes|no}
		# dhcp_options_id: ${17:# The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)}
		# netbios_name_servers: ${18:# List of hosts to advertise as NetBIOS servers.}
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# dhcp_options_ids: ${7:# Get details of specific DHCP Option ID}
		# filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet aws_s3 "manage objects in S3." b
- name: $1
	aws_s3:
		mode: ${2:get|put|delete|create|geturl|getstr|delobj|list}
		bucket: ${3:# Bucket name.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# permission: ${5:private}
		# dest: ${6:# The destination file path when downloading an object/key with a GET operation.}
		# max_keys: ${7:1000}
		# object: ${8:# Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.}
		# prefix: ${9:}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# marker: ${11:# Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.}
		# ignore_nonexistent_bucket: ${12:# Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.}
		# overwrite: ${13:always}
		# aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
		# src: ${15:# The source file path when performing a PUT operation.}
		# aws_access_key: ${16:# AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
		# encrypt: ${17:yes}
		# security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# rgw: ${19:no}
		# region: ${20:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.}
		# retries: ${21:0}
		# headers: ${22:# Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
		# version: ${23:# Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.}
		# expiration: ${24:600}
		# s3_url: ${25:# S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS}
		# validate_certs: ${26:#yes|no}
		# metadata: ${27:# Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
$0
endsnippet

snippet aws_api_gateway "Manage AWS API Gateway APIs" b
- name: $1
	aws_api_gateway:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# swagger_file: ${6:# JSON or YAML file containing swagger definitions for API. Exactly one of swagger_file, swagger_text or swagger_dict must be present.}
		# swagger_dict: ${7:# Swagger definitions API ansible dictionary which will be converted to JSON and uploaded.}
		# deploy_desc: ${8:Automatic deployment by Ansible.}
		# api_id: ${9:# The ID of the API you want to manage.}
		# state: ${10:#present|absent}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# swagger_text: ${12:# Swagger definitions for API in JSON or YAML as a string direct from playbook.}
		# validate_certs: ${13:#yes|no}
		# stage: ${14:# The name of the stage the API should be deployed to.}
$0
endsnippet

snippet aws_direct_connect_connection "Creates, deletes, modifies a DirectConnect connection" b
- name: $1
	aws_direct_connect_connection:
		# bandwidth: ${2:1Gbps|10Gbps}
		# name: ${3:# The name of the Direct Connect connection. This is required to create a new connection. To recreate or delete a connection I(name) or I(connection_id) is required.}
		# link_aggregation_group: ${4:# The ID of the link aggregation group you want to associate with the connection. This is optional in case a stand-alone connection is desired.}
		# state: ${5:present|absent}
		# force_update: ${6:# To modify bandwidth or location the connection will need to be deleted and recreated. By default this will not happen - this option must be set to True.}
		# connection_id: ${7:# The ID of the Direct Connect connection. I(name) or I(connection_id) is required to recreate or delete a connection. Modifying attributes of a connection with I(force_update) will result in a new Direct Connect connection ID.}
		# location: ${8:# Where the Direct Connect connection is located. Required when I(state=present).}
$0
endsnippet

snippet aws_direct_connect_link_aggregation_group "Manage Direct Connect LAG bundles." b
- name: $1
	aws_direct_connect_link_aggregation_group:
		# name: ${2:# The name of the Direct Connect link aggregation group.}
		# state: ${3:present|absent}
		# delete_with_disassociation: ${4:# To be used with I(state=absent) to delete connections after disassociating them with the LAG.}
		# force_delete: ${5:# This allows the minimum number of links to be set to 0, any hosted connections disassociated, and any virtual interfaces associated to the LAG deleted.}
		# num_connections: ${6:# The number of connections with which to intialize the link aggregation group.}
		# connection_id: ${7:# A connection ID to link with the link aggregation group upon creation.}
		# bandwidth: ${8:# The bandwidth of the link aggregation group.}
		# wait_timeout: ${9:120}
		# location: ${10:# The location of the link aggregation group.}
		# min_links: ${11:# The minimum number of physical connections that must be operational for the LAG itself to be operational.}
		# link_aggregation_group_id: ${12:# The ID of the Direct Connect link aggregation group.}
		# wait: ${13:# Whether or not to wait for the operation to complete. May be useful when waiting for virtual interfaces to be deleted. May modify the time of waiting with C(wait_timeout).}
$0
endsnippet

snippet aws_kms "Perform various KMS management tasks." b
- name: $1
	aws_kms:
		mode: ${2:#grant|deny}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# role_arn: ${6:# ARN of role to allow/deny access. One of C(role_name) or C(role_arn) are required.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# grant_types: ${9:# List of grants to give to user/role. Likely "role,role grant" or "role,role grant,admin". Required when C(mode=grant).}
		# role_name: ${10:# Role to allow/deny access. One of C(role_name) or C(role_arn) are required.}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# key_arn: ${12:# Full ARN to the key. One of C(key_alias) or C(key_arn) are required.}
		# clean_invalid_entries: ${13:yes}
		# validate_certs: ${14:#yes|no}
		# key_alias: ${15:# Alias label to the key. One of C(key_alias) or C(key_arn) are required.}
$0
endsnippet

snippet aws_s3 "manage objects in S3." b
- name: $1
	aws_s3:
		mode: ${2:get|put|delete|create|geturl|getstr|delobj|list}
		bucket: ${3:# Bucket name.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# permission: ${5:private}
		# dest: ${6:# The destination file path when downloading an object/key with a GET operation.}
		# max_keys: ${7:1000}
		# object: ${8:# Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.}
		# prefix: ${9:}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# marker: ${11:# Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.}
		# ignore_nonexistent_bucket: ${12:# Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.}
		# overwrite: ${13:always}
		# aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
		# src: ${15:# The source file path when performing a PUT operation.}
		# aws_access_key: ${16:# AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
		# encrypt: ${17:yes}
		# security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# rgw: ${19:no}
		# region: ${20:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.}
		# retries: ${21:0}
		# headers: ${22:# Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
		# version: ${23:# Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.}
		# expiration: ${24:600}
		# s3_url: ${25:# S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS}
		# validate_certs: ${26:#yes|no}
		# metadata: ${27:# Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
$0
endsnippet

snippet aws_s3_bucket_facts "Lists S3 buckets in AWS" b
- name: $1
	aws_s3_bucket_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# validate_certs: ${8:#yes|no}
$0
endsnippet

snippet aws_waf_facts "Retrieve facts for WAF ACLs, Rule , Conditions and Filters." b
- name: $1
	aws_waf_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# The name of a Web Application Firewall}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${8:#yes|no}
$0
endsnippet

snippet cloudformation "Create or delete an AWS CloudFormation stack" b
- name: $1
	cloudformation:
		stack_name: ${2:# name of the cloudformation stack}
		state: ${3:# If state is "present", stack will be created.  If state is "present" and if stack exists and template has changed, it will be updated. If state is "absent", stack will be removed.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# disable_rollback: ${5:true|#false}
		# notification_arns: ${6:# The Simple Notification Service (SNS) topic ARNs to publish stack related events.}
		# tags: ${7:# Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.}
		# template_url: ${8:# Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# aws_secret_key: ${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# role_arn: ${12:# The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)}
		# security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# stack_policy: ${14:# the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. (for instance, [allow all updates](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# template_format: ${16:#json|yaml}
		# template_parameters: ${17:{}}
		# validate_certs: ${18:#yes|no}
		# template: ${19:# The local path of the cloudformation template.}
		# changeset_name: ${20:# Name given to the changeset when creating a changeset, only used when create_changeset is true. By default a name prefixed with Ansible-STACKNAME is generated based on input parameters. See the AWS Change Sets docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html)}
		# create_changeset: ${21:no}
$0
endsnippet

snippet cloudformation_facts "Obtain facts about an AWS CloudFormation stack" b
- name: $1
	cloudformation_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# stack_template: ${6:no}
		# all_facts: ${7:no}
		# stack_policy: ${8:no}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# stack_events: ${10:no}
		# stack_name: ${11:# The name or id of the CloudFormation stack. Gathers facts for all stacks by default.}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# stack_resources: ${13:no}
		# validate_certs: ${14:#yes|no}
$0
endsnippet

snippet cloudfront_facts "Obtain facts about an AWS CloudFront distribution" b
- name: $1
	cloudfront_facts:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# list_streaming_distributions: ${3:no}
		# origin_access_identity_config: ${4:no}
		# streaming_distribution_configuration: ${5:no}
		# invalidation: ${6:no}
		# domain_name_alias: ${7:# Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.}
		# list_invalidations: ${8:no}
		# origin_access_identity_id: ${9:# The id of the cloudfront origin access identity to get information about.}
		# list_distributions_by_web_acl_id: ${10:no}
		# origin_access_identity: ${11:no}
		# all_lists: ${12:no}
		# ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# list_distributions: ${14:no}
		# summary: ${15:no}
		# aws_secret_key: ${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# web_acl_id: ${19:# Used with I(list_distributions_by_web_acl_id).}
		# region: ${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# streaming_distribution: ${21:no}
		# distribution_id: ${22:# The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).}
		# distribution_config: ${23:no}
		# invalidation_id: ${24:# The id of the invalidation to get information about. Used with I(invalidation).}
		# distribution: ${25:no}
		# validate_certs: ${26:#yes|no}
		# list_origin_access_identities: ${27:no}
$0
endsnippet

snippet cloudtrail "manage CloudTrail create, delete, update" b
- name: $1
	cloudtrail:
		name: ${2:# Name for the CloudTrail.}
		state: ${3:present|absent|enabled|disabled}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# tags: ${5:{}}
		# kms_key_id: ${6:# Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. This also has the effect of enabling log file encryption.}
		# s3_bucket_name: ${7:# An existing S3 bucket where CloudTrail will deliver log files.}
		# is_multi_region_trail: ${8:no}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# sns_topic_name: ${10:# SNS Topic name to send notifications to when a log file is delivered}
		# s3_key_prefix: ${11:# S3 Key prefix for delivered log files. A trailing slash is not necessary and will be removed.}
		# enable_logging: ${12:yes}
		# aws_secret_key: ${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# enable_log_file_validation: ${14:no}
		# aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# cloudwatch_logs_role_arn: ${17:# Specifies a full ARN for an IAM role that assigns the proper permissions for CloudTrail to create and write to the log group listed below.}
		# region: ${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# include_global_events: ${19:yes}
		# cloudwatch_logs_log_group_arn: ${20:# A full ARN specifying a valid CloudWatch log group to which CloudTrail logs will be delivered. The log group should already exist.}
		# validate_certs: ${21:#yes|no}
$0
endsnippet

snippet cloudwatchevent_rule "Manage CloudWatch Event rules and targets" b
- name: $1
	cloudwatchevent_rule:
		name: ${2:# The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\.\-_A-Za-z0-9]+))}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# role_arn: ${6:# The Amazon Resource Name (ARN) of the IAM role associated with the rule}
		# description: ${7:# A description of the rule}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# event_pattern: ${9:# A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered}
		# schedule_expression: ${10:# A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))}
		# state: ${11:#present|disabled|absent}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
		# targets: ${14:# A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], role_arn: [string], input: [valid JSON string], input_path: [valid JSONPath string], ecs_parameters: {task_definition_arn: [string], task_count: [int]}}). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(role_arn) (optional) is The Amazon Resource Name of the IAM role to be used for this target when the rule is triggered. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form. I(task_definition_arn) [optional] is ecs task definition arn. I(task_count) [optional] is ecs task count.}
$0
endsnippet

snippet data_pipeline "Create and manage AWS Datapipelines" b
- name: $1
	data_pipeline:
		name: ${2:# The name of the Datapipeline to create/modify/delete.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# A dict of key:value pair(s) to add to the pipeline.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${9:#present|absent|active|inactive}
		# objects: ${10:# A list of pipeline object definitions, each of which is a dict that takes the keys C(id), C(name) and C(fields).}
		# values: ${11:# A list of parameter values (dicts) in the pipeline definition. Each dict takes the keys C(id) and C(stringValue) both of which are strings.}
		# timeout: ${12:300}
		# ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# parameters: ${14:# A list of parameter objects (dicts) in the pipeline definition.}
		# validate_certs: ${15:#yes|no}
		# description: ${16:}
$0
endsnippet

snippet dynamodb_table "Create, update or delete AWS Dynamo DB tables." b
- name: $1
	dynamodb_table:
		name: ${2:# Name of the table.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# read_capacity: ${4:1}
		# hash_key_name: ${5:# Name of the hash key.}
		# range_key_type: ${6:#STRING|NUMBER|BINARY}
		# tags: ${7:# a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# range_key_name: ${9:# Name of the range key.}
		# wait_for_active_timeout: ${10:60}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# write_capacity: ${13:1}
		# security_token: ${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# indexes: ${16:[]}
		# state: ${17:#present|absent}
		# validate_certs: ${18:#yes|no}
		# hash_key_type: ${19:#STRING|NUMBER|BINARY}
$0
endsnippet

snippet dynamodb_ttl "set TTL for a given DynamoDB table." b
- name: $1
	dynamodb_ttl:
		attribute_name: ${2:# the name of the Time to Live attribute used to store the expiration time for items in the table}
		table_name: ${3:# name of the DynamoDB table to work on}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${9:#enable|disable}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ec2 "create, terminate, start or stop an instance in ec2" b
- name: $1
	ec2:
		image: ${2:# I(ami) ID to use for the instance}
		instance_type: ${3:# instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)}
		# kernel: ${4:# kernel I(eki) to use for the instance}
		# ramdisk: ${5:# ramdisk I(eri) to use for the instance}
		# user_data: ${6:# opaque blob of data which is made available to the ec2 instance}
		# termination_protection: ${7:yes|no}
		# private_ip: ${8:# the private ip address to assign the instance (from the vpc subnet)}
		# spot_type: ${9:#one-time|persistent}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# id: ${11:# identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances. This identifier is valid for at least 24 hours after the termination of the instance, and should not be reused for another call later on. For details, see the description of client token at U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).}
		# source_dest_check: ${12:yes|no}
		# aws_secret_key: ${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# spot_wait_timeout: ${14:600}
		# monitoring: ${15:yes|no}
		# zone: ${16:# AWS availability zone in which to launch the instance}
		# exact_count: ${17:# An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.}
		# ebs_optimized: ${18:false}
		# state: ${19:#present|absent|running|restarted|stopped}
		# placement_group: ${20:# placement group for the instance when using EC2 Clustered Compute}
		# count_tag: ${21:# Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running. This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with "class=webserver". The specified tag must already exist or be passed in as the 'instance_tags' option.}
		# profile: ${22:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# key_name: ${23:# key pair to use on the instance}
		# spot_launch_group: ${24:# Launch group for spot request, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group)}
		# vpc_subnet_id: ${25:# the subnet ID in which to launch the instance (VPC)}
		# instance_ids: ${26:# list of instance ids, currently used for states: absent, running, stopped}
		# spot_price: ${27:# Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started.}
		# tenancy: ${28:#default|dedicated}
		# assign_public_ip: ${29:yes|no}
		# group: ${30:# security group (or list of groups) to use with the instance}
		# wait: ${31:yes|#no}
		# count: ${32:1}
		# aws_access_key: ${33:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# instance_profile_name: ${34:# Name of the IAM instance profile to use. Boto library must be 2.5.0+}
		# security_token: ${35:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${36:# The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# network_interfaces: ${37:# A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)}
		# instance_initiated_shutdown_behavior: ${38:#stop|terminate}
		# wait_timeout: ${39:300}
		# volumes: ${40:# a list of hash/dictionaries of volumes to add to the new instance; '[{"key":"value", "key":"value"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), iops (int) - device_type is deprecated use volume_type, iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.}
		# instance_tags: ${41:# a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# group_id: ${42:# security group id (or list of ids) to use with the instance}
		# validate_certs: ${43:#yes|no}
$0
endsnippet

snippet ec2_ami "create or destroy an image in ec2" b
- name: $1
	ec2_ami:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# description: ${3:# Human-readable string describing the contents and purpose of the AMI.}
		# tags: ${4:# A dictionary of tags to add to the new image; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# kernel_id: ${5:# The target kernel id of the image to register}
		# launch_permissions: ${6:# Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, "all" is the only acceptable value currently.}
		# image_id: ${7:# Image ID to be deregistered.}
		# no_reboot: ${8:yes|no}
		# wait_timeout: ${9:300}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${11:yes|#no}
		# aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# root_device_name: ${14:# The root device name of the image to register}
		# name: ${15:# The name of the new AMI.}
		# security_token: ${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# delete_snapshot: ${17:yes|#no}
		# region: ${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# instance_id: ${19:# Instance ID to create the AMI from.}
		# state: ${20:absent|#present}
		# architecture: ${21:# The target architecture of the image to register}
		# validate_certs: ${22:#yes|no}
		# virtualization_type: ${23:# The virtualization type of the image to register}
		# device_mapping: ${24:# List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters)}
$0
endsnippet

snippet ec2_ami_copy "copies AMI between AWS regions, return new image id" b
- name: $1
	ec2_ami_copy:
		source_image_id: ${2:# The ID of the AMI in source region that should be copied.}
		source_region: ${3:# The source region the AMI should be copied from.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# description: ${5:# An optional human-readable string describing the contents and purpose of the new AMI.}
		# tags: ${6:# A hash/dictionary of tags to add to the new copied AMI; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# encrypted: ${7:# Whether or not the destination snapshots of the copied AMI should be encrypted.}
		# kms_key_id: ${8:# KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.}
		# wait_timeout: ${9:1200}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${11:yes|#no}
		# aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${14:default}
		# security_token: ${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# validate_certs: ${17:#yes|no}
$0
endsnippet

snippet ec2_ami_find "Searches for AMIs to obtain the AMI ID and other information" b
- name: $1
	ec2_ami_find:
		region: ${2:# The AWS region to use.}
		# sort: ${3:name|description|tag|architecture|block_device_mapping|creationDate|hypervisor|is_public|location|owner_id|platform|root_device_name|root_device_type|state|virtualization_type}
		# no_result_action: ${4:#success|fail}
		# sort_end: ${5:# Which result to end with (when sorting).}
		# sort_order: ${6:#ascending|descending}
		# owner: ${7:# Search AMIs owned by the specified owner}
		# is_public: ${8:yes|no}
		# product_code: ${9:# Marketplace product code to match.}
		# ami_id: ${10:# An AMI ID to match.}
		# name: ${11:# An AMI name to match.}
		# ami_tags: ${12:# A hash/dictionary of tags to match for the AMI.}
		# hypervisor: ${13:# A hypervisor type type to match (e.g. xen).}
		# sort_tag: ${14:# Tag name with which to sort results.}
		# platform: ${15:# Platform type to match.}
		# state: ${16:available}
		# sort_start: ${17:# Which result to start with (when sorting).}
		# architecture: ${18:# An architecture type to match (e.g. x86_64).}
		# virtualization_type: ${19:# Virtualization type to match (e.g. hvm).}
$0
endsnippet

snippet ec2_asg "Create or delete AWS Autoscaling Groups" b
- name: $1
	ec2_asg:
		launch_config_name: ${2:# Name of the Launch configuration to use for the group. See the ec2_lc module for managing these. If unspecified then the current group value will be used.}
		name: ${3:# Unique name for group to be created or deleted}
		# target_group_arns: ${4:# List of target group ARNs to use for the group}
		# default_cooldown: ${5:300 seconds}
		# health_check_period: ${6:500 seconds}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# aws_secret_key: ${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# lc_check: ${9:yes}
		# availability_zones: ${10:# List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.}
		# replace_batch_size: ${11:1}
		# vpc_zone_identifier: ${12:# List of VPC subnets to use}
		# suspend_processes: ${13:[Launch, Terminate, HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions, AddToLoadBalancer}
		# replace_instances: ${14:# List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.}
		# desired_capacity: ${15:# Desired number of instances in group, if unspecified then the current group value will be used.}
		# state: ${16:#present|absent}
		# max_size: ${17:# Maximum number of instances in group, if unspecified then the current group value will be used.}
		# placement_group: ${18:# Physical location of your cluster placement group created in Amazon EC2.}
		# profile: ${19:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# tags: ${20:# A list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.}
		# min_size: ${21:# Minimum number of instances in group, if unspecified then the current group value will be used.}
		# wait_timeout: ${22:300}
		# load_balancers: ${23:# List of ELB names to use for the group}
		# aws_access_key: ${24:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${25:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# replace_all_instances: ${26:no}
		# validate_certs: ${27:#yes|no}
		# region: ${28:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# termination_policies: ${29:OldestInstance|NewestInstance|OldestLaunchConfiguration|ClosestToNextInstanceHour|#Default}
		# health_check_type: ${30:#EC2|ELB}
		# notification_topic: ${31:# A SNS topic ARN to send auto scaling notifications to.}
		# notification_types: ${32:[u'autoscaling:EC2_INSTANCE_LAUNCH', u'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', u'autoscaling:EC2_INSTANCE_TERMINATE', u'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']}
		# wait_for_instances: ${33:yes}
$0
endsnippet

snippet ec2_asg_facts "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS" b
- name: $1
	ec2_asg_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# The prefix or name of the auto scaling group(s) you are searching for.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.
}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_customer_gateway "Manage an AWS customer gateway" b
- name: $1
	ec2_customer_gateway:
		name: ${2:# Name of the customer gateway.}
		ip_address: ${3:# Internet-routable IP address for customers gateway, must be a static address.}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# validate_certs: ${8:#yes|no}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# state: ${11:#present|absent}
		# routing: ${12:static|#dynamic}
		# bgp_asn: ${13:# Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.}
$0
endsnippet

snippet ec2_eip "manages EC2 elastic IP (EIP) addresses." b
- name: $1
	ec2_eip:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# reuse_existing_ip_allowed: ${6:no}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# public_ip: ${8:# The IP address of a previously allocated EIP.}
		# state: ${9:#present|absent}
		# in_vpc: ${10:no}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# private_ip_address: ${12:# The primary or secondary private IP address to associate with the Elastic IP address.}
		# validate_certs: ${13:#yes|no}
		# release_on_disassociation: ${14:no}
		# device_id: ${15:# The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.}
$0
endsnippet

snippet ec2_eni "Create and optionally attach an Elastic Network Interface (ENI) to an instance" b
- name: $1
	ec2_eni:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# description: ${3:# Optional description of the ENI.}
		# ec2_url: ${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# security_groups: ${5:# List of security groups associated with the interface. Only used when state=present. Since version 2.2, you can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.}
		# aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# secondary_private_ip_addresses: ${7:# A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count}
		# aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# subnet_id: ${10:# ID of subnet in which to create the ENI.}
		# validate_certs: ${11:#yes|no}
		# region: ${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# device_index: ${13:0}
		# attached: ${14:yes}
		# force_detach: ${15:no}
		# instance_id: ${16:# Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.}
		# state: ${17:#present|absent}
		# source_dest_check: ${18:# By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.}
		# private_ip_address: ${19:# Private IP address.}
		# secondary_private_ip_address_count: ${20:# The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses}
		# eni_id: ${21:# The ID of the ENI (to modify); if null and state is present, a new eni will be created.}
		# delete_on_termination: ${22:# Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.}
$0
endsnippet

snippet ec2_eni_facts "Gather facts about ec2 ENI interfaces in AWS" b
- name: $1
	ec2_eni_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_group "maintain an ec2 VPC security group." b
- name: $1
	ec2_group:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# rules_egress: ${3:# List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled. Rule Egress sources list support was added in version 2.4.}
		# description: ${4:# Description of the security group. Required when C(state) is C(present).}
		# purge_rules: ${5:true}
		# tags: ${6:# A dictionary of one or more tags to assign to the security group.}
		# rules: ${7:# List of firewall inbound rules to enforce in this group (see example). If none are supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to access itself). Rule sources list support was added in version 2.4. This allows to define multiple sources per source type as well as multiple source types per rule. Prior to 2.4 an individual source is allowed.}
		# purge_tags: ${8:yes|no}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# purge_rules_egress: ${10:true}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${13:# Name of the security group.}
		# security_token: ${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${16:#present|absent}
		# vpc_id: ${17:# ID of the VPC to create the group in.}
		# group_id: ${18:# Id of group to delete (works only with absent).}
		# validate_certs: ${19:#yes|no}
$0
endsnippet

snippet ec2_group_facts "Gather facts about ec2 security groups in AWS." b
- name: $1
	ec2_group_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:{}}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_instance_facts "Gather facts about ec2 instances in AWS" b
- name: $1
	ec2_instance_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# instance_ids: ${7:# If you specify one or more instance IDs, only instances that have the specified IDs are returned.}
		# filters: ${8:{}}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_key "maintain an ec2 key pair." b
- name: $1
	ec2_key:
		name: ${2:# Name of the key pair.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# force: ${6:yes}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# key_material: ${9:# Public key material.}
		# state: ${10:present}
		# wait_timeout: ${11:300}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
		# wait: ${14:no}
$0
endsnippet

snippet ec2_lc "Create or delete AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc:
		name: ${2:# Unique name for configuration}
		instance_type: ${3:# Instance type to use for the instance}
		state: ${4:present|absent}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# kernel_id: ${7:# Kernel id for the EC2 instance}
		# key_name: ${8:# The SSH key name to be used for access to managed instances}
		# ramdisk_id: ${9:# A RAM disk id for the instances.}
		# user_data: ${10:# Opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path).}
		# image_id: ${11:# The AMI unique identifier to be used for the group}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# instance_monitoring: ${13:no}
		# classic_link_vpc_id: ${14:# Id of ClassicLink enabled VPC}
		# security_groups: ${15:# A list of security groups to apply to the instances. Since version 2.4 you can specify either security group names or IDs or a mix.  Previous to 2.4, for VPC instances, specify security group IDs and for EC2-Classic, specify either security group names or IDs.}
		# classic_link_vpc_security_groups: ${16:# A list of security group IDs with which to associate the ClassicLink VPC instances.}
		# aws_secret_key: ${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# spot_price: ${19:# The spot price you are bidding. Only applies for an autoscaling group with spot instances.}
		# instance_profile_name: ${20:# The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.}
		# user_data_path: ${21:# Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data).}
		# region: ${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ebs_optimized: ${23:no}
		# assign_public_ip: ${24:# Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.}
		# instance_id: ${25:# The Id of a running instance to use as a basis for a launch configuration. Can be used in place of image_id and instance_type.}
		# volumes: ${26:# A list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.}
		# vpc_id: ${27:# VPC ID, used when resolving security group names to IDs.}
		# validate_certs: ${28:#yes|no}
		# placement_tenancy: ${29:default}
$0
endsnippet

snippet ec2_lc_facts "Gather facts about AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:[]}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# validate_certs: ${7:#yes|no}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# sort_end: ${9:# Which result to end with (when sorting).}
		# sort: ${10:launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name}
		# sort_start: ${11:# Which result to start with (when sorting).}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# sort_order: ${13:#ascending|descending}
$0
endsnippet

snippet ec2_lc_find "Find AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_find:
		region: ${2:# The AWS region to use.}
		name_regex: ${3:# A Launch Configuration to match}
		# sort_order: ${4:#ascending|descending}
		# limit: ${5:# How many results to show.}
$0
endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
- name: $1
$0
endsnippet

snippet ec2_metric_alarm "Create/update or delete AWS Cloudwatch 'metric alarms'" b
- name: $1
	ec2_metric_alarm:
		name: ${2:# Unique name for the alarm}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# ok_actions: ${5:# A list of the names of action(s) to take when the alarm is in the 'ok' status}
		# description: ${6:# A longer description of the alarm}
		# evaluation_periods: ${7:# The number of times in which the metric is evaluated before final calculation}
		# metric: ${8:# Name of the monitored metric (e.g. CPUUtilization)}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# period: ${10:# The time (in seconds) between metric evaluations}
		# statistic: ${11:SampleCount|Average|Sum|Minimum|Maximum}
		# threshold: ${12:# Sets the min/max bound for triggering the alarm}
		# unit: ${13:Seconds|Microseconds|Milliseconds|Bytes|Kilobytes|Megabytes|Gigabytes|Terabytes|Bits|Kilobits|Megabits|Gigabits|Terabits|Percent|Count|Bytes/Second|Kilobytes/Second|Megabytes/Second|Gigabytes/Second|Terabytes/Second|Bits/Second|Kilobits/Second|Megabits/Second|Gigabits/Second|Terabits/Second|Count/Second|None}
		# aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# comparison: ${15:<=|<|>|>=}
		# alarm_actions: ${16:# A list of the names action(s) taken when the alarm is in the 'alarm' status}
		# dimensions: ${17:# Describes to what the alarm is applied}
		# security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# namespace: ${20:# Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch}
		# insufficient_data_actions: ${21:# A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status}
		# aws_access_key: ${22:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# validate_certs: ${23:#yes|no}
$0
endsnippet

snippet ec2_scaling_policy "Create or delete AWS scaling policies for Autoscaling groups" b
- name: $1
	ec2_scaling_policy:
		name: ${2:# Unique name for the scaling policy}
		asg_name: ${3:# Name of the associated autoscaling group}
		state: ${4:present|absent}
		# aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# adjustment_type: ${10:ChangeInCapacity|ExactCapacity|PercentChangeInCapacity}
		# min_adjustment_step: ${11:# Minimum amount of adjustment when policy is triggered}
		# scaling_adjustment: ${12:# The amount by which the autoscaling group is adjusted by the policy}
		# cooldown: ${13:# The minimum period of time between which autoscaling actions can take place}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${15:#yes|no}
$0
endsnippet

snippet ec2_snapshot "creates a snapshot from an existing volume" b
- name: $1
	ec2_snapshot:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# description: ${3:# description to be applied to the snapshot}
		# snapshot_id: ${4:# snapshot id to remove}
		# wait_timeout: ${5:0}
		# volume_id: ${6:# volume from which to take the snapshot}
		# wait: ${7:yes|no}
		# aws_secret_key: ${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# snapshot_tags: ${11:# a hash/dictionary of tags to add to the snapshot}
		# region: ${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# device_name: ${14:# device name of a mounted volume to be snapshotted}
		# instance_id: ${15:# instance that has the required volume to snapshot mounted}
		# state: ${16:absent|#present}
		# last_snapshot_min_age: ${17:0}
		# validate_certs: ${18:#yes|no}
$0
endsnippet

snippet ec2_snapshot_copy "copies an EC2 snapshot and returns the new Snapshot ID." b
- name: $1
	ec2_snapshot_copy:
		source_region: ${2:# The source region the Snapshot should be copied from.}
		source_snapshot_id: ${3:# The ID of the Snapshot in source region that should be copied.}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# description: ${7:# An optional human-readable string describing purpose of the new Snapshot.}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${9:# A hash/dictionary of tags to add to the new Snapshot; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# encrypted: ${10:no}
		# region: ${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# kms_key_id: ${12:# KMS key id used to encrypt snapshot. If not specified, defaults to EBS Customer Master Key (CMK) for that account.}
		# validate_certs: ${13:#yes|no}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${15:yes|#no}
$0
endsnippet

snippet ec2_snapshot_facts "Gather facts about ec2 volume snapshots in AWS" b
- name: $1
	ec2_snapshot_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# snapshot_ids: ${7:[]}
		# filters: ${8:{}}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# restorable_by_user_ids: ${10:[]}
		# validate_certs: ${11:#yes|no}
		# owner_ids: ${12:[]}
$0
endsnippet

snippet ec2_tag "create and remove tag(s) to ec2 resources." b
- name: $1
	ec2_tag:
		resource: ${2:# The EC2 resource id.}
		tags: ${3:# a hash/dictionary of tags to add to the resource; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${9:#present|absent|list}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ec2_vol "create and attach a volume, return volume id and device map" b
- name: $1
	ec2_vol:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# tags: ${3:{}}
		# encrypted: ${4:no}
		# kms_key_id: ${5:# Specify the id of the KMS key to use.}
		# iops: ${6:100}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# id: ${8:# volume id if you wish to attach an existing volume (requires instance) or remove an existing volume}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${11:# volume Name tag if you wish to attach an existing volume (requires instance)}
		# security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# instance: ${13:# instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.}
		# region: ${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# volume_type: ${15:standard}
		# device_name: ${16:# device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.}
		# volume_size: ${17:# size of volume (in GB) to create.}
		# state: ${18:absent|#present|list}
		# snapshot: ${19:# snapshot ID on which to base the volume}
		# zone: ${20:# zone in which to create the volume, if unset uses the zone the instance is in (if set)}
		# validate_certs: ${21:#yes|no}
		# delete_on_termination: ${22:yes|#no}
$0
endsnippet

snippet ec2_vol_facts "Gather facts about ec2 volumes in AWS" b
- name: $1
	ec2_vol_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# dns_servers: ${3:# A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)}
		# tags: ${4:# Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)}
		# ntp_servers: ${5:# List of hosts to advertise as NTP servers for the VPC.}
		# netbios_node_type: ${6:# NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# inherit_existing: ${8:no}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# domain_name: ${12:# The domain name to set in the DHCP option sets}
		# delete_old: ${13:yes}
		# state: ${14:absent|#present}
		# vpc_id: ${15:# VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.}
		# validate_certs: ${16:#yes|no}
		# dhcp_options_id: ${17:# The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)}
		# netbios_name_servers: ${18:# List of hosts to advertise as NetBIOS servers.}
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# dhcp_options_ids: ${7:# Get details of specific DHCP Option ID}
		# filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_endpoint "Create and delete AWS VPC Endpoints." b
- name: $1
	ec2_vpc_endpoint:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# vpc_endpoint_id: ${3:# One or more vpc endpoint ids to remove from the AWS account}
		# wait_timeout: ${4:320}
		# ec2_url: ${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${6:yes|no}
		# aws_secret_key: ${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# policy_path: ${9:# The path to the properly json formatted policy file, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813) on how to use it properly. Cannot be used with I(policy).}
		# security_token: ${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# service: ${11:# An AWS supported vpc endpoint service. Use the ec2_vpc_endpoint_facts module to describe the supported endpoint services.}
		# region: ${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${13:#present|absent}
		# policy: ${14:# A properly formatted json policy as string, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813). Cannot be used with I(policy_file).}
		# vpc_id: ${15:# Required when creating a VPC endpoint.}
		# client_token: ${16:# Optional client token to ensure idempotency}
		# validate_certs: ${17:#yes|no}
		# route_table_ids: ${18:# List of one or more route table ids to attach to the endpoint. A route is added to the route table with the destination of the endpoint if provided.}
$0
endsnippet

snippet ec2_vpc_endpoint_facts "Retrieves AWS VPC endpoints details using AWS methods." b
- name: $1
	ec2_vpc_endpoint_facts:
		query: ${2:services|endpoints}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# vpc_endpoint_ids: ${6:# Get details of specific endpoint IDs}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html) for possible filters.}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_igw "Manage an AWS VPC Internet gateway" b
- name: $1
	ec2_vpc_igw:
		vpc_id: ${2:# The VPC ID for the VPC in which to manage the Internet Gateway.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# A dict of tags to apply to the internet gateway. Any tags currently applied to the internet gateway and not present here will be removed.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${9:#present|absent}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ec2_vpc_igw_facts "Gather facts about internet gateways in AWS" b
- name: $1
	ec2_vpc_igw_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# internet_gateway_ids: ${6:# Get details of specific Internet Gateway ID. Provide this value as a list.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html) for possible filters.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_nacl "create and delete Network ACLs." b
- name: $1
	ec2_vpc_nacl:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# Tagged name identifying a network ACL.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# subnets: ${7:# The list of subnets that should be associated with the network ACL.}
		# tags: ${8:# Dictionary of tags to look for and apply when creating a network ACL.}
		# ingress: ${9:# List of rules for incoming traffic.}
		# state: ${10:#present|absent}
		# egress: ${11:# A list of rules for outgoing traffic.}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# vpc_id: ${13:# VPC id of the requesting VPC.}
		# validate_certs: ${14:#yes|no}
		# nacl_id: ${15:# NACL id identifying a network ACL.}
$0
endsnippet

snippet ec2_vpc_nacl_facts "Gather facts about Network ACLs in an AWS VPC" b
- name: $1
	ec2_vpc_nacl_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# nacl_ids: ${7:[]}
		# filters: ${8:{}}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_nat_gateway "Manage AWS VPC NAT Gateways." b
- name: $1
	ec2_vpc_nat_gateway:
		# profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# eip_address: ${3:# The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.}
		# if_exist_do_not_create: ${4:no}
		# wait_timeout: ${5:300}
		# ec2_url: ${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# release_eip: ${7:yes}
		# wait: ${8:no}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# nat_gateway_id: ${11:# The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.}
		# security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# allocation_id: ${13:# The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.}
		# subnet_id: ${14:# The id of the subnet to create the NAT Gateway in. This is required with the present option.}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${16:#present|absent}
		# client_token: ${17:# Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.}
		# validate_certs: ${18:#yes|no}
$0
endsnippet

snippet ec2_vpc_nat_gateway_facts "Retrieves AWS VPC Managed Nat Gateway details using AWS methods." b
- name: $1
	ec2_vpc_nat_gateway_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# nat_gateway_ids: ${7:# Get details of specific nat gateway IDs}
		# filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_net "Configure AWS virtual private clouds" b
- name: $1
	ec2_vpc_net:
		cidr_block: ${2:# The CIDR of the VPC}
		name: ${3:# The name to give your VPC. This is used in combination with the cidr_block parameter to determine if a VPC already exists.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# tags: ${5:# The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.}
		# dns_support: ${6:yes|no}
		# multi_ok: ${7:no}
		# tenancy: ${8:#default|dedicated}
		# dns_hostnames: ${9:yes|no}
		# aws_secret_key: ${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# state: ${15:#present|absent}
		# validate_certs: ${16:#yes|no}
		# dhcp_opts_id: ${17:# the id of the DHCP options to use for this vpc}
$0
endsnippet

snippet ec2_vpc_net_facts "Gather facts about ec2 VPCs in AWS" b
- name: $1
	ec2_vpc_net_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_peer "create, delete, accept, and reject VPC peering connections between two VPCs." b
- name: $1
	ec2_vpc_peer:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# peering_id: ${5:# Peering connection id.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# Dictionary of tags to look for and apply when creating a Peering Connection.}
		# peer_vpc_id: ${8:# VPC id of the accepting VPC.}
		# peer_owner_id: ${9:# The AWS account number for cross account peering.}
		# state: ${10:#present|absent|accept|reject}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# vpc_id: ${12:# VPC id of the requesting VPC.}
		# validate_certs: ${13:#yes|no}
$0
endsnippet

snippet ec2_vpc_peering_facts "Retrieves AWS VPC Peering details using AWS methods." b
- name: $1
	ec2_vpc_peering_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# filters: ${5:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html) for possible filters.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# peer_connection_ids: ${8:# Get details of specific vpc peer IDs}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_route_table "Manage route tables for AWS virtual private clouds" b
- name: $1
	ec2_vpc_route_table:
		vpc_id: ${2:# VPC ID of the VPC in which to create the route table.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# subnets: ${4:# An array of subnets to add to this route table. Subnets may be specified by either subnet ID, Name tag, or by a CIDR such as '10.0.0.0/24'.}
		# tags: ${5:# A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }. Tags are used to uniquely identify route tables within a VPC when the route_table_id is not supplied.}
		# purge_subnets: ${6:true}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# route_table_id: ${8:# The ID of the route table to update or delete.}
		# propagating_vgw_ids: ${9:# Enable route propagation from virtual gateways specified by ID.}
		# aws_secret_key: ${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# purge_routes: ${14:true}
		# state: ${15:#present|absent}
		# lookup: ${16:#tag|id}
		# routes: ${17:# List of routes in the route table. Routes are specified as dicts containing the keys 'dest' and one of 'gateway_id', 'instance_id', 'interface_id', or 'vpc_peering_connection_id'. If 'gateway_id' is specified, you can refer to the VPC's IGW by using the value 'igw'. Routes are required for present states.}
		# validate_certs: ${18:#yes|no}
$0
endsnippet

snippet ec2_vpc_route_table_facts "Gather facts about ec2 VPC route tables in AWS" b
- name: $1
	ec2_vpc_route_table_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_subnet "Manage subnets in AWS virtual private clouds" b
- name: $1
	ec2_vpc_subnet:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${6:# A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${8:#present|absent}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# map_public: ${10:no}
		# vpc_id: ${11:# VPC ID of the VPC in which to create the subnet.}
		# cidr: ${12:# The CIDR block for the subnet. E.g. 192.0.2.0/24. Only required when state=present.}
		# az: ${13:# The availability zone for the subnet. Only required when state=present.}
		# validate_certs: ${14:#yes|no}
$0
endsnippet

snippet ec2_vpc_subnet_facts "Gather facts about ec2 VPC subnets in AWS" b
- name: $1
	ec2_vpc_subnet_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${7:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# subnet_ids: ${9:# A list of subnet IDs to gather facts for.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_vgw "Create and delete AWS VPN Virtual Gateways." b
- name: $1
	ec2_vpc_vgw:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# name of the vgw to be created or deleted}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# dictionary of resource tags}
		# validate_certs: ${8:#yes|no}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${10:#present|absent}
		# wait_timeout: ${11:320}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# vpc_id: ${13:# the vpc-id of a vpc to attach or detach}
		# vpn_gateway_id: ${14:# vpn gateway id of an existing virtual gateway}
		# type: ${15:ipsec.1}
$0
endsnippet

snippet ec2_vpc_vgw_facts "Gather facts about virtual gateways in AWS" b
- name: $1
	ec2_vpc_vgw_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# vpn_gateway_ids: ${5:# Get details of a specific Virtual Gateway ID. This value should be provided as a list.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_vpn "Create, modify, and delete EC2 VPN connections." b
- name: $1
	ec2_vpc_vpn:
		# connection_type: ${2:#ipsec.1}
		# customer_gateway_id: ${3:# The ID of the customer gateway.}
		# tags: ${4:# Tags to attach to the VPN connection.}
		# purge_tags: ${5:no}
		# state: ${6:#present|absent}
		# purge_routes: ${7:# Whether or not to delete VPN connections routes that are not specified in the task.}
		# vpn_connection_id: ${8:# The ID of the VPN connection. Required to modify or delete a connection if the filters option does not provide a unique match.}
		# filters: ${9:# An alternative to using vpn_connection_id. If multiple matches are found, vpn_connection_id is required. If one of the following suboptions is a list of items to filter by, only one item needs to match to find the VPN that correlates. e.g. if the filter 'cidr' is ['194.168.2.0/24', '192.168.2.0/24'] and the VPN route only has the destination cidr block of '192.168.2.0/24' it will be found with this filter (assuming there are not multiple VPNs that are matched). Another example, if the filter 'vpn' is equal to ['vpn-ccf7e7ad', 'vpn-cb0ae2a2'] and one of of the VPNs has the state deleted (exists but is unmodifiable) and the other exists and is not deleted, it will be found via this filter. See examples.}
		# routes: ${10:# Routes to add to the connection.}
		# vpn_gateway_id: ${11:# The ID of the virtual private gateway.}
		# static_only: ${12:no}
$0
endsnippet

snippet ec2_win_password "gets the default administrator password for ec2 windows instances" b
- name: $1
	ec2_win_password:
		instance_id: ${2:# The instance id to get the password data from.}
		key_file: ${3:# Path to the file containing the key pair used on the instance.}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# key_passphrase: ${9:# The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) openssl rsa -in current_key -out new_key -des3.}
		# wait_timeout: ${10:120}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
		# wait: ${13:yes|#no}
$0
endsnippet

snippet ecs_attribute "manage ecs attributes" b
- name: $1
	ecs_attribute:
		cluster: ${2:# The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to apply attributes.}
		ec2_instance_id: ${3:# EC2 instance ID of ECS cluster container instance.}
		attributes: ${4:# List of attributes.}
		# aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${10:#present|absent}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet ecs_cluster "create or terminate ecs clusters" b
- name: $1
	ecs_cluster:
		name: ${2:# The cluster name}
		state: ${3:present|absent|has_instances}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# repeat: ${7:# The number of times to wait for the cluster to have an instance}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# delay: ${10:# Number of seconds to wait}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet ecs_ecr "Manage Elastic Container Registry repositories" b
- name: $1
	ecs_ecr:
		name: ${2:# the name of the repository}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# registry_id: ${7:# AWS account id associated with the registry.}
		# delete_policy: ${8:no}
		# force_set_policy: ${9:no}
		# state: ${10:#present|absent}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# policy: ${12:# JSON or dict that represents the new policy}
		# validate_certs: ${13:#yes|no}
$0
endsnippet

snippet ecs_service "create, terminate, start or stop a service in ecs" b
- name: $1
	ecs_service:
		name: ${2:# The name of the service}
		state: ${3:present|absent|deleting}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# repeat: ${5:10}
		# desired_count: ${6:# The count of how many instances of the service. This parameter is required when state=present}
		# cluster: ${7:# The name of the cluster in which the service exists}
		# deployment_configuration: ${8:# Optional parameters that control the deployment_configuration; format is '{"maximum_percent":<integer>, "minimum_healthy_percent":<integer>}}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# load_balancers: ${10:# The list of ELBs defined for this service}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# placement_constraints: ${14:# The placement constraints for the tasks in the service}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# delay: ${16:10}
		# task_definition: ${17:# The task definition the service will run. This parameter is required when state=present}
		# role: ${18:# The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service.}
		# client_token: ${19:# Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.}
		# validate_certs: ${20:#yes|no}
		# placement_strategy: ${21:# The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service}
$0
endsnippet

snippet ecs_service_facts "list or describe services in ecs" b
- name: $1
	ecs_service_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# service: ${6:# The service to get details for (required if details is true)}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# cluster: ${8:default}
		# details: ${9:true|#false}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ecs_task "run, start or stop a task in ecs" b
- name: $1
	ecs_task:
		operation: ${2:run|start|stop}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# task: ${6:# The task to stop}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# count: ${9:# How many new instances to start}
		# started_by: ${10:# A value showing who or what started the task (for informational purposes)}
		# cluster: ${11:# The name of the cluster to run the task on}
		# task_definition: ${12:# The task definition to start or run}
		# container_instances: ${13:# The list of container instances on which to deploy the task}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${15:#yes|no}
		# overrides: ${16:# A dictionary of values to pass to the new instances}
$0
endsnippet

snippet ecs_taskdefinition "register a task definition in ecs" b
- name: $1
	ecs_taskdefinition:
		state: ${2:present|absent}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# family: ${7:# A Name that would be given to the task definition}
		# task_role_arn: ${8:# The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# network_mode: ${10:#bridge|host|none}
		# containers: ${11:# A list of containers definitions}
		# volumes: ${12:# A list of names of volumes to be attached}
		# ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${14:#yes|no}
		# arn: ${15:# The arn of the task description to delete}
		# revision: ${16:# A revision number for the task definition}
$0
endsnippet

snippet efs "create and maintain EFS file systems" b
- name: $1
	efs:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# Creation Token of Amazon EFS file system. Required for create. Either name or ID required for delete.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.}
		# performance_mode: ${8:#general_purpose|max_io}
		# id: ${9:# ID of Amazon EFS. Either name or ID required for delete.}
		# state: ${10:#present|absent}
		# wait_timeout: ${11:0}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
		# targets: ${14:# List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in. - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet. - security_groups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.}
		# wait: ${15:yes|#no}
$0
endsnippet

snippet efs_facts "Get information about Amazon EFS file systems" b
- name: $1
	efs_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# Creation Token of Amazon EFS file system.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# tags: ${8:# List of tags of Amazon EFS. Should be defined as dictionary}
		# validate_certs: ${9:#yes|no}
		# id: ${10:# ID of Amazon EFS.}
		# targets: ${11:# List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - SubnetId - Mandatory. The ID of the subnet to add the mount target in. - IpAddress - Optional. A valid IPv4 address within the address range of the specified subnet. - SecurityGroups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified.}
$0
endsnippet

snippet elasticache "Manage cache clusters in Amazon Elasticache." b
- name: $1
	elasticache:
		name: ${2:# The cache cluster identifier}
		state: ${3:present|absent|rebooted}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# engine: ${5:redis|#memcached}
		# cache_engine_version: ${6:# The version number of the cache engine}
		# aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# node_type: ${8:cache.m1.small}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# security_group_ids: ${10:# A list of vpc security group names to associate with this cache cluster. Only use if inside a vpc}
		# num_nodes: ${11:# The initial number of cache nodes that the cache cluster will have. Required when state=present.}
		# wait: ${12:yes|no}
		# aws_secret_key: ${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# cache_port: ${14:# The port number on which each of the cache nodes will accept connections}
		# zone: ${15:# The EC2 Availability Zone in which the cache cluster will be created}
		# region: ${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# hard_modify: ${17:yes|no}
		# cache_security_groups: ${18:# A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc}
		# cache_subnet_group: ${19:# The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc}
		# security_token: ${20:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# cache_parameter_group: ${21:# The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.}
		# validate_certs: ${22:#yes|no}
$0
endsnippet

snippet elasticache_parameter_group "Manage cache security groups in Amazon Elasticache." b
- name: $1
	elasticache_parameter_group:
		state: ${2:present|absent|reset}
		name: ${3:# A user-specified name for the cache parameter group.}
		# group_family: ${4:memcached1.4|redis2.6|redis2.8|redis3.2}
		# values: ${5:# A user-specified dictionary of parameters to reset or modify for the cache parameter group.}
		# description: ${6:# A user-specified description for the cache parameter group.}
$0
endsnippet

snippet elasticache_snapshot "Manage cache snapshots in Amazon Elasticache." b
- name: $1
	elasticache_snapshot:
		name: ${2:# The name of the snapshot we want to create, copy, delete}
		# state: ${3:present|absent|copy}
		# replication_id: ${4:# The name of the existing replication group to make the snapshot.}
		# cluster_id: ${5:# The name of an existing cache cluster in the replication group to make the snapshot.}
		# bucket: ${6:# The s3 bucket to which the snapshot is exported}
		# target: ${7:# The name of a snapshot copy}
$0
endsnippet

snippet elasticache_subnet_group "manage Elasticache subnet groups" b
- name: $1
	elasticache_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# subnets: ${8:# List of subnet IDs that make up the Elasticache subnet group.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
		# description: ${12:# Elasticache subnet group description. Only set when a new group is added.}
$0
endsnippet

snippet elb_application_lb "Manage an Application load balancer" b
- name: $1
	elb_application_lb:
		name: ${2:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# subnets: ${5:# A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present.}
		# tags: ${6:# A dictionary of one or more tags to assign to the load balancer.}
		# purge_tags: ${7:yes|no}
		# idle_timeout: ${8:60}
		# deletion_protection: ${9:yes|no}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# access_logs_s3_prefix: ${11:# The prefix for the location in the S3 bucket. If you don't specify a prefix, the access logs are stored in the root of the bucket.}
		# security_groups: ${12:[]}
		# access_logs_enabled: ${13:yes|no}
		# aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# access_logs_s3_bucket: ${17:# The name of the S3 bucket for the access logs. This attribute is required if access logs in Amazon S3 are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permission to write to the bucket.}
		# region: ${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# listeners: ${19:# A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.}
		# purge_listeners: ${20:yes|no}
		# scheme: ${21:#internet-facing|internal}
		# validate_certs: ${22:#yes|no}
$0
endsnippet

snippet elb_application_lb_facts "Gather facts about application ELBs in AWS" b
- name: $1
	elb_application_lb_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# names: ${7:# The names of the load balancers.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
		# load_balancer_arns: ${10:# The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load balancers in a single call.}
$0
endsnippet

snippet elb_classic_lb "Creates or destroys Amazon ELB." b
- name: $1
	elb_classic_lb:
		name: ${2:# The name of the ELB}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# subnets: ${5:# A list of VPC subnets to use when creating ELB. Zones should be empty if using this.}
		# health_check: ${6:# An associative array of health check configuration settings (see example)}
		# tags: ${7:# An associative array of tags. To delete all tags, supply an empty dict.}
		# purge_subnets: ${8:no}
		# aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# instance_ids: ${10:no}
		# zones: ${11:# List of availability zones to enable on this ELB}
		# idle_timeout: ${12:# ELB connections from clients and to servers are timed out after this amount of time}
		# wait_timeout: ${13:60}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# cross_az_load_balancing: ${15:yes|#no}
		# security_group_ids: ${16:# A list of security groups to apply to the elb}
		# purge_zones: ${17:no}
		# wait: ${18:yes|no}
		# aws_secret_key: ${19:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# purge_instance_ids: ${20:no}
		# connection_draining_timeout: ${21:# Wait a specified timeout allowing connections to drain before terminating an instance}
		# security_token: ${22:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${23:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# listeners: ${24:# List of ports/protocols for this ELB to listen on (see example)}
		# access_logs: ${25:# An associative array of access logs configuration settings (see example)}
		# security_group_names: ${26:# A list of security group names to apply to the elb}
		# purge_listeners: ${27:yes}
		# scheme: ${28:internal|#internet-facing}
		# validate_certs: ${29:#yes|no}
		# stickiness: ${30:# An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )}
$0
endsnippet

snippet elb_classic_lb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	elb_classic_lb_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# names: ${7:# List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet elb_instance "De-registers or registers instances from EC2 ELBs" b
- name: $1
	elb_instance:
		instance_id: ${2:# EC2 Instance ID}
		state: ${3:present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# wait_timeout: ${9:0}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# wait: ${11:yes|no}
		# validate_certs: ${12:#yes|no}
		# enable_availability_zone: ${13:yes|no}
		# ec2_elbs: ${14:# List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.}
$0
endsnippet

snippet elb_target_group "Manage a target group for an Application load balancer" b
- name: $1
	elb_target_group:
		name: ${2:# The name of the target group.}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# protocol: ${5:http|https}
		# tags: ${6:# A dictionary of one or more tags to assign to the target group.}
		# purge_tags: ${7:yes|no}
		# health_check_port: ${8:The port on which each target receives traffic from the load balancer.}
		# successful_response_codes: ${9:# The HTTP codes to use when checking for a successful response from a target. You can specify multiple values (for example, "200,202") or a range of values (for example, "200-299").
}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# stickiness_type: ${11:lb_cookie}
		# modify_targets: ${12:yes}
		# healthy_threshold_count: ${13:# The number of consecutive health checks successes required before considering an unhealthy target healthy.}
		# targets: ${14:# A list of targets to assign to the target group. This parameter defaults to an empty list. Unless you set the 'modify_targets' parameter then all existing targets will be removed from the group. The list should be an Id and a Port parameter. See the Examples for detail.}
		# health_check_path: ${15:# The ping path that is the destination on the targets for health checks. The path must be defined in order to set a health check.}
		# health_check_protocol: ${16:http|https}
		# aws_secret_key: ${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# unhealthy_threshold_count: ${18:# The number of consecutive health check failures required before considering a target unhealthy.}
		# aws_access_key: ${19:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# health_check_interval: ${20:# The approximate amount of time, in seconds, between health checks of an individual target.}
		# security_token: ${21:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# port: ${23:# The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. Required if I(state) is C(present).}
		# stickiness_lb_cookie_duration: ${24:# The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds).}
		# stickiness_enabled: ${25:yes|no}
		# vpc_id: ${26:# The identifier of the virtual private cloud (VPC). Required when I(state) is C(present).}
		# deregistration_delay_timeout: ${27:# The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds.}
		# validate_certs: ${28:#yes|no}
		# health_check_timeout: ${29:# The amount of time, in seconds, during which no response from a target means a failed health check.}
$0
endsnippet

snippet elb_target_group_facts "Gather facts about ELB target groups in AWS" b
- name: $1
	elb_target_group_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# load_balancer_arn: ${5:# The Amazon Resource Name (ARN) of the load balancer.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# target_group_arns: ${8:# The Amazon Resource Names (ARN) of the target groups.}
		# names: ${9:# The names of the target groups.}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet execute_lambda "Execute an AWS Lambda function" b
- name: $1
	execute_lambda:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# name: ${5:# The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# dry_run: ${7:no}
		# function_arn: ${8:# The name of the function to be invoked}
		# tail_log: ${9:no}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# version_qualifier: ${11:LATEST}
		# validate_certs: ${12:#yes|no}
		# payload: ${13:{}}
		# wait: ${14:yes}
$0
endsnippet

snippet iam "Manage IAM users, groups, roles and keys" b
- name: $1
	iam:
		name: ${2:# Name of IAM resource to create or identify}
		iam_type: ${3:user|group|role}
		state: ${4:present|absent|update}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# new_name: ${6:# When state is update, will replace name with new_name on IAM resource}
		# update_password: ${7:#always|on_create}
		# key_count: ${8:1}
		# access_key_ids: ${9:# A list of the keys that you want impacted by the access_key_state parameter.}
		# groups: ${10:# A list of groups the user should belong to. When update, will gracefully remove groups not listed.}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# path: ${12:/}
		# password: ${13:# When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.}
		# aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# new_path: ${16:# When state is update, will replace the path with new_path on the IAM resource}
		# security_token: ${17:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# trust_policy_filepath: ${18:# The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy).}
		# access_key_state: ${19:create|remove|active|inactive}
		# trust_policy: ${20:# The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath).}
		# validate_certs: ${21:#yes|no}
$0
endsnippet

snippet iam_cert "Manage server certificates for use on ELBs and CloudFront" b
- name: $1
	iam_cert:
		name: ${2:# Name of certificate to add, update or remove.}
		state: ${3:present|absent}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# new_name: ${5:# When state is present, this will update the name of the cert.}
		# dup_ok: ${6:no}
		# key: ${7:# The path to, or content of the private key in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# path: ${9:/}
		# cert_chain: ${10:# The path to, or content of the CA certificate chain in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# new_path: ${13:# When state is present, this will update the path of the cert.}
		# security_token: ${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# cert: ${16:# The path to, or content of the certificate body in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
		# validate_certs: ${17:#yes|no}
$0
endsnippet

snippet iam_group "Manage AWS IAM groups" b
- name: $1
	iam_group:
		name: ${2:# The name of the group to create.}
		state: ${3:present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# purge_users: ${8:no}
		# purge_policy: ${9:no}
		# managed_policy: ${10:# A list of managed policy ARNs or friendly names to attach to the role. To embed an inline policy, use M(iam_policy).}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
		# users: ${13:# A list of existing users to add as members of the group.}
$0
endsnippet

snippet iam_managed_policy "Manage User Managed IAM policies" b
- name: $1
	iam_managed_policy:
		state: ${2:present|absent}
		policy_name: ${3:# The name of the managed policy.}
		# policy_description: ${4:}
		# make_default: ${5:yes}
		# policy: ${6:# A properly json formatted policy}
		# only_version: ${7:no}
$0
endsnippet

snippet iam_mfa_device_facts "List the MFA (Multi-Factor Authentication) devices registered for a user" b
- name: $1
	iam_mfa_device_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# validate_certs: ${6:#yes|no}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# user_name: ${9:# The name of the user whose MFA devices will be listed}
$0
endsnippet

snippet iam_policy "Manage IAM policies for users, groups, and roles" b
- name: $1
	iam_policy:
		iam_name: ${2:# Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.}
		iam_type: ${3:user|group|role}
		policy_name: ${4:# The name label for the policy to create or remove.}
		state: ${5:present|absent}
		# aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# policy_document: ${10:# The path to the properly json formatted policy file (mutually exclusive with C(policy_json))}
		# region: ${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# policy_json: ${12:# A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)}
		# skip_duplicates: ${13:/}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${15:#yes|no}
$0
endsnippet

snippet iam_role "Manage AWS IAM roles" b
- name: $1
	iam_role:
		name: ${2:# The name of the role to create.}
		state: ${3:present|absent}
		managed_policy: ${4:# A list of managed policy ARNs or, since Ansible 2.4, a list of either managed policy ARNs or friendly names. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.}
		# aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# assume_role_policy_document: ${9:# The trust relationship policy document that grants an entity permission to assume the role.  This parameter is required when state: present.}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# path: ${11:/}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet kinesis_stream "Manage a Kinesis Stream." b
- name: $1
	kinesis_stream:
		name: ${2:# The name of the Kinesis Stream you are managing.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${7:# A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# shards: ${9:# The number of shards you want to have with this stream.}
		# retention_period: ${10:# The default retention period is 24 hours and can not be less than 24 hours.}
		# state: ${11:#present|absent}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
		# wait_timeout: ${14:300}
		# wait: ${15:yes}
$0
endsnippet

snippet lambda "Manage AWS Lambda functions" b
- name: $1
	lambda:
		name: ${2:# The name you want to assign to the function you are uploading. Cannot be changed.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# description: ${4:# A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.}
		# s3_key: ${5:# The Amazon S3 object (the deployment package) key name you want to upload}
		# zip_file: ${6:# A .zip file containing your deployment package}
		# s3_object_version: ${7:# The Amazon S3 object (the deployment package) version you want to upload.}
		# memory_size: ${8:128}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# dead_letter_arn: ${10:# The parent object that contains the target Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${15:#present|absent}
		# handler: ${16:# The function within your code that Lambda calls to begin execution}
		# role: ${17:# The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.}
		# timeout: ${18:3}
		# environment_variables: ${19:# A dictionary of environment variables the Lambda function is given.}
		# runtime: ${20:# The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7}
		# validate_certs: ${21:#yes|no}
		# s3_bucket: ${22:# Amazon S3 bucket name where the .zip file containing your deployment package is stored}
		# vpc_subnet_ids: ${23:# List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.}
		# vpc_security_group_ids: ${24:# List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.}
$0
endsnippet

snippet lambda_alias "Creates, updates or deletes AWS Lambda function aliases." b
- name: $1
	lambda_alias:
		name: ${2:# Name of the function alias.}
		state: ${3:#present|absent}
		function_name: ${4:# The name of the function alias.}
		# aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# description: ${8:# A short, user-defined function alias description.}
		# security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# version: ${10:# Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet lambda_event "Creates, updates or deletes AWS Lambda function event mappings." b
- name: $1
	lambda_event:
		source_params: ${2:# Sub-parameters required for event source.}
		lambda_function_arn: ${3:# The name or ARN of the lambda function.}
		alias: ${4:# Name of the function alias. Mutually exclusive with C(version).}
		state: ${5:#present|absent}
		# aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# event_source: ${9:#stream}
		# security_token: ${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# version: ${11:# Version of the Lambda function. Mutually exclusive with C(alias).}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
$0
endsnippet

snippet lambda_facts "Gathers AWS Lambda function details as Ansible facts" b
- name: $1
	lambda_facts:
		query: ${2:aliases|#all|config|mappings|policy|versions}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# event_source_arn: ${6:# For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${9:#yes|no}
		# function_name: ${10:# The name of the lambda function for which facts are requested.}
$0
endsnippet

snippet lambda_policy "Creates, updates or deletes AWS Lambda policy statements." b
- name: $1
	lambda_policy:
		statement_id: ${2:# A unique statement identifier.}
		state: ${3:#present|absent}
		action: ${4:# The AWS Lambda action you want to allow in this statement. Each Lambda action is a string starting with lambda: followed by the API name (see Operations ). For example, lambda:CreateFunction . You can use wildcard (lambda:* ) to grant permission for all AWS Lambda actions.}
		principal: ${5:# The principal who is getting this permission. It can be Amazon S3 service Principal (s3.amazonaws.com ) if you want Amazon S3 to invoke the function, an AWS account ID if you are granting cross-account permission, or any valid AWS service principal such as sns.amazonaws.com . For example, you might want to allow a custom application in another AWS account to push events to AWS Lambda by invoking your function.}
		function_name: ${6:# Name of the Lambda function whose resource policy you are updating by adding a new permission.}
		# profile: ${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# event_source_token: ${8:# Token string representing source ARN or account. Mutually exclusive with C(source_arn) or C(source_account).}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# source_account: ${10:# The AWS account ID (without a hyphen) of the source owner. For example, if the SourceArn identifies a bucket, then this is the bucket owner's account ID. You can use this additional condition to ensure the bucket you specify is owned by a specific account (it is possible the bucket owner deleted the bucket and some other AWS account created the bucket). You can also use this condition to specify all sources (that is, you don't specify the SourceArn ) owned by a specific account.}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# alias: ${14:# Name of the function alias. Mutually exclusive with C(version).}
		# version: ${15:# Version of the Lambda function. Mutually exclusive with C(alias).}
		# source_arn: ${16:# This is optional; however, when granting Amazon S3 permission to invoke your function, you should specify this field with the bucket Amazon Resource Name (ARN) as its value. This ensures that only events generated from the specified bucket can invoke the function.}
		# validate_certs: ${17:#yes|no}
$0
endsnippet

snippet lightsail "Create or delete a virtual machine instance in AWS Lightsail" b
- name: $1
	lightsail:
		name: ${2:# Name of the instance}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# blueprint_id: ${7:# ID of the instance blueprint image. Required when state='present'}
		# wait_timeout: ${8:300}
		# user_data: ${9:# Launch script that can configure the instance with additional data}
		# state: ${10:#present|absent|running|restarted|stopped}
		# key_pair_name: ${11:# Name of the key pair to use with the instance}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# bundle_id: ${13:# Bundle of specification info for the instance. Required when state='present'}
		# zone: ${14:# AWS availability zone in which to launch the instance. Required when state='present'}
		# validate_certs: ${15:#yes|no}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet rds "create, delete, or modify an Amazon rds instance" b
- name: $1
	rds:
		command: ${2:create|replicate|delete|facts|modify|promote|snapshot|reboot|restore}
		region: ${3:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# db_engine: ${5:mariadb|MySQL|oracle-se1|oracle-se2|oracle-se|oracle-ee|sqlserver-ee|sqlserver-se|sqlserver-ex|sqlserver-web|postgres|aurora}
		# iops: ${6:# Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000.}
		# backup_window: ${7:# Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# backup_retention: ${9:# Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.
}
		# port: ${10:3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.}
		# security_groups: ${11:# Comma separated list of one or more security groups.  Used only when command=create or command=modify.}
		# size: ${12:# Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.}
		# aws_secret_key: ${13:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
		# subnet: ${14:# VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.}
		# vpc_security_groups: ${15:# Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.}
		# upgrade: ${16:yes|no}
		# zone: ${17:# availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.}
		# instance_type: ${18:# The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.}
		# source_instance: ${19:# Name of the database to replicate. Used only when command=replicate.}
		# parameter_group: ${20:# Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.}
		# multi_zone: ${21:yes|no}
		# new_instance_name: ${22:# Name to rename an instance to. Used only when command=modify.}
		# username: ${23:# Master database username. Used only when command=create.}
		# tags: ${24:# tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0}
		# db_name: ${25:# Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.}
		# license_model: ${26:license-included|bring-your-own-license|general-public-license|postgresql-license}
		# password: ${27:# Password for the master database username. Used only when command=create or command=modify.}
		# apply_immediately: ${28:yes|no}
		# wait: ${29:yes|#no}
		# aws_access_key: ${30:# AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
		# security_token: ${31:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# force_failover: ${32:yes|#no}
		# validate_certs: ${33:#yes|no}
		# option_group: ${34:# The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.}
		# engine_version: ${35:# Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used}
		# instance_name: ${36:# Database instance identifier. Required except when using command=facts or command=delete on just a snapshot}
		# character_set_name: ${37:# Associate the DB instance with a specified character set. Used with command=create.}
		# wait_timeout: ${38:300}
		# snapshot: ${39:# Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.}
		# publicly_accessible: ${40:# explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0}
		# maint_window: ${41:# Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.
}
$0
endsnippet

snippet rds_param_group "manage RDS parameter groups" b
- name: $1
	rds_param_group:
		name: ${2:# Database parameter group identifier.}
		state: ${3:#present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# tags: ${8:# Dictionary of tags to attach to the parameter group}
		# purge_tags: ${9:# Whether or not to remove tags that do not appear in the I(tags) list. Defaults to false.}
		# region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# immediate: ${11:# Whether to apply the changes immediately, or after the next reboot of any associated instances.}
		# engine: ${12:aurora5.6|mariadb10.0|mariadb10.1|mysql5.1|mysql5.5|mysql5.6|mysql5.7|oracle-ee-11.2|oracle-ee-12.1|oracle-se-11.2|oracle-se-12.1|oracle-se1-11.2|oracle-se1-12.1|postgres9.3|postgres9.4|postgres9.5|postgres9.6|sqlserver-ee-10.5|sqlserver-ee-11.0|sqlserver-ex-10.5|sqlserver-ex-11.0|sqlserver-ex-12.0|sqlserver-se-10.5|sqlserver-se-11.0|sqlserver-se-12.0|sqlserver-web-10.5|sqlserver-web-11.0|sqlserver-web-12.0}
		# params: ${13:# Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.}
		# ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${15:#yes|no}
		# description: ${16:# Database parameter group description. Only set when a new group is added.}
$0
endsnippet

snippet rds_subnet_group "manage RDS database subnet groups" b
- name: $1
	rds_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# subnets: ${8:# List of subnet IDs that make up the database subnet group.}
		# region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${11:#yes|no}
		# description: ${12:# Database subnet group description. Only set when a new group is added.}
$0
endsnippet

snippet redshift "create, delete, or modify an Amazon Redshift instance" b
- name: $1
	redshift:
		command: ${2:create|facts|delete|modify}
		identifier: ${3:# Redshift cluster identifier.}
		# cluster_parameter_group_name: ${4:# name of the cluster parameter group}
		# username: ${5:# Master database username. Used only when command=create.}
		# availability_zone: ${6:# availability zone in which to launch cluster}
		# encrypted: ${7:no}
		# node_type: ${8:ds1.xlarge|ds1.8xlarge|ds2.xlarge|ds2.8xlarge|dc1.large|dc1.8xlarge|dw1.xlarge|dw1.8xlarge|dw2.large|dw2.8xlarge}
		# publicly_accessible: ${9:no}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# port: ${11:# which port the cluster is listining}
		# aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# allow_version_upgrade: ${13:yes}
		# cluster_type: ${14:multi-node|#single-node}
		# final_cluster_snapshot_identifier: ${15:# identifier of the final snapshot to be created before deleting the cluster. If this parameter is provided, final_cluster_snapshot_identifier must be false. Used only when command=delete.}
		# vpc_security_group_ids: ${16:# VPC security group}
		# profile: ${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# new_cluster_identifier: ${18:# Only used when command=modify.}
		# number_of_nodes: ${19:# Number of nodes. Only used when cluster_type=multi-node.}
		# cluster_version: ${20:1.0}
		# db_name: ${21:# Name of the database.}
		# password: ${22:# Master database password. Used only when command=create.}
		# cluster_subnet_group_name: ${23:# which subnet to place the cluster}
		# wait: ${24:yes|#no}
		# aws_access_key: ${25:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${26:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# cluster_security_groups: ${27:# in which security group the cluster belongs}
		# elastic_ip: ${28:# if the cluster has an elastic IP or not}
		# wait_timeout: ${29:300}
		# automated_snapshot_retention_period: ${30:# period when the snapshot take place}
		# validate_certs: ${31:#yes|no}
		# skip_final_cluster_snapshot: ${32:no}
		# preferred_maintenance_window: ${33:# maintenance window}
$0
endsnippet

snippet redshift_facts "Gather facts about Redshift cluster(s)" b
- name: $1
	redshift_facts:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# cluster_identifier: ${5:# The prefix of cluster identifier of the Redshift cluster you are searching for.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# tags: ${9:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the security group(s) you are searching for.}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet redshift_subnet_group "mange Redshift cluster subnet groups" b
- name: $1
	redshift_subnet_group:
		group_name: ${2:# Cluster subnet group name.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# group_subnets: ${8:# List of subnet IDs that make up the cluster subnet group.}
		# group_description: ${9:# Database subnet group description.}
		# validate_certs: ${10:#yes|no}
		# state: ${11:#present|absent}
$0
endsnippet

snippet route53 "add or delete entries in Amazons Route53 DNS service" b
- name: $1
	route53:
		type: ${2:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|NS|SOA}
		record: ${3:# The full DNS record to create or delete}
		state: ${4:present|absent|get|create|delete}
		zone: ${5:# The DNS zone to modify}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# health_check: ${7:# Health check to associate with this record}
		# weight: ${8:# Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.}
		# ttl: ${9:3600 (one hour)}
		# hosted_zone_id: ${10:# The Hosted Zone ID of the DNS zone to modify}
		# wait_timeout: ${11:300}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# overwrite: ${13:# Whether an existing record should be overwritten on create if values do not match}
		# wait: ${14:no}
		# aws_secret_key: ${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# identifier: ${17:# Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.}
		# alias_hosted_zone_id: ${18:# The hosted zone identifier.}
		# security_token: ${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# alias: ${20:True|False}
		# region: ${21:# Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing}
		# retry_interval: ${22:500}
		# private_zone: ${23:no}
		# value: ${24:# The new value when creating a DNS record.  YAML lists or multiple comma-spaced values are allowed for non-alias records.}
		# alias_evaluate_target_health: ${25:no}
		# vpc_id: ${26:# When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.}
		# validate_certs: ${27:#yes|no}
		# failover: ${28:# Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY}
$0
endsnippet

snippet route53_facts "Retrieves route53 details using AWS methods" b
- name: $1
	route53_facts:
		query: ${2:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# resource_id: ${4:# The ID/s of the specified resource/s}
		# hosted_zone_method: ${5:details|#list|list_by_name|count|tags}
		# health_check_method: ${6:#list|details|status|failure_reason|count|tags}
		# delegation_set_id: ${7:# The DNS Zone delegation set ID}
		# hosted_zone_id: ${8:# The Hosted Zone ID of the DNS zone}
		# health_check_id: ${9:# The ID of the health check}
		# ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# aws_secret_key: ${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# start_record_name: ${13:# The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from}
		# type: ${14:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|NS}
		# security_token: ${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# dns_name: ${16:# The first name in the lexicographic ordering of domain names that you want the list_command to start listing from}
		# max_items: ${17:# Maximum number of items to return for various get/list requests}
		# change_id: ${18:# The ID of the change batch request. The value that you specify here is the value that ChangeResourceRecordSets returned in the Id element when you submitted the request.}
		# next_marker: ${19:# Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100 or the number specified by max_items. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results}
		# validate_certs: ${20:#yes|no}
$0
endsnippet

snippet route53_health_check "add or delete health-checks in Amazons Route53 DNS service" b
- name: $1
	route53_health_check:
		request_interval: ${2:10|#30}
		state: ${3:present|absent}
		failure_threshold: ${4:1|2|#3|4|5|6|7|8|9|10}
		type: ${5:HTTP|HTTPS|HTTP_STR_MATCH|HTTPS_STR_MATCH|TCP}
		# profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# ip_address: ${8:# IP address of the end-point to check. Either this or `fqdn` has to be provided.}
		# port: ${9:# The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.}
		# aws_secret_key: ${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# validate_certs: ${13:#yes|no}
		# region: ${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# fqdn: ${15:# Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.}
		# resource_path: ${16:# The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.}
		# string_match: ${17:# If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.}
$0
endsnippet

snippet route53_zone "add or delete Route53 zones" b
- name: $1
	route53_zone:
		zone: ${2:# The DNS zone record (eg: foo.com.)}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# vpc_region: ${7:# The VPC Region the zone should be a part of (if this is going to be a private zone)}
		# region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# comment: ${9:}
		# hosted_zone_id: ${10:# The unique zone identifier you want to delete or "all" if there are many zones with the same domain name. Required if there are multiple zones identified with the above options}
		# state: ${11:present|absent}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# vpc_id: ${13:# The VPC ID the zone should be a part of (if this is going to be a private zone)}
		# validate_certs: ${14:#yes|no}
$0
endsnippet

snippet s3_bucket "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3" b
- name: $1
	s3_bucket:
		name: ${2:# Name of the s3 bucket}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# force: ${4:yes|no}
		# tags: ${5:# tags dict to apply to bucket}
		# ceph: ${6:# Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# requester_pays: ${8:yes|no}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${13:#present|absent}
		# policy: ${14:# The JSON policy as a string.}
		# s3_url: ${15:# S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS}
		# validate_certs: ${16:#yes|no}
		# versioning: ${17:yes|no}
$0
endsnippet

snippet s3_lifecycle "Manage s3 bucket lifecycle rules in AWS" b
- name: $1
	s3_lifecycle:
		name: ${2:# Name of the s3 bucket}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# status: ${4:#enabled|disabled}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# prefix: ${6:# Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket.}
		# ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# expiration_days: ${8:# Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.}
		# aws_secret_key: ${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# transition_days: ${10:# Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.}
		# security_token: ${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# expiration_date: ${12:# Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.
}
		# region: ${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${14:#present|absent}
		# storage_class: ${15:#glacier|standard_ia}
		# validate_certs: ${16:#yes|no}
		# rule_id: ${17:# Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.}
		# transition_date: ${18:# Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required."
}
$0
endsnippet

snippet s3_logging "Manage logging facility of an s3 bucket in AWS" b
- name: $1
	s3_logging:
		name: ${2:# Name of the s3 bucket.}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# target_prefix: ${8:}
		# target_bucket: ${9:# The bucket to log to. Required when state=present.}
		# state: ${10:#present|absent}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet s3_sync "Efficiently upload multiple files to S3" b
- name: $1
	s3_sync:
		file_root: ${2:# File/directory path for synchronization. This is a local path.}
		bucket: ${3:# Bucket name.}
		mode: ${4:#push}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# file_change_strategy: ${6:force|checksum|#date_size}
		# permission: ${7:|private|public-read|public-read-write|authenticated-read|aws-exec-read|bucket-owner-read|bucket-owner-full-control}
		# ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# exclude: ${9:.*}
		# aws_secret_key: ${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# mime_map: ${12:# Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({".txt": "application/text", ".yml": "appication/text"})
}
		# security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# include: ${15:*}
		# validate_certs: ${16:#yes|no}
		# cache_control: ${17:# This is a string.}
		# key_prefix: ${18:# In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary.}
		# delete: ${19:no}
$0
endsnippet

snippet s3_website "Configure an s3 bucket as a website" b
- name: $1
	s3_website:
		name: ${2:# Name of the s3 bucket}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# suffix: ${6:index.html}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# region: ${8:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.
}
		# redirect_all_requests: ${9:# Describes the redirect behavior for every request to this s3 bucket website endpoint}
		# error_key: ${10:# The object key name to use when a 4XX class error occurs. To remove an error key, set to None.}
		# state: ${11:#present|absent}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${13:#yes|no}
$0
endsnippet

snippet sns "Send Amazon Simple Notification Service (SNS) messages" b
- name: $1
	sns:
		topic: ${2:# The topic you want to publish to.}
		msg: ${3:# Default message to send.}
		message_structure: ${4:#json|string}
		# aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
		# http: ${7:# Message to send to HTTP-only subscription}
		# sqs: ${8:# Message to send to SQS-only subscription}
		# region: ${9:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		# sms: ${10:# Message to send to SMS-only subscription}
		# https: ${11:# Message to send to HTTPS-only subscription}
		# message_attributes: ${12:# Dictionary of message attributes. These are optional structured data entries to be sent along to the endpoint.}
		# email: ${13:# Message to send to email-only subscription}
		# subject: ${14:# Subject line for email delivery.}
$0
endsnippet

snippet sns_topic "Manages AWS SNS topics and subscriptions" b
- name: $1
	sns_topic:
		name: ${2:# The name or ARN of the SNS topic to converge}
		# aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# display_name: ${6:# Display name of the topic}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# subscriptions: ${8:[]}
		# delivery_policy: ${9:# Delivery policy to apply to the SNS topic}
		# state: ${10:absent|#present}
		# ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# policy: ${12:# Policy to apply to the SNS topic}
		# purge_subscriptions: ${13:yes}
		# validate_certs: ${14:#yes|no}
$0
endsnippet

snippet sqs_queue "Creates or deletes AWS SQS queues." b
- name: $1
	sqs_queue:
		name: ${2:# Name of the queue.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# message_retention_period: ${4:# The message retention period in seconds.}
		# ec2_url: ${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# delivery_delay: ${6:# The delivery delay in seconds.}
		# receive_message_wait_time: ${7:# The receive message wait time in seconds.}
		# aws_secret_key: ${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# default_visibility_timeout: ${11:# The default visibility timeout in seconds.}
		# validate_certs: ${12:#yes|no}
		# region: ${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# state: ${14:#present|absent}
		# maximum_message_size: ${15:# The maximum message size in bytes.}
		# policy: ${16:# The json dict policy to attach to queue}
		# redrive_policy: ${17:# json dict with the redrive_policy (see example)}
$0
endsnippet

snippet sts_assume_role "Assume a role using AWS Security Token Service and obtain temporary credentials" b
- name: $1
	sts_assume_role:
		role_arn: ${2:# The Amazon Resource Name (ARN) of the role that the caller is assuming (http://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs)}
		role_session_name: ${3:# Name of the role's session - will be used by CloudTrail}
		# aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# duration_seconds: ${8:# The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds.}
		# validate_certs: ${9:#yes|no}
		# region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# mfa_token: ${11:# The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.}
		# ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# policy: ${13:# Supplemental policy to use in addition to assumed role's policies.}
		# external_id: ${14:# A unique identifier that is used by third parties to assume a role in their customers' accounts.}
		# mfa_serial_number: ${15:# he identification number of the MFA device that is associated with the user who is making the AssumeRole call.}
$0
endsnippet

snippet sts_session_token "Obtain a session token from the AWS Security Token Service" b
- name: $1
	sts_session_token:
		# aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		# profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		# aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		# security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		# duration_seconds: ${6:# The duration, in seconds, of the session token. See http://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters for acceptable and default values.}
		# region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		# mfa_token: ${8:# The value provided by the MFA device, if the trust policy of the user requires MFA.}
		# ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		# validate_certs: ${10:#yes|no}
		# mfa_serial_number: ${11:# The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.}
$0
endsnippet

snippet atomic_container "Manage the containers on the atomic host platform" b
- name: $1
	atomic_container:
		state: ${2:#latest|absent|#latest|rollback}
		name: ${3:# Name of the container}
		image: ${4:# The image to use to install the container}
		backend: ${5:docker|ostree}
		mode: ${6:user|system}
		# values: ${7:# Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'. The values specified here will be used at installation time as --set arguments for atomic install.}
		# rootfs: ${8:# Define the rootfs of the image}
$0
endsnippet

snippet atomic_host "Manage the atomic host platform" b
- name: $1
	atomic_host:
		# revision: ${2:latest}
$0
endsnippet

snippet atomic_image "Manage the container images on the atomic host platform" b
- name: $1
	atomic_image:
		name: ${2:# Name of the container image}
		# started: ${3:yes|no}
		# state: ${4:present|absent|#latest}
		# backend: ${5:docker|ostree}
$0
endsnippet

snippet azure_rm_acs "Manage an Azure Container Service Instance (ACS)." b
- name: $1
	azure_rm_acs:
		linux_profile: ${2:# The linux profile suboptions.}
		resource_group: ${3:# Name of a resource group where the Container Services exists or will be created.}
		agent_pool_profiles: ${4:# The agent pool profile suboptions.}
		diagnostics_profile: ${5:no}
		master_profile: ${6:# Master profile suboptions.}
		name: ${7:# Name of the Container Services instance.}
		orchestration_platform: ${8:# Specifies the Container Orchestration Platform to use. Currently can be either DCOS, Kubernetes or Swarm.}
		# profile: ${9:# Security profile found in ~/.azure/credentials file.}
		# tags: ${10:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${11:AzureCloud}
		# secret: ${12:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${13:# Azure client ID. Use when authenticating with a Service Principal.}
		# password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# append_tags: ${16:yes}
		# ad_user: ${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# state: ${18:absent|#present}
		# location: ${19:resource_group location}
		# subscription_id: ${20:# Your Azure subscription Id.}
		# service_principal: ${21:# The service principal suboptions.}
$0
endsnippet

snippet azure_rm_availabilityset "Manage Azure availability set." b
- name: $1
	azure_rm_availabilityset:
		resource_group: ${2:# Name of a resource group where the availability set exists or will be created.}
		name: ${3:# Name of the availability set.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${6:AzureCloud}
		# client_id: ${7:# Azure client ID. Use when authenticating with a Service Principal.}
		# password: ${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# sku: ${10:#Classic|Aligned}
		# append_tags: ${11:yes}
		# ad_user: ${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${13:# Azure client secret. Use when authenticating with a Service Principal.}
		# platform_update_domain_count: ${14:5}
		# platform_fault_domain_count: ${15:3}
		# state: ${16:absent|#present}
		# location: ${17:resource_group location}
		# subscription_id: ${18:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_availabilityset_facts "Get availability set facts." b
- name: $1
	azure_rm_availabilityset_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Limit results to a specific availability set}
		# resource_group: ${4:# The resource group to search for the desired availability set}
		# ad_user: ${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${6:AzureCloud}
		# secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${9:# Your Azure subscription Id.}
		# password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_deployment "Create or destroy Azure Resource Manager template deployments" b
- name: $1
	azure_rm_deployment:
		resource_group_name: ${2:# The resource group name to use or create to host the deployed template}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# deployment_name: ${4:ansible-arm}
		# parameters: ${5:# A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'parameters_link'. Either one of them is required if "state" parameter is "present".}
		# wait_for_deployment_polling_period: ${6:10}
		# ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# wait_for_deployment_completion: ${8:yes|no}
		# template_link: ${9:# Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if "state" parameter is "present".}
		# cloud_environment: ${10:AzureCloud}
		# state: ${11:#present|absent}
		# secret: ${12:# Azure client secret. Use when authenticating with a Service Principal.}
		# location: ${13:westus}
		# client_id: ${14:# Azure client ID. Use when authenticating with a Service Principal.}
		# parameters_link: ${15:# Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if "state" parameter is "present".}
		# subscription_id: ${16:# Your Azure subscription Id.}
		# password: ${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# deployment_mode: ${18:complete|#incremental}
		# tenant: ${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# template: ${20:# A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if "state" parameter is "present".}
$0
endsnippet

snippet azure_rm_dnsrecordset "Create, delete and update DNS record sets and records." b
- name: $1
	azure_rm_dnsrecordset:
		resource_group: ${2:# name of resource group}
		relative_name: ${3:# relative name of the record set}
		record_type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		zone_name: ${5:# name of the existing DNS zone in which to manage the record set}
		# profile: ${6:# Security profile found in ~/.azure/credentials file.}
		# records: ${7:# list of records to be created depending on the type of record (set)}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# time_to_live: ${9:3600}
		# cloud_environment: ${10:AzureCloud}
		# state: ${11:absent|#present}
		# secret: ${12:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${13:# Azure client ID. Use when authenticating with a Service Principal.}
		# record_mode: ${14:append|#purge}
		# subscription_id: ${15:# Your Azure subscription Id.}
		# password: ${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_dnsrecordset_facts "Get DNS Record Set facts." b
- name: $1
	azure_rm_dnsrecordset_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# resource_group: ${3:# Limit results by resource group. Required when filtering by name or type.}
		# ad_user: ${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# top: ${5:100}
		# cloud_environment: ${6:AzureCloud}
		# relative_name: ${7:# Only show results for a Record Set.}
		# record_type: ${8:# Limit record sets by record type.}
		# secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${10:# Azure client ID. Use when authenticating with a Service Principal.}
		# zone_name: ${11:# Limit results by zones. Required when filtering by name or type.}
		# subscription_id: ${12:# Your Azure subscription Id.}
		# password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_dnszone "Manage Azure DNS zones." b
- name: $1
	azure_rm_dnszone:
		name: ${2:# name of the DNS Zone.}
		resource_group: ${3:# name of resource group.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${6:AzureCloud}
		# append_tags: ${7:yes}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${10:absent|#present}
		# client_id: ${11:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${12:# Your Azure subscription Id.}
		# password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_dnszone_facts "Get DNS zone facts." b
- name: $1
	azure_rm_dnszone_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific zone.}
		# resource_group: ${4:# Limit results by resource group. Required when filtering by name.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# cloud_environment: ${6:AzureCloud}
		# append_tags: ${7:yes}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${10:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${11:# Your Azure subscription Id.}
		# password: ${12:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_functionapp "Manage Azure Function Apps" b
- name: $1
	azure_rm_functionapp:
		name: ${2:# Name of the Azure Function App}
		resource_group: ${3:# Name of resource group}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# ad_user: ${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${6:AzureCloud}
		# state: ${7:absent|#present}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_functionapp_facts "Get Azure Function App facts" b
- name: $1
	azure_rm_functionapp_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific Function App}
		# resource_group: ${4:# Limit results to a resource group. Required when filtering by name}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_loadbalancer "Manage Azure load balancers." b
- name: $1
	azure_rm_loadbalancer:
		resource_group: ${2:# Name of a resource group where the load balancer exists or will be created.}
		name: ${3:# Name of the load balancer.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# probe_port: ${5:# The port that the health probe will use.}
		# protocol: ${6:Tcp|Udp}
		# tags: ${7:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		# natpool_protocol: ${10:# The protocol for the NAT pool.}
		# idle_timeout: ${11:4}
		# probe_interval: ${12:15}
		# client_id: ${13:# Azure client ID. Use when authenticating with a Service Principal.}
		# probe_protocol: ${14:Tcp|Http}
		# load_distribution: ${15:Default|SourceIP|SourceIPProtocol}
		# password: ${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# public_ip_address_name: ${18:# Name of an existing public IP address object to associate with the security group.}
		# probe_fail_count: ${19:3}
		# natpool_frontend_port_end: ${20:# End of the port range for a NAT pool.}
		# natpool_backend_port: ${21:# Backend port used by the NAT pool.}
		# append_tags: ${22:yes}
		# cloud_environment: ${23:AzureCloud}
		# natpool_frontend_port_start: ${24:# Start of the port range for a NAT pool.}
		# state: ${25:absent|#present}
		# frontend_port: ${26:# Frontend port that will be exposed for the load balancer.}
		# backend_port: ${27:# Backend port that will be exposed for the load balancer.}
		# probe_request_path: ${28:# The URL that an HTTP probe will use (only relevant if probe_protocol is set to Http).}
		# subscription_id: ${29:# Your Azure subscription Id.}
		# location: ${30:resource_group location}
$0
endsnippet

snippet azure_rm_loadbalancer_facts "Get load balancer facts." b
- name: $1
	azure_rm_loadbalancer_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Limit results to a specific resource group.}
		# resource_group: ${4:# The resource group to search for the desired load balancer}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_managed_disk "Manage Azure Manage Disks" b
- name: $1
	azure_rm_managed_disk:
		resource_group: ${2:# Name of a resource group where the managed disk exists or will be created.}
		disk_size_gb: ${3:# -}
		name: ${4:# Name of the managed disk}
		# profile: ${5:# Security profile found in ~/.azure/credentials file.}
		# tags: ${6:# Tags to assign to the managed disk.}
		# cloud_environment: ${7:AzureCloud}
		# source_uri: ${8:# URI to a valid VHD file to be used when 'create_option' is 'import'.}
		# os_type: ${9:linux|windows}
		# client_id: ${10:# Azure client ID. Use when authenticating with a Service Principal.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# create_option: ${12:empty|import|copy}
		# tenant: ${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# source_resource_uri: ${14:# The resource ID of the managed disk to copy when 'create_option' is 'copy'.}
		# append_tags: ${15:yes}
		# ad_user: ${16:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${17:# Azure client secret. Use when authenticating with a Service Principal.}
		# storage_account_type: ${18:Standard_LRS|Premium_LRS}
		# state: ${19:absent|#present}
		# location: ${20:resource_group location}
		# subscription_id: ${21:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_managed_disk_facts "Get managed disk facts." b
- name: $1
	azure_rm_managed_disk_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Limit results to a specific managed disk}
		# resource_group: ${4:# Limit results to a specific resource group}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_networkinterface "Manage Azure network interfaces." b
- name: $1
	azure_rm_networkinterface:
		resource_group: ${2:# Name of a resource group where the network interface exists or will be created.}
		virtual_network_name: ${3:# Name of an existing virtual network with which the network interface will be associated. Required when creating a network interface.}
		name: ${4:# Name of the network interface.}
		subnet_name: ${5:# Name of an existing subnet within the specified virtual network. Required when creating a network interface}
		# profile: ${6:# Security profile found in ~/.azure/credentials file.}
		# tags: ${7:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# open_ports: ${9:# When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.}
		# public_ip: ${10:yes}
		# private_ip_address: ${11:# Valid IPv4 address that falls within the specified subnet.}
		# client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		# security_group_name: ${13:# Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created.}
		# subscription_id: ${14:# Your Azure subscription Id.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# public_ip_address_name: ${16:# Name of an existing public IP address object to associate with the security group.}
		# password: ${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# append_tags: ${18:yes}
		# cloud_environment: ${19:AzureCloud}
		# secret: ${20:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${21:absent|#present}
		# location: ${22:resource_group location}
		# public_ip_allocation_method: ${23:#Dynamic|Static}
		# private_ip_allocation_method: ${24:#Dynamic|Static}
		# os_type: ${25:Windows|#Linux}
$0
endsnippet

snippet azure_rm_networkinterface_facts "Get network interface facts." b
- name: $1
	azure_rm_networkinterface_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific network interface.}
		# resource_group: ${4:# Name of the resource group containing the network interface(s). Required when searching by name.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_publicipaddress "Manage Azure Public IP Addresses." b
- name: $1
	azure_rm_publicipaddress:
		resource_group: ${2:# Name of resource group with which the Public IP is associated.}
		name: ${3:# Name of the Public IP.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${6:AzureCloud}
		# domain_name_label: ${7:# The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP.}
		# client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		# allocation_method: ${9:#Dynamic|Static}
		# password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# append_tags: ${12:yes}
		# ad_user: ${13:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${14:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${15:absent|#present}
		# location: ${16:resource_group location}
		# subscription_id: ${17:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_publicipaddress_facts "Get public IP facts." b
- name: $1
	azure_rm_publicipaddress_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific Public IP.}
		# resource_group: ${4:# Limit results by resource group. Required when using name parameter.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_resourcegroup "Manage Azure resource groups." b
- name: $1
	azure_rm_resourcegroup:
		name: ${2:# Name of the resource group.}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# force: ${4:no}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${6:AzureCloud}
		# append_tags: ${7:yes}
		# ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${10:absent|#present}
		# location: ${11:# Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.}
		# client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${13:# Your Azure subscription Id.}
		# password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_resourcegroup_facts "Get resource group facts." b
- name: $1
	azure_rm_resourcegroup_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Limit results to a specific resource group.}
		# tags: ${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${6:AzureCloud}
		# secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${9:# Your Azure subscription Id.}
		# password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_securitygroup "Manage Azure network security groups." b
- name: $1
	azure_rm_securitygroup:
		resource_group: ${2:# Name of the resource group the security group belongs to.}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# purge_rules: ${4:no}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# rules: ${6:# Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.}
		# cloud_environment: ${7:AzureCloud}
		# client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		# password: ${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# name: ${11:# Name of the security group to operate on.}
		# append_tags: ${12:yes}
		# ad_user: ${13:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${14:# Azure client secret. Use when authenticating with a Service Principal.}
		# default_rules: ${15:# The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.}
		# purge_default_rules: ${16:no}
		# state: ${17:absent|#present}
		# location: ${18:resource_group location}
		# subscription_id: ${19:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_securitygroup_facts "Get security group facts." b
- name: $1
	azure_rm_securitygroup_facts:
		resource_group: ${2:# Name of the resource group to use.}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# name: ${4:# Only show results for a specific security group.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_storageaccount "Manage Azure storage accounts." b
- name: $1
	azure_rm_storageaccount:
		resource_group: ${2:# Name of the resource group to use.}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# account_type: ${4:Premium_LRS|Standard_GRS|Standard_LRS|Standard_RAGRS|Standard_ZRS}
		# tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${6:AzureCloud}
		# client_id: ${7:# Azure client ID. Use when authenticating with a Service Principal.}
		# password: ${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# name: ${10:# Name of the storage account to update or create.}
		# kind: ${11:#Storage|BlobStorage}
		# custom_domain: ${12:# User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.}
		# append_tags: ${13:yes}
		# ad_user: ${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${15:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${16:absent|#present}
		# location: ${17:resource_group location}
		# access_tier: ${18:Hot|Cool}
		# subscription_id: ${19:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_storageaccount_facts "Get storage account facts." b
- name: $1
	azure_rm_storageaccount_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific account.}
		# resource_group: ${4:# Limit results to a resource group. Required when filtering by name.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_storageblob "Manage blob containers and blob objects." b
- name: $1
	azure_rm_storageblob:
		resource_group: ${2:# Name of the resource group to use.}
		container: ${3:# Name of a blob container within the storage account.}
		storage_account_name: ${4:# Name of the storage account to use.}
		# profile: ${5:# Security profile found in ~/.azure/credentials file.}
		# force: ${6:no}
		# client_id: ${7:# Azure client ID. Use when authenticating with a Service Principal.}
		# tags: ${8:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# dest: ${9:# Destination file path. Use with state 'present' to download a blob.}
		# ad_user: ${10:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# content_language: ${11:# Set the blob content-language header.}
		# content_type: ${12:# Set the blob content-type header. For example, 'image/png'.}
		# public_access: ${13:container|blob}
		# password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# src: ${16:# Source file path. Use with state 'present' to upload a blob.}
		# append_tags: ${17:yes}
		# cloud_environment: ${18:AzureCloud}
		# secret: ${19:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${20:absent|#present}
		# blob: ${21:# Name of a blob object within the container.}
		# content_md5: ${22:# Set the blob md5 hash value.}
		# subscription_id: ${23:# Your Azure subscription Id.}
		# content_disposition: ${24:# Set the blob content-disposition header.}
		# cache_control: ${25:# Set the blob cache-control header.}
		# content_encoding: ${26:# Set the blob encoding header.}
$0
endsnippet

snippet azure_rm_subnet "Manage Azure subnets." b
- name: $1
	azure_rm_subnet:
		name: ${2:# Name of the subnet.}
		resource_group: ${3:# Name of resource group.}
		virtual_network_name: ${4:# Name of an existing virtual network with which the subnet is or will be associated.}
		address_prefix_cidr: ${5:# CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.}
		# profile: ${6:# Security profile found in ~/.azure/credentials file.}
		# ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${8:AzureCloud}
		# state: ${9:absent|#present}
		# security_group_name: ${10:# Name of an existing security group with which to associate the subnet.}
		# secret: ${11:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${13:# Your Azure subscription Id.}
		# password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_virtualmachine "Manage Azure virtual machines." b
- name: $1
	azure_rm_virtualmachine:
		resource_group: ${2:# Name of the resource group containing the virtual machine.}
		image: ${3:# A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image.}
		name: ${4:# Name of the virtual machine.}
		# virtual_network_resource_group: ${5:# When creating a virtual machine, if a specific virtual network from another resource group should be used, use this parameter to specify the resource group to use.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# managed_disk_type: ${7:Standard_LRS|Premium_LRS}
		# ssh_public_keys: ${8:# For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.}
		# storage_container_name: ${9:vhds}
		# allocated: ${10:yes}
		# ssh_password_enabled: ${11:yes}
		# vm_size: ${12:# A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices. Required when creating a VM.}
		# remove_on_absent: ${13:[u'all']}
		# append_tags: ${14:yes}
		# cloud_environment: ${15:AzureCloud}
		# secret: ${16:# Azure client secret. Use when authenticating with a Service Principal.}
		# short_hostname: ${17:# Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.}
		# virtual_network_name: ${18:# When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead.}
		# state: ${19:absent|#present}
		# subnet_name: ${20:# When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead.}
		# location: ${21:# Valid Azure location. Defaults to location of the resource group.}
		# public_ip_allocation_method: ${22:[Dynamic, #Static}
		# network_interface_names: ${23:# List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist.}
		# subscription_id: ${24:# Your Azure subscription Id.}
		# admin_password: ${25:# Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.}
		# profile: ${26:# Security profile found in ~/.azure/credentials file.}
		# tags: ${27:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# started: ${28:yes}
		# open_ports: ${29:# If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.}
		# client_id: ${30:# Azure client ID. Use when authenticating with a Service Principal.}
		# storage_blob_name: ${31:# Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'}
		# password: ${32:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${33:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# restarted: ${34:no}
		# admin_username: ${35:# Admin username used to access the host after it is created. Required when creating a VM.}
		# os_type: ${36:[Windows, #Linux}
		# storage_account_name: ${37:# Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.}
		# data_disks: ${38:# Describes list of data disks.}
		# os_disk_caching: ${39:#ReadOnly|ReadWrite}
$0
endsnippet

snippet azure_rm_virtualmachine_extension "Managed Azure Virtual Machine extension" b
- name: $1
	azure_rm_virtualmachine_extension:
		name: ${2:# Name of the vm extension}
		resource_group: ${3:# Name of a resource group where the vm extension exists or will be created.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# publisher: ${5:# The name of the extension handler publisher.}
		# virtual_machine_extension_type: ${6:# The type of the extension handler.}
		# auto_upgrade_minor_version: ${7:# Whether the extension handler should be automatically upgraded across minor versions.}
		# settings: ${8:# Json formatted public settings for the extension.}
		# ad_user: ${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${10:AzureCloud}
		# state: ${11:absent|#present}
		# secret: ${12:# Azure client secret. Use when authenticating with a Service Principal.}
		# location: ${13:resource_group location}
		# client_id: ${14:# Azure client ID. Use when authenticating with a Service Principal.}
		# protected_settings: ${15:# Json formatted protected settings for the extension.}
		# subscription_id: ${16:# Your Azure subscription Id.}
		# password: ${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# type_handler_version: ${18:# The type version of the extension handler.}
		# tenant: ${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# virtual_machine_name: ${20:# The name of the virtual machine where the extension should be create or updated.}
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset "Manage Azure virtual machine scale sets." b
- name: $1
	azure_rm_virtualmachine_scaleset:
		resource_group: ${2:# Name of the resource group containing the virtual machine scale set.}
		image: ${3:# A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image.}
		vm_size: ${4:# A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices.}
		capacity: ${5:# Capacity of VMSS}
		name: ${6:# Name of the virtual machine.}
		# profile: ${7:# Security profile found in ~/.azure/credentials file.}
		# location: ${8:# Valid Azure location. Defaults to location of the resource group.}
		# tags: ${9:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# virtual_network_name: ${10:# Virtual Network name}
		# ad_user: ${11:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# upgrade_policy: ${12:Manual|Automatic}
		# managed_disk_type: ${13:Standard_LRS|Premium_LRS}
		# ssh_public_keys: ${14:# For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.}
		# client_id: ${15:# Azure client ID. Use when authenticating with a Service Principal.}
		# tier: ${16:Basic|Standard}
		# password: ${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# ssh_password_enabled: ${18:yes}
		# subscription_id: ${19:# Your Azure subscription Id.}
		# tenant: ${20:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# remove_on_absent: ${21:[u'all']}
		# append_tags: ${22:yes}
		# cloud_environment: ${23:AzureCloud}
		# secret: ${24:# Azure client secret. Use when authenticating with a Service Principal.}
		# admin_username: ${25:# Admin username used to access the host after it is created. Required when creating a VM.}
		# state: ${26:absent|#present}
		# subnet_name: ${27:# Subnet name}
		# admin_password: ${28:# Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.}
		# os_type: ${29:[Windows, #Linux}
		# data_disks: ${30:# Describes list of data disks.}
		# os_disk_caching: ${31:#ReadOnly|ReadWrite}
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset_facts "Get Virtual Machine Scale Set facts" b
- name: $1
	azure_rm_virtualmachine_scaleset_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Limit results to a specific virtual machine scale set}
		# resource_group: ${4:# The resource group to search for the desired virtual machine scale set}
		# ad_user: ${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${6:AzureCloud}
		# secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${9:# Your Azure subscription Id.}
		# password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_virtualmachineimage_facts "Get virtual machine image facts." b
- name: $1
	azure_rm_virtualmachineimage_facts:
		location: ${2:# Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.}
		# profile: ${3:# Security profile found in ~/.azure/credentials file.}
		# sku: ${4:# Image offering SKU. Combine with offer to see a list of available versions.}
		# name: ${5:# Only show results for a specific security group.}
		# publisher: ${6:# Name of an image publisher. List image offerings associated with a particular publisher.}
		# ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# offer: ${8:# Name of an image offering. Combine with sku to see a list of available image versions.}
		# cloud_environment: ${9:AzureCloud}
		# secret: ${10:# Azure client secret. Use when authenticating with a Service Principal.}
		# version: ${11:# Specific version number of an image.}
		# client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${13:# Your Azure subscription Id.}
		# password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_virtualnetwork "Manage Azure virtual networks." b
- name: $1
	azure_rm_virtualnetwork:
		resource_group: ${2:# name of resource group.}
		name: ${3:# name of the virtual network.}
		# profile: ${4:# Security profile found in ~/.azure/credentials file.}
		# dns_servers: ${5:# Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.}
		# tags: ${6:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		# cloud_environment: ${7:AzureCloud}
		# address_prefixes_cidr: ${8:# List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# purge_dns_servers: ${10:no}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
		# append_tags: ${13:yes}
		# ad_user: ${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# secret: ${15:# Azure client secret. Use when authenticating with a Service Principal.}
		# state: ${16:absent|#present}
		# location: ${17:resource_group location}
		# purge_address_prefixes: ${18:no}
		# subscription_id: ${19:# Your Azure subscription Id.}
$0
endsnippet

snippet azure_rm_virtualnetwork_facts "Get virtual network facts." b
- name: $1
	azure_rm_virtualnetwork_facts:
		# profile: ${2:# Security profile found in ~/.azure/credentials file.}
		# name: ${3:# Only show results for a specific security group.}
		# resource_group: ${4:# Limit results by resource group. Required when filtering by name.}
		# tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		# ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		# cloud_environment: ${7:AzureCloud}
		# secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		# client_id: ${9:# Azure client ID. Use when authenticating with a Service Principal.}
		# subscription_id: ${10:# Your Azure subscription Id.}
		# password: ${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		# tenant: ${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet clc_aa_policy "Create or Delete Anti Affinity Policies at CenturyLink Cloud." b
- name: $1
	clc_aa_policy:
		location: ${2:# Datacenter in which the policy lives/should live.}
		name: ${3:# The name of the Anti Affinity Policy.}
		# state: ${4:#present|absent}
		# wait: ${5:#True|False}
$0
endsnippet

snippet clc_alert_policy "Create or Delete Alert Policies at CenturyLink Cloud." b
- name: $1
	clc_alert_policy:
		alias: ${2:# The alias of your CLC Account}
		# name: ${3:# The name of the alert policy. This is mutually exclusive with id}
		# metric: ${4:cpu|memory|disk}
		# alert_recipients: ${5:# A list of recipient email ids to notify the alert. This is required for state 'present'}
		# state: ${6:#present|absent}
		# threshold: ${7:# The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0}
		# id: ${8:# The alert policy id. This is mutually exclusive with name}
		# duration: ${9:# The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'}
$0
endsnippet

snippet clc_blueprint_package "deploys a blue print package on a set of servers in CenturyLink Cloud." b
- name: $1
	clc_blueprint_package:
		server_ids: ${2:# A list of server Ids to deploy the blue print package.}
		package_id: ${3:# The package id of the blue print.}
		# package_params: ${4:{}}
		# state: ${5:#present}
		# wait: ${6:#True|False}
$0
endsnippet

snippet clc_firewall_policy "Create/delete/update firewall policies" b
- name: $1
	clc_firewall_policy:
		location: ${2:# Target datacenter for the firewall policy}
		source_account_alias: ${3:# CLC alias for the source account}
		# destination_account_alias: ${4:# CLC alias for the destination account}
		# destination: ${5:# The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'}
		# enabled: ${6:#True|False}
		# source: ${7:# The list  of source addresses for traffic on the originating firewall. This is required when state is 'present"}
		# state: ${8:#present|absent}
		# firewall_policy_id: ${9:# Id of the firewall policy. This is required to update or delete an existing firewall policy}
		# ports: ${10:any|icmp|TCP/123|UDP/123|TCP/123-456|UDP/123-456}
		# wait: ${11:#True|False}
$0
endsnippet

snippet clc_group "Create/delete Server Groups at Centurylink Cloud" b
- name: $1
	clc_group:
		name: ${2:# The name of the Server Group}
		# state: ${3:#present|absent}
		# parent: ${4:# The parent group of the server group. If parent is not provided, it creates the group at top level.}
		# wait: ${5:#True|False}
		# location: ${6:# Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account}
		# description: ${7:# A description of the Server Group}
$0
endsnippet

snippet clc_loadbalancer "Create, Delete shared loadbalancers in CenturyLink Cloud." b
- name: $1
	clc_loadbalancer:
		name: ${2:# The name of the loadbalancer}
		alias: ${3:# The alias of your CLC Account}
		location: ${4:# The location of the datacenter where the load balancer resides in}
		# status: ${5:#enabled|disabled}
		# method: ${6:leastConnection|roundRobin}
		# state: ${7:#present|absent|port_absent|nodes_present|nodes_absent}
		# nodes: ${8:[]}
		# port: ${9:80|443}
		# persistence: ${10:standard|sticky}
		# description: ${11:# A description for the loadbalancer}
$0
endsnippet

snippet clc_modify_server "modify servers in CenturyLink Cloud." b
- name: $1
	clc_modify_server:
		server_ids: ${2:# A list of server Ids to modify.}
		# alert_policy_id: ${3:# The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'}
		# anti_affinity_policy_name: ${4:# The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'}
		# state: ${5:#present|absent}
		# anti_affinity_policy_id: ${6:# The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'}
		# alert_policy_name: ${7:# The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'}
		# memory: ${8:# Memory (in GB) to set to the server.}
		# cpu: ${9:# How many CPUs to update on the server}
		# wait: ${10:#True|False}
$0
endsnippet

snippet clc_publicip "Add and Delete public ips on servers in CenturyLink Cloud." b
- name: $1
	clc_publicip:
		server_ids: ${2:# A list of servers to create public ips on.}
		# state: ${3:#present|absent}
		# protocol: ${4:#TCP|UDP|ICMP}
		# ports: ${5:# A list of ports to expose. This is required when state is 'present'}
		# wait: ${6:#True|False}
$0
endsnippet

snippet clc_server "Create, Delete, Start and Stop servers in CenturyLink Cloud." b
- name: $1
	clc_server:
		# cpu_autoscale_policy_id: ${2:# The autoscale policy to assign to the server.}
		# anti_affinity_policy_name: ${3:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.}
		# storage_type: ${4:#standard|hyperscale}
		# anti_affinity_policy_id: ${5:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.}
		# ttl: ${6:# The time to live for the server in seconds.  The server will be deleted when this time expires.}
		# count_group: ${7:# Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.}
		# secondary_dns: ${8:# Secondary DNS used by the server.}
		# custom_fields: ${9:[]}
		# packages: ${10:[]}
		# group: ${11:Default Group}
		# exact_count: ${12:# Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.}
		# state: ${13:#present|absent|started|stopped}
		# location: ${14:# The Datacenter to create servers in.}
		# template: ${15:# The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'}
		# memory: ${16:1}
		# server_ids: ${17:[]}
		# type: ${18:#standard|hyperscale|bareMetal}
		# managed_os: ${19:True|#False}
		# additional_disks: ${20:[]}
		# description: ${21:# The description to set for the server.}
		# add_public_ip: ${22:#False|True}
		# alert_policy_id: ${23:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.}
		# alert_policy_name: ${24:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.}
		# password: ${25:# Password for the administrator / root user}
		# ip_address: ${26:# The IP Address for the server. One is assigned if not provided.}
		# public_ip_protocol: ${27:#TCP|UDP|ICMP}
		# wait: ${28:#True|False}
		# count: ${29:1}
		# name: ${30:# A 1 to 6 character identifier to use for the server. This is required when state is 'present'}
		# network_id: ${31:# The network UUID on which to create servers.}
		# primary_dns: ${32:# Primary DNS used by the server.}
		# alias: ${33:# The account alias to provision the servers under.}
		# public_ip_ports: ${34:[]}
		# source_server_password: ${35:# The password for the source server if a clone is specified.}
		# os_type: ${36:redHat6_64Bit|centOS6_64Bit|windows2012R2Standard_64Bit|ubuntu14_64Bit}
		# configuration_id: ${37:# Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.}
		# cpu: ${38:1}
$0
endsnippet

snippet clc_server_snapshot "Create, Delete and Restore server snapshots in CenturyLink Cloud." b
- name: $1
	clc_server_snapshot:
		server_ids: ${2:# The list of CLC server Ids.}
		# expiration_days: ${3:7}
		# state: ${4:#present|absent|restore}
		# wait: ${5:#True|False}
$0
endsnippet

snippet cloudscale_server "Manages servers on the cloudscale.ch IaaS service" b
- name: $1
	cloudscale_server:
		# volume_size_gb: ${2:10}
		# uuid: ${3:# UUID of the server}
		# name: ${4:# Name of the Server}
		# use_public_network: ${5:yes}
		# state: ${6:#running|stopped|absent}
		# image: ${7:# Image used to create the server}
		# use_ipv6: ${8:yes}
		# user_data: ${9:# Cloud-init configuration (cloud-config) data to use for the server.}
		# anti_affinity_with: ${10:# UUID of another server to create an anti-affinity group with}
		# use_private_network: ${11:no}
		# bulk_volume_size_gb: ${12:null (no bulk storage volume)}
		# api_token: ${13:# cloudscale.ch API token.}
		# flavor: ${14:# Flavor of the server}
		# ssh_keys: ${15:# List of SSH public keys}
$0
endsnippet

snippet cs_account "Manages accounts on Apache CloudStack based clouds." b
- name: $1
	cs_account:
		name: ${2:# Name of account.}
		# username: ${3:# Username of the user to be created if account did not exist.}
		# domain: ${4:ROOT}
		# last_name: ${5:# Last name of the user to be created if account did not exist.}
		# account_type: ${6:#user|root_admin|domain_admin}
		# api_http_method: ${7:#get|post}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# timezone: ${10:# Timezone of the user to be created if account did not exist.}
		# password: ${11:# Password of the user to be created if account did not exist.}
		# first_name: ${12:# First name of the user to be created if account did not exist.}
		# network_domain: ${13:# Network domain of the account.}
		# poll_async: ${14:yes}
		# api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_region: ${16:cloudstack}
		# state: ${17:#present|absent|enabled|disabled|locked|unlocked}
		# api_key: ${18:# API key of the CloudStack API.}
		# email: ${19:# Email of the user to be created if account did not exist.}
$0
endsnippet

snippet cs_affinitygroup "Manages affinity groups on Apache CloudStack based clouds." b
- name: $1
	cs_affinitygroup:
		name: ${2:# Name of the affinity group.}
		# account: ${3:# Account the affinity group is related to.}
		# poll_async: ${4:yes}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# description: ${8:# Description of the affinity group.}
		# api_timeout: ${9:10}
		# affinty_type: ${10:# Type of the affinity group. If not specified, first found affinity type is used.}
		# api_region: ${11:cloudstack}
		# project: ${12:# Name of the project the affinity group is related to.}
		# state: ${13:#present|absent}
		# domain: ${14:# Domain the affinity group is related to.}
		# api_key: ${15:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_cluster "Manages host clusters on Apache CloudStack based clouds." b
- name: $1
	cs_cluster:
		name: ${2:# name of the cluster.}
		# username: ${3:# Username for the cluster.}
		# guest_vswitch_type: ${4:vmwaresvs|vmwaredvs}
		# ovm3_cluster: ${5:# Ovm3 native OCFS2 clustering enabled for cluster.}
		# ovm3_pool: ${6:# Ovm3 native pooling enabled for cluster.}
		# api_http_method: ${7:#get|post}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# vms_ip_address: ${10:# IP address of the VSM associated with this cluster.}
		# public_vswitch_name: ${11:# Name of virtual switch used for public traffic in the cluster.}
		# pod: ${12:# Name of the pod in which the cluster belongs to.}
		# password: ${13:# Password for the cluster.}
		# guest_vswitch_name: ${14:# Name of virtual switch used for guest traffic in the cluster.}
		# vms_username: ${15:# Username for the VSM associated with this cluster.}
		# public_vswitch_type: ${16:vmwaresvs|vmwaredvs}
		# api_url: ${17:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${18:# Name of the zone in which the cluster belongs to.}
		# url: ${19:# URL for the cluster}
		# hypervisor: ${20:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		# ovm3_vip: ${21:# Ovm3 vip to use for pool (and cluster).}
		# api_region: ${22:cloudstack}
		# state: ${23:#present|absent|disabled|enabled}
		# cluster_type: ${24:CloudManaged|ExternalManaged}
		# api_key: ${25:# API key of the CloudStack API.}
		# vms_password: ${26:# Password for the VSM associated with this cluster.}
$0
endsnippet

snippet cs_configuration "Manages configuration on Apache CloudStack based clouds." b
- name: $1
	cs_configuration:
		value: ${2:# Value of the configuration.}
		name: ${3:# Name of the configuration.}
		# domain: ${4:ROOT}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# api_timeout: ${8:10}
		# storage: ${9:# Ensure the value for corresponding storage pool.}
		# api_region: ${10:cloudstack}
		# cluster: ${11:# Ensure the value for corresponding cluster.}
		# zone: ${12:# Ensure the value for corresponding zone.}
		# account: ${13:# Ensure the value for corresponding account.}
		# api_key: ${14:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_domain "Manages domains on Apache CloudStack based clouds." b
- name: $1
	cs_domain:
		path: ${2:# Path of the domain.}
		# network_domain: ${3:# Network domain for networks in the domain.}
		# poll_async: ${4:yes}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# api_timeout: ${8:10}
		# api_region: ${9:cloudstack}
		# clean_up: ${10:no}
		# state: ${11:#present|absent}
		# api_key: ${12:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_facts "Gather facts on instances of Apache CloudStack based clouds." b
- name: $1
	cs_facts:
		# filter: ${2:cloudstack_service_offering|cloudstack_availability_zone|cloudstack_public_hostname|cloudstack_public_ipv4|cloudstack_local_hostname|cloudstack_local_ipv4|cloudstack_instance_id|cloudstack_user_data}
		# meta_data_host: ${3:# Host or IP of the meta data API service.}
$0
endsnippet

snippet cs_firewall "Manages firewall rules on Apache CloudStack based clouds." b
- name: $1
	cs_firewall:
		# icmp_code: ${2:# Error code for this icmp message. Considered if C(protocol=icmp).}
		# domain: ${3:# Domain the firewall rule is related to.}
		# end_port: ${4:# End port for this rule. Considered if C(protocol=tcp) or C(protocol=udp). If not specified, equal C(start_port).}
		# protocol: ${5:#tcp|udp|icmp|all}
		# api_http_method: ${6:#get|post}
		# tags: ${7:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# start_port: ${10:# Start port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).}
		# cidr: ${11:0.0.0.0/0}
		# icmp_type: ${12:# Type of the icmp message being sent. Considered if C(protocol=icmp).}
		# ip_address: ${13:# Public IP address the ingress rule is assigned to.}
		# network: ${14:# Network the egress rule is related to.}
		# account: ${15:# Account the firewall rule is related to.}
		# poll_async: ${16:yes}
		# api_url: ${17:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${18:# Name of the zone in which the virtual machine is in.}
		# api_region: ${19:cloudstack}
		# project: ${20:# Name of the project the firewall rule is related to.}
		# state: ${21:#present|absent}
		# api_key: ${22:# API key of the CloudStack API.}
		# type: ${23:#ingress|egress}
$0
endsnippet

snippet cs_host "Manages hosts on Apache CloudStack based clouds." b
- name: $1
	cs_host:
		name: ${2:# Name of the host.}
		# username: ${3:# Username for the host.}
		# api_http_method: ${4:#get|post}
		# host_tags: ${5:# Tags of the host.}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# cluster: ${8:# Name of the cluster.}
		# pod: ${9:# Name of the pod.}
		# password: ${10:# Password for the host.}
		# api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${12:# Name of the zone in which the host should be deployed.}
		# url: ${13:# Url of the host used to create a host.}
		# hypervisor: ${14:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator}
		# api_region: ${15:cloudstack}
		# state: ${16:#present|absent}
		# api_key: ${17:# API key of the CloudStack API.}
		# allocation_state: ${18:enabled|disabled}
$0
endsnippet

snippet cs_instance "Manages instances and virtual machines on Apache CloudStack based clouds." b
- name: $1
	cs_instance:
		# domain: ${2:# Domain the instance is related to.}
		# force: ${3:no}
		# disk_offering: ${4:# Name of the disk offering to be used.}
		# api_http_method: ${5:#get|post}
		# cpu_speed: ${6:# The clock speed/shares allocated to the instance, used with custom service offerings}
		# user_data: ${7:# Optional data (ASCII) that can be sent to the instance upon a successful deployment.}
		# root_disk_size: ${8:# Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)}
		# keyboard: ${9:de|de-ch|es|fi|fr|fr-be|fr-ch|is|it|jp|nl-be|no|pt|uk|us}
		# ip6_address: ${10:# IPv6 address for default instance's network.}
		# networks: ${11:[]}
		# security_groups: ${12:# List of security groups the instance to be applied to.}
		# display_name: ${13:# Custom display name of the instances.}
		# api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${15:# Name of the zone in which the instance should be deployed.}
		# state: ${16:deployed|started|stopped|restarted|restored|destroyed|expunged|#present|absent}
		# template: ${17:# Name or id of the template to be used for creating the new instance.}
		# memory: ${18:# The memory allocated to the instance, used with custom service offerings}
		# iso: ${19:# Name or id of the ISO to be used for creating the new instance.}
		# api_key: ${20:# API key of the CloudStack API.}
		# template_filter: ${21:featured|self|selfexecutable|sharedexecutable|#executable|community}
		# tags: ${22:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${23:# Secret key of the CloudStack API.}
		# api_timeout: ${24:10}
		# ssh_key: ${25:# Name of the SSH key to be deployed on the new instance.}
		# group: ${26:# Group in where the new instance should be in.}
		# service_offering: ${27:# Name or id of the service offering of the new instance.}
		# ip_address: ${28:# IPv4 address for default instance's network during creation.}
		# account: ${29:# Account the instance is related to.}
		# disk_size: ${30:# Disk size in GByte required if deploying instance from ISO.}
		# name: ${31:# Host name of the instance. C(name) can only contain ASCII letters.}
		# hypervisor: ${32:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		# ip_to_networks: ${33:# List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4}}
		# api_region: ${34:cloudstack}
		# project: ${35:# Name of the project the instance to be deployed in.}
		# affinity_groups: ${36:[]}
		# poll_async: ${37:yes}
		# cpu: ${38:# The number of CPUs to allocate to the instance, used with custom service offerings}
$0
endsnippet

snippet cs_instance_facts "Gathering facts from the API of instances from Apache CloudStack based clouds." b
- name: $1
	cs_instance_facts:
		name: ${2:# Name or display name of the instance.}
		# project: ${3:# Project the instance is related to.}
		# account: ${4:# Account the instance is related to.}
		# api_key: ${5:# API key of the CloudStack API.}
		# domain: ${6:# Domain the instance is related to.}
		# api_url: ${7:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${8:#get|post}
		# api_secret: ${9:# Secret key of the CloudStack API.}
		# api_timeout: ${10:10}
		# api_region: ${11:cloudstack}
$0
endsnippet

snippet cs_instance_nic "Manages NICs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic:
		vm: ${2:# Name of instance.}
		network: ${3:# Name of the network.}
		# domain: ${4:# Domain the instance is related to.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# vpc: ${8:# Name of the VPC the C(vm) is related to.}
		# ip_address: ${9:# IP address to be used for the nic.}
		# account: ${10:# Account the instance is related to.}
		# poll_async: ${11:yes}
		# api_url: ${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${13:# Name of the zone in which the instance is deployed in.}
		# api_region: ${14:cloudstack}
		# project: ${15:# Name of the project the instance is deployed in.}
		# state: ${16:#present|absent}
		# api_key: ${17:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_instance_nic_secondaryip "Manages secondary IPs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic_secondaryip:
		vm: ${2:# Name of instance.}
		# vm_guest_ip: ${3:# Secondary IP address to be added to the instance nic.}
		# domain: ${4:# Domain the instance is related to.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# vpc: ${8:# Name of the VPC the C(vm) is related to.}
		# network: ${9:# Name of the network.}
		# account: ${10:# Account the instance is related to.}
		# poll_async: ${11:yes}
		# api_url: ${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${13:# Name of the zone in which the instance is deployed in.}
		# api_region: ${14:cloudstack}
		# project: ${15:# Name of the project the instance is deployed in.}
		# state: ${16:#present|absent}
		# api_key: ${17:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_instancegroup "Manages instance groups on Apache CloudStack based clouds." b
- name: $1
	cs_instancegroup:
		name: ${2:# Name of the instance group.}
		# account: ${3:# Account the instance group is related to.}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
		# project: ${9:# Project the instance group is related to.}
		# state: ${10:#present|absent}
		# domain: ${11:# Domain the instance group is related to.}
		# api_key: ${12:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_ip_address "Manages public IP address associations on Apache CloudStack based clouds." b
- name: $1
	cs_ip_address:
		# account: ${2:# Account the IP address is related to.}
		# poll_async: ${3:yes}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
		# project: ${9:# Name of the project the IP address is related to.}
		# zone: ${10:# Name of the zone in which the IP address is in.}
		# domain: ${11:# Domain the IP address is related to.}
		# api_key: ${12:# API key of the CloudStack API.}
		# ip_address: ${13:# Public IP address.}
		# vpc: ${14:# VPC the IP address is related to.}
		# network: ${15:# Network the IP address is related to.}
$0
endsnippet

snippet cs_iso "Manages ISO images on Apache CloudStack based clouds." b
- name: $1
	cs_iso:
		name: ${2:# Name of the ISO.}
		# is_featured: ${3:# Register the ISO to be featured. Only used if C(state) is present.}
		# api_http_method: ${4:#get|post}
		# tags: ${5:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# iso_filter: ${8:featured|#self|selfexecutable|sharedexecutable|executable|community}
		# is_dynamically_scalable: ${9:# Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if C(state) is present.}
		# domain: ${10:# Domain the ISO is related to.}
		# is_public: ${11:# Register the ISO to be publicly available to all users. Only used if C(state) is present.}
		# display_text: ${12:# Display text of the ISO.}
		# account: ${13:# Account the ISO is related to.}
		# poll_async: ${14:yes}
		# api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${16:# Name of the zone you wish the ISO to be registered or deleted from.}
		# url: ${17:# URL where the ISO can be downloaded from. Required if C(state) is present.}
		# checksum: ${18:# The MD5 checksum value of this ISO. If set, we search by checksum instead of name.}
		# api_region: ${19:cloudstack}
		# cross_zones: ${20:no}
		# project: ${21:# Name of the project the ISO to be registered in.}
		# bootable: ${22:# Register the ISO to be bootable. Only used if C(state) is present.}
		# state: ${23:#present|absent}
		# is_ready: ${24:no}
		# os_type: ${25:# Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present.}
		# api_key: ${26:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_loadbalancer_rule "Manages load balancer rules on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule:
		ip_address: ${2:# Public IP address from where the network traffic will be load balanced from.}
		name: ${3:# The name of the load balancer rule.}
		public_port: ${4:# The public port from where the network traffic will be load balanced from.}
		state: ${5:#present|absent}
		# domain: ${6:# Domain the rule is related to.}
		# protocol: ${7:# The protocol to be used on the load balancer}
		# description: ${8:# The description of the load balancer rule.}
		# api_http_method: ${9:#get|post}
		# api_secret: ${10:# Secret key of the CloudStack API.}
		# api_timeout: ${11:10}
		# private_port: ${12:# The private port of the private ip address/virtual machine where the network traffic will be load balanced to.}
		# zone: ${13:# Name of the zone in which the rule should be created.}
		# cidr: ${14:# CIDR (full notation) to be used for firewall rule if required.}
		# account: ${15:# Account the rule is related to.}
		# api_url: ${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# algorithm: ${17:#source|roundrobin|leastconn}
		# open_firewall: ${18:no}
		# api_region: ${19:cloudstack}
		# project: ${20:# Name of the project the load balancer IP address is related to.}
		# api_key: ${21:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_loadbalancer_rule_member "Manages load balancer rule members on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule_member:
		vms: ${2:# List of VMs to assign to or remove from the rule.}
		name: ${3:# The name of the load balancer rule.}
		# domain: ${4:# Domain the rule is related to.}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# state: ${7:#present|absent}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# api_region: ${10:cloudstack}
		# project: ${11:# Name of the project the firewall rule is related to.}
		# zone: ${12:# Name of the zone in which the rule should be located.}
		# account: ${13:# Account the rule is related to.}
		# api_key: ${14:# API key of the CloudStack API.}
		# ip_address: ${15:# Public IP address from where the network traffic will be load balanced from.}
$0
endsnippet

snippet cs_network "Manages networks on Apache CloudStack based clouds." b
- name: $1
	cs_network:
		name: ${2:# Name (case sensitive) of the network.}
		# domain: ${3:# Domain the network is related to.}
		# vlan: ${4:# The ID or VID of the network.}
		# end_ipv6: ${5:# The ending IPv6 address of the network belongs to.}
		# api_http_method: ${6:#get|post}
		# network_domain: ${7:# The network domain.}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# clean_up: ${10:no}
		# netmask: ${11:# The netmask of the network.}
		# network_offering: ${12:# Name of the offering for the network.}
		# vpc: ${13:# Name of the VPC of the network.}
		# start_ip: ${14:# The beginning IPv4 address of the network belongs to.}
		# gateway: ${15:# The gateway of the network.}
		# gateway_ipv6: ${16:# The gateway of the IPv6 network.}
		# display_text: ${17:# Display text of the network.}
		# isolated_pvlan: ${18:# The isolated private VLAN for this network.}
		# account: ${19:# Account the network is related to.}
		# acl_type: ${20:#account|domain}
		# poll_async: ${21:yes}
		# api_url: ${22:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${23:# Name of the zone in which the network should be deployed.}
		# api_region: ${24:cloudstack}
		# start_ipv6: ${25:# The beginning IPv6 address of the network belongs to.}
		# cidr_ipv6: ${26:# CIDR of IPv6 network, must be at least /64.}
		# project: ${27:# Name of the project the network to be deployed in.}
		# state: ${28:#present|absent|restarted}
		# end_ip: ${29:# The ending IPv4 address of the network belongs to.}
		# api_key: ${30:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_network_acl "Manages network access control lists (ACL) on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl:
		vpc: ${2:# VPC the network ACL is related to.}
		name: ${3:# Name of the network ACL.}
		# account: ${4:# Account the network ACL rule is related to.}
		# poll_async: ${5:yes}
		# api_url: ${6:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${7:#get|post}
		# state: ${8:#present|absent}
		# api_secret: ${9:# Secret key of the CloudStack API.}
		# description: ${10:# Description of the network ACL.}
		# api_timeout: ${11:10}
		# api_region: ${12:cloudstack}
		# project: ${13:# Name of the project the network ACL is related to.}
		# zone: ${14:# Name of the zone the VPC is related to.}
		# domain: ${15:# Domain the network ACL rule is related to.}
		# api_key: ${16:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_network_acl_rule "Manages network access control list (ACL) rules on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl_rule:
		rule_position: ${2:# CIDR of the rule.}
		network_acl: ${3:# Name of the network ACL.}
		vpc: ${4:# VPC the network ACL is related to.}
		# icmp_code: ${5:# Error code for this icmp message.}
		# domain: ${6:# Domain the VPC is related to.}
		# end_port: ${7:# End port for this rule.}
		# start_port: ${8:# Start port for this rule.}
		# action_policy: ${9:allow|deny}
		# api_http_method: ${10:#get|post}
		# tags: ${11:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${12:# Secret key of the CloudStack API.}
		# api_timeout: ${13:10}
		# protocol: ${14:#tcp|udp|icmp|all|by_number}
		# cidr: ${15:0.0.0.0/0}
		# icmp_type: ${16:# Type of the icmp message being sent.}
		# account: ${17:# Account the VPC is related to.}
		# poll_async: ${18:yes}
		# api_url: ${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${20:# Name of the zone the VPC related to.}
		# protocol_number: ${21:# Protocol number from 1 to 256 required if C(protocol=by_number).}
		# api_region: ${22:cloudstack}
		# project: ${23:# Name of the project the VPC is related to.}
		# state: ${24:#present|absent}
		# traffic_type: ${25:#ingress|egress}
		# api_key: ${26:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_pod "Manages pods on Apache CloudStack based clouds." b
- name: $1
	cs_pod:
		name: ${2:# Name of the pod.}
		# api_url: ${3:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${4:#get|post}
		# state: ${5:#present|enabled|disabled|absent}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
		# id: ${9:# uuid of the existing pod.}
		# zone: ${10:# Name of the zone in which the pod belongs to.}
		# end_ip: ${11:# Ending IP address for the Pod.}
		# start_ip: ${12:# Starting IP address for the Pod.}
		# api_key: ${13:# API key of the CloudStack API.}
		# netmask: ${14:# Netmask for the Pod.}
		# gateway: ${15:# Gateway for the Pod.}
$0
endsnippet

snippet cs_portforward "Manages port forwarding rules on Apache CloudStack based clouds." b
- name: $1
	cs_portforward:
		private_port: ${2:# Start private port for this rule.}
		ip_address: ${3:# Public IP address the rule is assigned to.}
		public_port: ${4:# Start public port for this rule.}
		# vm_guest_ip: ${5:no}
		# domain: ${6:# Domain the C(vm) is related to.}
		# protocol: ${7:#tcp|udp}
		# api_http_method: ${8:#get|post}
		# tags: ${9:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${10:# Secret key of the CloudStack API.}
		# api_timeout: ${11:10}
		# vm: ${12:# Name of virtual machine which we make the port forwarding rule for.}
		# zone: ${13:# Name of the zone in which the virtual machine is in.}
		# vpc: ${14:# Name of the VPC.}
		# private_end_port: ${15:# End private port for this rule.}
		# network: ${16:# Name of the network.}
		# account: ${17:# Account the C(vm) is related to.}
		# poll_async: ${18:yes}
		# api_url: ${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# open_firewall: ${20:no}
		# api_region: ${21:cloudstack}
		# public_end_port: ${22:# End public port for this rule.}
		# project: ${23:# Name of the project the C(vm) is located in.}
		# state: ${24:#present|absent}
		# api_key: ${25:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_project "Manages projects on Apache CloudStack based clouds." b
- name: $1
	cs_project:
		name: ${2:# Name of the project.}
		# display_text: ${3:# Display text of the project.}
		# account: ${4:# Account the project is related to.}
		# poll_async: ${5:yes}
		# api_url: ${6:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${7:#get|post}
		# tags: ${8:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${9:# Secret key of the CloudStack API.}
		# api_timeout: ${10:10}
		# api_region: ${11:cloudstack}
		# state: ${12:#present|absent|active|suspended}
		# domain: ${13:# Domain the project is related to.}
		# api_key: ${14:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_region "Manages regions on Apache CloudStack based clouds." b
- name: $1
	cs_region:
		id: ${2:# ID of the region.}
		# state: ${3:#present|absent}
		# api_key: ${4:# API key of the CloudStack API.}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# name: ${7:# Name of the region.}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# endpoint: ${10:# Endpoint URL of the region.}
		# api_region: ${11:cloudstack}
$0
endsnippet

snippet cs_resourcelimit "Manages resource limits on Apache CloudStack based clouds." b
- name: $1
	cs_resourcelimit:
		resource_type: ${2:instance|ip_address|volume|snapshot|template|network|vpc|cpu|memory|primary_storage|secondary_storage}
		# domain: ${3:# Domain the resource is related to.}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
		# project: ${9:# Name of the project the resource is related to.}
		# limit: ${10:-1}
		# account: ${11:# Account the resource is related to.}
		# api_key: ${12:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_role "Manages user roles on Apache CloudStack based clouds." b
- name: $1
	cs_role:
		name: ${2:# Name of the role.}
		# api_url: ${3:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${4:#get|post}
		# api_secret: ${5:# Secret key of the CloudStack API.}
		# api_timeout: ${6:10}
		# api_region: ${7:cloudstack}
		# state: ${8:#present|absent}
		# api_key: ${9:# API key of the CloudStack API.}
		# id: ${10:# ID of the role.}
		# role_type: ${11:#User|DomainAdmin|ResourceAdmin|Admin}
		# description: ${12:# Description of the role.}
$0
endsnippet

snippet cs_router "Manages routers on Apache CloudStack based clouds." b
- name: $1
	cs_router:
		name: ${2:# Name of the router.}
		# account: ${3:# Account the router is related to.}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# state: ${6:#present|absent|started|stopped|restarted}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# api_timeout: ${8:10}
		# api_region: ${9:cloudstack}
		# project: ${10:# Name of the project the router is related to.}
		# zone: ${11:# Name of the zone the router is deployed in.}
		# domain: ${12:# Domain the router is related to.}
		# service_offering: ${13:# Name or id of the service offering of the router.}
		# api_key: ${14:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_securitygroup "Manages security groups on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup:
		name: ${2:# Name of the security group.}
		# account: ${3:# Account the security group is related to.}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# description: ${7:# Description of the security group.}
		# api_timeout: ${8:10}
		# api_region: ${9:cloudstack}
		# project: ${10:# Name of the project the security group to be created in.}
		# state: ${11:#present|absent}
		# domain: ${12:# Domain the security group is related to.}
		# api_key: ${13:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_securitygroup_rule "Manages security group rules on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup_rule:
		security_group: ${2:# Name of the security group the rule is related to. The security group must be existing.}
		# icmp_code: ${3:# Error code for this icmp message. Required if C(protocol=icmp).}
		# end_port: ${4:# End port for this rule. Required if C(protocol=tcp) or C(protocol=udp), but C(start_port) will be used if not set.}
		# protocol: ${5:#tcp|udp|icmp|ah|esp|gre}
		# api_http_method: ${6:#get|post}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# api_timeout: ${8:10}
		# start_port: ${9:# Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).}
		# cidr: ${10:0.0.0.0/0}
		# icmp_type: ${11:# Type of the icmp message being sent. Required if C(protocol=icmp).}
		# poll_async: ${12:yes}
		# api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# user_security_group: ${14:# Security group this rule is based of.}
		# api_region: ${15:cloudstack}
		# project: ${16:# Name of the project the security group to be created in.}
		# state: ${17:#present|absent}
		# api_key: ${18:# API key of the CloudStack API.}
		# type: ${19:#ingress|egress}
$0
endsnippet

snippet cs_snapshot_policy "Manages volume snapshot policies on Apache CloudStack based clouds." b
- name: $1
	cs_snapshot_policy:
		# domain: ${2:# Domain the volume is related to.}
		# api_http_method: ${3:#get|post}
		# schedule: ${4:# Time the snapshot is scheduled. Required if C(state=present).}
		# api_secret: ${5:# Secret key of the CloudStack API.}
		# api_timeout: ${6:10}
		# vm: ${7:# Name of the instance to select the volume from.}
		# time_zone: ${8:UTC}
		# volume: ${9:# Name of the volume.}
		# vpc: ${10:# Name of the vpc the instance is deployed in.}
		# max_snaps: ${11:8}
		# device_id: ${12:# ID of the device on a VM the volume is attached to.}
		# account: ${13:# Account the volume is related to.}
		# api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# interval_type: ${15:hourly|#daily|weekly|monthly}
		# api_region: ${16:cloudstack}
		# volume_type: ${17:DATADISK|ROOT}
		# project: ${18:# Name of the project the volume is related to.}
		# state: ${19:#present|absent}
		# api_key: ${20:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_sshkeypair "Manages SSH keys on Apache CloudStack based clouds." b
- name: $1
	cs_sshkeypair:
		name: ${2:# Name of public key.}
		# public_key: ${3:# String of the public key.}
		# account: ${4:# Account the public key is related to.}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# api_secret: ${7:# Secret key of the CloudStack API.}
		# api_timeout: ${8:10}
		# api_region: ${9:cloudstack}
		# project: ${10:# Name of the project the public key to be registered in.}
		# state: ${11:#present|absent}
		# domain: ${12:# Domain the public key is related to.}
		# api_key: ${13:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_staticnat "Manages static NATs on Apache CloudStack based clouds." b
- name: $1
	cs_staticnat:
		ip_address: ${2:# Public IP address the static NAT is assigned to.}
		# vm_guest_ip: ${3:no}
		# domain: ${4:# Domain the static NAT is related to.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# vm: ${8:# Name of virtual machine which we make the static NAT for.}
		# vpc: ${9:# VPC the network related to.}
		# network: ${10:# Network the IP address is related to.}
		# account: ${11:# Account the static NAT is related to.}
		# poll_async: ${12:yes}
		# api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${14:# Name of the zone in which the virtual machine is in.}
		# api_region: ${15:cloudstack}
		# project: ${16:# Name of the project the static NAT is related to.}
		# state: ${17:#present|absent}
		# api_key: ${18:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_storage_pool "Manages Primary Storage Pools on Apache CloudStack based clouds." b
- name: $1
	cs_storage_pool:
		name: ${2:# Name of the storage pool.}
		# managed: ${3:# Whether the storage pool should be managed by CloudStack.}
		# api_http_method: ${4:#get|post}
		# api_secret: ${5:# Secret key of the CloudStack API.}
		# api_timeout: ${6:10}
		# storage_tags: ${7:# Tags associated with this storage pool.}
		# cluster: ${8:# Name of the cluster.}
		# pod: ${9:# Name of the pod.}
		# storage_url: ${10:# URL of the storage pool.}
		# api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${12:# Name of the zone in which the host should be deployed.}
		# capacity_iops: ${13:# Bytes CloudStack can provision from this storage pool.}
		# hypervisor: ${14:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator}
		# api_region: ${15:cloudstack}
		# state: ${16:#present|absent}
		# capacity_bytes: ${17:# Bytes CloudStack can provision from this storage pool.}
		# provider: ${18:DefaultPrimary}
		# scope: ${19:cluster|zone}
		# api_key: ${20:# API key of the CloudStack API.}
		# allocation_state: ${21:enabled|disabled}
$0
endsnippet

snippet cs_template "Manages templates on Apache CloudStack based clouds." b
- name: $1
	cs_template:
		name: ${2:# Name of the template.}
		# is_featured: ${3:no}
		# sshkey_enabled: ${4:no}
		# api_http_method: ${5:#get|post}
		# vm: ${6:# VM name the template will be created from its volume or alternatively from a snapshot.}
		# domain: ${7:# Domain the template, snapshot or VM is related to.}
		# is_extractable: ${8:no}
		# poll_async: ${9:yes}
		# api_url: ${10:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${11:# Name of the zone you wish the template to be registered or deleted from.}
		# format: ${12:QCOW2|RAW|VHD|OVA}
		# is_dynamically_scalable: ${13:no}
		# state: ${14:#present|absent|extacted}
		# template_filter: ${15:featured|#self|selfexecutable|sharedexecutable|executable|community}
		# is_ready: ${16:no}
		# details: ${17:# Template details in key/value pairs.}
		# is_routing: ${18:# True if the template type is routing i.e., if template is used to deploy router.}
		# api_key: ${19:# API key of the CloudStack API.}
		# bits: ${20:64}
		# tags: ${21:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${22:# Secret key of the CloudStack API.}
		# api_timeout: ${23:10}
		# is_public: ${24:no}
		# requires_hvm: ${25:no}
		# password_enabled: ${26:no}
		# display_text: ${27:# Display text of the template.}
		# account: ${28:# Account the template, snapshot or VM is related to.}
		# template_tag: ${29:# the tag for this template.}
		# url: ${30:# URL of where the template is hosted on C(state=present).}
		# checksum: ${31:no}
		# api_region: ${32:cloudstack}
		# cross_zones: ${33:no}
		# project: ${34:# Name of the project the template to be registered in.}
		# snapshot: ${35:# Name of the snapshot, created from the VM ROOT volume, the template will be created from.}
		# mode: ${36:#http_download|ftp_upload}
		# hypervisor: ${37:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		# os_type: ${38:# OS type that best represents the OS of this template.}
$0
endsnippet

snippet cs_user "Manages users on Apache CloudStack based clouds." b
- name: $1
	cs_user:
		username: ${2:# Username of the user.}
		# domain: ${3:ROOT}
		# last_name: ${4:# Last name of the user.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# first_name: ${8:# First name of the user.}
		# timezone: ${9:# Timezone of the user.}
		# password: ${10:# Password of the user to be created.}
		# keys_registered: ${11:# If API keys of the user should be generated.}
		# account: ${12:# Account the user will be created under.}
		# poll_async: ${13:yes}
		# api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_region: ${15:cloudstack}
		# state: ${16:#present|absent|enabled|disabled|locked|unlocked}
		# api_key: ${17:# API key of the CloudStack API.}
		# email: ${18:# Email of the user.}
$0
endsnippet

snippet cs_vmsnapshot "Manages VM snapshots on Apache CloudStack based clouds." b
- name: $1
	cs_vmsnapshot:
		vm: ${2:# Name of the virtual machine.}
		name: ${3:# Unique Name of the snapshot. In CloudStack terms display name.}
		# snapshot_memory: ${4:no}
		# domain: ${5:# Domain the VM snapshot is related to.}
		# description: ${6:# Description of the snapshot.}
		# api_http_method: ${7:#get|post}
		# tags: ${8:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${9:# Secret key of the CloudStack API.}
		# api_timeout: ${10:10}
		# account: ${11:# Account the VM snapshot is related to.}
		# poll_async: ${12:yes}
		# api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${14:# Name of the zone in which the VM is in. If not set, default zone is used.}
		# api_region: ${15:cloudstack}
		# project: ${16:# Name of the project the VM is assigned to.}
		# state: ${17:#present|absent|revert}
		# api_key: ${18:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_volume "Manages volumes on Apache CloudStack based clouds." b
- name: $1
	cs_volume:
		name: ${2:# Name of the volume.}
		# custom_id: ${3:# Custom id to the resource.}
		# domain: ${4:# Name of the domain the volume to be deployed in.}
		# force: ${5:no}
		# disk_offering: ${6:# Name of the disk offering to be used.}
		# api_http_method: ${7:#get|post}
		# tags: ${8:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${9:# Secret key of the CloudStack API.}
		# api_timeout: ${10:10}
		# shrink_ok: ${11:no}
		# vm: ${12:# Name of the virtual machine to attach the volume to.}
		# display_volume: ${13:yes}
		# state: ${14:#present|absent|attached|detached}
		# min_iops: ${15:# Min iops}
		# size: ${16:# Size of disk in GB}
		# account: ${17:# Account the volume is related to.}
		# poll_async: ${18:yes}
		# api_url: ${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${20:# Name of the zone in which the volume should be deployed.}
		# api_region: ${21:cloudstack}
		# project: ${22:# Name of the project the volume to be deployed in.}
		# max_iops: ${23:# Max iops}
		# snapshot: ${24:# The snapshot name for the disk volume.}
		# api_key: ${25:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_vpc "Manages VPCs on Apache CloudStack based clouds." b
- name: $1
	cs_vpc:
		name: ${2:# Name of the VPC.}
		# domain: ${3:# Domain the VPC is related to.}
		# api_http_method: ${4:#get|post}
		# tags: ${5:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# account: ${8:# Account the VPC is related to.}
		# cidr: ${9:# CIDR of the VPC, e.g. 10.1.0.0/16}
		# display_text: ${10:# Display text of the VPC.}
		# vpc_offering: ${11:# Name of the VPC offering.}
		# network_domain: ${12:# Network domain for the VPC.}
		# poll_async: ${13:yes}
		# api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# zone: ${15:# Name of the zone.}
		# api_region: ${16:cloudstack}
		# project: ${17:# Name of the project the VPC is related to.}
		# state: ${18:#present|absent|restarted}
		# api_key: ${19:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_vpn_gateway "Manages site-to-site VPN gateways on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_gateway:
		vpc: ${2:# Name of the VPC.}
		# account: ${3:# Account the VPN gateway is related to.}
		# poll_async: ${4:yes}
		# api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${6:#get|post}
		# state: ${7:#present|absent}
		# api_secret: ${8:# Secret key of the CloudStack API.}
		# api_timeout: ${9:10}
		# api_region: ${10:cloudstack}
		# project: ${11:# Name of the project the VPN gateway is related to.}
		# zone: ${12:# Name of the zone the VPC is related to.}
		# domain: ${13:# Domain the VPN gateway is related to.}
		# api_key: ${14:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_zone "Manages zones on Apache CloudStack based clouds." b
- name: $1
	cs_zone:
		name: ${2:# Name of the zone.}
		# domain: ${3:# Domain the zone is related to.}
		# api_http_method: ${4:#get|post}
		# api_secret: ${5:# Secret key of the CloudStack API.}
		# dhcp_provider: ${6:# DHCP provider for the Zone.}
		# api_timeout: ${7:10}
		# guest_cidr_address: ${8:# Guest CIDR address for the zone.}
		# dns2_ipv6: ${9:# Second DNS for IPv6 for the zone.}
		# dns1_ipv6: ${10:# First DNS for IPv6 for the zone.}
		# id: ${11:# uuid of the existing zone.}
		# internal_dns1: ${12:# First internal DNS for the zone.}
		# internal_dns2: ${13:# Second internal DNS for the zone.}
		# network_domain: ${14:# Network domain for the zone.}
		# api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# dns2: ${16:# Second DNS for the zone.}
		# dns1: ${17:# First DNS for the zone.}
		# api_region: ${18:cloudstack}
		# state: ${19:#present|enabled|disabled|absent}
		# api_key: ${20:# API key of the CloudStack API.}
		# network_type: ${21:#basic|advanced}
$0
endsnippet

snippet cs_zone_facts "Gathering facts of zones from Apache CloudStack based clouds." b
- name: $1
	cs_zone_facts:
		name: ${2:# Name of the zone.}
		# api_key: ${3:# API key of the CloudStack API.}
		# api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		# api_http_method: ${5:#get|post}
		# api_secret: ${6:# Secret key of the CloudStack API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
$0
endsnippet

snippet digital_ocean "Create/delete a droplet/SSH_key in DigitalOcean" b
- name: $1
	digital_ocean:
		# unique_name: ${2:yes|#no}
		# virtio: ${3:#yes|no}
		# region_id: ${4:# This is the slug of the region you would like your server to be created in.}
		# backups_enabled: ${5:yes|#no}
		# user_data: ${6:# opaque blob of data which is made available to the droplet}
		# image_id: ${7:# This is the slug of the image you would like the droplet created with.}
		# wait_timeout: ${8:300}
		# api_token: ${9:# DigitalOcean api token.}
		# ssh_pub_key: ${10:# The public SSH key you want to add to your account.}
		# wait: ${11:#yes|no}
		# name: ${12:# String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.}
		# size_id: ${13:# This is the slug of the size you would like the droplet created with.}
		# id: ${14:# Numeric, the droplet id you want to operate on.}
		# state: ${15:#present|active|absent|deleted}
		# command: ${16:#droplet|ssh}
		# ssh_key_ids: ${17:# Optional, array of SSH key (numeric) ID that you would like to be added to the server.}
		# ipv6: ${18:yes|#no}
		# private_networking: ${19:yes|#no}
$0
endsnippet

snippet digital_ocean_block_storage "Create/destroy or attach/detach Block Storage volumes in DigitalOcean" b
- name: $1
	digital_ocean_block_storage:
		region: ${2:# The slug of the region where your Block Storage volume should be located in.}
		volume_name: ${3:# The name of the Block Storage volume.}
		state: ${4:present|absent}
		command: ${5:create|attach}
		api_token: ${6:# DigitalOcean api token.}
		# droplet_id: ${7:# The droplet id you want to operate on. Required when command=attach.}
		# description: ${8:# Description of the Block Storage volume.}
		# timeout: ${9:10}
		# block_size: ${10:# The size of the Block Storage volume in gigabytes. Required when command=create and state=present.}
$0
endsnippet

snippet digital_ocean_domain "Create/delete a DNS record in DigitalOcean" b
- name: $1
	digital_ocean_domain:
		# ip: ${2:# The IP address to point a domain at.}
		# state: ${3:#present|absent}
		# api_token: ${4:# DigitalOcean api token.}
		# id: ${5:# Numeric, the droplet id you want to operate on.}
		# name: ${6:# String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.}
$0
endsnippet

snippet digital_ocean_floating_ip "Manage DigitalOcean Floating IPs" b
- name: $1
	digital_ocean_floating_ip:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# ip: ${3:# Public IP address of the Floating IP. Used to remove an IP}
		# state: ${4:#present|absent}
		# region: ${5:# The region that the Floating IP is reserved to.}
		# droplet_id: ${6:# The Droplet that the Floating IP has been assigned to.}
$0
endsnippet

snippet digital_ocean_sshkey "Manage DigitalOcean SSH keys" b
- name: $1
	digital_ocean_sshkey:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# state: ${3:#present|absent}
		# fingerprint: ${4:# This is a unique identifier for the SSH key used to delete a key}
		# ssh_pub_key: ${5:# The Public SSH key to add.}
		# name: ${6:# The name for the SSH key}
$0
endsnippet

snippet digital_ocean_tag "Create and remove tag(s) to DigitalOcean resource." b
- name: $1
	digital_ocean_tag:
		name: ${2:# The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.}
		# state: ${3:#present|absent}
		# resource_id: ${4:# The ID of the resource to operate on.}
		# resource_type: ${5:#droplet}
		# api_token: ${6:# DigitalOcean api token.}
$0
endsnippet

snippet dimensiondata_network "Create, update, and delete MCP 1.0 & 2.0 networks" b
- name: $1
	dimensiondata_network:
		name: ${2:# The name of the network domain to create.}
		location: ${3:# The target datacenter.}
		# service_plan: ${4:#ESSENTIALS|ADVANCED}
		# mcp_user: ${5:# The username used to authenticate to the CloudControl API.}
		# wait_poll_interval: ${6:2}
		# mcp_password: ${7:# The password used to authenticate to the CloudControl API.}
		# region: ${8:Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.}
		# description: ${9:# Additional description of the network domain.}
		# wait_time: ${10:600}
		# state: ${11:#present|absent}
		# validate_certs: ${12:yes}
		# wait: ${13:no}
$0
endsnippet

snippet docker_container "manage docker containers" b
- name: $1
	docker_container:
		name: ${2:# Assign a name to a new container or match an existing container.}
		# tty: ${3:no}
		# dns_servers: ${4:# List of custom DNS servers.}
		# auto_remove: ${5:no}
		# image: ${6:# Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.}
		# labels: ${7:# Dictionary of key value pairs.}
		# docker_host: ${8:unix://var/run/docker.sock}
		# cpuset_cpus: ${9:# CPUs in which to allow execution C(1,3) or C(1-3).}
		# force_kill: ${10:no}
		# pid_mode: ${11:# Set the PID namespace mode for the container. Currently only supports 'host'.}
		# networks: ${12:# List of networks the container belongs to.}
		# cpu_period: ${13:0}
		# tmpfs: ${14:# Mount a tmpfs directory}
		# working_dir: ${15:# Path to the working directory.}
		# capabilities: ${16:# List of capabilities to add to the container.}
		# restart: ${17:no}
		# mac_address: ${18:# Container MAC address (e.g. 92:d0:c6:0a:29:33)}
		# volumes_from: ${19:# List of container names or Ids to get volumes from.}
		# log_options: ${20:# Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details.}
		# memory_reservation: ${21:0}
		# recreate: ${22:no}
		# ipc_mode: ${23:# Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.}
		# memory: ${24:0}
		# memory_swappiness: ${25:0}
		# network_mode: ${26:bridge|container:<name|id>|host|none}
		# detach: ${27:yes}
		# memory_swap: ${28:0}
		# pull: ${29:no}
		# stop_signal: ${30:# Override default signal used to stop the container.}
		# devices: ${31:# List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>}
		# uts: ${32:# Set the UTS namespace mode for the container.}
		# published_ports: ${33:# List of ports to publish from the container to the host.}
		# timeout: ${34:60}
		# dns_search_domains: ${35:# List of custom DNS search domains.}
		# ulimits: ${36:# List of ulimit options. A ulimit is specified as C(nofile:262144:262144)}
		# interactive: ${37:no}
		# links: ${38:# List of name aliases for linked containers in the format C(container_name:alias)}
		# oom_score_adj: ${39:0}
		# restart_policy: ${40:always|False|#on-failure|unless-stopped}
		# paused: ${41:no}
		# tls_verify: ${42:no}
		# stop_timeout: ${43:# Number of seconds to wait for the container to stop before sending SIGKILL.}
		# kernel_memory: ${44:0}
		# env_file: ${45:# Path to a file containing environment variables I(FOO=BAR).}
		# cpu_quota: ${46:0}
		# read_only: ${47:no}
		# cpuset_mems: ${48:# Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)}
		# hostname: ${49:# Container hostname.}
		# state: ${50:absent|present|stopped|#started}
		# cleanup: ${51:no}
		# entrypoint: ${52:# Command that overwrites the default ENTRYPOINT of the image.}
		# key_path: ${53:# Path to the client's TLS key file.}
		# env: ${54:# Dictionary of key,value pairs.}
		# keep_volumes: ${55:yes}
		# blkio_weight: ${56:# Block IO (relative weight), between 10 and 1000.}
		# privileged: ${57:no}
		# api_version: ${58:default provided by docker-py}
		# exposed_ports: ${59:# List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.}
		# trust_image_content: ${60:no}
		# cacert_path: ${61:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# log_driver: ${62:none|json-file|syslog|journald|gelf|fluentd|awslogs|splunk}
		# oom_killer: ${63:no}
		# shm_size: ${64:# Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes).}
		# kill_signal: ${65:# Override default signal used to kill a running container.}
		# tls_hostname: ${66:localhost}
		# volume_driver: ${67:none}
		# user: ${68:# Sets the username or UID used and optionally the groupname or GID for the specified command.}
		# groups: ${69:# List of additional group names and/or IDs that the container process will run as.}
		# cert_path: ${70:# Path to the client's TLS certificate file.}
		# purge_networks: ${71:no}
		# tls: ${72:no}
		# ignore_image: ${73:no}
		# ssl_version: ${74:1.0}
		# security_opts: ${75:# List of security options in the form of C("label:user:User")}
		# etc_hosts: ${76:# Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.}
		# sysctls: ${77:# Dictionary of key,value pairs.}
		# command: ${78:# Command to execute when the container starts. A command may be either a string or a list. Prior to version 2.4, strings were split on commas.}
		# volumes: ${79:# List of volumes to mount within the container.}
		# cpu_shares: ${80:# CPU shares (relative weight).}
		# restart_retries: ${81:0}
$0
endsnippet

snippet docker_image "Manage docker images." b
- name: $1
	docker_image:
		name: ${2:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}
		# archive_path: ${3:# Use with state C(present) to archive an image to a .tar file.}
		# cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# force: ${5:no}
		# buildargs: ${6:# Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.}
		# repository: ${7:# Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).}
		# tls_hostname: ${8:localhost}
		# docker_host: ${9:unix://var/run/docker.sock}
		# tls_verify: ${10:no}
		# path: ${11:# Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.}
		# cert_path: ${12:# Path to the client's TLS certificate file.}
		# tls: ${13:no}
		# pull: ${14:yes}
		# nocache: ${15:no}
		# container_limits: ${16:# A dictionary of limits applied to each container created by the build process.}
		# dockerfile: ${17:Dockerfile}
		# ssl_version: ${18:1.0}
		# load_path: ${19:# Use with state C(present) to load an image from a .tar file.}
		# use_tls: ${20:#False|encrypt|verify}
		# state: ${21:absent|#present|build}
		# tag: ${22:latest}
		# key_path: ${23:# Path to the client's TLS key file.}
		# timeout: ${24:60}
		# push: ${25:no}
		# rm: ${26:yes}
		# http_timeout: ${27:# Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.}
		# api_version: ${28:default provided by docker-py}
$0
endsnippet

snippet docker_image_facts "Inspect docker images" b
- name: $1
	docker_image_facts:
		name: ${2:# An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.}
		# tls: ${3:no}
		# cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# ssl_version: ${5:1.0}
		# tls_hostname: ${6:localhost}
		# docker_host: ${7:unix://var/run/docker.sock}
		# tls_verify: ${8:no}
		# key_path: ${9:# Path to the client's TLS key file.}
		# timeout: ${10:60}
		# cert_path: ${11:# Path to the client's TLS certificate file.}
		# api_version: ${12:default provided by docker-py}
$0
endsnippet

snippet docker_login "Log into a Docker registry." b
- name: $1
	docker_login:
		username: ${2:# The username for the registry account}
		password: ${3:# The plaintext password for the registry account}
		# tls: ${4:no}
		# cacert_path: ${5:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# config_path: ${6:~/.docker/config.json}
		# registry_url: ${7:https://index.docker.io/v1/}
		# ssl_version: ${8:1.0}
		# state: ${9:#present|absent}
		# tls_hostname: ${10:localhost}
		# docker_host: ${11:unix://var/run/docker.sock}
		# tls_verify: ${12:no}
		# key_path: ${13:# Path to the client's TLS key file.}
		# timeout: ${14:60}
		# cert_path: ${15:# Path to the client's TLS certificate file.}
		# email: ${16:# The email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it.}
		# api_version: ${17:default provided by docker-py}
		# reauthorize: ${18:yes|no}
$0
endsnippet

snippet docker_network "Manage Docker networks" b
- name: $1
	docker_network:
		name: ${2:# Name of the network to operate on.}
		# tls: ${3:no}
		# cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# force: ${5:no}
		# driver: ${6:bridge}
		# driver_options: ${7:# Dictionary of network settings. Consult docker docs for valid options and values.}
		# ssl_version: ${8:1.0}
		# state: ${9:absent|#present}
		# ipam_options: ${10:# Dictionary of IPAM options.}
		# tls_hostname: ${11:localhost}
		# docker_host: ${12:unix://var/run/docker.sock}
		# tls_verify: ${13:no}
		# connected: ${14:# List of container names or container IDs to connect to a network.}
		# key_path: ${15:# Path to the client's TLS key file.}
		# timeout: ${16:60}
		# ipam_driver: ${17:# Specify an IPAM driver.}
		# cert_path: ${18:# Path to the client's TLS certificate file.}
		# appends: ${19:no}
		# api_version: ${20:default provided by docker-py}
$0
endsnippet

snippet docker_secret "Manage docker secrets." b
- name: $1
	docker_secret:
		name: ${2:# The name of the secret.}
		# tls: ${3:no}
		# cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# force: ${5:no}
		# labels: ${6:# A map of key:value meta data, where both the I(key) and I(value) are expected to be a string.}
		# ssl_version: ${7:1.0}
		# state: ${8:absent|#present}
		# tls_hostname: ${9:localhost}
		# docker_host: ${10:unix://var/run/docker.sock}
		# tls_verify: ${11:no}
		# key_path: ${12:# Path to the client's TLS key file.}
		# timeout: ${13:60}
		# cert_path: ${14:# Path to the client's TLS certificate file.}
		# data: ${15:# String. The value of the secret. Required when state is C(present).}
		# api_version: ${16:default provided by docker-py}
$0
endsnippet

snippet docker_service "Manage docker services and containers." b
- name: $1
	docker_service:
		# files: ${2:# List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.}
		# cacert_path: ${3:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# project_src: ${4:# Path to a directory containing a docker-compose.yml or docker-compose.yaml file.}
		# hostname_check: ${5:no}
		# project_name: ${6:# Provide a project name. If not provided, the project name is taken from the basename of C(project_src).}
		# recreate: ${7:always|never|#smart}
		# tls_hostname: ${8:localhost}
		# docker_host: ${9:unix://var/run/docker.sock}
		# tls_verify: ${10:no}
		# remove_images: ${11:# Use with state I(absent) to remove the all images or only local images.}
		# services: ${12:# When C(state) is I(present) run I(docker-compose up) on a subset of services.}
		# cert_path: ${13:# Path to the client's TLS certificate file.}
		# tls: ${14:no}
		# pull: ${15:no}
		# scale: ${16:# When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.}
		# nocache: ${17:no}
		# restarted: ${18:no}
		# ssl_version: ${19:1.0}
		# remove_volumes: ${20:no}
		# state: ${21:absent|#present}
		# dependencies: ${22:yes}
		# stopped: ${23:no}
		# key_path: ${24:# Path to the client's TLS key file.}
		# timeout: ${25:60}
		# debug: ${26:no}
		# definition: ${27:# Provide docker-compose yaml describing one or more services, networks and volumes.}
		# api_version: ${28:default provided by docker-py}
		# build: ${29:no}
$0
endsnippet

snippet docker_volume "Manage Docker volumes" b
- name: $1
	docker_volume:
		name: ${2:# Name of the volume to operate on.}
		# tls: ${3:no}
		# cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		# force: ${5:no}
		# driver: ${6:local}
		# driver_options: ${7:# Dictionary of volume settings. Consult docker docs for valid options and values: U(https://docs.docker.com/engine/reference/commandline/volume_create/#driver-specific-options)}
		# labels: ${8:# List of labels to set for the volume}
		# ssl_version: ${9:1.0}
		# state: ${10:absent|#present}
		# tls_hostname: ${11:localhost}
		# docker_host: ${12:unix://var/run/docker.sock}
		# tls_verify: ${13:no}
		# key_path: ${14:# Path to the client's TLS key file.}
		# timeout: ${15:60}
		# cert_path: ${16:# Path to the client's TLS certificate file.}
		# api_version: ${17:default provided by docker-py}
$0
endsnippet

snippet gc_storage "This module manages objects/buckets in Google Cloud Storage." b
- name: $1
	gc_storage:
		gs_access_key: ${2:# GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.}
		bucket: ${3:# Bucket name.}
		mode: ${4:get|put|get_url|get_str|delete|create}
		gs_secret_key: ${5:# GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used.}
		# src: ${6:# The source file path when performing a PUT operation.}
		# force: ${7:yes}
		# permission: ${8:private}
		# dest: ${9:# The destination file path when downloading an object/key with a GET operation.}
		# object: ${10:# Keyname of the object inside the bucket. Can be also be used to create "virtual directories" (see examples).}
		# expiration: ${11:# Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.}
		# region: ${12:US}
		# versioning: ${13:yes|no}
		# headers: ${14:{}}
$0
endsnippet

snippet gcdns_record "Creates or removes resource records in Google Cloud DNS" b
- name: $1
	gcdns_record:
		record: ${2:# The fully-qualified domain name of the resource record.}
		type: ${3:A|AAAA|CNAME|SRV|TXT|SOA|NS|MX|SPF|PTR}
		# zone_id: ${4:# The Google Cloud ID of the zone (e.g., example-com).}
		# zone: ${5:# The DNS domain name of the zone (e.g., example.com).}
		# service_account_email: ${6:# The e-mail address for a service account with access to Google Cloud DNS.}
		# ttl: ${7:300}
		# pem_file: ${8:# The path to the PEM file associated with the service account email.}
		# record_data: ${9:# The record_data to use for the resource record.}
		# state: ${10:#present|absent}
		# credentials_file: ${11:# The path to the JSON file associated with the service account email.}
		# project_id: ${12:# The Google Cloud Platform project ID to use.}
		# overwrite: ${13:True|#False}
$0
endsnippet

snippet gcdns_zone "Creates or removes zones in Google Cloud DNS" b
- name: $1
	gcdns_zone:
		zone: ${2:# The DNS domain name of the zone.}
		# state: ${3:#present|absent}
		# description: ${4:}
		# credentials_file: ${5:# The path to the JSON file associated with the service account email.}
		# service_account_email: ${6:# The e-mail address for a service account with access to Google Cloud DNS.}
		# project_id: ${7:# The Google Cloud Platform project ID to use.}
		# pem_file: ${8:# The path to the PEM file associated with the service account email.}
$0
endsnippet

snippet gce "create or terminate GCE instances" b
- name: $1
	gce:
		zone: ${2:us-central1-a}
		# disks: ${3:# a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).}
		# num_instances: ${4:# can be used with 'name', specifies the number of nodes to provision using 'name' as a base name}
		# ip_forward: ${5:false}
		# image: ${6:debian-8}
		# service_account_permissions: ${7:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
		# pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		# instance_names: ${9:# a comma-separated list of instance names to create or destroy}
		# machine_type: ${10:n1-standard-1}
		# external_projects: ${11:# A list of other projects (accessible with the provisioning credentials) to be searched for the image.}
		# name: ${12:# either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes}
		# disk_size: ${13:10}
		# network: ${14:default}
		# external_ip: ${15:ephemeral}
		# service_account_email: ${16:# service account email}
		# tags: ${17:# a comma-separated list of tags to associate with the instance}
		# persistent_boot_disk: ${18:false}
		# disk_auto_delete: ${19:true}
		# preemptible: ${20:false}
		# state: ${21:active|#present|absent|deleted|started|stopped|terminated}
		# credentials_file: ${22:# path to the JSON file associated with the service account email}
		# subnetwork: ${23:# name of the subnetwork in which the instance should be created}
		# project_id: ${24:# your GCE project ID}
		# image_family: ${25:# image family from which to select the image.  The most recent non-deprecated image in the family will be used.}
		# metadata: ${26:# a hash/dictionary of custom data for the instance; '{"key":"value", ...}'}
$0
endsnippet

snippet gce_eip "Create or Destroy Global or Regional External IP addresses." b
- name: $1
	gce_eip:
		region: ${2:# Region to create the address in. Set to 'global' to create a global address.}
		name: ${3:# Name of Address.}
		# state: ${4:#present|absent}
$0
endsnippet

snippet gce_img "utilize GCE image resources" b
- name: $1
	gce_img:
		name: ${2:# the name of the image to create or delete}
		# project_id: ${3:# your GCE project ID}
		# family: ${4:# an optional family name}
		# service_account_email: ${5:# service account email}
		# pem_file: ${6:# path to the pem file associated with the service account email}
		# source: ${7:# the source disk or the Google Cloud Storage URI to create the image from}
		# state: ${8:#present|absent}
		# timeout: ${9:180}
		# zone: ${10:us-central1-a}
		# description: ${11:# an optional description}
$0
endsnippet

snippet gce_instance_template "create or destroy instance templates of Compute Engine of GCP." b
- name: $1
	gce_instance_template:
		name: ${2:# The name of the GCE instance template.}
		# description: ${3:# description of instance template}
		# tags: ${4:# a comma-separated list of tags to associate with the instance}
		# automatic_restart: ${5:# Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.}
		# image: ${6:# The image to use to create the instance. Cannot specify both both I(image) and I(source).}
		# service_account_permissions: ${7:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
		# pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		# subnetwork_region: ${9:# Region that subnetwork resides in. (Required for subnetwork to successfully complete)}
		# disk_type: ${10:pd-standard}
		# size: ${11:f1-micro}
		# network: ${12:default}
		# external_ip: ${13:ephemeral}
		# service_account_email: ${14:# service account email}
		# disks: ${15:# a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).}
		# nic_gce_struct: ${16:# Support passing in the GCE-specific formatted networkInterfaces[] structure.}
		# disk_auto_delete: ${17:yes}
		# source: ${18:# A source disk to attach to the instance. Cannot specify both I(image) and I(source).}
		# state: ${19:#present|absent}
		# disks_gce_struct: ${20:# Support passing in the GCE-specific formatted formatted disks[] structure. Case sensitive. see U(https://cloud.google.com/compute/docs/reference/latest/instanceTemplates#resource) for detailed information}
		# credentials_file: ${21:# path to the JSON file associated with the service account email}
		# image_family: ${22:# The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source).}
		# subnetwork: ${23:# The Subnetwork resource name for this instance.}
		# project_id: ${24:# your GCE project ID}
		# can_ip_forward: ${25:no}
		# preemptible: ${26:# Defines whether the instance is preemptible.}
		# metadata: ${27:# a hash/dictionary of custom data for the instance; '{"key":"value", ...}'}
$0
endsnippet

snippet gce_labels "Create, Update or Destory GCE Labels." b
- name: $1
	gce_labels:
		# labels: ${2:# A list of labels (key/value pairs) to add or remove for the resource.}
		# resource_url: ${3:# The 'self_link' for the resource (instance, disk, snapshot, etc)}
		# resource_name: ${4:# The name of resource.}
		# resource_type: ${5:# The type of resource (instances, disks, snapshots, images)}
		# resource_location: ${6:# The location of resource (global, us-central1-f, etc.)}
$0
endsnippet

snippet gce_lb "create/destroy GCE load-balancer resources" b
- name: $1
	gce_lb:
		# httphealthcheck_host: ${2:# host header to pass through on HTTP check requests}
		# protocol: ${3:#tcp|udp}
		# pem_file: ${4:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		# members: ${5:# a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]}
		# httphealthcheck_port: ${6:80}
		# httphealthcheck_name: ${7:# the name identifier for the HTTP health check}
		# name: ${8:# name of the load-balancer resource}
		# external_ip: ${9:# the external static IPv4 (or auto-assigned) address for the LB}
		# service_account_email: ${10:# service account email}
		# region: ${11:# the GCE region where the load-balancer is defined}
		# httphealthcheck_unhealthy_count: ${12:2}
		# httphealthcheck_healthy_count: ${13:2}
		# httphealthcheck_path: ${14:/}
		# port_range: ${15:# the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports}
		# state: ${16:active|#present|absent|deleted}
		# httphealthcheck_timeout: ${17:5}
		# credentials_file: ${18:# path to the JSON file associated with the service account email}
		# project_id: ${19:# your GCE project ID}
		# httphealthcheck_interval: ${20:5}
$0
endsnippet

snippet gce_mig "Create, Update or Destroy a Managed Instance Group (MIG)." b
- name: $1
	gce_mig:
		name: ${2:# Name of the Managed Instance Group.}
		zone: ${3:# The GCE zone to use for this Managed Instance Group.}
		# service_account_email: ${4:# service account email}
		# autoscaling: ${5:# A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.}
		# named_ports: ${6:# Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.}
		# state: ${7:absent|#present}
		# template: ${8:# Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.}
		# credentials_file: ${9:# Path to the JSON file associated with the service account email}
		# project_id: ${10:# GCE project ID}
		# size: ${11:# Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.}
$0
endsnippet

snippet gce_net "create/destroy GCE networks and firewall rules" b
- name: $1
	gce_net:
		# src_tags: ${2:[]}
		# subnet_region: ${3:# region of subnet to create}
		# ipv4_range: ${4:# the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory}
		# pem_file: ${5:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		# target_tags: ${6:[]}
		# allowed: ${7:# the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or 'tcp:80-800;udp:1-25') this parameter is mandatory when creating or updating a firewall rule}
		# fwname: ${8:# name of the firewall rule}
		# name: ${9:# name of the network}
		# src_range: ${10:[]}
		# state: ${11:active|#present|absent|deleted}
		# subnet_name: ${12:# name of subnet to create}
		# mode: ${13:#legacy|auto|custom}
		# credentials_file: ${14:# path to the JSON file associated with the service account email}
		# service_account_email: ${15:# service account email}
		# project_id: ${16:# your GCE project ID}
		# subnet_desc: ${17:# description of subnet to create}
$0
endsnippet

snippet gce_pd "utilize GCE persistent disk resources" b
- name: $1
	gce_pd:
		name: ${2:# name of the disk}
		# size_gb: ${3:10}
		# project_id: ${4:# your GCE project ID}
		# zone: ${5:us-central1-b}
		# service_account_email: ${6:# service account email}
		# image: ${7:# the source image to use for the disk}
		# pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		# instance_name: ${9:# instance name if you wish to attach or detach the disk}
		# state: ${10:active|#present|absent|deleted}
		# snapshot: ${11:# the source snapshot to use for the disk}
		# detach_only: ${12:yes|#no}
		# credentials_file: ${13:# path to the JSON file associated with the service account email}
		# disk_type: ${14:#pd-standard|pd-ssd}
		# delete_on_termination: ${15:yes|no}
		# mode: ${16:READ_WRITE|#READ_ONLY}
$0
endsnippet

snippet gce_snapshot "Create or destroy snapshots for GCE storage volumes" b
- name: $1
	gce_snapshot:
		instance_name: ${2:# The GCE instance to snapshot}
		project_id: ${3:# The GCP project ID to use}
		credentials_file: ${4:# The path to the credentials file associated with the service account}
		service_account_email: ${5:# GCP service account email for the project where the instance resides}
		# state: ${6:#present|absent}
		# snapshot_name: ${7:# The name of the snapshot to manage}
		# disks: ${8:all}
$0
endsnippet

snippet gce_tag "add or remove tag(s) to/from GCE instances" b
- name: $1
	gce_tag:
		tags: ${2:# comma-separated list of tags to add or remove}
		# zone: ${3:us-central1-a}
		# service_account_email: ${4:# service account email}
		# pem_file: ${5:# path to the pem file associated with the service account email}
		# instance_name: ${6:# The name of the GCE instance to add/remove tags.  Required if instance_pattern is not specified.}
		# state: ${7:#present|absent}
		# instance_pattern: ${8:# The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details. If instance_name is not specified, this field is required.}
		# project_id: ${9:# your GCE project ID}
$0
endsnippet

snippet gcp_backend_service "Create or Destroy a Backend Service." b
- name: $1
	gcp_backend_service:
		backends: ${2:# List of backends that make up the backend service. A backend is made up of an instance group and optionally several other parameters.  See U(https://cloud.google.com/compute/docs/reference/latest/backendServices) for details.}
		healthchecks: ${3:# List of healthchecks. Only one healthcheck is supported.}
		backend_service_name: ${4:# Name of the Backend Service.}
		# protocol: ${5:# The protocol this Backend Service uses to communicate with backends. Possible values are HTTP, HTTPS, TCP, and SSL. The default is HTTP.}
		# enable_cdn: ${6:# If true, enable Cloud CDN for this Backend Service.}
		# service_account_email: ${7:# Service account email}
		# state: ${8:absent|#present}
		# port_name: ${9:# Name of the port on the managed instance group (MIG) that backend services can forward data to. Required for external load balancing.}
		# timeout: ${10:# How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is 1-86400.}
		# credentials_file: ${11:# Path to the JSON file associated with the service account email.}
		# project_id: ${12:# GCE project ID.}
$0
endsnippet

snippet gcp_forwarding_rule "Create, Update or Destroy a Forwarding_Rule." b
- name: $1
	gcp_forwarding_rule:
		forwarding_rule_name: ${2:# Name of the Forwarding_Rule.}
		state: ${3:present|absent}
		# port_range: ${4:# For global forwarding rules, must be set to 80 or 8080 for TargetHttpProxy, and 443 for TargetHttpsProxy or TargetSslProxy.}
		# protocol: ${5:# For global forwarding rules, TCP, UDP, ESP, AH, SCTP or ICMP. Default is TCP.}
		# target: ${6:# Target resource for forwarding rule. For global proxy, this is a Global TargetProxy resource. Required for external load balancing (including Global load balancing)}
		# address: ${7:# IPv4 or named IP address. Must be of the same scope (regional, global). Reserved addresses can (and probably should) be used for global forwarding rules. You may reserve IPs from the console or via the gce_eip module.}
		# region: ${8:# The region for this forwarding rule. Currently, only 'global' is supported.}
$0
endsnippet

snippet gcp_healthcheck "Create, Update or Destroy a Healthcheck." b
- name: $1
	gcp_healthcheck:
		healthcheck_name: ${2:# Name of the Healthcheck.}
		healthcheck_type: ${3:HTTP|HTTPS}
		host_header: ${4:}
		state: ${5:present|absent}
		# check_interval: ${6:5}
		# service_account_email: ${7:# service account email}
		# healthy_threshold: ${8:2}
		# service_account_permissions: ${9:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
		# unhealthy_threshold: ${10:2}
		# timeout: ${11:5}
		# credentials_file: ${12:# Path to the JSON file associated with the service account email}
		# project_id: ${13:# Your GCP project ID}
		# port: ${14:# The TCP port number for the health check request. The default value is 443 for HTTPS and 80 for HTTP.}
		# request_path: ${15:/}
$0
endsnippet

snippet gcp_target_proxy "Create, Update or Destroy a Target_Proxy." b
- name: $1
	gcp_target_proxy:
		target_proxy_type: ${2:# Type of Target_Proxy. HTTP, HTTPS or SSL. Only HTTP is currently supported.}
		target_proxy_name: ${3:# Name of the Target_Proxy.}
		# url_map_name: ${4:# Name of the Url Map.  Required if type is HTTP or HTTPS proxy.}
$0
endsnippet

snippet gcp_url_map "Create, Update or Destory a Url_Map." b
- name: $1
	gcp_url_map:
		default_service: ${2:# Default Backend Service if no host rules match.}
		url_map_name: ${3:# Name of the Url_Map.}
		# host_rules: ${4:# The list of HostRules to use against the URL. Contains a list of hosts and an associated path_matcher.}
		# path_matchers: ${5:# The list of named PathMatchers to use against the URL. Contains path_rules, which is a list of paths and an associated service. A default_service can also be specified for each path_matcher.}
$0
endsnippet

snippet gcpubsub "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub." b
- name: $1
	gcpubsub:
		topic: ${2:# GCP pubsub topic name.  Only the name, not the full path, is required.}
		# pull: ${3:# Subfield of subscription. Not required. If specified, messages will be retrieved from topic via the provided subscription name. max_messages (int; default None; max number of messages to pull), message_ack (bool; default False; acknowledge the message) and return_immediately (bool; default True, don't wait for messages to appear). If the messages are acknowledged, changed is set to True, otherwise, changed is False.}
		# ack_deadline: ${4:# S}
		# name: ${5:# S}
		# publish: ${6:# List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.}
		# state: ${7:present}
		# push_endpoint: ${8:# Subfield of subscription.  Not required.  If specified, message will be sent to an endpoint. See U(https://cloud.google.com/pubsub/docs/advanced#push_endpoints) for more information.}
		# subscription: ${9:# Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields. See subfields name, push_endpoint and ack_deadline for more information.}
$0
endsnippet

snippet gcpubsub_facts "List Topics/Subscriptions and Messages from Google PubSub." b
- name: $1
	gcpubsub_facts:
		view: ${2:# Choices are 'topics' or 'subscriptions'}
		# topic: ${3:# GCP pubsub topic name.  Only the name, not the full path, is required.}
		# state: ${4:# list is the only valid option.}
$0
endsnippet

snippet gcspanner "Create and Delete Instances/Databases on Spanner." b
- name: $1
	gcspanner:
		instance_id: ${2:# GCP spanner instance name.}
		configuration: ${3:# Configuration the instance should use. Examples are us-central1, asia-east1 and europe-west1.}
		# state: ${4:present}
		# instance_display_name: ${5:# Name of Instance to display.  If not specified, instance_id will be used instead.}
		# database_name: ${6:# Name of database contained on the instance.}
		# force_instance_delete: ${7:no}
		# node_count: ${8:# Number of nodes in the instance.  If not specified while creating an instance, node_count will be set to 1.}
$0
endsnippet

snippet linode "create / delete / stop / restart an instance in Linode Public Cloud" b
- name: $1
	linode:
		# alert_diskio_enabled: ${2:True|False}
		# additional_disks: ${3:# L}
		# alert_bwin_enabled: ${4:True|False}
		# payment_term: ${5:#1|12|24}
		# kernel_id: ${6:# kernel to use for the instance (Linode Kernel)}
		# alert_bwin_threshold: ${7:# Set threshold in MB of bandwidth in alerts.}
		# alert_cpu_enabled: ${8:True|False}
		# alert_bwquota_enabled: ${9:True|False}
		# linode_id: ${10:# Unique ID of a linode server}
		# alert_diskio_threshold: ${11:# Set threshold for average IO ops/sec over 2 hour period.}
		# wait_timeout: ${12:300}
		# private_ip: ${13:yes|#no}
		# watchdog: ${14:#True|False}
		# password: ${15:# root password to apply to a new server (auto generated if missing)}
		# ssh_pub_key: ${16:# SSH public key applied to root user}
		# wait: ${17:yes|#no}
		# datacenter: ${18:# datacenter to create an instance in (Linode Datacenter)}
		# alert_bwquota_threshold: ${19:# Set threshold in MB of bandwidth quota alerts.}
		# backupweeklyday: ${20:# Integer value for what day of the week to store weekly backups.}
		# name: ${21:# Name to give the instance (alphanumeric, dashes, underscore)}
		# displaygroup: ${22:# Add the instance to a Display Group in Linode Manager}
		# alert_cpu_threshold: ${23:# Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.}
		# alert_bwout_enabled: ${24:True|False}
		# state: ${25:#present|active|started|absent|deleted|stopped|restarted}
		# swap: ${26:512}
		# alert_bwout_threshold: ${27:# Set threshold in MB of bandwidth out alerts.}
		# distribution: ${28:# distribution to use for the instance (Linode Distribution)}
		# api_key: ${29:# Linode API key}
		# plan: ${30:# plan to use for the instance (Linode plan)}
$0
endsnippet

snippet lxc_container "Manage LXC Containers" b
- name: $1
	lxc_container:
		name: ${2:# Name of a container.}
		# archive_path: ${3:# Path the save the archived container. If the path does not exist the archive method will attempt to create it.}
		# zfs_root: ${4:# Create zfs under given zfsroot.}
		# container_log_level: ${5:#INFO|ERROR|DEBUG}
		# template_options: ${6:# Template options when building the container.}
		# container_command: ${7:# Run a command within a container.}
		# clone_name: ${8:no}
		# lxc_path: ${9:# Place container under PATH}
		# container_config: ${10:# list of 'key=value' options to use when configuring a container.}
		# fs_type: ${11:ext4}
		# archive: ${12:True|#False}
		# vg_name: ${13:lxc}
		# clone_snapshot: ${14:True|#False}
		# container_log: ${15:True|#False}
		# lv_name: ${16:$CONTAINER_NAME}
		# fs_size: ${17:5G}
		# archive_compression: ${18:#gzip|bzip2|none}
		# backing_store: ${19:#dir|lvm|loop|btrfs|overlayfs|zfs}
		# state: ${20:#started|stopped|restarted|absent|frozen}
		# thinpool: ${21:# Use LVM thin pool called TP.}
		# template: ${22:ubuntu}
		# directory: ${23:# Place rootfs directory under DIR.}
		# config: ${24:# Path to the LXC configuration file.}
$0
endsnippet

snippet lxd_container "Manage LXD Containers" b
- name: $1
	lxd_container:
		name: ${2:# Name of a container.}
		# source: ${3:# The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		# url: ${4:unix:/var/lib/lxd/unix.socket}
		# config: ${5:# The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		# cert_file: ${6:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
		# ephemeral: ${7:# Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		# devices: ${8:# The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		# wait_for_ipv4_addresses: ${9:no}
		# state: ${10:#started|stopped|restarted|absent|frozen}
		# architecture: ${11:# The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		# timeout: ${12:30}
		# key_file: ${13:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
		# trust_password: ${14:# The client trusted password.}
		# force_stop: ${15:no}
$0
endsnippet

snippet lxd_profile "Manage LXD profiles" b
- name: $1
	lxd_profile:
		name: ${2:# Name of a profile.}
		# new_name: ${3:# A new name of a profile.}
		# url: ${4:unix:/var/lib/lxd/unix.socket}
		# config: ${5:# The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
		# cert_file: ${6:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
		# devices: ${7:# The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
		# state: ${8:#present|absent}
		# key_file: ${9:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
		# trust_password: ${10:# The client trusted password.}
$0
endsnippet

snippet helm "Manages Kubernetes packages with the Helm package manager" b
- name: $1
	helm:
		# disable_hooks: ${2:no}
		# name: ${3:# Release name to manage}
		# namespace: ${4:default}
		# chart: ${5:{}}
		# state: ${6:absent|purged|present}
		# values: ${7:{}}
		# host: ${8:localhost}
		# port: ${9:44134}
$0
endsnippet

snippet ovirt "oVirt/RHEV platform management" b
- name: $1
	ovirt:
		user: ${2:# the user to authenticate with}
		password: ${3:# password of the user to authenticate with}
		url: ${4:# the url of the oVirt instance}
		instance_name: ${5:# the name of the instance to use}
		# instance_mem: ${6:# the instance's amount of memory in MB}
		# instance_cores: ${7:1}
		# instance_cpus: ${8:1}
		# image: ${9:# template to use for the instance}
		# instance_hostname: ${10:# define the instance's Hostname}
		# instance_disksize: ${11:# size of the instance's disk in GB}
		# instance_nic: ${12:# name of the network interface in oVirt/RHEV}
		# instance_network: ${13:rhevm}
		# instance_type: ${14:#server|desktop}
		# sdomain: ${15:# the Storage Domain where you want to create the instance's disk on.}
		# instance_os: ${16:# type of Operating System}
		# instance_ip: ${17:# define the instance's IP}
		# zone: ${18:# deploy the image to this oVirt cluster}
		# disk_alloc: ${19:#thin|preallocated}
		# region: ${20:# the oVirt/RHEV datacenter where you want to deploy to}
		# instance_dns: ${21:# define the instance's Primary DNS server}
		# instance_netmask: ${22:# define the instance's Netmask}
		# state: ${23:#present|absent|shutdown|started|restarted}
		# instance_key: ${24:# define the instance's Authorized key}
		# instance_domain: ${25:# define the instance's Domain}
		# instance_rootpw: ${26:# define the instance's Root password}
		# resource_type: ${27:new|template}
		# disk_int: ${28:#virtio|ide}
$0
endsnippet

snippet proxmox "management of instances in Proxmox VE cluster" b
- name: $1
	proxmox:
		api_host: ${2:# the host of the Proxmox VE cluster}
		api_user: ${3:# the user to authenticate with}
		# node: ${4:# Proxmox VE node, when new VM will be created}
		# force: ${5:no}
		# cpuunits: ${6:1000}
		# vmid: ${7:# the instance id}
		# api_password: ${8:# the password to authenticate with}
		# cpus: ${9:1}
		# ostemplate: ${10:# the template for VM creating}
		# unprivileged: ${11:no}
		# disk: ${12:3}
		# ip_address: ${13:# specifies the address the container will be assigned}
		# pool: ${14:# Proxmox VE resource pool}
		# password: ${15:# the instance root password}
		# searchdomain: ${16:# sets DNS search domain for a container}
		# netif: ${17:# specifies network interfaces for the container. As a hash/dictionary defining interfaces.}
		# validate_certs: ${18:no}
		# hostname: ${19:# the instance hostname}
		# storage: ${20:local}
		# state: ${21:#present|started|absent|stopped|restarted}
		# swap: ${22:0}
		# timeout: ${23:30}
		# memory: ${24:512}
		# mounts: ${25:# specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points}
		# cores: ${26:1}
		# nameserver: ${27:# sets DNS server IP address for a container}
		# pubkey: ${28:# Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions}
		# onboot: ${29:no}
$0
endsnippet

snippet proxmox_kvm "Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster." b
- name: $1
	proxmox_kvm:
		api_host: ${2:# Specify the target host of the Proxmox VE cluster.}
		api_user: ${3:# Specify the user to authenticate with.}
		# revert: ${4:# Revert a pending change.}
		# boot: ${5:cnd}
		# migrate_speed: ${6:# Sets maximum speed (in MB/s) for migrations.}
		# vga: ${7:#std|cirrus|vmware|qxl|serial0|serial1|serial2|serial3|qxl2|qxl3|qxl4}
		# keyboard: ${8:# Sets the keyboard layout for VNC server.}
		# watchdog: ${9:# Creates a virtual hardware watchdog device.}
		# sockets: ${10:1}
		# digest: ${11:# Specify if to prevent changes if current configuration file has different SHA1 digest.}
		# tablet: ${12:yes|#no}
		# bios: ${13:seabios|ovmf}
		# hostpci: ${14:# Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').}
		# autostart: ${15:yes|#no}
		# memory: ${16:512}
		# migrate_downtime: ${17:# Sets maximum tolerated downtime (in seconds) for migrations.}
		# localtime: ${18:yes|no}
		# virtio: ${19:# A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').}
		# format: ${20:cloop|cow|qcow|#qcow2|qed|raw|vmdk}
		# snapname: ${21:# The name of the snapshot. Used only with clone.}
		# hotplug: ${22:# Selectively enable hotplug features.}
		# name: ${23:# Specifies the VM name. Only used on the configuration web interface.}
		# target: ${24:# Target node. Only allowed if the original VM is on shared storage.}
		# vmid: ${25:# Specifies the VM ID. Instead use I(name) parameter.}
		# bootdisk: ${26:# Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)}
		# vcpus: ${27:# Sets number of hotplugged vcpus.}
		# newid: ${28:# VMID for the clone. Used only with clone.}
		# timeout: ${29:30}
		# skiplock: ${30:# Ignore locks}
		# validate_certs: ${31:yes|#no}
		# onboot: ${32:#yes|no}
		# delete: ${33:# Specify a list of settings you want to delete.}
		# force: ${34:yes|no}
		# lock: ${35:migrate|backup|snapshot|rollback}
		# startup: ${36:# Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).}
		# agent: ${37:yes|no}
		# freeze: ${38:yes|no}
		# serial: ${39:# A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').}
		# startdate: ${40:# Sets the initial date of the real time clock.}
		# balloon: ${41:0}
		# cpuunits: ${42:1000}
		# storage: ${43:# Target storage for full clone.}
		# reboot: ${44:yes|no}
		# shares: ${45:# Rets amount of memory shares for auto-ballooning. (0 - 50000).}
		# machine: ${46:# Specifies the Qemu machine type.}
		# sata: ${47:# A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').}
		# state: ${48:#present|started|absent|stopped|restarted|current}
		# template: ${49:yes|#no}
		# net: ${50:# A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').}
		# acpi: ${51:#yes|no}
		# node: ${52:# Proxmox VE node, where the new VM will be created.}
		# full: ${53:yes|no}
		# description: ${54:# Specify the description for the VM. Only used on the configuration web interface.}
		# scsihw: ${55:lsi|lsi53c810|virtio-scsi-pci|virtio-scsi-single|megasas|pvscsi}
		# clone: ${56:# Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone.}
		# args: ${57:-serial unix:/var/run/qemu-server/VMID.serial,server,nowait}
		# api_password: ${58:# Specify the password to authenticate with.}
		# tdf: ${59:yes|no}
		# update: ${60:yes|#no}
		# kvm: ${61:#yes|no}
		# ostype: ${62:other|wxp|w2k|w2k3|w2k8|wvista|win7|win8|l24|#l26|solaris}
		# protection: ${63:yes|no}
		# numa: ${64:# A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').}
		# parallel: ${65:# A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').}
		# pool: ${66:# Add the new VM to the specified pool.}
		# cpulimit: ${67:# Specify if CPU usage will be limited. Value 0 indicates no CPU limit.}
		# hugepages: ${68:any|2|1024}
		# smbios: ${69:# Specifies SMBIOS type 1 fields.}
		# cores: ${70:1}
		# scsi: ${71:# A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').}
		# ide: ${72:# A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').}
		# cpu: ${73:kvm64}
$0
endsnippet

snippet proxmox_template "management of OS templates in Proxmox VE cluster" b
- name: $1
	proxmox_template:
		node: ${2:# Proxmox VE node, when you will operate with template}
		api_host: ${3:# the host of the Proxmox VE cluster}
		api_user: ${4:# the user to authenticate with}
		# src: ${5:# path to uploaded file}
		# force: ${6:no}
		# api_password: ${7:# the password to authenticate with}
		# storage: ${8:local}
		# state: ${9:#present|absent}
		# content_type: ${10:#vztmpl|iso}
		# timeout: ${11:30}
		# validate_certs: ${12:no}
		# template: ${13:# the template name}
$0
endsnippet

snippet rhevm "RHEV/oVirt automation" b
- name: $1
	rhevm:
		# vmhost: ${2:# The host you wish your VM to run on.}
		# vmmem: ${3:1}
		# cd_drive: ${4:# The CD you wish to have mounted on the VM when I(state = 'CD').}
		# image: ${5:# The template to use for the VM.}
		# cpu_share: ${6:0}
		# insecure_api: ${7:no}
		# cluster: ${8:# The rhev/ovirt cluster in which you want you VM to start.}
		# user: ${9:admin@internal}
		# port: ${10:443}
		# vm_ha: ${11:yes}
		# disks: ${12:# This option uses complex arguments and is a list of disks with the options name, size and domain.}
		# datacenter: ${13:Default}
		# name: ${14:# The name of the VM.}
		# ifaces: ${15:# This option uses complex arguments and is a list of interfaces with the options name and vlan.}
		# server: ${16:127.0.0.1}
		# state: ${17:ping|#present|absent|up|down|restarted|cd|info}
		# osver: ${18:rhel_6x64}
		# mempol: ${19:1}
		# timeout: ${20:# The timeout you wish to define for power actions.}
		# del_prot: ${21:yes}
		# boot_order: ${22:[u'network', u'hd']}
		# type: ${23:#server|desktop|host}
		# vmcpu: ${24:2}
$0
endsnippet

snippet serverless "Manages a Serverless Framework project" b
- name: $1
	serverless:
		service_path: ${2:# The path to the root of the Serverless Service to be operated on.}
		# functions: ${3:[]}
		# deploy: ${4:yes}
		# serverless_bin_path: ${5:# The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless}
		# region: ${6:us-east-1}
		# stage: ${7:# The name of the serverless framework project stage to deploy to. This uses the serverless framework default "dev".}
		# state: ${8:#present|absent}
$0
endsnippet

snippet virt "Manages virtual machines supported by libvirt" b
- name: $1
	virt:
		name: ${2:# name of the guest VM being managed. Note that VM must be previously defined with xml.}
		# xml: ${3:# XML document used with the define command}
		# state: ${4:running|shutdown|destroyed|paused}
		# command: ${5:create|status|start|stop|pause|unpause|shutdown|undefine|destroy|get_xml|freemem|list_vms|info|nodeinfo|virttype|define}
		# autostart: ${6:True|False}
		# uri: ${7:qemu:///system}
$0
endsnippet

snippet virt_net "Manage libvirt network configuration" b
- name: $1
	virt_net:
		name: ${2:# name of the network being managed. Note that network must be previously defined with xml.}
		# xml: ${3:# XML document used with the define command.}
		# state: ${4:active|inactive|present|absent}
		# command: ${5:define|create|start|stop|destroy|undefine|get_xml|list_nets|facts|info|status|modify}
		# autostart: ${6:yes|no}
		# uri: ${7:qemu:///system}
$0
endsnippet

snippet virt_pool "Manage libvirt storage pools" b
- name: $1
	virt_pool:
		# xml: ${2:# XML document used with the define command.}
		# state: ${3:active|inactive|present|absent|undefined|deleted}
		# command: ${4:define|build|create|start|stop|destroy|delete|undefine|get_xml|list_pools|facts|info|status}
		# name: ${5:# name of the storage pool being managed. Note that pool must be previously defined with xml.}
		# autostart: ${6:yes|no}
		# uri: ${7:qemu:///system}
		# mode: ${8:new|repair|resize|no_overwrite|overwrite|normal|zeroed}
$0
endsnippet

snippet xenserver_facts "get facts reported on xenserver" b
- name: $1
	xenserver_facts:
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# image: ${6:# Image the server should be rebuilt with}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# action: ${10:stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:yes}
$0
endsnippet

snippet os_auth "Retrieve an auth token" b
- name: $1
	os_auth:
		# auth_type: ${2:password}
		# region_name: ${3:# Name of the region.}
		# availability_zone: ${4:# Ignored. Present for backwards compatibility}
		# api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${6:180}
		# auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${8:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${9:#public|internal|admin}
		# key: ${10:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${12:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${14:#yes|no}
$0
endsnippet

snippet os_client_config "Get OpenStack Client config" b
- name: $1
	os_client_config:
		# clouds: ${2:[]}
$0
endsnippet

snippet os_flavor_facts "Retrieve facts about one or more flavors" b
- name: $1
	os_flavor_facts:
		# auth_type: ${2:password}
		# ram: ${3:no}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# ephemeral: ${7:no}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# name: ${10:# A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# limit: ${13:# Limits the number of flavors returned. All matching flavors are returned by default.}
		# key: ${14:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# vcpus: ${17:no}
		# cloud: ${18:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${19:#yes|no}
$0
endsnippet

snippet os_floating_ip "Add/Remove floating IP from an instance" b
- name: $1
	os_floating_ip:
		server: ${2:# The name or ID of the instance to which the IP address should be assigned.}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${8:#public|internal|admin}
		# floating_ip_address: ${9:# A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.}
		# key: ${10:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${13:no}
		# fixed_address: ${14:# To which fixed IP of server the floating IP address should be attached to.}
		# network: ${15:# The name or ID of a neutron external network or a nova pool name.}
		# reuse: ${16:no}
		# state: ${17:#present|absent}
		# nat_destination: ${18:# The name or id of a neutron private network that the fixed IP to attach floating IP is on}
		# purge: ${19:no}
		# cert: ${20:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${21:60}
		# validate_certs: ${22:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_group "Manage OpenStack Identity Groups" b
- name: $1
	os_group:
		name: ${2:# Group name}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# description: ${6:# Group description}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${14:# Ignored. Present for backwards compatibility}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# domain_id: ${16:# Domain id to create the group in if the cloud supports domains.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_image "Add/Delete images from OpenStack Cloud" b
- name: $1
	os_image:
		name: ${2:# Name that has to be given to the image}
		# auth_type: ${3:password}
		# ramdisk: ${4:# The name of an existing ramdisk image that will be associated with this image}
		# region_name: ${5:# Name of the region.}
		# kernel: ${6:# The name of an existing kernel image that will be associated with this image}
		# container_format: ${7:bare}
		# min_ram: ${8:# The minimum ram (in MB) required to boot this image}
		# api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# owner: ${11:# The owner of the image}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# is_public: ${15:yes}
		# id: ${16:# The Id of the image}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
		# min_disk: ${19:# The minimum disk space (in GB) required to boot this image}
		# properties: ${20:{}}
		# checksum: ${21:# The checksum of the image}
		# availability_zone: ${22:# Ignored. Present for backwards compatibility}
		# disk_format: ${23:qcow2}
		# state: ${24:#present|absent}
		# filename: ${25:# The path to the file which has to be uploaded}
		# cert: ${26:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${27:180}
		# validate_certs: ${28:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_image_facts "Retrieve facts about an image within OpenStack." b
- name: $1
	os_image_facts:
		image: ${2:# Name or ID of the image}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${13:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:#yes|no}
$0
endsnippet

snippet os_ironic "Create/Delete Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic:
		driver: ${2:# The name of the Ironic Driver to use with this node.}
		nics: ${3:# A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"}
		# auth_type: ${4:password}
		# ironic_url: ${5:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
		# region_name: ${6:# Name of the region.}
		# availability_zone: ${7:# Ignored. Present for backwards compatibility}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# properties: ${13:# Definition of the physical characteristics of this server, used for scheduling purposes}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:#yes|no}
		# uuid: ${16:# globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.}
		# driver_info: ${17:# Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.}
		# state: ${18:#present|absent}
		# name: ${19:# unique name identifier to be given to the resource.}
		# cert: ${20:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${21:180}
		# chassis_uuid: ${22:# Associate the node with a pre-defined chassis.}
		# validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# skip_update_of_driver_password: ${24:no}
$0
endsnippet

snippet os_ironic_inspect "Explicitly triggers baremetal node introspection in ironic." b
- name: $1
	os_ironic_inspect:
		# auth_type: ${2:password}
		# ironic_url: ${3:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:1200}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# name: ${9:# unique name identifier to identify the host in Ironic.}
		# mac: ${10:# unique mac address that is used to attempt to identify the host.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# uuid: ${15:# globally unique identifier (UUID) to identify the host.}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_ironic_node "Activate/Deactivate Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic_node:
		# auth_type: ${2:password}
		# ironic_url: ${3:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
		# maintenance: ${4:no}
		# region_name: ${5:# Name of the region.}
		# power: ${6:#present|absent}
		# deploy: ${7:true|false}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${10:#public|internal|admin}
		# maintenance_reason: ${11:# A string expression regarding the reason a node is in a maintenance mode.}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:no}
		# uuid: ${16:# globally unique identifier (UUID) to be given to the resource.}
		# availability_zone: ${17:# Ignored. Present for backwards compatibility}
		# state: ${18:#present|absent}
		# cert: ${19:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${20:# An integer value representing the number of seconds to wait for the node activation or deactivation to complete.}
		# validate_certs: ${21:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# instance_info: ${22:# Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.}
		# config_drive: ${23:# A configdrive file or HTTP(S) URL that will be passed along to the node.}
$0
endsnippet

snippet os_keypair "Add/Delete a keypair from OpenStack" b
- name: $1
	os_keypair:
		name: ${2:# Name that has to be given to the key pair}
		# auth_type: ${3:password}
		# public_key: ${4:# The public key that would be uploaded to nova and injected into VMs upon creation.}
		# region_name: ${5:# Name of the region.}
		# state: ${6:#present|absent}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${14:# Ignored. Present for backwards compatibility}
		# public_key_file: ${15:# Path to local file containing ssh public key. Mutually exclusive with public_key.}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_keystone_domain "Manage OpenStack Identity Domains" b
- name: $1
	os_keystone_domain:
		name: ${2:# Name that has to be given to the instance}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# description: ${6:# Description of the domain}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# enabled: ${8:yes}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${15:# Ignored. Present for backwards compatibility}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_keystone_domain_facts "Retrieve facts about one or more OpenStack domains" b
- name: $1
	os_keystone_domain_facts:
		name: ${2:# Name or ID of the domain}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# filters: ${6:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_keystone_role "Manage OpenStack Identity Roles" b
- name: $1
	os_keystone_role:
		name: ${2:# Role Name}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${13:# Ignored. Present for backwards compatibility}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_keystone_service "Manage OpenStack Identity services" b
- name: $1
	os_keystone_service:
		name: ${2:# Name of the service}
		service_type: ${3:# The type of service}
		# auth_type: ${4:password}
		# region_name: ${5:# Name of the region.}
		# state: ${6:#present|absent}
		# description: ${7:# Description of the service}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# enabled: ${9:yes}
		# timeout: ${10:180}
		# auth: ${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${12:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${13:#public|internal|admin}
		# key: ${14:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${16:# Ignored. Present for backwards compatibility}
		# validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${18:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${19:#yes|no}
$0
endsnippet

snippet os_network "Creates/removes networks from OpenStack" b
- name: $1
	os_network:
		name: ${2:# Name to be assigned to the network.}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# provider_network_type: ${5:# The type of physical network that maps to this network resource.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# provider_physical_network: ${9:# The physical network where this network object is implemented.}
		# endpoint_type: ${10:#public|internal|admin}
		# external: ${11:no}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:#yes|no}
		# admin_state_up: ${16:yes}
		# state: ${17:#present|absent}
		# project: ${18:# Project name or ID containing the network (name admin-only)}
		# cert: ${19:# A path to a client certificate to use as part of the SSL transaction.}
		# provider_segmentation_id: ${20:# An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.}
		# timeout: ${21:180}
		# shared: ${22:no}
		# validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_networks_facts "Retrieve facts about one or more OpenStack networks." b
- name: $1
	os_networks_facts:
		# auth_type: ${2:password}
		# region_name: ${3:# Name of the region.}
		# availability_zone: ${4:# Ignored. Present for backwards compatibility}
		# filters: ${5:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# name: ${9:# Name or ID of the Network}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_nova_flavor "Manage OpenStack compute flavors" b
- name: $1
	os_nova_flavor:
		name: ${2:# Flavor name.}
		# auth_type: ${3:password}
		# ram: ${4:# Amount of memory, in MB.}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${9:#public|internal|admin}
		# extra_specs: ${10:# Metadata dictionary}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# rxtx_factor: ${12:1.0}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# is_public: ${14:yes}
		# disk: ${15:# Size of local disk, in GB.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
		# flavorid: ${18:auto}
		# ephemeral: ${19:0}
		# state: ${20:#present|absent}
		# cert: ${21:# A path to a client certificate to use as part of the SSL transaction.}
		# swap: ${22:0}
		# timeout: ${23:180}
		# validate_certs: ${24:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# vcpus: ${25:# Number of virtual CPUs.}
$0
endsnippet

snippet os_nova_host_aggregate "Manage OpenStack host aggregates" b
- name: $1
	os_nova_host_aggregate:
		name: ${2:# N}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${10:#public|internal|admin}
		# hosts: ${11:# L}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${14:# A}
		# metadata: ${15:# M}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_object "Create or Delete objects and containers from OpenStack" b
- name: $1
	os_object:
		container: ${2:# The name of the container in which to create the object}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# name: ${9:# Name to be give to the object. If omitted, operations will be on the entire container}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# container_access: ${12:#private|public}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${15:# Ignored. Present for backwards compatibility}
		# filename: ${16:# Path to local file to be uploaded.}
		# validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${18:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${19:#yes|no}
$0
endsnippet

snippet os_port "Add/Update/Delete ports from an OpenStack cloud." b
- name: $1
	os_port:
		network: ${2:# Network ID or name this port belongs to.}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# allowed_address_pairs: ${5:# Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# extra_dhcp_opts: ${7:# Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# device_owner: ${10:# The ID of the entity that uses this port.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# fixed_ips: ${14:# Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
		# admin_state_up: ${17:# Sets admin state.}
		# state: ${18:#present|absent}
		# name: ${19:# Name that has to be given to the port.}
		# cert: ${20:# A path to a client certificate to use as part of the SSL transaction.}
		# no_security_groups: ${21:no}
		# security_groups: ${22:# Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)}
		# timeout: ${23:180}
		# mac_address: ${24:# MAC address of this port.}
		# device_id: ${25:# Device ID of device using this port.}
		# validate_certs: ${26:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_port_facts "Retrieve facts about ports within OpenStack." b
- name: $1
	os_port_facts:
		# auth_type: ${2:password}
		# region_name: ${3:# Name of the region.}
		# availability_zone: ${4:# Ignored. Present for backwards compatibility}
		# filters: ${5:# A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${13:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# port: ${14:# Unique name or ID of a port.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_project "Manage OpenStack Projects" b
- name: $1
	os_project:
		name: ${2:# Name for the project}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# description: ${6:# Description for the project}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# enabled: ${8:yes}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${15:# Ignored. Present for backwards compatibility}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# domain_id: ${17:# Domain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0}
		# cloud: ${18:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${19:#yes|no}
$0
endsnippet

snippet os_project_facts "Retrieve facts about one or more OpenStack projects" b
- name: $1
	os_project_facts:
		name: ${2:# Name or ID of the project}
		# auth_type: ${3:password}
		# domain: ${4:# Name or ID of the domain containing the project if the cloud supports domains}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# filters: ${7:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
$0
endsnippet

snippet os_quota "Manage OpenStack Quotas" b
- name: $1
	os_quota:
		name: ${2:# Name of the OpenStack Project to manage.}
		# auth_type: ${3:password}
		# snapshots_lvm: ${4:# N}
		# server_group_members: ${5:# N}
		# server_groups: ${6:# N}
		# ram: ${7:# M}
		# snapshots: ${8:# N}
		# instances: ${9:# M}
		# backups: ${10:# M}
		# fixed_ips: ${11:# N}
		# port: ${12:# N}
		# cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# subnet: ${14:# N}
		# per_volume_gigabytes: ${15:# M}
		# network: ${16:# N}
		# floatingip: ${17:# N}
		# availability_zone: ${18:# Ignored. Present for backwards compatibility}
		# volumes_lvm: ${19:# N}
		# floating_ips: ${20:# N}
		# security_group_rule: ${21:# N}
		# state: ${22:present}
		# injected_files: ${23:# N}
		# gigabytes_lvm: ${24:# M}
		# subnetpool: ${25:# N}
		# injected_path_size: ${26:# M}
		# region_name: ${27:# Name of the region.}
		# gigabytes: ${28:# M}
		# backup_gigabytes: ${29:# M}
		# api_timeout: ${30:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${31:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# rbac_policy: ${32:# N}
		# endpoint_type: ${33:#public|internal|admin}
		# key_pairs: ${34:# N}
		# key: ${35:# A path to a client key to use as part of the SSL transaction.}
		# router: ${36:# N}
		# cacert: ${37:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# volumes: ${38:# N}
		# properties: ${39:# N}
		# pool: ${40:# N}
		# wait: ${41:#yes|no}
		# cert: ${42:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${43:180}
		# security_group: ${44:# N}
		# cores: ${45:# M}
		# validate_certs: ${46:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# loadbalancer: ${47:# N}
		# injected_file_size: ${48:# M}
$0
endsnippet

snippet os_recordset "Manage OpenStack DNS recordsets" b
- name: $1
	os_recordset:
		zone: ${2:# Zone managing the recordset}
		name: ${3:# Name of the recordset}
		records: ${4:# List of recordset definitions}
		recordset_type: ${5:# Recordset type}
		# auth_type: ${6:password}
		# state: ${7:#present|absent}
		# region_name: ${8:# Name of the region.}
		# availability_zone: ${9:# Ignored. Present for backwards compatibility}
		# description: ${10:# Description of the recordset}
		# api_timeout: ${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${12:180}
		# auth: ${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${15:#public|internal|admin}
		# key: ${16:# A path to a client key to use as part of the SSL transaction.}
		# ttl: ${17:# TTL (Time To Live) value in seconds}
		# cacert: ${18:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${20:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${21:#yes|no}
$0
endsnippet

snippet os_router "Create or delete routers from OpenStack" b
- name: $1
	os_router:
		name: ${2:# Name to be give to the router}
		# auth_type: ${3:password}
		# state: ${4:#present|absent}
		# enable_snat: ${5:yes}
		# region_name: ${6:# Name of the region.}
		# admin_state_up: ${7:yes}
		# interfaces: ${8:# List of subnets to attach to the router internal interface.}
		# api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${10:180}
		# auth: ${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# project: ${12:# Unique name or ID of the project.}
		# network: ${13:# Unique name or ID of the external gateway network.}
		# cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${15:#public|internal|admin}
		# key: ${16:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${17:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${18:# Ignored. Present for backwards compatibility}
		# external_fixed_ips: ${19:# The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.}
		# validate_certs: ${20:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${21:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${22:#yes|no}
$0
endsnippet

snippet os_security_group "Add/Delete security groups from an OpenStack cloud." b
- name: $1
	os_security_group:
		name: ${2:# Name that has to be given to the security group. This module requires that security group names be unique.}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# description: ${6:# Long description of the purpose of the security group}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${14:# Ignored. Present for backwards compatibility}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
$0
endsnippet

snippet os_security_group_rule "Add/Delete rule from an existing security group" b
- name: $1
	os_security_group_rule:
		security_group: ${2:# Name or ID of the security group}
		# auth_type: ${3:password}
		# direction: ${4:egress|#ingress}
		# protocol: ${5:tcp|udp|icmp|112|#None}
		# region_name: ${6:# Name of the region.}
		# availability_zone: ${7:# Ignored. Present for backwards compatibility}
		# port_range_max: ${8:# Ending port}
		# api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:#yes|no}
		# remote_ip_prefix: ${16:# Source IP address(es) in CIDR notation (exclusive with remote_group)}
		# remote_group: ${17:# Name or ID of the Security group to link (exclusive with remote_ip_prefix)}
		# state: ${18:#present|absent}
		# cert: ${19:# A path to a client certificate to use as part of the SSL transaction.}
		# port_range_min: ${20:# Starting port}
		# timeout: ${21:180}
		# ethertype: ${22:#IPv4|IPv6}
		# validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_server "Create/Delete Compute Instances from OpenStack" b
- name: $1
	os_server:
		image: ${2:# The name or id of the base image to boot.}
		name: ${3:# Name that has to be given to the instance}
		# auth_type: ${4:password}
		# availability_zone: ${5:# Availability zone in which to create the server.}
		# image_exclude: ${6:# Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"}
		# flavor_include: ${7:# Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.}
		# meta: ${8:# A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"}
		# flavor: ${9:1}
		# cloud: ${10:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# scheduler_hints: ${11:# Arbitrary key/value pairs to the scheduler for custom use}
		# boot_from_volume: ${12:no}
		# userdata: ${13:# Opaque blob of data which is made available to the instance}
		# network: ${14:# Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.}
		# terminate_volume: ${15:no}
		# nics: ${16:# A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.}
		# floating_ips: ${17:# list of valid floating IPs that pre-exist to assign to this node}
		# flavor_ram: ${18:1}
		# volume_size: ${19:# The size of the volume to create in GB if booting from volume based on an image.}
		# state: ${20:#present|absent}
		# auto_ip: ${21:yes}
		# security_groups: ${22:# Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.}
		# config_drive: ${23:no}
		# region_name: ${24:# Name of the region.}
		# key_name: ${25:# The key pair name to be used when creating a instance}
		# api_timeout: ${26:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${27:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${28:#public|internal|admin}
		# boot_volume: ${29:# Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.}
		# key: ${30:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${31:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# volumes: ${32:[]}
		# wait: ${33:yes}
		# delete_fip: ${34:no}
		# cert: ${35:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${36:180}
		# floating_ip_pools: ${37:# Name of floating IP pool from which to choose a floating IP}
		# validate_certs: ${38:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# reuse_ips: ${39:yes}
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# image: ${6:# Image the server should be rebuilt with}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# action: ${10:stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:yes}
$0
endsnippet

snippet os_server_facts "Retrieve facts about one or more compute instances" b
- name: $1
	os_server_facts:
		# auth_type: ${2:password}
		# detailed: ${3:no}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# server: ${9:# restrict results to servers with names or UUID matching this glob expression (e.g., C<web*>).}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_server_group "Manage OpenStack server groups" b
- name: $1
	os_server_group:
		name: ${2:# Server group name.}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# state: ${5:#present|absent}
		# api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${7:180}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${13:# Ignored. Present for backwards compatibility}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# policies: ${15:# A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
$0
endsnippet

snippet os_server_volume "Attach/Detach Volumes from OpenStack VM's" b
- name: $1
	os_server_volume:
		server: ${2:# Name or ID of server you want to attach a volume to}
		volume: ${3:# Name or id of volume you want to attach to a server}
		# auth_type: ${4:password}
		# region_name: ${5:# Name of the region.}
		# state: ${6:#present|absent}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# device: ${10:# Device you want to attach. Defaults to auto finding a device name.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${15:# Ignored. Present for backwards compatibility}
		# validate_certs: ${16:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
$0
endsnippet

snippet os_stack "Add/Remove Heat Stack" b
- name: $1
	os_stack:
		name: ${2:# Name of the stack that should be created, name could be char and digit, no space}
		# auth_type: ${3:password}
		# state: ${4:#present|absent}
		# rollback: ${5:no}
		# region_name: ${6:# Name of the region.}
		# parameters: ${7:# Dictionary of parameters for the stack creation}
		# availability_zone: ${8:# Ignored. Present for backwards compatibility}
		# api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${10:3600}
		# auth: ${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# environment: ${12:# List of environment files that should be used for the stack creation}
		# cert: ${13:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${14:#public|internal|admin}
		# key: ${15:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# template: ${17:# Path of the template file to use for the stack creation}
		# validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${19:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${20:#yes|no}
$0
endsnippet

snippet os_subnet "Add/Remove subnet to an OpenStack network" b
- name: $1
	os_subnet:
		name: ${2:# The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.}
		# auth_type: ${3:password}
		# no_gateway_ip: ${4:no}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# ipv6_ra_mode: ${9:dhcpv6-stateful|dhcpv6-stateless|slaac}
		# endpoint_type: ${10:#public|internal|admin}
		# host_routes: ${11:# A list of host route dictionaries for the subnet.}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# ipv6_address_mode: ${14:dhcpv6-stateful|dhcpv6-stateless|slaac}
		# cidr: ${15:# The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.}
		# network_name: ${16:# Name of the network to which the subnet should be attached}
		# cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${18:#yes|no}
		# project: ${19:# Project name or ID containing the subnet (name admin-only)}
		# enable_dhcp: ${20:yes}
		# dns_nameservers: ${21:# List of DNS nameservers for this subnet.}
		# state: ${22:#present|absent}
		# use_default_subnetpool: ${23:no}
		# cert: ${24:# A path to a client certificate to use as part of the SSL transaction.}
		# allocation_pool_start: ${25:# From the subnet pool the starting address from which the IP should be allocated.}
		# gateway_ip: ${26:# The ip that would be assigned to the gateway for this subnet}
		# allocation_pool_end: ${27:# From the subnet pool the last IP that should be assigned to the virtual machines.}
		# timeout: ${28:180}
		# ip_version: ${29:4}
		# validate_certs: ${30:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_subnets_facts "Retrieve facts about one or more OpenStack subnets." b
- name: $1
	os_subnets_facts:
		# auth_type: ${2:password}
		# subnet: ${3:# Name or ID of the subnet}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# filters: ${6:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
$0
endsnippet

snippet os_user "Manage OpenStack Identity Users" b
- name: $1
	os_user:
		name: ${2:# Username for the user}
		# auth_type: ${3:password}
		# update_password: ${4:#always|on_create}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# domain: ${8:# Domain to create the user in if the cloud supports domains}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# endpoint_type: ${10:#public|internal|admin}
		# key: ${11:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# password: ${13:# Password for the user}
		# cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${15:#yes|no}
		# default_project: ${16:# Project name or ID that the user should be associated with by default}
		# description: ${17:# Description about the user}
		# enabled: ${18:yes}
		# state: ${19:#present|absent}
		# cert: ${20:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${21:180}
		# validate_certs: ${22:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# email: ${23:# Email address for the user}
$0
endsnippet

snippet os_user_facts "Retrieve facts about one or more OpenStack users" b
- name: $1
	os_user_facts:
		name: ${2:# Name or ID of the user}
		# auth_type: ${3:password}
		# domain: ${4:# Name or ID of the domain containing the user if the cloud supports domains}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# filters: ${7:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${11:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${12:#public|internal|admin}
		# key: ${13:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
$0
endsnippet

snippet os_user_group "Associate OpenStack Identity users and groups" b
- name: $1
	os_user_group:
		group: ${2:# Name or id for the group.}
		user: ${3:# Name or id for the user}
		# auth_type: ${4:password}
		# region_name: ${5:# Name of the region.}
		# state: ${6:#present|absent}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${8:180}
		# auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${11:#public|internal|admin}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# availability_zone: ${14:# Ignored. Present for backwards compatibility}
		# validate_certs: ${15:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${17:#yes|no}
$0
endsnippet

snippet os_user_role "Associate OpenStack Identity users and roles" b
- name: $1
	os_user_role:
		role: ${2:# Name or ID for the role.}
		# auth_type: ${3:password}
		# domain: ${4:# ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.}
		# group: ${5:# Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.}
		# region_name: ${6:# Name of the region.}
		# availability_zone: ${7:# Ignored. Present for backwards compatibility}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# project: ${11:# Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.}
		# cert: ${12:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${13:#public|internal|admin}
		# user: ${14:# Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.}
		# key: ${15:# A path to a client key to use as part of the SSL transaction.}
		# cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# state: ${17:#present|absent}
		# validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# cloud: ${19:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${20:#yes|no}
$0
endsnippet

snippet os_volume "Create/Delete Cinder Volumes" b
- name: $1
	os_volume:
		display_name: ${2:# Name of volume}
		# auth_type: ${3:password}
		# region_name: ${4:# Name of the region.}
		# availability_zone: ${5:# Ignored. Present for backwards compatibility}
		# image: ${6:# Image name or id for boot from volume}
		# api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# volume: ${9:# Volume name or id to create from}
		# endpoint_type: ${10:#public|internal|admin}
		# display_description: ${11:# String describing the volume}
		# key: ${12:# A path to a client key to use as part of the SSL transaction.}
		# snapshot_id: ${13:# Volume snapshot id to create from}
		# cacert: ${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${16:#yes|no}
		# scheduler_hints: ${17:# Scheduler hints passed to volume API in form of dict}
		# state: ${18:#present|absent}
		# volume_type: ${19:# Volume type for volume}
		# cert: ${20:# A path to a client certificate to use as part of the SSL transaction.}
		# timeout: ${21:180}
		# size: ${22:# Size of volume in GB. This parameter is required when the I(state) parameter is 'present'.}
		# validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_zone "Manage OpenStack DNS zones" b
- name: $1
	os_zone:
		name: ${2:# Zone name}
		# auth_type: ${3:password}
		# masters: ${4:# Master nameservers (only applies if zone_type is secondary)}
		# region_name: ${5:# Name of the region.}
		# availability_zone: ${6:# Ignored. Present for backwards compatibility}
		# description: ${7:# Zone description}
		# api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		# timeout: ${9:180}
		# auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		# zone_type: ${11:primary|secondary}
		# cert: ${12:# A path to a client certificate to use as part of the SSL transaction.}
		# endpoint_type: ${13:#public|internal|admin}
		# key: ${14:# A path to a client key to use as part of the SSL transaction.}
		# ttl: ${15:# TTL (Time To Live) value in seconds}
		# cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		# state: ${17:#present|absent}
		# validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		# email: ${19:# Email of the zone owner (only applies if zone_type is primary)}
		# cloud: ${20:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		# wait: ${21:#yes|no}
$0
endsnippet

snippet ovh_ip_loadbalancing_backend "Manage OVH IP LoadBalancing backends" b
- name: $1
	ovh_ip_loadbalancing_backend:
		endpoint: ${2:# The endpoint to use ( for instance ovh-eu)}
		name: ${3:# Name of the LoadBalancing internal name (ip-X.X.X.X)}
		application_key: ${4:# The applicationKey to use}
		application_secret: ${5:# The application secret to use}
		consumer_key: ${6:# The consumer key to use}
		backend: ${7:# The IP address of the backend to update / modify / delete}
		# weight: ${8:8}
		# probe: ${9:#none|http|icmp|oco}
		# state: ${10:#present|absent}
		# timeout: ${11:120}
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the affinity group to manage.}
		# description: ${4:# Description of the affinity group.}
		# host_rule: ${5:positive|negative}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${7:# Name of the cluster of the affinity group.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# vm_rule: ${9:positive|negative|disabled}
		# host_enforcing: ${10:# If I(true) VM cannot start on host if it does not satisfy the C(host_rule).}
		# vms: ${11:# List of the VMs names, which should have assigned this affinity group.}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
		# vm_enforcing: ${13:# If I(true) VM cannot start if it does not satisfy the C(vm_rule).}
		# poll_interval: ${14:3}
		# state: ${15:#present|absent}
		# hosts: ${16:# List of the hosts names, which should have assigned this affinity group.}
		# timeout: ${17:180}
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: ${4:3}
		# state: ${5:#present|absent}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${7:# Name of the cluster where vms and hosts resides.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# hosts: ${9:# List of the hosts names, which should have assigned this affinity label.}
		# timeout: ${10:180}
		# vms: ${11:# List of the VMs names, which should have assigned this affinity label.}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${3:# If I(True) the module will fetch additional data from the API.}
		# vm: ${4:# Name of the VM, which affinity labels should be listed.}
		# host: ${5:# Name of the host, which affinity labels should be listed.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# name: ${7:# Name of the affinity labels which should be listed.}
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the cluster to manage.}
		# comment: ${4:# Comment of the cluster.}
		# ha_reservation: ${5:# If I(True) enable the oVirt/RHV to monitor cluster capacity for highly available virtual machines.}
		# fence_skip_if_connectivity_broken: ${6:# If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.}
		# mac_pool: ${7:# MAC pool to be used by this cluster.}
		# virt: ${8:# If I(True), hosts in this cluster will be used to run virtual machines.}
		# threads_as_cores: ${9:# If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.}
		# gluster: ${10:# If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.}
		# vm_reason: ${11:# If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		# fetch_nested: ${12:# If I(True) the module will fetch additional data from the API.}
		# migration_bandwidth_limit: ${13:# Set the I(custom) migration bandwidth limit.}
		# data_center: ${14:# Datacenter name where cluster reside.}
		# ksm_numa: ${15:# If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.}
		# migration_auto_converge: ${16:true|false|inherit}
		# cpu_arch: ${17:x86_64|ppc64|undefined}
		# rng_sources: ${18:# List that specify the random number generator devices that all hosts in the cluster will use.}
		# compatibility_version: ${19:# The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.}
		# network: ${20:# Management network of cluster to access cluster hosts.}
		# state: ${21:#present|absent}
		# ksm: ${22:# I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.}
		# migration_compressed: ${23:true|false|inherit}
		# ballooning: ${24:# If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.}
		# description: ${25:# Description of the cluster.}
		# fence_enabled: ${26:# If I(True) enables fencing on the cluster.}
		# migration_policy: ${27:legacy|minimal_downtime|suspend_workload|post_copy}
		# nested_attributes: ${28:# Specifies list of the attributes which should be fetched from the API.}
		# resilience_policy: ${29:do_not_migrate|migrate|migrate_highly_available}
		# fence_connectivity_threshold: ${30:# The threshold used by C(fence_skip_if_connectivity_broken).}
		# spice_proxy: ${31:# The proxy by which the SPICE client will connect to virtual machines.}
		# memory_policy: ${32:disabled|server|desktop}
		# migration_bandwidth: ${33:auto|hypervisor_default|custom}
		# fence_skip_if_sd_active: ${34:# If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.}
		# scheduling_policy: ${35:# Name of the scheduling policy to be used for cluster.}
		# wait: ${36:# I(True) if the module should wait for the entity to get into desired state.}
		# switch_type: ${37:legacy|ovs}
		# serial_policy_value: ${38:# Allows you to specify a custom serial number.}
		# host_reason: ${39:# If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		# poll_interval: ${40:3}
		# cpu_type: ${41:# CPU codename. For example I(Intel SandyBridge Family).}
		# timeout: ${42:180}
		# serial_policy: ${43:# Specify a serial number policy for the virtual machines in the cluster.}
		# trusted_service: ${44:# If (True) enable integration with an OpenAttestation server.}
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: ${4:# Comment of the data center.}
		# compatibility_version: ${5:# Compatibility version of the data center.}
		# mac_pool: ${6:# MAC pool to be used by this datacenter.}
		# quota_mode: ${7:disabled|audit|enabled}
		# description: ${8:# Description of the data center.}
		# poll_interval: ${9:3}
		# state: ${10:#present|absent}
		# nested_attributes: ${11:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${12:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${13:180}
		# local: ${14:# I(True) if the data center should be local, I(False) if should be shared.}
		# wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm_name: ${3:# Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		# profile: ${4:# Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.}
		# storage_domains: ${5:# Storage domain names where disk should be copied.}
		# force: ${6:# Please take a look at C(image_path) documentation to see the correct usage of this parameter.}
		# format: ${7:raw|cow}
		# upload_image_path: ${8:# Path to disk image, which should be uploaded.}
		# logical_unit: ${9:# Dictionary which describes LUN to be directly attached to VM:}
		# nested_attributes: ${10:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# download_image_path: ${12:# Path on a file system where disk should be downloaded.}
		# interface: ${13:#virtio|ide|virtio_scsi}
		# vm_id: ${14:# ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		# id: ${15:# ID of the disk to manage. Either C(id) or C(name) is required.}
		# wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
		# storage_domain: ${17:# Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.}
		# openstack_volume_type: ${18:# Name of the openstack volume type. This is valid when working with cinder.}
		# bootable: ${19:# I(True) if the disk should be bootable. By default when disk is created it isn't bootable.}
		# sparsify: ${20:# I(True) if the disk should be sparsified.}
		# poll_interval: ${21:3}
		# name: ${22:# Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.}
		# state: ${23:#present|absent|attached|detached}
		# shareable: ${24:# I(True) if the disk should be shareable. By default when disk is created it isn't shareable.}
		# timeout: ${25:180}
		# image_provider: ${26:# When C(state) is I(exported) disk is exported to given Glance image provider.}
		# size: ${27:# Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.}
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: ${3:# Username to be used for login to external provider.}
		# description: ${4:# Description of the external provider.}
		# tenant_name: ${5:# Name of the tenant.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		# data_center: ${8:# Name of the data center where provider should be attached.}
		# password: ${9:# Password of the user specified in C(username) parameter.}
		# wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
		# read_only: ${11:# Specify if the network should be read only.}
		# name: ${12:# Name of the external provider to manage.}
		# url: ${13:# URL where external provider is hosted.}
		# poll_interval: ${14:3}
		# state: ${15:#present|absent}
		# authentication_url: ${16:# Keystone authentication URL of the openstack provider.}
		# timeout: ${17:180}
		# type: ${18:os_image|network|os_volume|foreman}
		# network_type: ${19:[#external, neutron}
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		type: ${2:os_image|os_network|os_volume|foreman}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
		# name: ${6:# Name of the external provider, can be used as glob expression.}
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# timeout: ${7:180}
		# namespace: ${8:# Namespace of the authorization provider, where group resides.}
		# poll_interval: ${9:3}
		# state: ${10:#present|absent}
		# wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the affinity group to manage.}
		# description: ${4:# Description of the affinity group.}
		# host_rule: ${5:positive|negative}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${7:# Name of the cluster of the affinity group.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# vm_rule: ${9:positive|negative|disabled}
		# host_enforcing: ${10:# If I(true) VM cannot start on host if it does not satisfy the C(host_rule).}
		# vms: ${11:# List of the VMs names, which should have assigned this affinity group.}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
		# vm_enforcing: ${13:# If I(true) VM cannot start if it does not satisfy the C(vm_rule).}
		# poll_interval: ${14:3}
		# state: ${15:#present|absent}
		# hosts: ${16:# List of the hosts names, which should have assigned this affinity group.}
		# timeout: ${17:180}
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: ${4:3}
		# state: ${5:#present|absent}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${7:# Name of the cluster where vms and hosts resides.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# hosts: ${9:# List of the hosts names, which should have assigned this affinity label.}
		# timeout: ${10:180}
		# vms: ${11:# List of the VMs names, which should have assigned this affinity label.}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${3:# If I(True) the module will fetch additional data from the API.}
		# vm: ${4:# Name of the VM, which affinity labels should be listed.}
		# host: ${5:# Name of the host, which affinity labels should be listed.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# name: ${7:# Name of the affinity labels which should be listed.}
$0
endsnippet

snippet ovirt_auth "Module to manage authentication to oVirt/RHV" b
- name: $1
	ovirt_auth:
		username: ${2:# The name of the user. For example: I(admin@internal).}
		url: ${3:# A string containing the base URL of the server. For example: I(https://server.example.com/ovirt-engine/api).}
		password: ${4:# The password of the user.}
		# ca_file: ${5:# A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used.}
		# insecure: ${6:# A boolean flag that indicates if the server TLS certificate and host name should be checked.}
		# kerberos: ${7:# A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.}
		# compress: ${8:# A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).}
		# headers: ${9:# A dictionary of HTTP headers to be added to each API call.}
		# state: ${10:#present|absent}
		# timeout: ${11:# The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.}
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the cluster to manage.}
		# comment: ${4:# Comment of the cluster.}
		# ha_reservation: ${5:# If I(True) enable the oVirt/RHV to monitor cluster capacity for highly available virtual machines.}
		# fence_skip_if_connectivity_broken: ${6:# If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.}
		# mac_pool: ${7:# MAC pool to be used by this cluster.}
		# virt: ${8:# If I(True), hosts in this cluster will be used to run virtual machines.}
		# threads_as_cores: ${9:# If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.}
		# gluster: ${10:# If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.}
		# vm_reason: ${11:# If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		# fetch_nested: ${12:# If I(True) the module will fetch additional data from the API.}
		# migration_bandwidth_limit: ${13:# Set the I(custom) migration bandwidth limit.}
		# data_center: ${14:# Datacenter name where cluster reside.}
		# ksm_numa: ${15:# If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.}
		# migration_auto_converge: ${16:true|false|inherit}
		# cpu_arch: ${17:x86_64|ppc64|undefined}
		# rng_sources: ${18:# List that specify the random number generator devices that all hosts in the cluster will use.}
		# compatibility_version: ${19:# The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.}
		# network: ${20:# Management network of cluster to access cluster hosts.}
		# state: ${21:#present|absent}
		# ksm: ${22:# I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.}
		# migration_compressed: ${23:true|false|inherit}
		# ballooning: ${24:# If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.}
		# description: ${25:# Description of the cluster.}
		# fence_enabled: ${26:# If I(True) enables fencing on the cluster.}
		# migration_policy: ${27:legacy|minimal_downtime|suspend_workload|post_copy}
		# nested_attributes: ${28:# Specifies list of the attributes which should be fetched from the API.}
		# resilience_policy: ${29:do_not_migrate|migrate|migrate_highly_available}
		# fence_connectivity_threshold: ${30:# The threshold used by C(fence_skip_if_connectivity_broken).}
		# spice_proxy: ${31:# The proxy by which the SPICE client will connect to virtual machines.}
		# memory_policy: ${32:disabled|server|desktop}
		# migration_bandwidth: ${33:auto|hypervisor_default|custom}
		# fence_skip_if_sd_active: ${34:# If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.}
		# scheduling_policy: ${35:# Name of the scheduling policy to be used for cluster.}
		# wait: ${36:# I(True) if the module should wait for the entity to get into desired state.}
		# switch_type: ${37:legacy|ovs}
		# serial_policy_value: ${38:# Allows you to specify a custom serial number.}
		# host_reason: ${39:# If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		# poll_interval: ${40:3}
		# cpu_type: ${41:# CPU codename. For example I(Intel SandyBridge Family).}
		# timeout: ${42:180}
		# serial_policy: ${43:# Specify a serial number policy for the virtual machines in the cluster.}
		# trusted_service: ${44:# If (True) enable integration with an OpenAttestation server.}
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: ${4:# Comment of the data center.}
		# compatibility_version: ${5:# Compatibility version of the data center.}
		# mac_pool: ${6:# MAC pool to be used by this datacenter.}
		# quota_mode: ${7:disabled|audit|enabled}
		# description: ${8:# Description of the data center.}
		# poll_interval: ${9:3}
		# state: ${10:#present|absent}
		# nested_attributes: ${11:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${12:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${13:180}
		# local: ${14:# I(True) if the data center should be local, I(False) if should be shared.}
		# wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm_name: ${3:# Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		# profile: ${4:# Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.}
		# storage_domains: ${5:# Storage domain names where disk should be copied.}
		# force: ${6:# Please take a look at C(image_path) documentation to see the correct usage of this parameter.}
		# format: ${7:raw|cow}
		# upload_image_path: ${8:# Path to disk image, which should be uploaded.}
		# logical_unit: ${9:# Dictionary which describes LUN to be directly attached to VM:}
		# nested_attributes: ${10:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# download_image_path: ${12:# Path on a file system where disk should be downloaded.}
		# interface: ${13:#virtio|ide|virtio_scsi}
		# vm_id: ${14:# ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		# id: ${15:# ID of the disk to manage. Either C(id) or C(name) is required.}
		# wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
		# storage_domain: ${17:# Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.}
		# openstack_volume_type: ${18:# Name of the openstack volume type. This is valid when working with cinder.}
		# bootable: ${19:# I(True) if the disk should be bootable. By default when disk is created it isn't bootable.}
		# sparsify: ${20:# I(True) if the disk should be sparsified.}
		# poll_interval: ${21:3}
		# name: ${22:# Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.}
		# state: ${23:#present|absent|attached|detached}
		# shareable: ${24:# I(True) if the disk should be shareable. By default when disk is created it isn't shareable.}
		# timeout: ${25:180}
		# image_provider: ${26:# When C(state) is I(exported) disk is exported to given Glance image provider.}
		# size: ${27:# Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.}
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: ${3:# Username to be used for login to external provider.}
		# description: ${4:# Description of the external provider.}
		# tenant_name: ${5:# Name of the tenant.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		# data_center: ${8:# Name of the data center where provider should be attached.}
		# password: ${9:# Password of the user specified in C(username) parameter.}
		# wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
		# read_only: ${11:# Specify if the network should be read only.}
		# name: ${12:# Name of the external provider to manage.}
		# url: ${13:# URL where external provider is hosted.}
		# poll_interval: ${14:3}
		# state: ${15:#present|absent}
		# authentication_url: ${16:# Keystone authentication URL of the openstack provider.}
		# timeout: ${17:180}
		# type: ${18:os_image|network|os_volume|foreman}
		# network_type: ${19:[#external, neutron}
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		type: ${2:os_image|os_network|os_volume|foreman}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
		# name: ${6:# Name of the external provider, can be used as glob expression.}
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# timeout: ${7:180}
		# namespace: ${8:# Namespace of the authorization provider, where group resides.}
		# poll_interval: ${9:3}
		# state: ${10:#present|absent}
		# wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_host_networks "Module to manage host networks in oVirt/RHV" b
- name: $1
	ovirt_host_networks:
		name: ${2:# Name of the host to manage networks for.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# bond: ${4:# Dictionary describing network bond:}
		# labels: ${5:# List of names of the network label to be assigned to bond or interface.}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# check: ${9:# If I(true) verify connectivity between host and engine.}
		# fetch_nested: ${10:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${11:180}
		# interface: ${12:# Name of the network interface where logical network should be attached.}
		# save: ${13:# If I(true) network configuration will be persistent, by default they are temporary.}
		# networks: ${14:# List of dictionary describing networks to be attached to interface or bond:}
		# wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_host_pm "Module to manage power management of hosts in oVirt/RHV" b
- name: $1
	ovirt_host_pm:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the host to manage.}
		# username: ${4:# Username to be used to connect to power management interface.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		# address: ${7:# Address of the power management interface.}
		# password: ${8:# Password of the user specified in C(username) parameter.}
		# port: ${9:# Power management interface port.}
		# wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
		# slot: ${11:# Power management slot.}
		# poll_interval: ${12:3}
		# options: ${13:# Dictionary of additional fence agent options.}
		# state: ${14:#present|absent}
		# timeout: ${15:180}
		# encrypt_options: ${16:# If (true) options will be encrypted when send to agent.}
		# type: ${17:# Type of the power management. oVirt/RHV predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type.}
		# order: ${18:# Integer value specifying, by default it's added at the end.}
$0
endsnippet

snippet ovirt_host_storage_facts "Retrieve facts about one or more oVirt/RHV HostStorages (applicable only for block storage)" b
- name: $1
	ovirt_host_storage_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		host: ${3:# Host to get device list from.}
		# fcp: ${4:# Dictionary with values for fibre channel storage type:}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# iscsi: ${6:# Dictionary with values for iSCSI storage type:}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_hosts "Module to manage hosts in oVirt/RHV" b
- name: $1
	ovirt_hosts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the host to manage.}
		# comment: ${4:# Description of the host.}
		# activate: ${5:yes}
		# force: ${6:no}
		# hosted_engine: ${7:# If I(deploy) it means this host should deploy also hosted engine components.}
		# power_management_enabled: ${8:# Enable or disable power management of the host.}
		# nested_attributes: ${9:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${10:# Name of the cluster, where host should be created.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# address: ${12:# Host address. It can be either FQDN (preferred) or IP address.}
		# override_iptables: ${13:# If True host iptables will be overridden by host deploy script.}
		# kdump_integration: ${14:#enabled|disabled}
		# wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
		# check_upgrade: ${16:yes}
		# public_key: ${17:no}
		# password: ${18:# Password of the root. It's required in case C(public_key) is set to I(False).}
		# spm_priority: ${19:# SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.}
		# iscsi: ${20:# If C(state) is I(iscsidiscover) it means that the iscsi attribute is being used to discover targets}
		# poll_interval: ${21:3}
		# kernel_params: ${22:# List of kernel boot parameters.}
		# state: ${23:#present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled|iscsidiscover|iscsilogin}
		# timeout: ${24:180}
		# override_display: ${25:# Override the display address of all VMs on this host with specified address.}
$0
endsnippet

snippet ovirt_hosts_facts "Retrieve facts about one or more oVirt/RHV hosts" b
- name: $1
	ovirt_hosts_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_mac_pools "Module to manage MAC pools in oVirt/RHV" b
- name: $1
	ovirt_mac_pools:
		name: ${2:# Name of the MAC pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# ranges: ${4:# List of MAC ranges. The from and to should be split by comma.}
		# description: ${5:# Description of the MAC pool.}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# allow_duplicates: ${9:# If (true) allow a MAC address to be used multiple times in a pool.}
		# fetch_nested: ${10:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${11:180}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_networks "Module to manage logical networks in oVirt/RHV" b
- name: $1
	ovirt_networks:
		name: ${2:# Name of the network to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: ${4:# Comment of the network.}
		# description: ${5:# Description of the network.}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# mtu: ${9:# Maximum transmission unit (MTU) of the network.}
		# vm_network: ${10:# If I(True) network will be marked as network for VM.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${12:180}
		# data_center: ${13:# Datacenter name where network reside.}
		# clusters: ${14:# List of dictionaries describing how the network is managed in specific cluster.}
		# vlan_tag: ${15:# Specify VLAN tag.}
		# wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_networks_facts "Retrieve facts about one or more oVirt/RHV networks" b
- name: $1
	ovirt_networks_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_nics "Module to manage network interfaces of Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_nics:
		name: ${2:# Name of the network interface to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# profile: ${4:# Virtual network interface profile to be attached to VM network interface.}
		# network: ${5:# Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.}
		# state: ${6:#present|absent|plugged|unplugged}
		# poll_interval: ${7:3}
		# vm: ${8:# Name of the Virtual Machine to manage.}
		# nested_attributes: ${9:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${10:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${11:180}
		# mac_address: ${12:# Custom MAC address of the network interface, by default it's obtained from MAC pool.}
		# interface: ${13:#virtio|e1000|rtl8139|pci_passthrough|rtl8139_virtio|spapr_vlan}
		# template: ${14:# Name of the template to manage.}
		# wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_nics_facts "Retrieve facts about one or more oVirt/RHV virtual machine network interfaces" b
- name: $1
	ovirt_nics_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm: ${3:# Name of the VM where NIC is attached.}
		# name: ${4:# Name of the NIC, can be used as glob expression.}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_permissions "Module to manage permissions of users/groups in oVirt/RHV" b
- name: $1
	ovirt_permissions:
		authz_name: ${2:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# object_id: ${4:# ID of the object where the permissions should be managed.}
		# object_type: ${5:data_center|cluster|host|storage_domain|network|disk|#vm|vm_pool|template|cpu_profile|disk_profile|vnic_profile|system}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# group_name: ${9:# Name of the group to manage.}
		# object_name: ${10:# Name of the object where the permissions should be managed.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# role: ${12:UserRole}
		# timeout: ${13:180}
		# namespace: ${14:# Namespace of the authorization provider, where user/group resides.}
		# user_name: ${15:# Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		# wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_permissions_facts "Retrieve facts about one or more oVirt/RHV permissions" b
- name: $1
	ovirt_permissions_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		authz_name: ${3:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# user_name: ${5:# Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		# namespace: ${6:# Namespace of the authorization provider, where user/group resides.}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		# group_name: ${8:# Name of the group to manage.}
$0
endsnippet

snippet ovirt_quotas "Module to manage datacenter quotas in oVirt/RHV" b
- name: $1
	ovirt_quotas:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		data_center: ${3:# Name of the datacenter where quota should be managed.}
		name: ${4:# Name of the quota to manage.}
		# description: ${5:# Description of the quota to manage.}
		# cluster_grace: ${6:# Cluster grace(hard limit) defined in percentage (1-100).}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# storage_grace: ${9:# Storage grace(hard limit) defined in percentage (1-100).}
		# storage_threshold: ${10:# Storage threshold(soft limit) defined in percentage (0-100).}
		# wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
		# poll_interval: ${12:3}
		# state: ${13:#present|absent}
		# timeout: ${14:180}
		# cluster_threshold: ${15:# Cluster threshold(soft limit) defined in percentage (0-100).}
		# clusters: ${16:# List of dictionary of cluster limits, which is valid to specific cluster.}
		# storages: ${17:# List of dictionary of storage limits, which is valid to specific storage.}
$0
endsnippet

snippet ovirt_quotas_facts "Retrieve facts about one or more oVirt/RHV quotas" b
- name: $1
	ovirt_quotas_facts:
		data_center: ${2:# Name of the datacenter where quota resides.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
		# name: ${6:# Name of the quota, can be used as glob expression.}
$0
endsnippet

snippet ovirt_scheduling_policies_facts "Retrieve facts about one or more oVirt scheduling policies" b
- name: $1
	ovirt_scheduling_policies_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		id: ${3:# ID of the scheduling policy.}
		# name: ${4:# Name of the scheduling policy, can be used as glob expression.}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_snapshots "Module to manage Virtual Machine Snapshots in oVirt/RHV" b
- name: $1
	ovirt_snapshots:
		vm_name: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: ${4:# Description of the snapshot.}
		# use_memory: ${5:# If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.}
		# poll_interval: ${6:3}
		# state: ${7:restore|#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${9:# If I(True) the module will fetch additional data from the API.}
		# timeout: ${10:180}
		# snapshot_id: ${11:# ID of the snapshot to manage.}
		# wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_snapshots_facts "Retrieve facts about one or more oVirt/RHV virtual machine snapshots" b
- name: $1
	ovirt_snapshots_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm: ${3:# Name of the VM with snapshot.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# snapshot_id: ${5:# Id of the snaphost we want to retrieve facts about.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# description: ${7:# Description of the snapshot, can be used as glob expression.}
$0
endsnippet

snippet ovirt_storage_connections "Module to manage storage connections in oVirt" b
- name: $1
	ovirt_storage_connections:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: ${3:# A CHAP username for logging into a target.}
		# force: ${4:# This parameter is releven only when updating a connection.}
		# storage: ${5:# Name of the storage domain to be used with storage connection.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		# address: ${8:# Address of the storage server. E.g.: myserver.mydomain.com}
		# nfs_timeout: ${9:# The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.}
		# path: ${10:# Path of the mount point of the storage. E.g.: /path/to/my/data}
		# password: ${11:# A CHAP password for logging into a target.}
		# nfs_version: ${12:# NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).}
		# wait: ${13:# I(True) if the module should wait for the entity to get into desired state.}
		# target: ${14:# The target IQN for the storage device.}
		# poll_interval: ${15:3}
		# nfs_retrans: ${16:# The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.}
		# id: ${17:# Id of the storage connection to manage.}
		# port: ${18:# Port of the iSCSI storage server.}
		# state: ${19:#present|absent}
		# timeout: ${20:180}
		# vfs_type: ${21:# Virtual File System type.}
		# type: ${22:# Storage type. For example: I(nfs), I(iscsi), etc.}
		# mount_options: ${23:# Option which will be passed when mounting storage.}
$0
endsnippet

snippet ovirt_storage_domains "Module to manage storage domains in oVirt/RHV" b
- name: $1
	ovirt_storage_domains:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: ${3:# Comment of the storage domain.}
		# fcp: ${4:# Dictionary with values for fibre channel storage type:}
		# description: ${5:# Description of the storage domain.}
		# format: ${6:# If I(True) storage domain will be formatted after removing it from oVirt/RHV.}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		# localfs: ${9:# Dictionary with values for localfs storage type:}
		# data_center: ${10:# Data center name where storage domain should be attached.}
		# host: ${11:# Host to be used to mount storage.}
		# id: ${12:# Id of the storage domain to be imported.}
		# wait: ${13:# I(True) if the module should wait for the entity to get into desired state.}
		# domain_function: ${14:#data|iso|export}
		# name: ${15:# Name of the storage domain to manage. (Not required when state is I(imported))}
		# iscsi: ${16:# Dictionary with values for iSCSI storage type:}
		# posixfs: ${17:# Dictionary with values for PosixFS storage type:}
		# poll_interval: ${18:3}
		# glusterfs: ${19:# Dictionary with values for GlusterFS storage type:}
		# state: ${20:#present|absent|maintenance|unattached}
		# nfs: ${21:# Dictionary with values for NFS storage type:}
		# timeout: ${22:180}
		# destroy: ${23:# Logical remove of the storage domain. If I(true) retains the storage domain's data for import.}
$0
endsnippet

snippet ovirt_storage_domains_facts "Retrieve facts about one or more oVirt/RHV storage domains" b
- name: $1
	ovirt_storage_domains_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_storage_templates_facts "Retrieve facts about one or more oVirt/RHV templates relate to a storage domain." b
- name: $1
	ovirt_storage_templates_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: ${3:# Flag which indicates whether to get unregistered templates which contain one or more disks which reside on a storage domain or diskless templates.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_storage_vms_facts "Retrieve facts about one or more oVirt/RHV virtual machines relate to a storage domain." b
- name: $1
	ovirt_storage_vms_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: ${3:# Flag which indicates whether to get unregistered virtual machines which contain one or more disks which reside on a storage domain or diskless virtual machines.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_tags "Module to manage tags in oVirt/RHV" b
- name: $1
	ovirt_tags:
		name: ${2:# Name of the tag to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# parent: ${4:# Name of the parent tag.}
		# description: ${5:# Description of the tag to manage.}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent|attached|detached}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# fetch_nested: ${9:# If I(True) the module will fetch additional data from the API.}
		# hosts: ${10:# List of the hosts names, which should have assigned this tag.}
		# timeout: ${11:180}
		# vms: ${12:# List of the VMs names, which should have assigned this tag.}
		# wait: ${13:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_tags_facts "Retrieve facts about one or more oVirt/RHV tags" b
- name: $1
	ovirt_tags_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${3:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${4:# Specifies list of the attributes which should be fetched from the API.}
		# timeout: ${5:180}
		# vm: ${6:# Name of the VM, which tags should be listed.}
		# name: ${7:# Name of the tag which should be listed.}
		# poll_interval: ${8:3}
		# host: ${9:# Name of the host, which tags should be listed.}
		# wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_templates "Module to manage virtual machine templates in oVirt/RHV" b
- name: $1
	ovirt_templates:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# exclusive: ${3:# When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.}
		# description: ${4:# Description of the template.}
		# image_disk: ${5:# When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.}
		# vm: ${6:# Name of the VM, which will be used to create template.}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		# cluster: ${8:# Name of the cluster, where template should be created/imported.}
		# fetch_nested: ${9:# If I(True) the module will fetch additional data from the API.}
		# id: ${10:# ID of the template to be registered.}
		# wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
		# storage_domain: ${12:# When C(state) is I(imported) this parameter specifies the name of the destination data storage domain. When C(state) is I(registered) this parameter specifies the name of the data storage domain of the unregistered template.}
		# name: ${13:# Name of the template to manage.}
		# export_domain: ${14:# When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.}
		# template_image_disk_name: ${15:# When C(state) is I(imported) and C(image_provider) is used this parameter specifies the new name for imported disk, if omitted then I(image_disk) name is used by default. This parameter is used only in case of importing disk image from Glance domain.}
		# cpu_profile: ${16:# CPU profile to be set to template.}
		# poll_interval: ${17:3}
		# state: ${18:#present|absent|exported|imported|registered}
		# timeout: ${19:180}
		# allow_partial_import: ${20:# Boolean indication whether to allow partial registration of a template when C(state) is registered.}
		# image_provider: ${21:# When C(state) is I(imported) this parameter specifies the name of the image provider to be used.}
		# clone_permissions: ${22:no}
$0
endsnippet

snippet ovirt_templates_facts "Retrieve facts about one or more oVirt/RHV templates" b
- name: $1
	ovirt_templates_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_users "Module to manage users in oVirt/RHV" b
- name: $1
	ovirt_users:
		name: ${2:# Name of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		authz_name: ${3:# Authorization provider of the user. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		# timeout: ${7:180}
		# poll_interval: ${8:3}
		# state: ${9:#present|absent}
		# wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_users_facts "Retrieve facts about one or more oVirt/RHV users" b
- name: $1
	ovirt_users_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_vmpools "Module to manage VM pools in oVirt/RHV" b
- name: $1
	ovirt_vmpools:
		name: ${2:# Name of the VM pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# type: ${4:manual|automatic}
		# description: ${5:# Description of the VM pool.}
		# poll_interval: ${6:3}
		# state: ${7:#present|absent}
		# nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		# vm_per_user: ${9:# Maximum number of VMs a single user can attach to from this pool.}
		# cluster: ${10:# Name of the cluster, where VM pool should be created.}
		# fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		# prestarted: ${12:# Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.}
		# timeout: ${13:180}
		# vm_count: ${14:# Number of VMs in the pool.}
		# template: ${15:# Name of the template, which will be used to create VM pool.}
		# wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_vmpools_facts "Retrieve facts about one or more oVirt/RHV vmpools" b
- name: $1
	ovirt_vmpools_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: ${3:# Search term which is accepted by oVirt/RHV search backend.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_vms "Module to manage Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_vms:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: ${3:# Comment of the Virtual Machine.}
		# memory_guaranteed: ${4:# Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
		# force: ${5:no}
		# cloud_init_nics: ${6:# List of dictionaries representing network interafaces to be setup by cloud init.}
		# xen: ${7:# Dictionary of values to be used to connect to XEN and import a virtual machine to oVirt.}
		# template_version: ${8:# Version number of the template to be used for VM.}
		# cluster: ${9:# Name of the cluster, where Virtual Machine should be created. Required if creating VM.}
		# fetch_nested: ${10:# If I(True) the module will fetch additional data from the API.}
		# timezone: ${11:# Sets time zone offset of the guest hardware clock.}
		# id: ${12:# ID of the Virtual Machine to manage.}
		# cpu_sockets: ${13:# Number of virtual CPUs sockets of the Virtual Machine. Default value is set by oVirt/RHV engine.}
		# high_availability: ${14:# If I(True) Virtual Machine will be set as highly available.}
		# storage_domain: ${15:# Name of the storage domain where all template disks should be created.}
		# instance_type: ${16:# Name of virtual machine's hardware configuration.}
		# nics: ${17:# List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary:}
		# disk_format: ${18:#cow|raw}
		# sysprep: ${19:# Dictionary with values for Windows Virtual Machine initialization using sysprep:}
		# cpu_cores: ${20:# Number of virtual CPUs cores of the Virtual Machine. Default value is set by oVirt/RHV engine.}
		# state: ${21:running|stopped|#present|absent|suspended|next_run|registered}
		# vmware: ${22:# Dictionary of values to be used to connect to VMware and import a virtual machine to oVirt.}
		# delete_protected: ${23:# If I(True) Virtual Machine will be set as delete protected.}
		# memory: ${24:# Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
		# cd_iso: ${25:# ISO file from ISO storage domain which should be attached to Virtual Machine.}
		# clone_permissions: ${26:no}
		# type: ${27:server|desktop}
		# initrd_path: ${28:# Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.}
		# lease: ${29:# Name of the storage domain this virtual machine lease reside on.}
		# description: ${30:# Description of the Virtual Machine.}
		# clone: ${31:no}
		# kvm: ${32:# Dictionary of values to be used to connect to kvm and import a virtual machine to oVirt.}
		# boot_devices: ${33:# List of boot devices which should be used to boot. Choices I(network), I(hd) and I(cdrom).}
		# nested_attributes: ${34:# Specifies list of the attributes which should be fetched from the API.}
		# host: ${35:# Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.}
		# serial_policy: ${36:# Specify a serial number policy for the Virtual Machine.}
		# wait: ${37:# I(True) if the module should wait for the entity to get into desired state.}
		# use_latest_template_version: ${38:# Specify if latest template version should be used, when running a stateless VM.}
		# stateless: ${39:# If I(True) Virtual Machine will be set as stateless.}
		# operating_system: ${40:rhel_6_ppc64|other|freebsd|windows_2003x64|windows_10|rhel_6x64|rhel_4x64|windows_2008x64|windows_2008R2x64|debian_7|windows_2012x64|ubuntu_14_04|ubuntu_12_04|ubuntu_13_10|windows_8x64|other_linux_ppc64|windows_2003|other_linux|windows_10x64|windows_2008|rhel_3|rhel_5|rhel_4|other_ppc64|sles_11|rhel_6|windows_xp|rhel_7x64|freebsdx64|rhel_7_ppc64|windows_7|rhel_5x64|ubuntu_14_04_ppc64|sles_11_ppc64|windows_8|windows_2012R2x64|windows_2008r2x64|ubuntu_13_04|ubuntu_12_10|windows_7x64}
		# serial_policy_value: ${41:# Allows you to specify a custom serial number.}
		# name: ${42:# Name of the Virtual Machine to manage. If VM don't exists C(name) is required. Otherwise C(id) or C(name) can be used.}
		# kernel_path: ${43:# Path to a kernel image used to boot the virtual machine.}
		# cloud_init: ${44:# Dictionary with values for Unix-like Virtual Machine initialization using cloud init:}
		# disks: ${45:# List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary:}
		# poll_interval: ${46:3}
		# kernel_params: ${47:# Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.}
		# template: ${48:# Name of the template, which should be used to create Virtual Machine. Required if creating VM.}
		# timeout: ${49:180}
		# allow_partial_import: ${50:# Boolean indication whether to allow partial registration of Virtual Machine when C(state) is registered.}
		# cpu_shares: ${51:# Set a CPU shares for this Virtual Machine. Default value is set by oVirt/RHV engine.}
$0
endsnippet

snippet ovirt_vms_facts "Retrieve facts about one or more oVirt/RHV virtual machines" b
- name: $1
	ovirt_vms_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# all_content: ${3:# If I(true) all the attributes of the virtual machines should be included in the response.}
		# fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		# max: ${5:# The maximum number of results to return.}
		# pattern: ${6:# Search term which is accepted by oVirt/RHV search backend.}
		# nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		# case_sensitive: ${8:# If I(true) performed search will take case into account.}
$0
endsnippet

snippet packet_device "Manage a bare metal server in the Packet Host." b
- name: $1
	packet_device:
		project_id: ${2:# ID of project of the device.}
		# features: ${3:# Dict with "features" for device creation. See Packet API docs for details.}
		# facility: ${4:# Facility slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/facilities/).}
		# wait_for_public_IPv: ${5:4|6}
		# auth_token: ${6:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
		# count_offset: ${7:1}
		# user_data: ${8:# Userdata blob made available to the machine}
		# always_pxe: ${9:no}
		# hostnames: ${10:# A hostname of a device, or a list of hostnames.}
		# plan: ${11:# Plan slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/plans/).}
		# ipxe_script_url: ${12:# URL of custom iPXE script for provisioning.}
		# count: ${13:1}
		# operating_system: ${14:# OS slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/operatingsystems/).}
		# locked: ${15:no}
		# device_ids: ${16:# List of device IDs on which to operate.}
		# wait: ${17:no}
		# state: ${18:#present|absent|active|inactive|rebooted}
		# wait_timeout: ${19:900}
$0
endsnippet

snippet packet_sshkey "Create/delete an SSH key in Packet host." b
- name: $1
	packet_sshkey:
		# state: ${2:#present|absent}
		# key: ${3:# Public Key string ({type} {base64 encoded key} {description}).}
		# fingerprint: ${4:# Fingerprint of the key which you want to remove.}
		# id: ${5:# UUID of the key which you want to remove.}
		# auth_token: ${6:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
		# key_file: ${7:# File with the public key.}
		# label: ${8:# Label for the key. If you keep it empty, it will be read from key string.}
$0
endsnippet

snippet profitbricks "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine." b
- name: $1
	profitbricks:
		image: ${2:# The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.}
		name: ${3:# The name of the virtual machine.}
		# lan: ${4:1}
		# image_password: ${5:# Password set for the administrative user.}
		# bus: ${6:IDE|#VIRTIO}
		# ram: ${7:2048}
		# instance_ids: ${8:# list of instance ids, currently only used when state='absent' to remove instances.}
		# subscription_password: ${9:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		# wait_timeout: ${10:600}
		# assign_public_ip: ${11:no}
		# wait: ${12:#yes|no}
		# count: ${13:1}
		# datacenter: ${14:# The datacenter to provision this virtual machine.}
		# remove_boot_volume: ${15:#yes|no}
		# ssh_keys: ${16:# Public SSH keys allowing access to the virtual machine.}
		# subscription_user: ${17:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		# cpu_family: ${18:#AMD_OPTERON|INTEL_XEON}
		# volume_size: ${19:10}
		# state: ${20:running|stopped|absent|#present}
		# location: ${21:#us/las|de/fra|de/fkb}
		# auto_increment: ${22:yes|no}
		# cores: ${23:2}
$0
endsnippet

snippet profitbricks_datacenter "Create or destroy a ProfitBricks Virtual Datacenter." b
- name: $1
	profitbricks_datacenter:
		name: ${2:# The name of the virtual datacenter.}
		# subscription_user: ${3:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		# subscription_password: ${4:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		# state: ${5:#present|absent}
		# wait_timeout: ${6:600}
		# location: ${7:#us/las|de/fra|de/fkb}
		# wait: ${8:#yes|no}
		# description: ${9:# The description of the virtual datacenter.}
$0
endsnippet

snippet profitbricks_nic "Create or Remove a NIC." b
- name: $1
	profitbricks_nic:
		datacenter: ${2:# The datacenter in which to operate.}
		lan: ${3:# The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.}
		name: ${4:# The name or ID of the NIC. This is only required on deletes, but not on create.}
		server: ${5:# The server name or ID.}
		# subscription_user: ${6:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		# subscription_password: ${7:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		# state: ${8:#present|absent}
		# wait_timeout: ${9:600}
		# wait: ${10:#yes|no}
$0
endsnippet

snippet profitbricks_volume "Create or destroy a volume." b
- name: $1
	profitbricks_volume:
		image: ${2:# The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.}
		datacenter: ${3:# The datacenter in which to create the volumes.}
		name: ${4:# The name of the volumes. You can enumerate the names using auto_increment.}
		# image_password: ${5:# Password set for the administrative user.}
		# licence_type: ${6:LINUX|WINDOWS|#UNKNOWN|OTHER}
		# bus: ${7:IDE|#VIRTIO}
		# instance_ids: ${8:# list of instance ids, currently only used when state='absent' to remove instances.}
		# subscription_password: ${9:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		# wait_timeout: ${10:600}
		# disk_type: ${11:#HDD|SSD}
		# wait: ${12:#yes|no}
		# count: ${13:1}
		# subscription_user: ${14:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		# state: ${15:#present|absent}
		# auto_increment: ${16:yes|no}
		# size: ${17:10}
		# ssh_keys: ${18:# Public SSH keys allowing access to the virtual machine.}
$0
endsnippet

snippet profitbricks_volume_attachments "Attach or detach a volume." b
- name: $1
	profitbricks_volume_attachments:
		datacenter: ${2:# The datacenter in which to operate.}
		server: ${3:# The name of the server you wish to detach or attach the volume.}
		volume: ${4:# The volume name or ID.}
		# subscription_user: ${5:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		# state: ${6:#present|absent}
		# wait_timeout: ${7:600}
		# subscription_password: ${8:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		# wait: ${9:#yes|no}
$0
endsnippet

snippet pubnub_blocks "PubNub blocks management module." b
- name: $1
	pubnub_blocks:
		name: ${2:# Name of managed block which will be later visible on admin.pubnub.com.}
		keyset: ${3:# Name of application's keys set which is bound to managed blocks.}
		application: ${4:# Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.}
		# account: ${5:# Name of PubNub account for from which C(application) will be used to manage blocks.}
		# changes: ${6:{}}
		# cache: ${7:{}}
		# state: ${8:#started|stopped|present|absent}
		# password: ${9:# Password which match to account to which specified C(email) belong.}
		# validate_certs: ${10:yes}
		# email: ${11:# Email from account for which new session should be started.}
		# event_handlers: ${12:[]}
		# description: ${13:New block}
$0
endsnippet

snippet rax "create / delete an instance in Rackspace Public Cloud" b
- name: $1
	rax:
		# files: ${2:# Files to insert into the instance. remotefilename:localcontent}
		# tenant_name: ${3:# The tenant name used for authentication.}
		# image: ${4:# image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image}
		# user_data: ${5:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
		# verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		# meta: ${7:# A hash of metadata to associate with the instance}
		# boot_volume_terminate: ${8:no}
		# flavor: ${9:# flavor to use for the instance}
		# networks: ${10:[u'public', u'private']}
		# auth_endpoint: ${11:https://identity.api.rackspacecloud.com/v2.0/}
		# boot_from_volume: ${12:yes|#no}
		# group: ${13:# host group to assign to server, is also used for idempotent operations to ensure a specific number of instances}
		# exact_count: ${14:yes|no}
		# disk_config: ${15:#auto|manual}
		# state: ${16:#present|absent}
		# env: ${17:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# key_name: ${18:# key pair to use on the instance}
		# api_key: ${19:# Rackspace API key, overrides I(credentials).}
		# config_drive: ${20:yes|no}
		# username: ${21:# Rackspace username, overrides I(credentials).}
		# auto_increment: ${22:yes|no}
		# count_offset: ${23:1}
		# boot_volume: ${24:# Cloud Block Storage ID or Name to use as the boot volume of the instance}
		# wait_timeout: ${25:300}
		# instance_ids: ${26:# list of instance ids, currently only used when state='absent' to remove instances}
		# credentials: ${27:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# wait: ${28:yes|#no}
		# count: ${29:1}
		# boot_volume_size: ${30:100}
		# name: ${31:# Name to give the instance}
		# identity_type: ${32:rackspace}
		# tenant_id: ${33:# The tenant ID used for authentication.}
		# region: ${34:DFW}
		# extra_client_args: ${35:# A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.}
		# extra_create_args: ${36:# A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.}
$0
endsnippet

snippet rax_cbs "Manipulate Rackspace Cloud Block Storage Volumes" b
- name: $1
	rax_cbs:
		size: ${2:100}
		state: ${3:#present|absent}
		volume_type: ${4:#SATA|SSD}
		name: ${5:# Name to give the volume being created}
		# username: ${6:# Rackspace username, overrides I(credentials).}
		# description: ${7:# Description to give the volume being created}
		# identity_type: ${8:rackspace}
		# tenant_id: ${9:# The tenant ID used for authentication.}
		# region: ${10:DFW}
		# wait: ${11:yes|#no}
		# verify_ssl: ${12:# Whether or not to require SSL validation of API endpoints.}
		# meta: ${13:# A hash of metadata to associate with the volume}
		# snapshot_id: ${14:# The id of the snapshot to create the volume from}
		# env: ${15:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${16:# The tenant name used for authentication.}
		# credentials: ${17:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${18:# Rackspace API key, overrides I(credentials).}
		# image: ${19:# image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)}
		# wait_timeout: ${20:300}
		# auth_endpoint: ${21:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_cbs_attachments "Manipulate Rackspace Cloud Block Storage Volume Attachments" b
- name: $1
	rax_cbs_attachments:
		state: ${2:#present|absent}
		server: ${3:# Name or id of the server to attach/detach}
		volume: ${4:# Name or id of the volume to attach/detach}
		# username: ${5:# Rackspace username, overrides I(credentials).}
		# identity_type: ${6:rackspace}
		# tenant_id: ${7:# The tenant ID used for authentication.}
		# region: ${8:DFW}
		# wait: ${9:yes|#no}
		# verify_ssl: ${10:# Whether or not to require SSL validation of API endpoints.}
		# wait_timeout: ${11:300}
		# env: ${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${13:# The tenant name used for authentication.}
		# device: ${14:# The device path to attach the volume to, e.g. /dev/xvde.}
		# credentials: ${15:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${16:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${17:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_cdb "create/delete or resize a Rackspace Cloud Databases instance" b
- name: $1
	rax_cdb:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# cdb_type: ${3:MySQL}
		# name: ${4:# Name of the databases server instance}
		# region: ${5:DFW}
		# state: ${6:#present|absent}
		# cdb_version: ${7:5.1|5.6|10}
		# volume: ${8:2}
		# verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		# wait_timeout: ${10:300}
		# env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# flavor: ${13:1}
		# api_key: ${14:# Rackspace API key, overrides I(credentials).}
		# wait: ${15:yes|#no}
$0
endsnippet

snippet rax_cdb_database "create / delete a database in the Cloud Databases" b
- name: $1
	rax_cdb_database:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# name: ${3:# Name to give to the database}
		# cdb_id: ${4:# The databases server UUID}
		# region: ${5:DFW}
		# state: ${6:#present|absent}
		# verify_ssl: ${7:# Whether or not to require SSL validation of API endpoints.}
		# collate: ${8:utf8_general_ci}
		# env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${11:# Rackspace API key, overrides I(credentials).}
		# character_set: ${12:utf8}
$0
endsnippet

snippet rax_cdb_user "create / delete a Rackspace Cloud Database" b
- name: $1
	rax_cdb_user:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# db_username: ${3:# Name of the database user}
		# db_password: ${4:# Database user password}
		# region: ${5:DFW}
		# databases: ${6:[]}
		# state: ${7:#present|absent}
		# verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		# env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# cdb_id: ${10:# The databases server UUID}
		# host: ${11:%}
		# credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${13:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet rax_clb "create / delete a load balancer in Rackspace Public Cloud" b
- name: $1
	rax_clb:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# protocol: ${3:DNS_TCP|DNS_UDP|FTP|#HTTP|HTTPS|IMAPS|IMAPv4|LDAP|LDAPS|MYSQL|POP3|POP3S|SMTP|TCP|TCP_CLIENT_FIRST|UDP|UDP_STREAM|SFTP}
		# timeout: ${4:30}
		# verify_ssl: ${5:# Whether or not to require SSL validation of API endpoints.}
		# wait_timeout: ${6:300}
		# credentials: ${7:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# port: ${8:80}
		# vip_id: ${9:# Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol}
		# name: ${10:# Name to give the load balancer}
		# algorithm: ${11:RANDOM|#LEAST_CONNECTIONS|ROUND_ROBIN|WEIGHTED_LEAST_CONNECTIONS|WEIGHTED_ROUND_ROBIN}
		# region: ${12:DFW}
		# wait: ${13:yes|#no}
		# state: ${14:#present|absent}
		# meta: ${15:# A hash of metadata to associate with the instance}
		# env: ${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${17:# Rackspace API key, overrides I(credentials).}
		# type: ${18:#PUBLIC|SERVICENET}
$0
endsnippet

snippet rax_clb_nodes "add, modify and remove nodes from a Rackspace Cloud Load Balancer" b
- name: $1
	rax_clb_nodes:
		load_balancer_id: ${2:# Load balancer id}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# weight: ${4:# Weight of node}
		# verify_ssl: ${5:# Whether or not to require SSL validation of API endpoints.}
		# wait_timeout: ${6:30}
		# address: ${7:# IP address or domain name of the node}
		# credentials: ${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# port: ${9:# Port number of the load balanced service on the node}
		# condition: ${10:enabled|disabled|draining}
		# wait: ${11:yes|#no}
		# region: ${12:DFW}
		# state: ${13:#present|absent}
		# node_id: ${14:# Node id}
		# env: ${15:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${16:# Rackspace API key, overrides I(credentials).}
		# type: ${17:primary|secondary}
$0
endsnippet

snippet rax_clb_ssl "Manage SSL termination for a Rackspace Cloud Load Balancer." b
- name: $1
	rax_clb_ssl:
		loadbalancer: ${2:# Name or ID of the load balancer on which to manage SSL termination.}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# private_key: ${4:# The private SSL key as a string in PEM format.}
		# https_redirect: ${5:# If "true", the load balancer will redirect HTTP traffic to HTTPS.}
		# verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		# wait_timeout: ${7:300}
		# credentials: ${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# wait: ${9:no}
		# certificate: ${10:# The public SSL certificates as a string in PEM format.}
		# region: ${11:DFW}
		# enabled: ${12:yes}
		# state: ${13:#present|absent}
		# intermediate_certificate: ${14:# One or more intermediate certificate authorities as a string in PEM}
		# secure_port: ${15:443}
		# secure_traffic_only: ${16:no}
		# env: ${17:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${18:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet rax_dns "Manage domains on Rackspace Cloud DNS" b
- name: $1
	rax_dns:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# comment: ${3:# Brief description of the domain. Maximum length of 160 characters}
		# name: ${4:# Domain name to create}
		# region: ${5:DFW}
		# state: ${6:#present|absent}
		# verify_ssl: ${7:# Whether or not to require SSL validation of API endpoints.}
		# env: ${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# ttl: ${9:3600}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${11:# Rackspace API key, overrides I(credentials).}
		# email: ${12:# Email address of the domain administrator}
$0
endsnippet

snippet rax_dns_record "Manage DNS records on Rackspace Cloud DNS" b
- name: $1
	rax_dns_record:
		data: ${2:# IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT}
		name: ${3:# FQDN record name to create}
		type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		# username: ${5:# Rackspace username, overrides I(credentials).}
		# comment: ${6:# Brief description of the domain. Maximum length of 160 characters}
		# domain: ${7:# Domain name to create the record in. This is an invalid option when type=PTR}
		# verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		# ttl: ${9:3600}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# overwrite: ${11:yes}
		# region: ${12:DFW}
		# server: ${13:# Server ID to create a PTR record for. Only used with type=PTR}
		# priority: ${14:# Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.}
		# state: ${15:#present|absent}
		# env: ${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${17:# Rackspace API key, overrides I(credentials).}
		# loadbalancer: ${18:# Load Balancer ID to create a PTR record for. Only used with type=PTR}
$0
endsnippet

snippet rax_facts "Gather facts for Rackspace Cloud Servers" b
- name: $1
	rax_facts:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# name: ${3:# Server name to retrieve facts for}
		# identity_type: ${4:rackspace}
		# tenant_id: ${5:# The tenant ID used for authentication.}
		# region: ${6:DFW}
		# address: ${7:# Server IP address to retrieve facts for, will match any IP assigned to the server}
		# verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		# env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${10:# The tenant name used for authentication.}
		# credentials: ${11:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${12:# Rackspace API key, overrides I(credentials).}
		# id: ${13:# Server ID to retrieve facts for}
		# auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_files "Manipulate Rackspace Cloud Files Containers" b
- name: $1
	rax_files:
		container: ${2:# The container to use for container or metadata operations.}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# private: ${4:# Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires}
		# verify_ssl: ${5:# Whether or not to require SSL validation of API endpoints.}
		# clear_meta: ${6:yes|#no}
		# ttl: ${7:# In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public}
		# credentials: ${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# web_index: ${9:# Sets an object to be presented as the HTTP index page when accessed by the CDN URL}
		# region: ${10:DFW}
		# state: ${11:#present|absent}
		# meta: ${12:# A hash of items to set as metadata values on a container}
		# env: ${13:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# web_error: ${14:# Sets an object to be presented as the HTTP error page when accessed by the CDN URL}
		# api_key: ${15:# Rackspace API key, overrides I(credentials).}
		# type: ${16:#file|meta}
		# public: ${17:# Used to set a container as public, available via the Cloud Files CDN}
$0
endsnippet

snippet rax_files_objects "Upload, download, and delete objects in Rackspace Cloud Files" b
- name: $1
	rax_files_objects:
		container: ${2:# The container to use for file object operations.}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# dest: ${4:# The destination of a "get" operation; i.e. a local directory, "/home/user/myfolder". Used to specify the destination of an operation on a remote object; i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17"}
		# expires: ${5:# Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds}
		# verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		# clear_meta: ${7:yes|#no}
		# credentials: ${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# structure: ${9:True|no}
		# src: ${10:# Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17".  src and dest are mutually exclusive on remote-only object operations}
		# region: ${11:DFW}
		# state: ${12:#present|absent}
		# meta: ${13:# A hash of items to set as metadata values on an uploaded file or folder}
		# env: ${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${15:# Rackspace API key, overrides I(credentials).}
		# type: ${16:#file|meta}
		# method: ${17:#get|put|delete}
$0
endsnippet

snippet rax_identity "Load Rackspace Cloud Identity" b
- name: $1
	rax_identity:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# identity_type: ${3:rackspace}
		# tenant_id: ${4:# The tenant ID used for authentication.}
		# region: ${5:DFW}
		# state: ${6:#present|absent}
		# verify_ssl: ${7:# Whether or not to require SSL validation of API endpoints.}
		# env: ${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${9:# The tenant name used for authentication.}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${11:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${12:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_keypair "Create a keypair for use with Rackspace Cloud Servers" b
- name: $1
	rax_keypair:
		name: ${2:# Name of keypair}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# public_key: ${4:# Public Key string to upload. Can be a file path or string}
		# identity_type: ${5:rackspace}
		# tenant_id: ${6:# The tenant ID used for authentication.}
		# region: ${7:DFW}
		# state: ${8:#present|absent}
		# verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		# env: ${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${11:# The tenant name used for authentication.}
		# credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${13:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_meta "Manipulate metadata for Rackspace Cloud Servers" b
- name: $1
	rax_meta:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# name: ${3:# Server name to modify metadata for}
		# identity_type: ${4:rackspace}
		# tenant_id: ${5:# The tenant ID used for authentication.}
		# region: ${6:DFW}
		# address: ${7:# Server IP address to modify metadata for, will match any IP assigned to the server}
		# verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		# meta: ${9:# A hash of metadata to associate with the instance}
		# env: ${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${11:# The tenant name used for authentication.}
		# credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${13:# Rackspace API key, overrides I(credentials).}
		# id: ${14:# Server ID to modify metadata for}
		# auth_endpoint: ${15:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_alarm "Create or delete a Rackspace Cloud Monitoring alarm." b
- name: $1
	rax_mon_alarm:
		entity_id: ${2:# ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.}
		notification_plan_id: ${3:# ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.}
		label: ${4:# Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.}
		check_id: ${5:# ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.}
		# username: ${6:# Rackspace username, overrides I(credentials).}
		# metadata: ${7:# Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.}
		# identity_type: ${8:rackspace}
		# tenant_id: ${9:# The tenant ID used for authentication.}
		# region: ${10:DFW}
		# criteria: ${11:# Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.}
		# state: ${12:#present|absent}
		# disabled: ${13:yes|no}
		# verify_ssl: ${14:# Whether or not to require SSL validation of API endpoints.}
		# env: ${15:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${16:# The tenant name used for authentication.}
		# credentials: ${17:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${18:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${19:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_check "Create or delete a Rackspace Cloud Monitoring check for an existing entity." b
- name: $1
	rax_mon_check:
		entity_id: ${2:# ID of the rax_mon_entity to target with this check.}
		check_type: ${3:remote.dns|remote.ftp-banner|remote.http|remote.imap-banner|remote.mssql-banner|remote.mysql-banner|remote.ping|remote.pop3-banner|remote.postgresql-banner|remote.smtp-banner|remote.smtp|remote.ssh|remote.tcp|remote.telnet-banner|agent.filesystem|agent.memory|agent.load_average|agent.cpu|agent.disk|agent.network|agent.plugin}
		label: ${4:# Defines a label for this check, between 1 and 64 characters long.}
		# username: ${5:# Rackspace username, overrides I(credentials).}
		# tenant_name: ${6:# The tenant name used for authentication.}
		# period: ${7:# The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.}
		# disabled: ${8:yes|no}
		# verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# auth_endpoint: ${11:https://identity.api.rackspacecloud.com/v2.0/}
		# timeout: ${12:# The number of seconds this check will wait when attempting to collect results. Must be less than the period.}
		# target_alias: ${13:# One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.}
		# identity_type: ${14:rackspace}
		# tenant_id: ${15:# The tenant ID used for authentication.}
		# region: ${16:DFW}
		# target_hostname: ${17:# One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.}
		# state: ${18:present|absent}
		# details: ${19:# Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.}
		# env: ${20:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# monitoring_zones_poll: ${21:# Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.}
		# api_key: ${22:# Rackspace API key, overrides I(credentials).}
		# metadata: ${23:# Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.}
$0
endsnippet

snippet rax_mon_entity "Create or delete a Rackspace Cloud Monitoring entity" b
- name: $1
	rax_mon_entity:
		label: ${2:# Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# identity_type: ${4:rackspace}
		# tenant_id: ${5:# The tenant ID used for authentication.}
		# region: ${6:DFW}
		# state: ${7:present|absent}
		# metadata: ${8:# Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.}
		# verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		# agent_id: ${10:# Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.}
		# env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${12:# The tenant name used for authentication.}
		# credentials: ${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${14:# Rackspace API key, overrides I(credentials).}
		# named_ip_addresses: ${15:# Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.}
		# auth_endpoint: ${16:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_notification "Create or delete a Rackspace Cloud Monitoring notification." b
- name: $1
	rax_mon_notification:
		label: ${2:# Defines a friendly name for this notification. String between 1 and 255 characters long.}
		details: ${3:# Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.}
		notification_type: ${4:webhook|email|pagerduty}
		# username: ${5:# Rackspace username, overrides I(credentials).}
		# identity_type: ${6:rackspace}
		# tenant_id: ${7:# The tenant ID used for authentication.}
		# region: ${8:DFW}
		# state: ${9:present|absent}
		# verify_ssl: ${10:# Whether or not to require SSL validation of API endpoints.}
		# env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${12:# The tenant name used for authentication.}
		# credentials: ${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${14:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${15:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_notification_plan "Create or delete a Rackspace Cloud Monitoring notification plan." b
- name: $1
	rax_mon_notification_plan:
		label: ${2:# Defines a friendly name for this notification plan. String between 1 and 255 characters long.}
		# username: ${3:# Rackspace username, overrides I(credentials).}
		# warning_state: ${4:# Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.}
		# identity_type: ${5:rackspace}
		# tenant_id: ${6:# The tenant ID used for authentication.}
		# region: ${7:DFW}
		# critical_state: ${8:# Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.}
		# state: ${9:present|absent}
		# ok_state: ${10:# Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.}
		# verify_ssl: ${11:# Whether or not to require SSL validation of API endpoints.}
		# env: ${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${13:# The tenant name used for authentication.}
		# credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# api_key: ${15:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${16:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_network "create / delete an isolated network in Rackspace Public Cloud" b
- name: $1
	rax_network:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# identity_type: ${3:rackspace}
		# tenant_id: ${4:# The tenant ID used for authentication.}
		# region: ${5:DFW}
		# state: ${6:#present|absent}
		# label: ${7:# Label (name) to give the network}
		# verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		# env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# tenant_name: ${10:# The tenant name used for authentication.}
		# credentials: ${11:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# cidr: ${12:# cidr of the network being created}
		# api_key: ${13:# Rackspace API key, overrides I(credentials).}
		# auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_queue "create / delete a queue in Rackspace Public Cloud" b
- name: $1
	rax_queue:
		# username: ${2:# Rackspace username, overrides I(credentials).}
		# verify_ssl: ${3:# Whether or not to require SSL validation of API endpoints.}
		# name: ${4:# Name to give the queue}
		# env: ${5:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# credentials: ${6:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# region: ${7:DFW}
		# api_key: ${8:# Rackspace API key, overrides I(credentials).}
		# state: ${9:#present|absent}
$0
endsnippet

snippet rax_scaling_group "Manipulate Rackspace Cloud Autoscale Groups" b
- name: $1
	rax_scaling_group:
		image: ${2:# image to use for the instance. Can be an C(id), C(human_id) or C(name)}
		min_entities: ${3:# The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		flavor: ${4:# flavor to use for the instance}
		max_entities: ${5:# The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		name: ${6:# Name to give the scaling group}
		server_name: ${7:# The base name for servers created by Autoscale}
		# username: ${8:# Rackspace username, overrides I(credentials).}
		# files: ${9:# Files to insert into the instance. Hash of C(remotepath: localpath)}
		# key_name: ${10:# key pair to use on the instance}
		# user_data: ${11:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
		# verify_ssl: ${12:# Whether or not to require SSL validation of API endpoints.}
		# cooldown: ${13:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
		# meta: ${14:# A hash of metadata to associate with the instance}
		# credentials: ${15:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# networks: ${16:[u'public', u'private']}
		# wait: ${17:yes|#no}
		# loadbalancers: ${18:# List of load balancer C(id) and C(port) hashes}
		# region: ${19:DFW}
		# disk_config: ${20:#auto|manual}
		# state: ${21:#present|absent}
		# wait_timeout: ${22:300}
		# env: ${23:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${24:# Rackspace API key, overrides I(credentials).}
		# config_drive: ${25:yes|no}
$0
endsnippet

snippet rax_scaling_policy "Manipulate Rackspace Cloud Autoscale Scaling Policy" b
- name: $1
	rax_scaling_policy:
		policy_type: ${2:webhook|schedule}
		scaling_group: ${3:# Name of the scaling group that this policy will be added to}
		name: ${4:# Name to give the policy}
		# username: ${5:# Rackspace username, overrides I(credentials).}
		# cron: ${6:# The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)}
		# verify_ssl: ${7:# Whether or not to require SSL validation of API endpoints.}
		# cooldown: ${8:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
		# at: ${9:# The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)}
		# credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		# change: ${11:# The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.}
		# is_percent: ${12:no}
		# region: ${13:DFW}
		# desired_capacity: ${14:# The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.}
		# state: ${15:#present|absent}
		# env: ${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		# api_key: ${17:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet imgadm "Manage SmartOS images" b
- name: $1
	imgadm:
		state: ${2:present|absent|deleted|imported|updated|vacuumed}
		# source: ${3:# URI for the image source.}
		# force: ${4:True|False}
		# uuid: ${5:# Image UUID. Can either be a full UUID or C(*) for all images.}
		# type: ${6:#imgapi|docker|dsapi}
		# pool: ${7:zones}
$0
endsnippet

snippet smartos_image_facts "Get SmartOS image details." b
- name: $1
	smartos_image_facts:
		# filters: ${2:# Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.}
$0
endsnippet

snippet vmadm "Manage SmartOS virtual machines and zones." b
- name: $1
	vmadm:
		state: ${2:present|absent|stopped|restarted}
		brand: ${3:#joyent|joyent-minimal|kvm|lx}
		# customer_metadata: ${4:# Metadata to be set and associated with this VM, this contain customer modifiable keys.}
		# disk_driver: ${5:# Default value for a virtual disk model for KVM guests.}
		# force: ${6:# Force a particular action (i.e. stop or delete a VM).}
		# zfs_root_compression: ${7:# Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.}
		# virtio_txtimer: ${8:# Timeout (in nanoseconds) for the TX timer of virtio NICs.}
		# spice_password: ${9:# Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.}
		# zfs_io_priority: ${10:# IO throttle priority value relative to other VMs.}
		# ram: ${11:# Amount of virtual RAM for a KVM guest (in MiBs).}
		# dns_domain: ${12:# Domain value for C(/etc/hosts).}
		# max_physical_memory: ${13:# Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.}
		# nic_driver: ${14:# Default value for a virtual NIC model for KVM guests.}
		# zfs_data_compression: ${15:# Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.}
		# image_uuid: ${16:# Image UUID.}
		# fs_allowed: ${17:# Comma separated list of filesystem types this zone is allowed to mount.}
		# indestructible_delegated: ${18:# Adds an C(@indestructible) snapshot to delegated datasets.}
		# qemu_opts: ${19:# Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.}
		# delegate_dataset: ${20:# Whether to delegate a ZFS dataset to an OS VM.}
		# firewall_enabled: ${21:# Enables the firewall, allowing fwadm(1M) rules to be applied.}
		# mdata_exec_timeout: ${22:# Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.}
		# archive_on_delete: ${23:# When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.}
		# nics: ${24:# A list of nics to add, valid properties are documented in vmadm(1M).}
		# hostname: ${25:# Zone/VM hostname.}
		# boot: ${26:# Set the boot order for KVM VMs.}
		# vga: ${27:# Specify VGA emulation used by KVM VMs.}
		# zfs_snapshot_limit: ${28:# Number of snapshots the VM can have.}
		# limit_priv: ${29:# Set (comma separated) list of privileges the zone is allowed to use.}
		# cpu_cap: ${30:# Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.}
		# maintain_resolvers: ${31:# Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.}
		# indestructible_zoneroot: ${32:# Adds an C(@indestructible) snapshot to zoneroot.}
		# vnc_password: ${33:# Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.}
		# vcpus: ${34:# Number of virtual CPUs for a KVM guest.}
		# disks: ${35:# A list of disks to add, valid properties are documented in vmadm(1M).}
		# max_swap: ${36:# Maximum amount of virtual memory (in MiBs) the VM is allowed to use.}
		# zfs_root_recsize: ${37:# Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.}
		# zfs_filesystem_limit: ${38:# Maximum number of filesystems the VM can have.}
		# quota: ${39:# Quota on zone filesystems (in MiBs).}
		# filesystems: ${40:# Mount additional filesystems into an OS VM.}
		# autoboot: ${41:# Whether or not a VM is booted when the system is rebooted.}
		# tmpfs: ${42:# Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.}
		# qemu_extra_opts: ${43:# Additional qemu cmdline arguments for KVM guests.}
		# resolvers: ${44:# List of resolvers to be put into C(/etc/resolv.conf).}
		# max_lwps: ${45:# Maximum number of lightweight processes this VM is allowed to have running.}
		# nowait: ${46:# Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.}
		# name: ${47:# Name of the VM. vmadm(1M) uses this as an optional name.}
		# kernel_version: ${48:# Kernel version to emulate for LX VMs.}
		# max_locked_memory: ${49:# Total amount of memory (in MiBs) on the host that can be locked by this VM.}
		# vnc_port: ${50:# TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.}
		# uuid: ${51:# UUID of the VM. Can either be a full UUID or C(*) for all VMs.}
		# internal_metadata_namespace: ${52:# List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata).}
		# virtio_txburst: ${53:# Number of packets that can be sent in a single flush of the tx queue of virtio NICs.}
		# spice_opts: ${54:# Addition options for SPICE-enabled KVM VMs.}
		# zfs_data_recsize: ${55:# Suggested block size (power of 2) for files in the delegated dataset's filesystem.}
		# internal_metadata: ${56:# Metadata to be set and associated with this VM, this contains operator generated keys.}
		# cpu_type: ${57:#qemu64|host}
		# routes: ${58:# Dictionary that maps destinations to gateways, these will be set as static routes in the VM.}
		# zpool: ${59:# ZFS pool the VM's zone dataset will be created in.}
		# cpu_shares: ${60:# Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.}
$0
endsnippet

snippet sl_vm "create or cancel a virtual instance in SoftLayer" b
- name: $1
	sl_vm:
		disks: ${2:[25]}
		cpus: ${3:# Count of cpus to be assigned to new virtual instance}
		memory: ${4:# Amount of memory to be assigned to new virtual instance}
		# domain: ${5:# Domain name to be provided to a virtual instance}
		# tags: ${6:# Tag or list of tags to be provided to a virtual instance}
		# instance_id: ${7:# Instance Id of the virtual instance to perform action option}
		# dedicated: ${8:no}
		# private: ${9:no}
		# image_id: ${10:# Image Template to be used for new virtual instance}
		# nic_speed: ${11:10}
		# private_vlan: ${12:# VLAN by its Id to be assigned to the private NIC}
		# datacenter: ${13:# Datacenter for the virtual instance to be deployed}
		# public_vlan: ${14:# VLAN by its Id to be assigned to the public NIC}
		# wait: ${15:yes}
		# hourly: ${16:yes}
		# ssh_keys: ${17:# List of ssh keys by their Id to be assigned to a virtual instance}
		# hostname: ${18:# Hostname to be provided to a virtual instance}
		# os_code: ${19:# OS Code to be used for new virtual instance}
		# wait_time: ${20:600}
		# local_disk: ${21:yes}
		# state: ${22:present}
		# post_uri: ${23:# URL of a post provisioning script to be loaded and executed on virtual instance}
$0
endsnippet

snippet udm_dns_record "Manage dns entries on a univention corporate server" b
- name: $1
	udm_dns_record:
		type: ${2:host_record|alias|ptr_record|srv_record|txt_record}
		name: ${3:# Name of the record, this is also the DNS record. E.g. www for www.example.com.}
		zone: ${4:# Corresponding DNS zone for this record, e.g. example.com.}
		# state: ${5:#present|absent}
		# data: ${6:[]}
$0
endsnippet

snippet udm_dns_zone "Manage dns zones on a univention corporate server" b
- name: $1
	udm_dns_zone:
		zone: ${2:# DNS zone name, e.g. C(example.com).}
		type: ${3:forward_zone|reverse_zone}
		# retry: ${4:1800}
		# interfaces: ${5:# List of interface IP addresses, on which the server should response this zone. Required if C(state=present).}
		# refresh: ${6:3600}
		# state: ${7:#present|absent}
		# contact: ${8:}
		# expire: ${9:604800}
		# ttl: ${10:600}
		# nameserver: ${11:# List of appropriate name servers. Required if C(state=present).}
		# mx: ${12:[]}
$0
endsnippet

snippet udm_group "Manage of the posix group" b
- name: $1
	udm_group:
		name: ${2:# Name of the posix group.}
		# state: ${3:#present|absent}
		# position: ${4:# define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).}
		# ou: ${5:# LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).}
		# subpath: ${6:# Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).}
		# description: ${7:# Group description.}
$0
endsnippet

snippet udm_share "Manage samba shares on a univention corporate server" b
- name: $1
	udm_share:
		name: ${2:# Name}
		ou: ${3:# Organisational unit, inside the LDAP Base DN.}
		# samba_name: ${4:# Windows name. Required if C(state=present).}
		# samba_hide_files: ${5:# Hide files.}
		# samba_blocking_locks: ${6:0|#1}
		# samba_directory_mode: ${7:0755}
		# samba_dos_filemode: ${8:#0|1}
		# samba_postexec: ${9:# Postexec script.}
		# owner: ${10:0}
		# samba_fake_oplocks: ${11:#0|1}
		# samba_strict_locking: ${12:Auto}
		# samba_public: ${13:#0|1}
		# samba_force_directory_security_mode: ${14:#0|1}
		# group: ${15:0}
		# samba_writeable: ${16:0|#1}
		# samba_nt_acl_support: ${17:0|#1}
		# samba_write_list: ${18:# Restrict write access to these users/groups.}
		# samba_preexec: ${19:# Preexec script.}
		# samba_browseable: ${20:0|#1}
		# samba_inherit_acls: ${21:0|#1}
		# samba_msdfs_root: ${22:#0|1}
		# state: ${23:#present|absent}
		# samba_valid_users: ${24:# Valid users or groups.}
		# samba_force_create_mode: ${25:#0|1}
		# root_squash: ${26:0|#1}
		# samba_directory_security_mode: ${27:0777}
		# samba_force_group: ${28:# Force group.}
		# samba_vfs_objects: ${29:# VFS objects.}
		# samba_force_directory_mode: ${30:#0|1}
		# writeable: ${31:0|#1}
		# samba_locking: ${32:0|#1}
		# samba_security_mode: ${33:0777}
		# samba_inherit_owner: ${34:#0|1}
		# samba_csc_policy: ${35:manual}
		# sync: ${36:sync}
		# nfs_hosts: ${37:[]}
		# path: ${38:# Directory on the providing server, e.g. C(/home). Required if C(state=present).}
		# nfs_custom_settings: ${39:[]}
		# samba_force_user: ${40:# Force user.}
		# samba_invalid_users: ${41:# Invalid users or groups.}
		# samba_create_mode: ${42:0744}
		# samba_force_security_mode: ${43:#0|1}
		# samba_level_2_oplocks: ${44:0|#1}
		# samba_custom_settings: ${45:[]}
		# samba_hide_unreadable: ${46:#0|1}
		# host: ${47:# Host FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present).}
		# samba_block_size: ${48:# Blocking size.}
		# samba_oplocks: ${49:0|#1}
		# samba_hosts_allow: ${50:[]}
		# samba_inherit_permissions: ${51:#0|1}
		# subtree_checking: ${52:0|#1}
		# directorymode: ${53:00755}
		# samba_hosts_deny: ${54:[]}
$0
endsnippet

snippet udm_user "Manage posix users on a univention corporate server" b
- name: $1
	udm_user:
		username: ${2:# User name}
		# update_password: ${3:always}
		# samba_user_workstations: ${4:[]}
		# homedrive: ${5:# Windows home drive, e.g. C("H:").}
		# room_number: ${6:# Room number of users business address.}
		# primary_group: ${7:cn=Domain Users,cn=groups,$LDAP_BASE_DN}
		# postcode: ${8:# Postal code of users business address.}
		# scriptpath: ${9:# Windows logon script.}
		# home_share: ${10:# Home NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com).}
		# override_pw_history: ${11:no}
		# city: ${12:# City of users business address.}
		# display_name: ${13:# Display name (not gecos)}
		# pager_telephonenumber: ${14:[]}
		# employee_number: ${15:# Employee number}
		# serviceprovider: ${16:[u'']}
		# organisation: ${17:# Organisation}
		# subpath: ${18:cn=users}
		# state: ${19:#present|absent}
		# home_share_path: ${20:# Path to home NFS share, inside the homeShare.}
		# userexpiry: ${21:Today + 1 year}
		# unixhome: ${22:/home/$USERNAME}
		# mail_home_server: ${23:# FQDN of mail server}
		# email: ${24:[u'']}
		# sambahome: ${25:# Windows home path, e.g. C('\\$FQDN\$USERNAME').}
		# home_telephone_number: ${26:[]}
		# shell: ${27:/bin/bash}
		# description: ${28:# Description (not gecos)}
		# firstname: ${29:# First name. Required if C(state=present).}
		# lastname: ${30:# Last name. Required if C(state=present).}
		# mail_alternative_address: ${31:[]}
		# phone: ${32:[]}
		# birthday: ${33:# Birthday}
		# groups: ${34:[]}
		# profilepath: ${35:# Windows profile directory}
		# employee_type: ${36:# Employee type}
		# password: ${37:# Password. Required if C(state=present).}
		# pwd_change_next_login: ${38:0|1}
		# mail_primary_address: ${39:# Primary e-mail address}
		# country: ${40:# Country of users business address.}
		# title: ${41:# Title, e.g. C(Prof.).}
		# override_pw_length: ${42:no}
		# street: ${43:# Street of users business address.}
		# gecos: ${44:# GECOS}
		# mobile_telephone_number: ${45:[]}
		# position: ${46:}
		# ou: ${47:}
		# department_number: ${48:# Department number of users business address.}
		# samba_privileges: ${49:[]}
		# secretary: ${50:[]}
$0
endsnippet

snippet vca_fw "add remove firewall rules in a gateway  in a vca" b
- name: $1
	vca_fw:
		fw_rules: ${2:no}
		# username: ${3:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
		# gateway_name: ${4:gateway}
		# host: ${5:# The authentication host to be used when service type is vcd.}
		# instance_id: ${6:# The instance id in a vchs environment to be used for creating the vapp.}
		# state: ${7:#present|absent}
		# service_type: ${8:#vca|vchs|vcd}
		# org: ${9:# The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).}
		# password: ${10:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
		# vdc_name: ${11:# The name of the vdc where the gateway is located.}
		# api_version: ${12:5.7}
		# verify_certs: ${13:yes}
$0
endsnippet

snippet vca_nat "add remove nat rules in a gateway  in a vca" b
- name: $1
	vca_nat:
		nat_rules: ${2:no}
		# username: ${3:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
		# gateway_name: ${4:gateway}
		# purge_rules: ${5:no}
		# host: ${6:# The authentication host to be used when service type is vcd.}
		# instance_id: ${7:# The instance id in a vchs environment to be used for creating the vapp.}
		# state: ${8:#present|absent}
		# service_type: ${9:#vca|vchs|vcd}
		# org: ${10:# The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).}
		# password: ${11:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
		# vdc_name: ${12:# The name of the vdc where the gateway is located.}
		# api_version: ${13:5.7}
		# verify_certs: ${14:yes}
$0
endsnippet

snippet vca_vapp "Manages vCloud Air vApp instances." b
- name: $1
	vca_vapp:
		vapp_name: ${2:# The name of the vCloud Air vApp instance}
		# vm_name: ${3:# The name of the virtual machine instance in the vApp to manage.}
		# username: ${4:# The vCloud Air username to use during authentication}
		# vm_memory: ${5:# The amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp.}
		# template_name: ${6:# The name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)}
		# network_mode: ${7:#pool|dhcp|static}
		# org: ${8:# The org to login to for creating vapp, mostly set when the service_type is vdc.}
		# operation: ${9:#noop|poweron|poweroff|suspend|shutdown|reboot|reset}
		# password: ${10:# The vCloud Air password to use during authentication}
		# vm_cpus: ${11:# The number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.}
		# vdc_name: ${12:# The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.}
		# network_name: ${13:# The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided.}
		# host: ${14:# The authentication host to be used when service type  is vcd.}
		# instance_id: ${15:# The instance id in a vchs environment to be used for creating the vapp}
		# state: ${16:#present|absent|deployed|undeployed}
		# service_type: ${17:#vca|vchs|vcd}
		# api_version: ${18:5.7}
$0
endsnippet

snippet vcenter_license "Manage VMware vCenter license keys" b
- name: $1
	vcenter_license:
		username: ${2:# The username to log into the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		license: ${4:# The license key to manage in vSphere vCenter.}
		password: ${5:# The password to log into to the vSphere vCenter.}
		# state: ${6:absent|#present}
		# labels: ${7:# The optional labels of the license key to manage in vSphere vCenter.}
$0
endsnippet

snippet vmware_cluster "Manage VMware vSphere clusters" b
- name: $1
	vmware_cluster:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		cluster_name: ${5:# The name of the cluster that will be created.}
		password: ${6:# The password of the vSphere vCenter.}
		# enable_ha: ${7:no}
		# enable_vsan: ${8:no}
		# state: ${9:absent|#present}
		# enable_drs: ${10:no}
		# validate_certs: ${11:#True|False}
$0
endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters" b
- name: $1
	vmware_datacenter:
		username: ${2:# The username of the vSphere vCenter}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter API server}
		password: ${5:# The password of the vSphere vCenter}
		# state: ${6:#present|absent}
		# validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration" b
- name: $1
	vmware_dns_config:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		domainname: ${4:# The domain the ESXi host should be apart of.}
		dns_servers: ${5:# The DNS servers that the host should be configured to use.}
		change_hostname_to: ${6:# The hostname that an ESXi host should be changed to.}
		password: ${7:# The password of the vSphere vCenter.}
		# validate_certs: ${8:#True|False}
$0
endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch" b
- name: $1
	vmware_dvs_host:
		username: ${2:# The username of the vSphere vCenter.}
		vmnics: ${3:# The ESXi hosts vmnics to use with the Distributed vSwitch}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		state: ${5:present|absent}
		esxi_hostname: ${6:# The ESXi hostname}
		password: ${7:# The password of the vSphere vCenter.}
		switch_name: ${8:# The name of the Distributed vSwitch}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup" b
- name: $1
	vmware_dvs_portgroup:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# The name of the portgroup that is to be created or deleted}
		portgroup_type: ${4:earlyBinding|lateBinding|ephemeral}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		num_ports: ${6:# The number of ports the portgroup should contain}
		password: ${7:# The password of the vSphere vCenter.}
		switch_name: ${8:# The name of the distributed vSwitch the port group should be created on.}
		vlan_id: ${9:# The VLAN ID that should be configured with the portgroup}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_dvswitch "Create or remove a distributed vSwitch" b
- name: $1
	vmware_dvswitch:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter_name: ${3:# The name of the datacenter that will contain the dvSwitch}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		discovery_proto: ${5:cdp|lldp}
		mtu: ${6:# The switch maximum transmission unit}
		password: ${7:# The password of the vSphere vCenter.}
		switch_name: ${8:# The name of the switch to create or remove}
		uplink_quantity: ${9:# Quantity of uplink per ESXi host added to the switch}
		# state: ${10:#present|absent}
		# discovery_operation: ${11:both|none|advertise|listen}
		# validate_certs: ${12:#True|False}
$0
endsnippet

snippet vmware_guest "Manages virtual machines in vCenter" b
- name: $1
	vmware_guest:
		username: ${2:# The username of the vSphere vCenter.}
		state: ${3:present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest}
		password: ${4:# The password of the vSphere vCenter.}
		name: ${5:# Name of the VM to work with.}
		hostname: ${6:# The hostname or IP address of the vSphere vCenter.}
		# resource_pool: ${7:# Affect machine to the given resource pool.}
		# snapshot_src: ${8:# Name of an existing snapshot to use to create a clone of a VM.}
		# force: ${9:no}
		# template: ${10:# Template used to create VM.}
		# hardware: ${11:# Manage some VM hardware attributes.}
		# cluster: ${12:# The cluster name where the VM will run.}
		# name_match: ${13:#first|last}
		# customization: ${14:# Parameters for OS customization when cloning from template.}
		# networks: ${15:# A list of networks (in the order of the NICs).}
		# wait_for_ip_address: ${16:no}
		# datacenter: ${17:ha-datacenter}
		# disk: ${18:# A list of disks to add.}
		# customvalues: ${19:# Define a list of customvalues to set on VM.}
		# guest_id: ${20:# Set the guest ID (Debian, RHEL, Windows...).}
		# uuid: ${21:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		# annotation: ${22:# A note or annotation to include in the VM.}
		# is_template: ${23:no}
		# esxi_hostname: ${24:# The ESXi hostname where the VM will run.}
		# linked_clone: ${25:no}
		# folder: ${26:/vm}
		# validate_certs: ${27:#True|False}
$0
endsnippet

snippet vmware_guest_facts "Gather facts about a single VM" b
- name: $1
	vmware_guest_facts:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter: ${3:# Destination datacenter for the deploy operation}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		# uuid: ${6:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		# name_match: ${7:#first|last}
		# folder: ${8:/vm}
		# validate_certs: ${9:#True|False}
		# name: ${10:# Name of the VM to work with}
$0
endsnippet

snippet vmware_guest_find "Find the folder path(s) for a VM by name or UUID" b
- name: $1
	vmware_guest_find:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter: ${3:# Destination datacenter for the find operation.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		# name: ${6:# Name of the VM to work with.}
		# validate_certs: ${7:#True|False}
		# uuid: ${8:# UUID of the instance to manage if known, this is VMware's BIOS UUID.}
$0
endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vcenter" b
- name: $1
	vmware_guest_snapshot:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter: ${3:# Destination datacenter for the deploy operation}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		state: ${5:present|absent|revert|remove_all}
		password: ${6:# The password of the vSphere vCenter.}
		# uuid: ${7:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		# quiesce: ${8:# If set to C(true) and virtual machine is powered on, it will quiesce the file system in virtual machine.}
		# description: ${9:# Define an arbitrary description to attach to snapshot.}
		# memory_dump: ${10:# If set to C(true), memory dump of virtual machine is also included in snapshot.}
		# snapshot_name: ${11:# Sets the snapshot name to manage.}
		# name_match: ${12:#first|last}
		# remove_children: ${13:# If set to C(true) and state is set to C(absent), then entire snapshot subtree is set for removal.}
		# folder: ${14:/vm}
		# validate_certs: ${15:#True|False}
		# name: ${16:# Name of the VM to work with}
$0
endsnippet

snippet vmware_guest_tools_wait "Wait for VMware tools to become available" b
- name: $1
	vmware_guest_tools_wait:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		password: ${4:# The password of the vSphere vCenter.}
		# uuid: ${5:# UUID of the VM  for which to wait until the tools become available, if known. This is VMware's unique identifier.}
		# name_match: ${6:#first|last}
		# folder: ${7:/vm}
		# validate_certs: ${8:#True|False}
		# name: ${9:# Name of the VM for which to wait until the tools become available.}
$0
endsnippet

snippet vmware_host "Add/remove ESXi host to/from vCenter" b
- name: $1
	vmware_host:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter_name: ${3:# Name of the datacenter to add the host.}
		esxi_password: ${4:# ESXi password.}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		esxi_username: ${6:# ESXi username.}
		cluster_name: ${7:# Name of the cluster to add the host.}
		esxi_hostname: ${8:# ESXi hostname to manage.}
		password: ${9:# The password of the vSphere vCenter.}
		# state: ${10:absent|#present}
		# validate_certs: ${11:#True|False}
$0
endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host" b
- name: $1
	vmware_local_user_manager:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		password: ${4:# The password of the vSphere vCenter.}
		local_user_name: ${5:# The local user name to be changed}
		# local_user_description: ${6:# Description for the user}
		# local_user_password: ${7:# The password to be set}
		# state: ${8:#present|absent}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode" b
- name: $1
	vmware_maintenancemode:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		esxi_hostname: ${4:# Name of the host as defined in vCenter}
		password: ${5:# The password of the vSphere vCenter.}
		# timeout: ${6:0}
		# evacuate: ${7:True|#False}
		# vsan_mode: ${8:ensureObjectAccessibility|evacuateAllData|noAction}
		# state: ${9:#present|absent}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS" b
- name: $1
	vmware_migrate_vmk:
		username: ${2:# The username of the vSphere vCenter.}
		current_switch_name: ${3:# Switch VMK interface is currently on}
		migrate_portgroup_name: ${4:# Portgroup name to migrate VMK interface to}
		current_portgroup_name: ${5:# Portgroup name VMK interface is currently on}
		hostname: ${6:# The hostname or IP address of the vSphere vCenter.}
		esxi_hostname: ${7:# ESXi hostname to be managed}
		device: ${8:# VMK interface name}
		password: ${9:# The password of the vSphere vCenter.}
		migrate_switch_name: ${10:# Switch name to migrate VMK interface to}
		# validate_certs: ${11:#True|False}
$0
endsnippet

snippet vmware_portgroup "Create a VMware portgroup" b
- name: $1
	vmware_portgroup:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# Portgroup name to add}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		switch_name: ${6:# vSwitch to modify}
		vlan_id: ${7:# VLAN ID to assign to portgroup}
		# network_policy: ${8:# Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits. Settings are promiscuous_mode, forged_transmits, mac_changes}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_resource_pool "Add/remove resource pools to/from vCenter" b
- name: $1
	vmware_resource_pool:
		username: ${2:# ESXi username.}
		resource_pool: ${3:# Resource pool name to manage.}
		cluster: ${4:# Name of the cluster to add the host.}
		password: ${5:# ESXi password.}
		datacenter: ${6:# Name of the datacenter to add the host.}
		hostname: ${7:# ESXi hostname to manage.}
		# cpu_reservation: ${8:0}
		# cpu_expandable_reservations: ${9:yes}
		# cpu_limit: ${10:-1 (No limit)}
		# mem_expandable_reservations: ${11:yes}
		# state: ${12:#present|absent}
		# mem_shares: ${13:high|custom|low|normal}
		# mem_limit: ${14:-1 (No limit)}
		# mem_reservation: ${15:0}
		# validate_certs: ${16:#True|False}
		# cpu_shares: ${17:high|custom|low|normal}
$0
endsnippet

snippet vmware_target_canonical_facts "Return canonical (NAA) from an ESXi host" b
- name: $1
	vmware_target_canonical_facts:
		username: ${2:# The username of the vSphere vCenter.}
		target_id: ${3:# The target id based on order of scsi device}
		password: ${4:# The password of the vSphere vCenter.}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		# validate_certs: ${6:#True|False}
$0
endsnippet

snippet vmware_vm_facts "Return basic facts pertaining to a vSphere virtual machine guest" b
- name: $1
	vmware_vm_facts:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		# validate_certs: ${5:#True|False}
$0
endsnippet

snippet vmware_vm_shell "Execute a process in VM" b
- name: $1
	vmware_vm_shell:
		username: ${2:# The username of the vSphere vCenter.}
		vm_id: ${3:# The identification for the VM}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		vm_shell: ${5:# The absolute path to the program to start. On Linux this is executed via bash.}
		password: ${6:# The password of the vSphere vCenter.}
		# datacenter: ${7:# The datacenter hosting the VM}
		# vm_password: ${8:# The password used to login to the VM.}
		# vm_shell_cwd: ${9:# The current working directory of the application from which it will be run}
		# vm_shell_args: ${10:# The argument to the program.}
		# vm_username: ${11:# The user to connect to the VM.}
		# vm_shell_env: ${12:# Comma separated list of envirnoment variable, specified in the guest OS notation}
		# cluster: ${13:# The cluster hosting the VM}
		# vm_id_type: ${14:uuid|dns_name|inventory_path|#vm_name}
		# folder: ${15:/vm}
		# validate_certs: ${16:#True|False}
$0
endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed" b
- name: $1
	vmware_vm_vss_dvs_migrate:
		username: ${2:# The username of the vSphere vCenter.}
		vm_name: ${3:# Name of the virtual machine to migrate to a dvSwitch}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		dvportgroup_name: ${5:# Name of the portgroup to migrate to the virtual machine to}
		password: ${6:# The password of the vSphere vCenter.}
		# validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_vmkernel "Create a VMware VMkernel Interface" b
- name: $1
	vmware_vmkernel:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# The name of the portgroup for the VMK interface}
		vland_id: ${4:# The VLAN ID for the VMK interface}
		vswitch_name: ${5:# The name of the vswitch where to add the VMK interface}
		ip_address: ${6:# The IP Address for the VMK interface}
		hostname: ${7:# The hostname or IP address of the vSphere vCenter.}
		subnet_mask: ${8:# The Subnet Mask for the VMK interface}
		password: ${9:# The password of the vSphere vCenter.}
		# enable_vmotion: ${10:# Enable the VMK interface for vMotion traffic}
		# enable_mgmt: ${11:# Enable the VMK interface for Management traffic}
		# mtu: ${12:# The MTU for the VMK interface}
		# enable_vsan: ${13:# Enable the VMK interface for VSAN traffic}
		# validate_certs: ${14:#True|False}
		# enable_ft: ${15:# Enable the VMK interface for Fault Tolerance traffic}
$0
endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address" b
- name: $1
	vmware_vmkernel_ip_config:
		username: ${2:# The username of the vSphere vCenter.}
		subnet_mask: ${3:# Subnet Mask to assign to VMkernel interface}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		vmk_name: ${5:# VMkernel interface name}
		ip_address: ${6:# IP address to assign to VMkernel interface}
		password: ${7:# The password of the vSphere vCenter.}
		# validate_certs: ${8:#True|False}
$0
endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion" b
- name: $1
	vmware_vmotion:
		username: ${2:# The username of the vSphere vCenter.}
		vm_name: ${3:# Name of the VM to perform a vMotion on}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		destination_host: ${6:# Name of the end host the VM should be running on}
		# validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host" b
- name: $1
	vmware_vsan_cluster:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		# cluster_uuid: ${5:# Desired cluster UUID}
		# validate_certs: ${6:#True|False}
$0
endsnippet

snippet vmware_vswitch "Add or remove a VMware Standard Switch to an ESXi host" b
- name: $1
	vmware_vswitch:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		switch: ${4:# vSwitch name to add.}
		password: ${5:# The password of the vSphere vCenter.}
		# number_of_ports: ${6:128}
		# nics: ${7:# A list of vmnic names or vmnic name to attach to vSwitch.}
		# state: ${8:absent|#present}
		# mtu: ${9:# MTU to configure on vSwitch.}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet vsphere_copy "Copy a file to a vCenter datastore" b
- name: $1
	vsphere_copy:
		src: ${2:# The file to push to vCenter}
		datacenter: ${3:# The datacenter on the vCenter server that holds the datastore.}
		host: ${4:# The vCenter server on which the datastore is available.}
		path: ${5:# The file to push to the datastore on the vCenter server.}
		login: ${6:# The login name to authenticate on the vCenter server.}
		password: ${7:# The password to authenticate on the vCenter server.}
		datastore: ${8:# The datastore on the vCenter server to push files to.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet vsphere_guest "Create/delete/manage a guest VM through VMware vSphere." b
- name: $1
	vsphere_guest:
		username: ${2:# Username to connect to vcenter as.}
		vcenter_hostname: ${3:# The hostname of the vcenter server the module will connect to, to create the guest.}
		password: ${4:# Password of the user to connect to vcenter as.}
		guest: ${5:# The virtual server name you wish to manage.}
		# resource_pool: ${6:# The name of the resource_pool to create the VM in.}
		# force: ${7:yes|#no}
		# vm_disk: ${8:# A key, value list of disks and their sizes and which datastore to keep it in.}
		# vm_hw_version: ${9:# Desired hardware version identifier (for example, "vmx-08" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported.}
		# cluster: ${10:# The name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on.}
		# vmware_guest_facts: ${11:# Gather facts from vCenter on a particular VM}
		# vm_extra_config: ${12:# A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM.}
		# template_src: ${13:# Name of the source template to deploy from}
		# power_on_after_clone: ${14:yes|no}
		# vm_nic: ${15:# A key, value list of nics, their types and what network to put them on.}
		# esxi: ${16:# Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha-datacenter should be used as the datacenter name}
		# vm_hardware: ${17:# A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi'].}
		# validate_certs: ${18:yes|no}
		# state: ${19:#present|powered_off|absent|powered_on|restarted|reconfigured}
		# from_template: ${20:yes|no}
		# snapshot_to_clone: ${21:none}
$0
endsnippet

snippet webfaction_app "Add or remove applications on a Webfaction host" b
- name: $1
	webfaction_app:
		name: ${2:# The name of the application}
		login_password: ${3:# The webfaction password to use}
		type: ${4:# The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list.}
		login_name: ${5:# The webfaction account to use}
		# port_open: ${6:no}
		# machine: ${7:# The machine name to use (optional for accounts with only one machine)}
		# state: ${8:#present|absent}
		# autostart: ${9:no}
		# extra_info: ${10:# Any extra parameters required by the app}
$0
endsnippet

snippet webfaction_db "Add or remove a database on Webfaction" b
- name: $1
	webfaction_db:
		name: ${2:# The name of the database}
		login_password: ${3:# The webfaction password to use}
		type: ${4:mysql|postgresql}
		login_name: ${5:# The webfaction account to use}
		# machine: ${6:# The machine name to use (optional for accounts with only one machine)}
		# state: ${7:#present|absent}
		# password: ${8:# The password for the new database user.}
$0
endsnippet

snippet webfaction_domain "Add or remove domains and subdomains on Webfaction" b
- name: $1
	webfaction_domain:
		login_name: ${2:# The webfaction account to use}
		name: ${3:# The name of the domain}
		login_password: ${4:# The webfaction password to use}
		# state: ${5:#present|absent}
		# subdomains: ${6:# Any subdomains to create.}
$0
endsnippet

snippet webfaction_mailbox "Add or remove mailboxes on Webfaction" b
- name: $1
	webfaction_mailbox:
		mailbox_password: ${2:# The password for the mailbox}
		login_name: ${3:# The webfaction account to use}
		mailbox_name: ${4:# The name of the mailbox}
		login_password: ${5:# The webfaction password to use}
		# state: ${6:#present|absent}
$0
endsnippet

snippet webfaction_site "Add or remove a website on a Webfaction host" b
- name: $1
	webfaction_site:
		name: ${2:# The name of the website}
		host: ${3:# The webfaction host on which the site should be created.}
		login_password: ${4:# The webfaction password to use}
		login_name: ${5:# The webfaction account to use}
		# subdomains: ${6:# A list of subdomains associated with this site.}
		# state: ${7:#present|absent}
		# https: ${8:True|False}
		# site_apps: ${9:# A mapping of URLs to apps}
$0
endsnippet

snippet consul "Add, modify & delete services within a consul cluster." b
- name: $1
	consul:
		state: ${2:present|absent}
		# service_address: ${3:# the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.}
		# http: ${4:# checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.}
		# tags: ${5:# a list of tags that will be attached to the service registration.}
		# check_name: ${6:# a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.}
		# service_name: ${7:# Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check}
		# host: ${8:localhost}
		# ttl: ${9:# checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m}
		# port: ${10:8500}
		# script: ${11:# the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa}
		# check_id: ${12:# an ID for the service check, defaults to the check name, ignored if part of a service definition.}
		# service_port: ${13:# the port on which the service is listening. Can optionally be supplied for registration of a service, i.e. if service_name or service_id is set}
		# notes: ${14:# Notes to attach to check when registering it.}
		# interval: ${15:# the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.}
		# token: ${16:# the token key indentifying an ACL rule set. May be required to register services.}
		# timeout: ${17:# A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.}
		# service_id: ${18:service_name if supplied}
		# scheme: ${19:http}
		# validate_certs: ${20:yes}
$0
endsnippet

snippet consul_acl "Manipulate Consul ACL keys and rules" b
- name: $1
	consul_acl:
		# name: ${2:# the name that should be associated with the acl key, this is opaque to Consul}
		# rules: ${3:# a list of the rules that should be associated with a given token}
		# state: ${4:#present|absent}
		# token_type: ${5:#client|management}
		# token: ${6:# the token key indentifying an ACL rule set. If generated by consul this will be a UUID}
		# mgmt_token: ${7:# a management token is required to manipulate the acl lists}
		# host: ${8:localhost}
		# scheme: ${9:http}
		# validate_certs: ${10:yes}
		# port: ${11:8500}
$0
endsnippet

snippet consul_kv "Manipulate entries in the key/value store of a consul cluster." b
- name: $1
	consul_kv:
		value: ${2:# the value should be associated with the given key, required if state is present}
		key: ${3:# the key at which the value should be stored.}
		# cas: ${4:# used when acquiring a lock with a session. If the cas is 0, then Consul will only put the key if it does not already exist. If the cas value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.}
		# recurse: ${5:no}
		# token: ${6:# the token key indentifying an ACL rule set that controls access to the key value pair}
		# state: ${7:#present|absent|acquire|release}
		# session: ${8:# the session that should be used to acquire or release a lock associated with a key/value pair}
		# flags: ${9:# opaque integer value that can be passed when setting a value.}
		# host: ${10:localhost}
		# scheme: ${11:http}
		# validate_certs: ${12:yes}
		# port: ${13:8500}
$0
endsnippet

snippet consul_session "manipulate consul sessions" b
- name: $1
	consul_session:
		# node: ${2:# the name of the node that with which the session will be associated. by default this is the name of the agent.}
		# datacenter: ${3:# name of the datacenter in which the session exists or should be created.}
		# name: ${4:# the name that should be associated with the session. This is opaque to Consul and not required.}
		# state: ${5:#present|absent|info|node|list}
		# checks: ${6:# a list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.}
		# delay: ${7:15}
		# host: ${8:localhost}
		# behavior: ${9:release}
		# scheme: ${10:http}
		# validate_certs: ${11:yes}
		# port: ${12:8500}
$0
endsnippet

snippet kubernetes "Manage Kubernetes resources." b
- name: $1
	kubernetes:
		inline_data: ${2:# The Kubernetes YAML data to send to the API I(endpoint). This option is mutually exclusive with C('file_reference').}
		api_endpoint: ${3:# The IPv4 API endpoint of the Kubernetes cluster.}
		state: ${4:#present|absent|update|replace}
		# url_password: ${5:# The HTTP Basic Auth password for the API I(endpoint). This should be set unless using the C('insecure') option.}
		# certificate_authority_data: ${6:# Certificate Authority data for Kubernetes server. Should be in either standard PEM format or base64 encoded PEM data. Note that certificate verification is broken until ansible supports a version of 'match_hostname' that can match the IP address against the CA data.}
		# insecure: ${7:# Reverts the connection to using HTTP instead of HTTPS. This option should only be used when execuing the M('kubernetes') module local to the Kubernetes cluster using the insecure local port (locahost:8080 by default).}
		# file_reference: ${8:# Specify full path to a Kubernets YAML file to send to API I(endpoint). This option is mutually exclusive with C('inline_data').}
		# url_username: ${9:admin}
		# validate_certs: ${10:no}
		# patch_operation: ${11:JSON Patch|Merge Patch|#Strategic Merge Patch}
$0
endsnippet

snippet oc "Manage OpenShift Resources" b
- name: $1
	oc:
		kind: ${2:# T}
		token: ${3:# The token with which to authenticate agains the OpenShift cluster.}
		state: ${4:present|absent}
		# name: ${5:# The name of the resource on which to take action.}
		# namespace: ${6:# The namespace of the resource upon which to take action.}
		# host: ${7:127.0.0.1}
		# inline: ${8:# The inline definition of the resource. This is mutually exclusive with name, namespace and kind.}
		# port: ${9:8443}
$0
endsnippet

snippet pacemaker_cluster "Manage a pacemaker cluster" b
- name: $1
	pacemaker_cluster:
		state: ${2:online|offline|restart|cleanup}
		# node: ${3:# Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.}
		# force: ${4:yes}
		# timeout: ${5:300}
$0
endsnippet

snippet znode "Create, delete, retrieve, and update znodes using ZooKeeper" b
- name: $1
	znode:
		hosts: ${2:# A list of ZooKeeper servers (format '[server]:[port]').}
		name: ${3:# The path of the znode.}
		# state: ${4:# The state to enforce. Mutually exclusive with op.}
		# timeout: ${5:300}
		# op: ${6:# An operation to perform. Mutually exclusive with state.}
		# value: ${7:# The value assigned to the znode.}
		# recursive: ${8:no}
$0
endsnippet

snippet command "Executes a command on a remote node" b
- name: $1
	command: $2
	args:
		# warn: ${3:yes}
		# creates: ${4:# A filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.}
		# chdir: ${5:# Change into this directory before running the command.}
		# stdin: ${6:# Set the stdin of the command directly to the specified value.}
		# removes: ${7:# A filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.}
$0
endsnippet

snippet expect "Executes a command and responds to prompts." b
- name: $1
	expect:
		command: ${2:# The command module takes command to run.}
		responses: ${3:# Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.}
		# creates: ${4:# A filename, when it already exists, this step will B(not) be run.}
		# chdir: ${5:# Change into this directory before running the command.}
		# timeout: ${6:30}
		# removes: ${7:# A filename, when it does not exist, this step will B(not) be run.}
		# echo: ${8:no}
$0
endsnippet

snippet raw "Executes a low-down and dirty SSH command" b
- name: $1
	raw: $2
	args:
		# executable: ${3:# change the shell used to execute the command. Should be an absolute path to the executable.}
$0
endsnippet

snippet script "Runs a local script on a remote node after transferring it" b
- name: $1
	script: $2
	args:
		# creates: ${3:# a filename, when it already exists, this step will B(not) be run.}
		# removes: ${4:# a filename, when it does not exist, this step will B(not) be run.}
		# chdir: ${5:# cd into this directory on the remote node before running the script}
		# decrypt: ${6:Yes}
$0
endsnippet

snippet shell "Execute commands in nodes." b
- name: $1
	shell: $2
	args:
		# warn: ${3:yes}
		# creates: ${4:# a filename, when it already exists, this step will B(not) be run.}
		# executable: ${5:# change the shell used to execute the command. Should be an absolute path to the executable.}
		# chdir: ${6:# cd into this directory before running the command}
		# stdin: ${7:# Set the stdin of the command directly to the specified value.}
		# removes: ${8:# a filename, when it does not exist, this step will B(not) be run.}
$0
endsnippet

snippet telnet "Executes a low-down and dirty telnet command" b
- name: $1
	telnet:
		commands: ${2:# List of commands to be executed in the telnet session.}
		# pause: ${3:1}
		# host: ${4:remote_addr}
		# prompts: ${5:[u'$']}
		# user: ${6:remote_user}
		# timeout: ${7:120}
		# password: ${8:# The password for login}
		# port: ${9:23}
$0
endsnippet

snippet openssl_certificate "Generate and/or check OpenSSL certificates" b
- name: $1
	openssl_certificate:
		path: ${2:# Remote absolute path where the generated certificate file should be created or is already located.}
		provider: ${3:selfsigned|assertonly|acme}
		# privatekey_passphrase: ${4:# The passphrase for the I(privatekey_path).}
		# subject_alt_name_strict: ${5:no}
		# force: ${6:no}
		# csr_path: ${7:# Path to the Certificate Signing Request (CSR) used to generate this certificate. This is not required in C(assertonly) mode.}
		# extended_key_usage: ${8:# The I(extended_key_usage) extension field must contain all these values.}
		# selfsigned_not_after: ${9:# The timestamp at which the certificate stops being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will stop being valid 10 years from now.}
		# extended_key_usage_strict: ${10:no}
		# acme_challenge_path: ${11:# Path to the ACME challenge directory that is served on U(http://<HOST>:80/.well-known/acme-challenge/)}
		# privatekey_path: ${12:# Path to the private key to use when signing the certificate.}
		# key_usage_strict: ${13:no}
		# key_usage: ${14:# The I(key_usage) extension field must contain all these values.}
		# invalid_at: ${15:# The certificate must be invalid at this point in time. The timestamp is formatted as an ASN.1 TIME.}
		# acme_accountkey: ${16:# Path to the accountkey for the C(acme) provider}
		# not_before: ${17:# The certificate must start to become valid at this point in time. The timestamp is formatted as an ASN.1 TIME.}
		# subject: ${18:# Key/value pairs that must be present in the subject name field of the certificate}
		# selfsigned_not_before: ${19:# The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.}
		# selfsigned_version: ${20:3}
		# subject_alt_name: ${21:# The I(subject_alt_name) extension field must contain these values.}
		# not_after: ${22:# The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME.}
		# signature_algorithms: ${23:# list of algorithms that you would accept the certificate to be signed with (e.g. ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']).}
		# has_expired: ${24:no}
		# state: ${25:#present|absent}
		# version: ${26:# Version of the certificate. Nowadays it should almost always be 3.}
		# selfsigned_digest: ${27:sha256}
		# issuer: ${28:# Key/value pairs that must be present in the issuer name field of the certificate}
		# valid_in: ${29:# The certificate must still be valid in I(valid_in) seconds from now.}
		# valid_at: ${30:# The certificate must be valid at this point in time. The timestamp is formatted as an ASN.1 TIME.}
$0
endsnippet

snippet openssl_csr "Generate OpenSSL Certificate Signing Request (CSR)" b
- name: $1
	openssl_csr:
		privatekey_path: ${2:# Path to the privatekey to use when signing the certificate signing request}
		path: ${3:# Name of the folder in which the generated OpenSSL certificate signing request will be written}
		# privatekey_passphrase: ${4:# The passphrase for the privatekey.}
		# state_or_province_name: ${5:# stateOrProvinceName field of the certificate signing request subject}
		# extended_key_usage_critical: ${6:# Should the extkeyUsage extension be considered as critical}
		# force: ${7:True|#False}
		# subject_alt_name: ${8:# SAN extension to attach to the certificate signing request}
		# subject_alt_name_critical: ${9:# Should the subjectAltName extension be considered as critical}
		# key_usage: ${10:# This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.}
		# common_name: ${11:# commonName field of the certificate signing request subject}
		# email_address: ${12:# emailAddress field of the certificate signing request subject}
		# digest: ${13:sha256}
		# key_usage_critical: ${14:# Should the keyUsage extension be considered as critical}
		# extended_key_usage: ${15:# Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.}
		# organizational_unit_name: ${16:# organizationalUnitName field of the certificate signing request subject}
		# locality_name: ${17:# localityName field of the certificate signing request subject}
		# organization_name: ${18:# organizationName field of the certificate signing request subject}
		# state: ${19:#present|absent}
		# version: ${20:1}
		# country_name: ${21:# countryName field of the certificate signing request subject}
$0
endsnippet

snippet openssl_privatekey "Generate OpenSSL private keys." b
- name: $1
	openssl_privatekey:
		path: ${2:# Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.}
		# state: ${3:#present|absent}
		# cipher: ${4:# The cipher to encrypt the private key. (cipher can be found by running `openssl list-cipher-algorithms`)}
		# force: ${5:True|#False}
		# passphrase: ${6:# The passphrase for the private key.}
		# type: ${7:#RSA|DSA}
		# size: ${8:4096}
$0
endsnippet

snippet openssl_publickey "Generate an OpenSSL public key from its private key." b
- name: $1
	openssl_publickey:
		path: ${2:# Name of the file in which the generated TLS/SSL public key will be written.}
		privatekey_path: ${3:# Path to the TLS/SSL private key from which to generate the public key.}
		# privatekey_passphrase: ${4:# The passphrase for the privatekey.}
		# state: ${5:#present|absent}
		# force: ${6:True|#False}
		# format: ${7:#PEM|OpenSSH}
$0
endsnippet

snippet influxdb_database "Manage InfluxDB databases" b
- name: $1
	influxdb_database:
		database_name: ${2:# Name of the database that will be created/destroyed}
		hostname: ${3:# The hostname or IP address on which InfluxDB server is listening}
		# username: ${4:root}
		# state: ${5:#present|absent}
		# password: ${6:root}
		# port: ${7:8086}
$0
endsnippet

snippet influxdb_retention_policy "Manage InfluxDB retention policies" b
- name: $1
	influxdb_retention_policy:
		default: ${2:# Sets the retention policy as default retention policy}
		database_name: ${3:# Name of the database where retention policy will be created}
		hostname: ${4:# The hostname or IP address on which InfluxDB server is listening}
		policy_name: ${5:# Name of the retention policy}
		replication: ${6:# Determines how many independent copies of each point are stored in the cluster}
		duration: ${7:# Determines how long InfluxDB should keep the data}
		# username: ${8:root}
		# password: ${9:root}
		# port: ${10:8086}
$0
endsnippet

snippet elasticsearch_plugin "Manage Elasticsearch plugins" b
- name: $1
	elasticsearch_plugin:
		name: ${2:# Name of the plugin to install. In Eleasticsearch >= 2.0, the name can be an URL or file location.}
		# proxy_host: ${3:# Proxy host to use during plugin installation}
		# url: ${4:# Set exact URL to download the plugin from (Only works for ES 1.x)}
		# proxy_port: ${5:# Proxy port to use during plugin installation}
		# state: ${6:#present|absent}
		# version: ${7:# Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated}
		# timeout: ${8:1m}
		# plugin_dir: ${9:/usr/share/elasticsearch/plugins/}
		# plugin_bin: ${10:# Location of the plugin binary. If this file is not found, the default plugin binaries will be used.}
$0
endsnippet

snippet kibana_plugin "Manage Kibana plugins" b
- name: $1
	kibana_plugin:
		name: ${2:# Name of the plugin to install}
		# force: ${3:yes|no}
		# url: ${4:# Set exact URL to download the plugin from. For local file, prefix its absolute path with file://}
		# state: ${5:#present|absent}
		# version: ${6:# Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes}
		# timeout: ${7:1m}
		# plugin_dir: ${8:/opt/kibana/installedPlugins/}
		# plugin_bin: ${9:/opt/kibana/bin/kibana}
$0
endsnippet

snippet redis "Various redis commands, slave and flush" b
- name: $1
	redis:
		command: ${2:slave|flush|config}
		# login_port: ${3:6379}
		# name: ${4:# A redis config key.}
		# flush_mode: ${5:#all|db}
		# master_host: ${6:# The host of the master instance [slave command]}
		# login_host: ${7:localhost}
		# master_port: ${8:# The port of the master instance [slave command]}
		# db: ${9:# The database to flush (used in db mode) [flush command]}
		# value: ${10:# A redis config value.}
		# login_password: ${11:# The password used to authenticate with (usually not used)}
		# slave_mode: ${12:master|#slave}
$0
endsnippet

snippet riak "This module handles some common Riak operations" b
- name: $1
	riak:
		# target_node: ${2:riak@127.0.0.1}
		# config_dir: ${3:/etc/riak}
		# wait_for_service: ${4:kv}
		# http_conn: ${5:127.0.0.1:8098}
		# wait_for_ring: ${6:# Number of seconds to wait for all nodes to agree on the ring.}
		# wait_for_handoffs: ${7:# Number of seconds to wait for handoffs to complete.}
		# command: ${8:ping|kv_test|join|plan|commit}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet mongodb_parameter "Change an administrative parameter on a MongoDB server." b
- name: $1
	mongodb_parameter:
		database: ${2:# The name of the database to add/remove the user from}
		param: ${3:# MongoDB administrative parameter to modify}
		value: ${4:# MongoDB administrative parameter value to set}
		# login_port: ${5:27017}
		# login_user: ${6:# The username used to authenticate with}
		# login_host: ${7:localhost}
		# login_database: ${8:# The database where login credentials are stored}
		# ssl: ${9:no}
		# param_type: ${10:str}
		# login_password: ${11:# The password used to authenticate with}
		# replica_set: ${12:# Replica set to connect to (automatically connects to primary for writes)}
$0
endsnippet

snippet mongodb_user "Adds or removes a user from a MongoDB database." b
- name: $1
	mongodb_user:
		name: ${2:# The name of the user to add or remove}
		database: ${3:# The name of the database to add/remove the user from}
		# login_port: ${4:27017}
		# update_password: ${5:#always|on_create}
		# roles: ${6:readWrite}
		# login_user: ${7:# The username used to authenticate with}
		# login_host: ${8:localhost}
		# login_database: ${9:# The database where login credentials are stored}
		# ssl_cert_reqs: ${10:#CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE}
		# ssl: ${11:no}
		# state: ${12:#present|absent}
		# login_password: ${13:# The password used to authenticate with}
		# password: ${14:# The password to use for the user}
		# replica_set: ${15:# Replica set to connect to (automatically connects to primary for writes)}
$0
endsnippet

snippet mssql_db "Add or remove MSSQL databases from a remote host." b
- name: $1
	mssql_db:
		name: ${2:# name of the database to add or remove}
		# autocommit: ${3:false|true}
		# login_port: ${4:1433}
		# login_user: ${5:# The username used to authenticate with}
		# login_host: ${6:# Host running the database}
		# state: ${7:#present|absent|import}
		# login_password: ${8:# The password used to authenticate with}
		# target: ${9:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.}
$0
endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host." b
- name: $1
	mysql_db:
		name: ${2:# name of the database to add or remove}
		# login_port: ${3:3306}
		# ssl_cert: ${4:# The path to a client public key certificate.}
		# config_file: ${5:~/.my.cnf}
		# target: ${6:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.}
		# ssl_key: ${7:# The path to the client private key.}
		# login_user: ${8:# The username used to authenticate with.}
		# login_host: ${9:localhost}
		# encoding: ${10:# Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)}
		# ssl_ca: ${11:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		# login_unix_socket: ${12:# The path to a Unix domain socket for local connections.}
		# state: ${13:#present|absent|dump|import}
		# login_password: ${14:# The password used to authenticate with.}
		# collation: ${15:# Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.}
		# quick: ${16:yes}
		# connect_timeout: ${17:30}
		# single_transaction: ${18:no}
$0
endsnippet

snippet mysql_replication "Manage MySQL replication" b
- name: $1
	mysql_replication:
		# ssl_key: ${2:# The path to the client private key.}
		# master_auto_position: ${3:# does the host uses GTID based replication or not}
		# config_file: ${4:~/.my.cnf}
		# master_ssl_cert: ${5:# same as mysql variable}
		# login_user: ${6:# The username used to authenticate with.}
		# login_host: ${7:localhost}
		# master_port: ${8:# same as mysql variable}
		# master_host: ${9:# same as mysql variable}
		# master_ssl_ca: ${10:# same as mysql variable}
		# login_unix_socket: ${11:# The path to a Unix domain socket for local connections.}
		# master_connect_retry: ${12:# same as mysql variable}
		# master_user: ${13:# same as mysql variable}
		# login_password: ${14:# The password used to authenticate with.}
		# master_log_file: ${15:# same as mysql variable}
		# master_ssl_cipher: ${16:# same as mysql variable}
		# master_password: ${17:# same as mysql variable}
		# relay_log_file: ${18:# same as mysql variable}
		# login_port: ${19:3306}
		# ssl_cert: ${20:# The path to a client public key certificate.}
		# master_ssl: ${21:0|1}
		# ssl_ca: ${22:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		# master_ssl_key: ${23:# same as mysql variable}
		# master_ssl_capath: ${24:# same as mysql variable}
		# mode: ${25:#getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall}
		# master_log_pos: ${26:# same as mysql variable}
		# connect_timeout: ${27:30}
		# relay_log_pos: ${28:# same as mysql variable}
$0
endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database." b
- name: $1
	mysql_user:
		name: ${2:# name of the user (role) to add or remove}
		# login_port: ${3:3306}
		# update_password: ${4:#always|on_create}
		# ssl_cert: ${5:# The path to a client public key certificate.}
		# config_file: ${6:~/.my.cnf}
		# ssl_key: ${7:# The path to the client private key.}
		# login_user: ${8:# The username used to authenticate with.}
		# login_host: ${9:localhost}
		# append_privs: ${10:yes|#no}
		# state: ${11:#present|absent}
		# host_all: ${12:yes|#no}
		# ssl_ca: ${13:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		# login_unix_socket: ${14:# The path to a Unix domain socket for local connections.}
		# sql_log_bin: ${15:#yes|no}
		# encrypted: ${16:yes|#no}
		# login_password: ${17:# The password used to authenticate with.}
		# host: ${18:localhost}
		# check_implicit_admin: ${19:yes|#no}
		# password: ${20:# set the user's password.}
		# connect_timeout: ${21:30}
		# priv: ${22:# MySQL privileges string in the format: C(db.table:priv1,priv2).}
$0
endsnippet

snippet mysql_variables "Manage MySQL global variables" b
- name: $1
	mysql_variables:
		variable: ${2:# Variable name to operate}
		# login_port: ${3:3306}
		# ssl_cert: ${4:# The path to a client public key certificate.}
		# config_file: ${5:~/.my.cnf}
		# ssl_key: ${6:# The path to the client private key.}
		# login_user: ${7:# The username used to authenticate with.}
		# login_host: ${8:localhost}
		# value: ${9:# If set, then sets variable value to this}
		# ssl_ca: ${10:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		# login_unix_socket: ${11:# The path to a Unix domain socket for local connections.}
		# login_password: ${12:# The password used to authenticate with.}
		# connect_timeout: ${13:30}
$0
endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host." b
- name: $1
	postgresql_db:
		name: ${2:# name of the database to add or remove}
		# ssl_rootcert: ${3:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
		# ssl_mode: ${4:disable|allow|#prefer|require|verify-ca|verify-full}
		# encoding: ${5:# Encoding of the database}
		# login_user: ${6:postgres}
		# login_host: ${7:# Host running the database}
		# login_unix_socket: ${8:# Path to a Unix domain socket for local connections}
		# login_password: ${9:# The password used to authenticate with}
		# owner: ${10:# Name of the role to set as owner of the database}
		# port: ${11:5432}
		# target: ${12:# File to back up or restore from. Used when state is "dump" or "restore"}
		# target_opts: ${13:# Further arguments for pg_dump or pg_restore. Used when state is "dump" or "restore"}
		# lc_ctype: ${14:# Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.}
		# state: ${15:#present|absent|dump|restore}
		# template: ${16:# Template used to create the database}
		# lc_collate: ${17:# Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.}
$0
endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database." b
- name: $1
	postgresql_ext:
		name: ${2:# name of the extension to add or remove}
		db: ${3:# name of the database to add or remove the extension to/from}
		# state: ${4:#present|absent}
		# login_password: ${5:# The password used to authenticate with}
		# login_user: ${6:# The username used to authenticate with}
		# login_host: ${7:localhost}
		# port: ${8:5432}
$0
endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database." b
- name: $1
	postgresql_lang:
		lang: ${2:# name of the procedural language to add, remove or change}
		# force_trust: ${3:yes|no}
		# login_user: ${4:postgres}
		# login_host: ${5:localhost}
		# db: ${6:# name of database where the language will be added, removed or changed}
		# cascade: ${7:yes|no}
		# state: ${8:#present|absent}
		# login_password: ${9:# Password used to authenticate with PostgreSQL (must match C(login_user))}
		# trust: ${10:yes|no}
		# fail_on_drop: ${11:#yes|no}
		# port: ${12:5432}
$0
endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects." b
- name: $1
	postgresql_privs:
		roles: ${2:# Comma separated list of role (user/group) names to set permissions for.}
		database: ${3:# Name of database to connect to.}
		# objs: ${4:# Comma separated list of database objects to set privileges on.}
		# ssl_rootcert: ${5:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
		# ssl_mode: ${6:disable|allow|#prefer|require|verify-ca|verify-full}
		# privs: ${7:# Comma separated list of privileges to grant/revoke.}
		# state: ${8:#present|absent}
		# unix_socket: ${9:# Path to a Unix domain socket for local connections.}
		# host: ${10:# Database host address. If unspecified, connect via Unix socket.}
		# login: ${11:postgres}
		# password: ${12:# The password to authenticate with.}
		# type: ${13:#table|sequence|function|database|schema|language|tablespace|group}
		# port: ${14:5432}
		# grant_option: ${15:yes|no}
		# schema: ${16:# Schema that contains the database objects specified via I(objs).}
$0
endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema from a remote host" b
- name: $1
	postgresql_schema:
		name: ${2:# Name of the schema to add or remove.}
		# database: ${3:postgres}
		# login_user: ${4:# The username used to authenticate with.}
		# login_host: ${5:localhost}
		# login_unix_socket: ${6:# Path to a Unix domain socket for local connections.}
		# state: ${7:#present|absent}
		# login_password: ${8:# The password used to authenticate with.}
		# owner: ${9:# Name of the role to set as owner of the schema.}
		# port: ${10:5432}
$0
endsnippet

snippet postgresql_user "Adds or removes a users (roles) from a PostgreSQL database." b
- name: $1
	postgresql_user:
		name: ${2:# name of the user (role) to add or remove}
		# ssl_rootcert: ${3:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
		# ssl_mode: ${4:disable|allow|#prefer|require|verify-ca|verify-full}
		# login_user: ${5:postgres}
		# login_host: ${6:localhost}
		# expires: ${7:# sets the user's password expiration.}
		# db: ${8:# name of database where permissions will be granted}
		# conn_limit: ${9:# Specifies the user connection limit.}
		# login_unix_socket: ${10:# Path to a Unix domain socket for local connections}
		# login_password: ${11:# Password used to authenticate with PostgreSQL}
		# password: ${12:# set the user's password, before 1.4 this was required.}
		# port: ${13:5432}
		# fail_on_user: ${14:#yes|no}
		# priv: ${15:# PostgreSQL privileges string in the format: C(table:priv1,priv2)}
		# no_password_changes: ${16:yes|#no}
		# state: ${17:#present|absent}
		# encrypted: ${18:no}
		# role_attr_flags: ${19:[NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEUSER|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION|[NO]BYPASSRLS}
$0
endsnippet

snippet proxysql_backend_servers "Adds or removes mysql hosts from proxysql admin interface." b
- name: $1
	proxysql_backend_servers:
		hostname: ${2:# The ip address at which the mysqld instance can be contacted.}
		# status: ${3:ONLINE|OFFLINE_SOFT|OFFLINE_HARD}
		# comment: ${4:}
		# config_file: ${5:}
		# weight: ${6:# The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.}
		# login_user: ${7:# The username used to authenticate to ProxySQL admin interface.}
		# login_host: ${8:127.0.0.1}
		# save_to_disk: ${9:yes}
		# load_to_runtime: ${10:yes}
		# login_password: ${11:# The password used to authenticate to ProxySQL admin interface.}
		# use_ssl: ${12:# If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
		# port: ${13:3306}
		# max_connections: ${14:# The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.}
		# login_port: ${15:6032}
		# compression: ${16:# If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.}
		# hostgroup_id: ${17:0}
		# state: ${18:#present|absent}
		# max_latency_ms: ${19:# Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.}
		# max_replication_lag: ${20:# If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.}
$0
endsnippet

snippet proxysql_global_variables "Gets or sets the proxysql global variables." b
- name: $1
	proxysql_global_variables:
		variable: ${2:# Defines which variable should be returned, or if I(value) is specified which variable should be updated.}
		# login_port: ${3:6032}
		# config_file: ${4:}
		# login_user: ${5:# The username used to authenticate to ProxySQL admin interface.}
		# login_host: ${6:127.0.0.1}
		# login_password: ${7:# The password used to authenticate to ProxySQL admin interface.}
		# value: ${8:# Defines a value the variable specified using I(variable) should be set to.}
		# load_to_runtime: ${9:yes}
		# save_to_disk: ${10:yes}
$0
endsnippet

snippet proxysql_manage_config "Writes the proxysql configuration settings between layers." b
- name: $1
	proxysql_manage_config:
		direction: ${2:FROM|TO}
		config_settings: ${3:MYSQL USERS|MYSQL SERVERS|MYSQL QUERY RULES|MYSQL VARIABLES|ADMIN VARIABLES|SCHEDULER}
		action: ${4:LOAD|SAVE}
		config_layer: ${5:MEMORY|DISK|RUNTIME|CONFIG}
		# login_port: ${6:6032}
		# config_file: ${7:}
		# login_user: ${8:# The username used to authenticate to ProxySQL admin interface.}
		# login_host: ${9:127.0.0.1}
		# login_password: ${10:# The password used to authenticate to ProxySQL admin interface.}
$0
endsnippet

snippet proxysql_mysql_users "Adds or removes mysql users from proxysql admin interface." b
- name: $1
	proxysql_mysql_users:
		username: ${2:# Name of the user connecting to the mysqld or ProxySQL instance.}
		# default_hostgroup: ${3:# If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.}
		# frontend: ${4:yes}
		# default_schema: ${5:# The schema to which the connection should change to by default.}
		# login_user: ${6:# The username used to authenticate to ProxySQL admin interface.}
		# login_host: ${7:127.0.0.1}
		# save_to_disk: ${8:yes}
		# fast_forward: ${9:# If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).}
		# load_to_runtime: ${10:yes}
		# login_password: ${11:# The password used to authenticate to ProxySQL admin interface.}
		# active: ${12:# A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).}
		# config_file: ${13:}
		# password: ${14:# Password of the user connecting to the mysqld or ProxySQL instance.}
		# max_connections: ${15:# The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.}
		# login_port: ${16:6032}
		# transaction_persistent: ${17:# If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).}
		# state: ${18:#present|absent}
		# use_ssl: ${19:# If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
		# backend: ${20:yes}
$0
endsnippet

snippet proxysql_query_rules "Modifies query rules using the proxysql admin interface." b
- name: $1
	proxysql_query_rules:
		# comment: ${2:# Free form text field, usable for a descriptive comment of the query rule.}
		# flagOUT: ${3:# Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.}
		# login_user: ${4:# The username used to authenticate to ProxySQL admin interface.}
		# save_to_disk: ${5:yes}
		# match_pattern: ${6:# Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
		# mirror_flagOUT: ${7:# Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.}
		# apply: ${8:# Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.}
		# schemaname: ${9:# Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.}
		# replace_pattern: ${10:# This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.}
		# digest: ${11:# Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.}
		# match_digest: ${12:# Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
		# mirror_hostgroup: ${13:# Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.}
		# log: ${14:# Query will be logged.}
		# delay: ${15:# Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.}
		# state: ${16:#present|absent}
		# proxy_addr: ${17:# Match incoming traffic on a specific local IP.}
		# username: ${18:# Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.}
		# config_file: ${19:}
		# retries: ${20:# The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.}
		# login_host: ${21:127.0.0.1}
		# destination_hostgroup: ${22:# Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).}
		# proxy_port: ${23:# Match incoming traffic on a specific local port.}
		# load_to_runtime: ${24:yes}
		# login_password: ${25:# The password used to authenticate to ProxySQL admin interface.}
		# active: ${26:# A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.}
		# cache_ttl: ${27:# The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.}
		# error_msg: ${28:# Query will be blocked, and the specified error_msg will be returned to the client.}
		# login_port: ${29:6032}
		# negate_match_pattern: ${30:# If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.}
		# flagIN: ${31:# Used in combination with I(flagOUT) and I(apply) to create chains of rules.}
		# client_addr: ${32:# Match traffic from a specific source.}
		# timeout: ${33:# The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.}
		# force_delete: ${34:no}
		# rule_id: ${35:# The unique id of the rule. Rules are processed in rule_id order.}
$0
endsnippet

snippet proxysql_replication_hostgroups "Manages replication hostgroups using the proxysql admin interface." b
- name: $1
	proxysql_replication_hostgroups:
		reader_hostgroup: ${2:# Id of the reader hostgroup.}
		writer_hostgroup: ${3:# Id of the writer hostgroup.}
		# comment: ${4:# Text field that can be used for any purposed defined by the user.}
		# login_port: ${5:6032}
		# config_file: ${6:}
		# login_user: ${7:# The username used to authenticate to ProxySQL admin interface.}
		# login_host: ${8:127.0.0.1}
		# save_to_disk: ${9:yes}
		# state: ${10:#present|absent}
		# load_to_runtime: ${11:yes}
		# login_password: ${12:# The password used to authenticate to ProxySQL admin interface.}
$0
endsnippet

snippet proxysql_scheduler "Adds or removes schedules from proxysql admin interface." b
- name: $1
	proxysql_scheduler:
		filename: ${2:# Full path of the executable to be executed.}
		# comment: ${3:# Text field that can be used for any purposed defined by the user.}
		# config_file: ${4:}
		# login_user: ${5:# The username used to authenticate to ProxySQL admin interface.}
		# arg2: ${6:# Argument that can be passed to the job.}
		# arg3: ${7:# Argument that can be passed to the job.}
		# arg4: ${8:# Argument that can be passed to the job.}
		# arg5: ${9:# Argument that can be passed to the job.}
		# interval_ms: ${10:10000}
		# load_to_runtime: ${11:yes}
		# login_password: ${12:# The password used to authenticate to ProxySQL admin interface.}
		# active: ${13:yes}
		# login_port: ${14:6032}
		# force_delete: ${15:no}
		# save_to_disk: ${16:yes}
		# state: ${17:#present|absent}
		# arg1: ${18:# Argument that can be passed to the job.}
		# login_host: ${19:127.0.0.1}
$0
endsnippet

snippet vertica_configuration "Updates Vertica configuration parameters." b
- name: $1
	vertica_configuration:
		name: ${2:# Name of the parameter to update.}
		value: ${3:# Value of the parameter to be set.}
		# cluster: ${4:localhost}
		# login_password: ${5:# The password used to authenticate with.}
		# login_user: ${6:dbadmin}
		# db: ${7:# Name of the Vertica database.}
		# port: ${8:5433}
$0
endsnippet

snippet vertica_facts "Gathers Vertica database facts." b
- name: $1
	vertica_facts:
		# login_user: ${2:dbadmin}
		# cluster: ${3:localhost}
		# db: ${4:# Name of the database running the schema.}
		# port: ${5:5433}
		# login_password: ${6:# The password used to authenticate with.}
$0
endsnippet

snippet vertica_role "Adds or removes Vertica database roles and assigns roles to them." b
- name: $1
	vertica_role:
		name: ${2:# Name of the role to add or remove.}
		# assigned_roles: ${3:# Comma separated list of roles to assign to the role.}
		# login_user: ${4:dbadmin}
		# db: ${5:# Name of the Vertica database.}
		# cluster: ${6:localhost}
		# state: ${7:#present|absent}
		# login_password: ${8:# The password used to authenticate with.}
		# port: ${9:5433}
$0
endsnippet

snippet vertica_schema "Adds or removes Vertica database schema and roles." b
- name: $1
	vertica_schema:
		name: ${2:# Name of the schema to add or remove.}
		# create_roles: ${3:# Comma separated list of roles to create and grant usage and create access to the schema.}
		# login_user: ${4:dbadmin}
		# db: ${5:# Name of the Vertica database.}
		# usage_roles: ${6:# Comma separated list of roles to create and grant usage access to the schema.}
		# cluster: ${7:localhost}
		# state: ${8:#present|absent}
		# login_password: ${9:# The password used to authenticate with.}
		# owner: ${10:# Name of the user to set as owner of the schema.}
		# port: ${11:5433}
$0
endsnippet

snippet vertica_user "Adds or removes Vertica database users and assigns roles." b
- name: $1
	vertica_user:
		name: ${2:# Name of the user to add or remove.}
		# profile: ${3:# Sets the user's profile.}
		# resource_pool: ${4:# Sets the user's resource pool.}
		# roles: ${5:# Comma separated list of roles to assign to the user.}
		# login_user: ${6:dbadmin}
		# ldap: ${7:# Set to true if users are authenticated via LDAP.}
		# db: ${8:# Name of the Vertica database.}
		# cluster: ${9:localhost}
		# state: ${10:#present|absent|locked}
		# login_password: ${11:# The password used to authenticate with.}
		# password: ${12:# The user's password encrypted by the MD5 algorithm.}
		# expired: ${13:# Sets the user's password expiration.}
		# port: ${14:5433}
$0
endsnippet

snippet acl "Sets and retrieves file ACL information." b
- name: $1
	acl:
		path: ${2:# The full path of the file or object.}
		# recursive: ${3:yes|no}
		# default: ${4:yes|no}
		# entity: ${5:# actual user or group that the ACL applies to when matching entity types user or group are selected.}
		# state: ${6:#query|present|absent}
		# follow: ${7:yes|no}
		# etype: ${8:user|group|mask|other}
		# entry: ${9:# DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '<etype>:<qualifier>:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields.}
		# permissions: ${10:# Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)}
$0
endsnippet

snippet archive "Creates a compressed archive of one or more files or trees." b
- name: $1
	archive:
		path: ${2:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}
		# group: ${3:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# format: ${4:#gz|bz2|zip}
		# unsafe_writes: ${5:no}
		# selevel: ${6:s0}
		# seuser: ${7:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${8:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# remove: ${9:no}
		# dest: ${10:# The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.}
		# setype: ${11:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# owner: ${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# attributes: ${14:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# exclude_path: ${15:# Remote absolute path, glob, or list of paths or globs for the file or files to exclude from the archive}
$0
endsnippet

snippet assemble "Assembles a configuration file from fragments" b
- name: $1
	assemble:
		dest: ${2:# A file to create using the concatenation of all of the source files.}
		src: ${3:# An already existing directory full of source files.}
		# remote_src: ${4:#True|False}
		# selevel: ${5:s0}
		# decrypt: ${6:Yes}
		# owner: ${7:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# regexp: ${8:# Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		# validate: ${9:# The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# ignore_hidden: ${10:no}
		# group: ${11:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# unsafe_writes: ${12:no}
		# delimiter: ${13:# A delimiter to separate the file contents.}
		# seuser: ${14:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# setype: ${15:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# serole: ${16:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${17:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${18:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${19:yes|#no}
$0
endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines." b
- name: $1
	blockinfile:
		path: ${2:# The file to modify.}
		# selevel: ${3:s0}
		# insertafter: ${4:#EOF|*regex*}
		# marker: ${5:# {mark} ANSIBLE MANAGED BLOCK}
		# follow: ${6:yes|#no}
		# validate: ${7:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# group: ${8:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# insertbefore: ${9:BOF|*regex*}
		# unsafe_writes: ${10:no}
		# create: ${11:yes|#no}
		# seuser: ${12:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${13:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# state: ${15:#present|absent}
		# mode: ${16:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${17:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${18:yes|#no}
		# block: ${19:}
		# setype: ${20:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet copy "Copies files to remote locations" b
- name: $1
	copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If I(src) is a directory, this must be a directory too. If I(dest) is a nonexistent path and if either I(dest) ends with "/" or I(src) is a directory, I(dest) is created. If I(src) and I(dest) are files, the parent directory of I(dest) isn't created: the task fails if it doesn't already exist.}
		# directory_mode: ${3:# When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.}
		# force: ${4:yes}
		# remote_src: ${5:no}
		# selevel: ${6:s0}
		# decrypt: ${7:Yes}
		# owner: ${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# follow: ${9:no}
		# validate: ${10:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# local_follow: ${11:yes}
		# src: ${12:# Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.}
		# group: ${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# unsafe_writes: ${14:no}
		# seuser: ${15:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${16:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# content: ${17:# When used instead of I(src), sets the contents of a file directly to the specified value. For anything advanced or with formatting also look at the template module.}
		# setype: ${18:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${19:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${20:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${21:no}
$0
endsnippet

snippet fetch "Fetches a file from remote nodes" b
- name: $1
	fetch:
		dest: ${2:# A directory to save the file into. For example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile)}
		src: ${3:# The file on the remote system to fetch. This I(must) be a file, not a directory. Recursive fetching may be supported in a later release.}
		# validate_checksum: ${4:#yes|no}
		# fail_on_missing: ${5:#yes|no}
		# flat: ${6:# Allows you to override the default behavior of appending hostname/path/to/file to the destination.  If dest ends with '/', it will use the basename of the source file, similar to the copy module. Obviously this is only handy if the filenames are unique.}
$0
endsnippet

snippet file "Sets attributes of files" b
- name: $1
	file:
		path: ${2:[]}
		# src: ${3:# path of the file to link to (applies only to C(state=link)). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded.}
		# force: ${4:yes|#no}
		# group: ${5:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# state: ${6:#file|link|directory|hard|touch|absent}
		# unsafe_writes: ${7:no}
		# selevel: ${8:s0}
		# seuser: ${9:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# recurse: ${10:yes|#no}
		# serole: ${11:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# setype: ${12:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# follow: ${13:yes|#no}
		# mode: ${14:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# owner: ${15:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# attributes: ${16:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
$0
endsnippet

snippet find "Return a list of files based on specific criteria" b
- name: $1
	find:
		paths: ${2:# List of paths of directories to search. All paths must be fully qualified.}
		# file_type: ${3:any|directory|#file|link}
		# age: ${4:# Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., "1w").}
		# contains: ${5:# One or more regex patterns which should be matched against the file content.}
		# recurse: ${6:#no|yes}
		# age_stamp: ${7:atime|ctime|#mtime}
		# patterns: ${8:*}
		# get_checksum: ${9:#no|yes}
		# use_regex: ${10:#no|yes}
		# follow: ${11:#no|yes}
		# hidden: ${12:#no|yes}
		# size: ${13:# Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.}
$0
endsnippet

snippet ini_file "Tweak settings in INI files" b
- name: $1
	ini_file:
		section: ${2:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}
		path: ${3:# Path to the INI-style file; this file is created if required.}
		# no_extra_spaces: ${4:no}
		# group: ${5:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# option: ${6:# If set (required for changing a I(value)), this is the name of the option.}
		# state: ${7:#present|absent}
		# unsafe_writes: ${8:no}
		# selevel: ${9:s0}
		# seuser: ${10:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${11:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# value: ${12:# The string value to be associated with an I(option). May be omitted when removing an I(option).}
		# setype: ${13:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${14:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# others: ${15:# All arguments accepted by the M(file) module also work here}
		# owner: ${16:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# attributes: ${17:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${18:yes|#no}
		# create: ${19:#yes|no}
$0
endsnippet

snippet iso_extract "Extract files from an ISO image" b
- name: $1
	iso_extract:
		dest: ${2:# The destination directory to extract files to.}
		files: ${3:# A list of files to extract from the image.}
		image: ${4:# The ISO image to extract files from.}
		# force: ${5:yes}
		# executable: ${6:7z}
$0
endsnippet

snippet lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression." b
- name: $1
	lineinfile:
		path: ${2:# The file to modify.}
		# selevel: ${3:s0}
		# backrefs: ${4:yes|#no}
		# owner: ${5:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# others: ${6:# All arguments accepted by the M(file) module also work here.}
		# insertafter: ${7:#EOF|*regex*}
		# regexp: ${8:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line(s) to remove.  Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		# validate: ${9:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# line: ${10:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
		# group: ${11:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# insertbefore: ${12:BOF|*regex*}
		# unsafe_writes: ${13:no}
		# create: ${14:yes|#no}
		# seuser: ${15:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${16:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# state: ${17:#present|absent}
		# mode: ${18:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${19:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${20:yes|#no}
		# setype: ${21:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet patch "Apply patch files using the GNU patch tool" b
- name: $1
	patch:
		src: ${2:# Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's I(files) directory.}
		# strip: ${3:0}
		# remote_src: ${4:#no|yes}
		# dest: ${5:# Path of the file on the remote machine to be patched.}
		# binary: ${6:#no|yes}
		# basedir: ${7:# Path of a base directory in which the patch file will be applied. May be omitted when C(dest) option is specified, otherwise required.}
		# backup: ${8:#no|yes}
$0
endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression." b
- name: $1
	replace:
		regexp: ${2:# The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses MULTILINE mode, which means C(^) and C($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.}
		path: ${3:# The file to modify.}
		# encoding: ${4:utf-8}
		# selevel: ${5:s0}
		# after: ${6:# If specified, the line after the replace/remove will start. Can be used in combination with C(before). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		# replace: ${7:# The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.}
		# owner: ${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# follow: ${9:yes|#no}
		# validate: ${10:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# before: ${11:# If specified, the line before the replace/remove will occur. Can be used in combination with C(after). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		# group: ${12:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# unsafe_writes: ${13:no}
		# seuser: ${14:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# setype: ${15:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# serole: ${16:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${17:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${18:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${19:yes|#no}
		# others: ${20:# All arguments accepted by the M(file) module also work here.}
$0
endsnippet

snippet stat "Retrieve file or file system status" b
- name: $1
	stat:
		path: ${2:# The full path of the file/object to get the facts of.}
		# get_checksum: ${3:no|#yes}
		# follow: ${4:#no|yes}
		# checksum_algorithm: ${5:#sha1|sha224|sha256|sha384|sha512}
		# get_mime: ${6:no|#yes}
		# get_md5: ${7:no|#yes}
		# get_attributes: ${8:no|#yes}
$0
endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy." b
- name: $1
	synchronize:
		src: ${2:# Path on the source host that will be synchronized to the destination; The path can be absolute or relative.}
		dest: ${3:# Path on the destination host that will be synchronized from the source; The path can be absolute or relative.}
		# dirs: ${4:yes|#no}
		# partial: ${5:no}
		# links: ${6:yes|no}
		# copy_links: ${7:yes|#no}
		# perms: ${8:yes|no}
		# compress: ${9:#yes|no}
		# rsync_timeout: ${10:0}
		# rsync_opts: ${11:# Specify additional rsync options by passing in an array.}
		# owner: ${12:yes|no}
		# set_remote_user: ${13:yes}
		# times: ${14:yes|no}
		# rsync_path: ${15:# Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.}
		# dest_port: ${16:Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set}
		# group: ${17:yes|no}
		# existing_only: ${18:yes|#no}
		# recursive: ${19:yes|no}
		# archive: ${20:#yes|no}
		# mode: ${21:#push|pull}
		# checksum: ${22:yes|#no}
		# verify_host: ${23:no}
		# use_ssh_args: ${24:yes|#no}
		# delete: ${25:yes|#no}
$0
endsnippet

snippet tempfile "Creates temporary files and directories." b
- name: $1
	tempfile:
		# path: ${2:# Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.}
		# state: ${3:#file|directory}
		# prefix: ${4:ansible.}
		# suffix: ${5:}
$0
endsnippet

snippet template "Templates a file out to a remote server" b
- name: $1
	template:
		dest: ${2:# Location to render the template to on the remote machine.}
		src: ${3:# Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.}
		# force: ${4:yes}
		# trim_blocks: ${5:no}
		# selevel: ${6:s0}
		# block_end_string: ${7:%}}
		# variable_start_string: ${8:{{}
		# block_start_string: ${9:{%}
		# variable_end_string: ${10:}}}
		# owner: ${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# follow: ${12:no}
		# validate: ${13:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		# group: ${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# unsafe_writes: ${15:no}
		# seuser: ${16:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# setype: ${17:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# serole: ${18:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# newline_sequence: ${19:#\n|\r|\r\n}
		# mode: ${20:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# attributes: ${21:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${22:no}
$0
endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine." b
- name: $1
	unarchive:
		src: ${2:# If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.}
		dest: ${3:# Remote absolute path where the archive should be unpacked.}
		# exclude: ${4:# List the directory and file entries that you would like to exclude from the unarchive action.}
		# keep_newer: ${5:no}
		# group: ${6:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# remote_src: ${7:no}
		# unsafe_writes: ${8:no}
		# selevel: ${9:s0}
		# list_files: ${10:no}
		# seuser: ${11:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# decrypt: ${12:Yes}
		# serole: ${13:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# creates: ${14:# A filename, when it already exists, this step will B(not) be run.}
		# setype: ${15:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${16:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# extra_opts: ${17:}
		# owner: ${18:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# attributes: ${19:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# copy: ${20:yes}
		# validate_certs: ${21:yes}
$0
endsnippet

snippet xattr "set/retrieve extended attributes" b
- name: $1
	xattr:
		path: ${2:# The full path of the file/object to get the facts of.}
		# state: ${3:#read|present|all|keys|absent}
		# key: ${4:# The name of a specific Extended attribute key to set/retrieve}
		# value: ${5:# The value to set the named name/key to, it automatically sets the C(state) to 'set'}
		# follow: ${6:yes|no}
$0
endsnippet

snippet xml "Manage bits and pieces of XML files or strings" b
- name: $1
	xml:
		xmlstring: ${2:# A string containing XML on which to operate.}
		path: ${3:# Path to the file to operate on. File must exist ahead of time.}
		# xpath: ${4:/}
		# count: ${5:no}
		# set_children: ${6:# Set the child-element(s) of a selected element for a given C(xpath).}
		# attribute: ${7:# The attribute to select when using parameter C(value).}
		# pretty_print: ${8:no}
		# add_children: ${9:# Add additional child-element(s) to a selected element for a given C(xpath).}
		# value: ${10:# Desired state of the selected attribute.}
		# content: ${11:attribute|text}
		# state: ${12:absent|#present}
		# namespaces: ${13:# The namespace C(prefix:uri) mapping for the XPath expression.}
		# input_type: ${14:xml|#yaml}
		# print_match: ${15:no}
		# backup: ${16:no}
$0
endsnippet

snippet cyberark_authentication "Module for CyberArk Vault Authentication using PAS Web Services SDK" b
- name: $1
	cyberark_authentication:
		# username: ${2:# The name of the user who will logon to the Vault.}
		# use_radius_authentication: ${3:no}
		# new_password: ${4:# The new password of the user. This parameter is optional, and enables you to change a password.}
		# cyberark_session: ${5:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session.}
		# state: ${6:#present|absent}
		# password: ${7:# The password of the user.}
		# validate_certs: ${8:yes}
		# use_shared_logon_authentication: ${9:no}
		# api_base_url: ${10:# A string containing the base URL of the server hosting CyberArk's Privileged Account Security Web Services SDK.}
$0
endsnippet

snippet cyberark_user "Module for CyberArk User Management using PAS Web Services SDK" b
- name: $1
	cyberark_user:
		username: ${2:# The name of the user who will be queried (for details), added, updated or deleted.}
		cyberark_session: ${3:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session, please see M(cyberark_authentication) module for an example of cyberark_session.}
		# first_name: ${4:# The user first name.}
		# last_name: ${5:# The user last name.}
		# initial_password: ${6:# The password that the new user will use to log on the first time. This password must meet the password policy requirements. this parameter is required when state is present -- Add User.}
		# user_type_name: ${7:EPVUser}
		# new_password: ${8:# The user updated password. Make sure that this password meets the password policy requirements.}
		# group_name: ${9:# The name of the group the user will be added to.}
		# disabled: ${10:no}
		# change_password_on_the_next_logon: ${11:no}
		# state: ${12:#present|absent}
		# expiry_date: ${13:# The date and time when the user account will expire and become disabled.}
		# location: ${14:# The Vault Location for the user.}
		# email: ${15:# The user email address.}
$0
endsnippet

snippet ipa_dnsrecord "Manage FreeIPA DNS records" b
- name: $1
	ipa_dnsrecord:
		record_name: ${2:# The DNS record name to manage.}
		record_value: ${3:# Manage DNS record name with this value.}
		ipa_pass: ${4:# P}
		zone_name: ${5:# The DNS zone name to which DNS record needs to be managed.}
		# ipa_port: ${6:443}
		# ipa_prot: ${7:http|#https}
		# record_type: ${8:#A|AAAA|PTR}
		# state: ${9:#present|absent}
		# ipa_host: ${10:ipa.example.com}
		# ipa_user: ${11:admin}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet ipa_group "Manage FreeIPA group" b
- name: $1
	ipa_group:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		# ipa_port: ${4:443}
		# group: ${5:# List of group names assigned to this group.}
		# user: ${6:# List of user names assigned to this group.}
		# ipa_prot: ${7:http|#https}
		# gidnumber: ${8:# GID (use this option to set it manually).}
		# state: ${9:#present|absent}
		# ipa_host: ${10:ipa.example.com}
		# ipa_user: ${11:admin}
		# validate_certs: ${12:yes}
		# nonposix: ${13:# Create as a non-POSIX group.}
		# external: ${14:# Allow adding external non-IPA members from trusted domains.}
$0
endsnippet

snippet ipa_hbacrule "Manage FreeIPA HBAC rule" b
- name: $1
	ipa_hbacrule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		# sourcehostcategory: ${4:all}
		# servicecategory: ${5:all}
		# hostcategory: ${6:all}
		# ipa_host: ${7:ipa.example.com}
		# usergroup: ${8:# List of user group names to assign.}
		# description: ${9:# D}
		# ipa_port: ${10:443}
		# sourcehost: ${11:# List of source host names to assign.}
		# service: ${12:# List of service names to assign.}
		# ipa_prot: ${13:http|#https}
		# host: ${14:# List of host names to assign.}
		# hostgroup: ${15:# List of hostgroup names to assign.}
		# usercategory: ${16:all}
		# state: ${17:#present|absent|enabled|disabled}
		# ipa_user: ${18:admin}
		# servicegroup: ${19:# List of service group names to assign.}
		# validate_certs: ${20:yes}
		# sourcehostgroup: ${21:# List of source host group names to assign.}
		# user: ${22:# List of user names to assign.}
$0
endsnippet

snippet ipa_host "Manage FreeIPA host" b
- name: $1
	ipa_host:
		fqdn: ${2:# Full qualified domain name.}
		ipa_pass: ${3:# P}
		# force: ${4:# Force host name even if not in DNS.}
		# description: ${5:# A description of this host.}
		# state: ${6:#present|absent|disabled}
		# ipa_host: ${7:ipa.example.com}
		# user_certificate: ${8:# List of Base-64 encoded server certificates.}
		# ip_address: ${9:# Add the host to DNS with this IP address.}
		# ns_hardware_platform: ${10:# Host hardware platform (e.g. "Lenovo T61")}
		# ipa_port: ${11:443}
		# ns_host_location: ${12:# Host location (e.g. "Lab 2")}
		# ipa_prot: ${13:http|#https}
		# ns_os_version: ${14:# Host operating system and version (e.g. "Fedora 9")}
		# ipa_user: ${15:admin}
		# mac_address: ${16:# List of Hardware MAC address(es) off this host.}
		# validate_certs: ${17:yes}
$0
endsnippet

snippet ipa_hostgroup "Manage FreeIPA host-group" b
- name: $1
	ipa_hostgroup:
		ipa_pass: ${2:# P}
		cn: ${3:# Name of host-group.}
		# ipa_port: ${4:443}
		# description: ${5:# Description}
		# ipa_prot: ${6:http|#https}
		# state: ${7:#present|absent}
		# hostgroup: ${8:# List of host-groups than belong to that host-group.}
		# host: ${9:# List of hosts that belong to the host-group.}
		# ipa_host: ${10:ipa.example.com}
		# ipa_user: ${11:admin}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet ipa_role "Manage FreeIPA role" b
- name: $1
	ipa_role:
		cn: ${2:# Role name.}
		ipa_pass: ${3:# P}
		# ipa_port: ${4:443}
		# group: ${5:# List of group names assign to this role.}
		# service: ${6:# List of service names to assign.}
		# description: ${7:# A description of this role-group.}
		# ipa_prot: ${8:http|#https}
		# state: ${9:#present|absent}
		# hostgroup: ${10:# List of host group names to assign.}
		# privilege: ${11:# List of privileges granted to the role.}
		# host: ${12:# List of host names to assign.}
		# ipa_host: ${13:ipa.example.com}
		# ipa_user: ${14:admin}
		# validate_certs: ${15:yes}
		# user: ${16:# List of user names to assign.}
$0
endsnippet

snippet ipa_sudocmd "Manage FreeIPA sudo command" b
- name: $1
	ipa_sudocmd:
		sudocmd: ${2:# Sudo Command.}
		ipa_pass: ${3:# P}
		# ipa_port: ${4:443}
		# ipa_host: ${5:ipa.example.com}
		# ipa_user: ${6:admin}
		# validate_certs: ${7:yes}
		# ipa_prot: ${8:http|#https}
		# state: ${9:#present|absent}
		# description: ${10:# A description of this command.}
$0
endsnippet

snippet ipa_sudocmdgroup "Manage FreeIPA sudo command group" b
- name: $1
	ipa_sudocmdgroup:
		ipa_pass: ${2:# P}
		cn: ${3:# Sudo Command Group.}
		# sudocmd: ${4:# List of sudo commands to assign to the group.}
		# ipa_port: ${5:443}
		# ipa_host: ${6:ipa.example.com}
		# ipa_user: ${7:admin}
		# validate_certs: ${8:yes}
		# description: ${9:# Group description.}
		# ipa_prot: ${10:http|#https}
		# state: ${11:#present|absent}
$0
endsnippet

snippet ipa_sudorule "Manage FreeIPA sudo rule" b
- name: $1
	ipa_sudorule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		# hostcategory: ${4:all}
		# ipa_host: ${5:ipa.example.com}
		# usergroup: ${6:# List of user groups assigned to the rule.}
		# cmdcategory: ${7:all}
		# ipa_port: ${8:443}
		# cmd: ${9:# List of commands assigned to the rule.}
		# ipa_prot: ${10:http|#https}
		# host: ${11:# List of hosts assigned to the rule.}
		# hostgroup: ${12:# List of host groups assigned to the rule.}
		# usercategory: ${13:all}
		# state: ${14:#present|absent|enabled|disabled}
		# ipa_user: ${15:admin}
		# validate_certs: ${16:yes}
		# user: ${17:# List of users assigned to the rule.}
$0
endsnippet

snippet ipa_user "Manage FreeIPA users" b
- name: $1
	ipa_user:
		uid: ${2:# u}
		ipa_pass: ${3:# P}
		# telephonenumber: ${4:# List of telephone numbers assigned to the user.}
		# sshpubkey: ${5:# List of public SSH key.}
		# displayname: ${6:# D}
		# ipa_host: ${7:ipa.example.com}
		# password: ${8:# Password for new user}
		# ipa_port: ${9:443}
		# givenname: ${10:# F}
		# title: ${11:# T}
		# loginshell: ${12:# L}
		# ipa_prot: ${13:http|#https}
		# state: ${14:#present|absent|enabled|disabled}
		# sn: ${15:# S}
		# ipa_user: ${16:admin}
		# mail: ${17:# List of mail addresses assigned to the user.}
		# validate_certs: ${18:yes}
$0
endsnippet

snippet opendj_backendprop "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command." b
- name: $1
	opendj_backendprop:
		name: ${2:# The configuration setting to update.}
		hostname: ${3:# The hostname of the OpenDJ server.}
		value: ${4:# The value for the configuration item.}
		port: ${5:# The Admin port on which the OpenDJ instance is available.}
		backend: ${6:# The name of the backend on which the property needs to be updated.}
		# username: ${7:cn=Directory Manager}
		# state: ${8:present}
		# passwordfile: ${9:# Location to the password file which holds the password for the cn=Directory Manager user.}
		# password: ${10:# The password for the cn=Directory Manager user.}
		# opendj_bindir: ${11:/opt/opendj/bin}
$0
endsnippet

snippet add_host "add a host (and alternatively a group) to the ansible-playbook in-memory inventory" b
- name: $1
	add_host:
		name: ${2:# The hostname/ip of the host to add to the inventory, can include a colon and a port number.}
		# groups: ${3:# The groups to add the hostname to, comma separated.}
$0
endsnippet

snippet group_by "Create Ansible groups based on facts" b
- name: $1
	group_by:
		key: ${2:# The variables whose values will be used as groups}
		# parents: ${3:all}
$0
endsnippet

snippet rabbitmq_binding "This module manages rabbitMQ bindings" b
- name: $1
	rabbitmq_binding:
		name: ${2:# source exchange to create binding on}
		destination: ${3:# destination exchange or queue for the binding}
		destination_type: ${4:queue|exchange}
		# login_port: ${5:15672}
		# login_user: ${6:guest}
		# login_host: ${7:localhost}
		# routing_key: ${8:#}
		# vhost: ${9:/}
		# state: ${10:#present|absent}
		# arguments: ${11:{}}
		# login_password: ${12:no}
$0
endsnippet

snippet rabbitmq_exchange "This module manages rabbitMQ exchanges" b
- name: $1
	rabbitmq_exchange:
		name: ${2:# Name of the exchange to create}
		# login_port: ${3:15672}
		# login_user: ${4:guest}
		# login_host: ${5:localhost}
		# durable: ${6:yes|no}
		# exchange_type: ${7:fanout|#direct|headers|topic}
		# vhost: ${8:/}
		# state: ${9:#present|absent}
		# internal: ${10:yes|no}
		# arguments: ${11:{}}
		# login_password: ${12:no}
		# auto_delete: ${13:yes|no}
$0
endsnippet

snippet rabbitmq_parameter "Adds or removes parameters to RabbitMQ" b
- name: $1
	rabbitmq_parameter:
		name: ${2:# Name of the parameter being set}
		component: ${3:# Name of the component of which the parameter is being set}
		# node: ${4:rabbit}
		# vhost: ${5:/}
		# state: ${6:#present|absent}
		# value: ${7:# Value of the parameter, as a JSON term}
$0
endsnippet

snippet rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# state: ${3:#enabled|disabled}
		# new_only: ${4:no}
		# prefix: ${5:# Specify a custom install prefix to a Rabbit.}
$0
endsnippet

snippet rabbitmq_policy "Manage the state of policies in RabbitMQ." b
- name: $1
	rabbitmq_policy:
		name: ${2:# The name of the policy to manage.}
		tags: ${3:# A dict or string describing the policy.}
		pattern: ${4:# A regex of queues to apply the policy to.}
		# node: ${5:rabbit}
		# priority: ${6:0}
		# vhost: ${7:/}
		# state: ${8:#present|absent}
		# apply_to: ${9:#all|exchanges|queues}
$0
endsnippet

snippet rabbitmq_queue "This module manages rabbitMQ queues" b
- name: $1
	rabbitmq_queue:
		name: ${2:# Name of the queue to create}
		# dead_letter_exchange: ${3:# Optional name of an exchange to which messages will be republished if they}
		# max_priority: ${4:# Maximum number of priority levels for the queue to support.}
		# login_user: ${5:guest}
		# login_host: ${6:localhost}
		# vhost: ${7:/}
		# login_password: ${8:no}
		# auto_expires: ${9:forever}
		# login_port: ${10:15672}
		# durable: ${11:yes|no}
		# state: ${12:#present|absent}
		# max_length: ${13:no limit}
		# arguments: ${14:{}}
		# message_ttl: ${15:forever}
		# dead_letter_routing_key: ${16:# Optional replacement routing key to use when a message is dead-lettered.}
		# auto_delete: ${17:yes|no}
$0
endsnippet

snippet rabbitmq_user "Adds or removes users to RabbitMQ" b
- name: $1
	rabbitmq_user:
		user: ${2:# Name of user to add}
		# node: ${3:rabbit}
		# force: ${4:yes|#no}
		# tags: ${5:# User tags specified as comma delimited}
		# read_priv: ${6:^$}
		# write_priv: ${7:^$}
		# state: ${8:#present|absent}
		# configure_priv: ${9:^$}
		# vhost: ${10:/}
		# password: ${11:# Password of user to add.}
		# permissions: ${12:[]}
$0
endsnippet

snippet rabbitmq_vhost "Manage the state of a virtual host in RabbitMQ" b
- name: $1
	rabbitmq_vhost:
		name: ${2:# The name of the vhost to manage}
		# node: ${3:rabbit}
		# tracing: ${4:yes|#no}
		# state: ${5:#present|absent}
$0
endsnippet

snippet airbrake_deployment "Notify airbrake about app deployments" b
- name: $1
	airbrake_deployment:
		environment: ${2:# The airbrake environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		# repo: ${4:# URL of the project repository}
		# user: ${5:# The username of the person doing the deployment}
		# url: ${6:https://airbrake.io/deploys.txt}
		# validate_certs: ${7:#yes|no}
		# revision: ${8:# A hash, number, tag, or other identifier showing what revision was deployed}
$0
endsnippet

snippet bigpanda "Notify BigPanda about deployments" b
- name: $1
	bigpanda:
		component: ${2:# The name of the component being deployed. Ex: billing}
		token: ${3:# API token.}
		state: ${4:started|finished|failed}
		version: ${5:# The deployment version.}
		# description: ${6:# Free text description of the deployment.}
		# url: ${7:https://api.bigpanda.io}
		# hosts: ${8:machine's hostname}
		# env: ${9:# The environment name, typically 'production', 'staging', etc.}
		# owner: ${10:# The person responsible for the deployment.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet boundary_meter "Manage boundary meters" b
- name: $1
	boundary_meter:
		apikey: ${2:# Organizations boundary API KEY}
		apiid: ${3:# Organizations boundary API ID}
		name: ${4:# meter name}
		# state: ${5:present|absent}
		# validate_certs: ${6:#yes|no}
$0
endsnippet

snippet circonus_annotation "create an annotation in circonus" b
- name: $1
	circonus_annotation:
		category: ${2:# Annotation Category}
		description: ${3:# Description of annotation}
		title: ${4:# Title of annotation}
		api_key: ${5:# Circonus API key}
		# start: ${6:I(now)}
		# duration: ${7:0}
		# stop: ${8:I(now) + I(duration)}
$0
endsnippet

snippet datadog_event "Posts events to DataDog  service" b
- name: $1
	datadog_event:
		title: ${2:# The event title.}
		text: ${3:# The body of the event.}
		app_key: ${4:# Your DataDog app key.}
		api_key: ${5:# Your DataDog API key.}
		# date_happened: ${6:now}
		# alert_type: ${7:error|warning|#info|success}
		# tags: ${8:# Comma separated list of tags to apply to the event.}
		# priority: ${9:#normal|low}
		# host: ${10:{{ ansible_hostname }}}
		# aggregation_key: ${11:# An arbitrary string to use for aggregation.}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet datadog_monitor "Manages Datadog monitors" b
- name: $1
	datadog_monitor:
		app_key: ${2:# Your DataDog app key.}
		name: ${3:# The name of the alert.}
		state: ${4:present|absent|muted|unmuted}
		api_key: ${5:# Your DataDog API key.}
		# notify_audit: ${6:no}
		# timeout_h: ${7:# The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.}
		# tags: ${8:# A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.}
		# thresholds: ${9:{u'warning': 1, u'ok': 1, u'critical': 1}}
		# new_host_delay: ${10:# A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts. This gives the host time to fully initialize.}
		# query: ${11:# The monitor query to notify on with syntax varying depending on what type of monitor you are creating.}
		# message: ${12:# A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.}
		# id: ${13:# The id of the alert. If set, will be used instead of the name to locate the alert.}
		# locked: ${14:no}
		# no_data_timeframe: ${15:2x timeframe for metric, 2 minutes for service}
		# silenced: ${16:}
		# require_full_window: ${17:# A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.}
		# notify_no_data: ${18:no}
		# renotify_interval: ${19:# The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.}
		# escalation_message: ${20:# A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None}
		# type: ${21:metric alert|service check|event alert}
$0
endsnippet

snippet honeybadger_deployment "Notify Honeybadger.io about app deployments" b
- name: $1
	honeybadger_deployment:
		environment: ${2:# The environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		# repo: ${4:# URL of the project repository}
		# user: ${5:# The username of the person doing the deployment}
		# url: ${6:https://api.honeybadger.io/v1/deploys}
		# validate_certs: ${7:#yes|no}
		# revision: ${8:# A hash, number, tag, or other identifier showing what revision was deployed}
$0
endsnippet

snippet icinga2_feature "Manage Icinga2 feature" b
- name: $1
	icinga2_feature:
		name: ${2:# This is the feature name to enable or disable.}
		# state: ${3:#present|absent}
$0
endsnippet

snippet librato_annotation "create an annotation in librato" b
- name: $1
	librato_annotation:
		links: ${2:# See examples}
		title: ${3:# The title of an annotation is a string and may contain spaces}
		api_key: ${4:# Librato account api key}
		user: ${5:# Librato account username}
		# description: ${6:# The description contains extra meta-data about a particular annotation}
		# start_time: ${7:# The unix timestamp indicating the time at which the event referenced by this annotation started}
		# name: ${8:# The annotation stream name}
		# source: ${9:# A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population}
		# end_time: ${10:# The unix timestamp indicating the time at which the event referenced by this annotation ended}
$0
endsnippet

snippet logentries "Module for tracking logs via logentries.com" b
- name: $1
	logentries:
		path: ${2:# path to a log file}
		# state: ${3:#present|absent}
		# name: ${4:# name of the log}
		# logtype: ${5:# type of the log}
$0
endsnippet

snippet logicmonitor "Manage your LogicMonitor account through Ansible Playbooks" b
- name: $1
	logicmonitor:
		company: ${2:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."}
		user: ${3:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${4:# The password of the specified LogicMonitor user}
		target: ${5:collector|host|datsource|hostgroup}
		action: ${6:add|remove|update|sdt}
		# displayname: ${7:hostname -f}
		# description: ${8:}
		# groups: ${9:[]}
		# duration: ${10:30}
		# collector: ${11:# The fully qualified domain name of a collector in your LogicMonitor account.}
		# id: ${12:# ID of the datasource to target.}
		# alertenable: ${13:#True|False}
		# hostname: ${14:hostname -f}
		# properties: ${15:{}}
		# starttime: ${16:Now}
		# fullpath: ${17:# The fullpath of the host group object you would like to manage.}
$0
endsnippet

snippet logicmonitor_facts "Collect facts about LogicMonitor objects" b
- name: $1
	logicmonitor_facts:
		target: ${2:host|hostgroup}
		company: ${3:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".}
		user: ${4:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${5:# The password for the chosen LogicMonitor User.}
		# displayname: ${6:hostname -f}
		# hostname: ${7:hostname -f}
		# fullpath: ${8:# The fullpath of the hostgroup object you would like to manage.}
		# collector: ${9:# The fully qualified domain name of a collector in your LogicMonitor account.}
$0
endsnippet

snippet logstash_plugin "Manage Logstash plugins" b
- name: $1
	logstash_plugin:
		name: ${2:# Install plugin with that name.}
		# proxy_port: ${3:# Proxy port to use during plugin installation.}
		# state: ${4:#present|absent}
		# version: ${5:# Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.}
		# proxy_host: ${6:# Proxy host to use during plugin installation.}
		# plugin_bin: ${7:/usr/share/logstash/bin/logstash-plugin}
$0
endsnippet

snippet monit "Manage the state of a program monitored via Monit" b
- name: $1
	monit:
		state: ${2:present|started|stopped|restarted|monitored|unmonitored|reloaded}
		name: ${3:# The name of the I(monit) program/process to manage}
		# timeout: ${4:300}
$0
endsnippet

snippet nagios "Perform common tasks in Nagios related to downtime and notifications." b
- name: $1
	nagios:
		action: ${2:downtime|delete_downtime|enable_alerts|disable_alerts|silence|unsilence|silence_nagios|unsilence_nagios|command|servicegroup_service_downtime|servicegroup_host_downtime}
		command: ${3:# The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action.}
		services: ${4:# What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions.}
		# comment: ${5:Scheduling downtime}
		# servicegroup: ${6:# The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime).}
		# author: ${7:Ansible}
		# host: ${8:# Host to operate on in Nagios.}
		# minutes: ${9:30}
		# cmdfile: ${10:auto-detected}
$0
endsnippet

snippet newrelic_deployment "Notify newrelic about app deployments" b
- name: $1
	newrelic_deployment:
		token: ${2:# API token, to place in the x-api-key header.}
		# application_id: ${3:# (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM}
		# description: ${4:# Text annotation for the deployment - notes for you}
		# changelog: ${5:# A list of changes for this deployment}
		# appname: ${6:# Name of the application}
		# environment: ${7:# The environment for this deployment}
		# user: ${8:# The name of the user/process that triggered this deployment}
		# revision: ${9:# A revision number (e.g., git commit SHA)}
		# validate_certs: ${10:#yes|no}
		# app_name: ${11:# (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application}
$0
endsnippet

snippet pagerduty "Create PagerDuty maintenance windows" b
- name: $1
	pagerduty:
		name: ${2:}
		passwd: ${3:}
		state: ${4:running|started|ongoing|absent}
		token: ${5:}
		user: ${6:}
		requester_id: ${7:}
		# service: ${8:}
		# minutes: ${9:}
		# hours: ${10:}
		# validate_certs: ${11:#yes|no}
		# desc: ${12:}
$0
endsnippet

snippet pagerduty_alert "Trigger, acknowledge or resolve PagerDuty incidents" b
- name: $1
	pagerduty_alert:
		name: ${2:# PagerDuty unique subdomain.}
		state: ${3:triggered|acknowledged|resolved}
		service_key: ${4:# The GUID of one of your "Generic API" services.}
		api_key: ${5:# The pagerduty API key (readonly access), generated on the pagerduty site.}
		# client_url: ${6:# The URL of the monitoring client that is triggering this event.}
		# incident_key: ${7:# Identifies the incident to which this I(state) should be applied.}
		# client: ${8:# The name of the monitoring client that is triggering this event.}
		# desc: ${9:Created via Ansible}
$0
endsnippet

snippet pingdom "Pause/unpause Pingdom alerts" b
- name: $1
	pingdom:
		checkid: ${2:}
		passwd: ${3:}
		state: ${4:running|paused}
		uid: ${5:}
		key: ${6:}
$0
endsnippet

snippet rollbar_deployment "Notify Rollbar about app deployments" b
- name: $1
	rollbar_deployment:
		environment: ${2:# Name of the environment being deployed, e.g. 'production'.}
		token: ${3:# Your project access token.}
		revision: ${4:# Revision number/sha being deployed.}
		# comment: ${5:# Deploy comment (e.g. what is being deployed).}
		# rollbar_user: ${6:# Rollbar username of the user who deployed.}
		# url: ${7:https://api.rollbar.com/api/1/deploy/}
		# user: ${8:# User who deployed.}
		# validate_certs: ${9:#yes|no}
$0
endsnippet

snippet sensu_check "Manage Sensu checks" b
- name: $1
	sensu_check:
		name: ${2:# The name of the check}
		command: ${3:# Path to the sensu check to run (not required when I(state=absent))}
		# interval: ${4:# Check interval in seconds}
		# handle: ${5:yes|no}
		# subscribers: ${6:[]}
		# metric: ${7:yes|no}
		# subdue_begin: ${8:# When to disable handling of check failures}
		# dependencies: ${9:[]}
		# occurrences: ${10:1}
		# low_flap_threshold: ${11:# The low threshold for flap detection}
		# ttl: ${12:# Time to live in seconds until the check is considered stale}
		# aggregate: ${13:yes|no}
		# path: ${14:/etc/sensu/conf.d/checks.json}
		# standalone: ${15:yes|no}
		# backup: ${16:yes|no}
		# handlers: ${17:[]}
		# publish: ${18:yes|no}
		# custom: ${19:{}}
		# source: ${20:# The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).}
		# state: ${21:#present|absent}
		# high_flap_threshold: ${22:# The high threshold for flap detection}
		# timeout: ${23:10}
		# subdue_end: ${24:# When to enable handling of check failures}
		# refresh: ${25:# Number of seconds handlers should wait before taking second action}
$0
endsnippet

snippet sensu_client "Manages Sensu client configuration" b
- name: $1
	sensu_client:
		subscriptions: ${2:# An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).}
		# address: ${3:Non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu)}
		# chef: ${4:# The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).}
		# redact: ${5:# Client definition attributes to redact (values) when logging and sending client keepalives.}
		# socket: ${6:# The socket definition scope, used to configure the Sensu client socket.}
		# puppet: ${7:# The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).}
		# ec2: ${8:# The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).}
		# safe_mode: ${9:true|false}
		# registration: ${10:# The registration definition scope, used to configure Sensu registration event handlers.}
		# deregistration: ${11:# The deregistration definition scope, used to configure automated Sensu client de-registration.}
		# keepalive: ${12:# The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).}
		# deregister: ${13:true|false}
		# name: ${14:System hostname as determined by Ruby Socket.gethostname (provided by Sensu)}
		# state: ${15:#present|absent}
		# keepalives: ${16:true|false}
		# servicenow: ${17:# The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).}
$0
endsnippet

snippet sensu_handler "Manages Sensu handler configuration" b
- name: $1
	sensu_handler:
		name: ${2:# A unique name for the handler. The name cannot contain special characters or spaces.}
		handlers: ${3:# An array of Sensu event handlers (names) to use for events using the handler set.}
		type: ${4:pipe|tcp|udp|transport|set}
		# filter: ${5:# The Sensu event filter (name) to use when filtering events for the handler.}
		# filters: ${6:# An array of Sensu event filters (names) to use when filtering events for the handler.}
		# severities: ${7:warning|critical|unknown}
		# pipe: ${8:# The pipe definition scope, used to configure the Sensu transport pipe.}
		# mutator: ${9:# The Sensu event mutator (name) to use to mutate event data for the handler.}
		# state: ${10:#present|absent}
		# command: ${11:# The handler command to be executed.}
		# timeout: ${12:10}
		# handle_flapping: ${13:no}
		# handle_silenced: ${14:no}
		# socket: ${15:# The socket definition scope, used to configure the TCP/UDP handler socket.}
$0
endsnippet

snippet sensu_silence "Manage Sensu silence entries" b
- name: $1
	sensu_silence:
		state: ${2:#present|absent}
		subscription: ${3:[]}
		# expire_on_resolve: ${4:# If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.}
		# url: ${5:http://127.0.01:4567}
		# creator: ${6:# Specifies the entity responsible for this entry.}
		# reason: ${7:# If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.}
		# expire: ${8:# If specified, the silence entry will be automatically cleared after this number of seconds.}
		# check: ${9:# Specifies the check which the silence entry applies to.}
$0
endsnippet

snippet sensu_subscription "Manage Sensu subscriptions" b
- name: $1
	sensu_subscription:
		name: ${2:# The name of the channel}
		# path: ${3:/etc/sensu/conf.d/subscriptions.json}
		# state: ${4:#present|absent}
		# backup: ${5:yes|no}
$0
endsnippet

snippet stackdriver "Send code deploy and annotation events to stackdriver" b
- name: $1
	stackdriver:
		key: ${2:# API key.}
		# repository: ${3:# The repository (or project) deployed}
		# level: ${4:#INFO|WARN|ERROR}
		# annotated_by: ${5:Ansible}
		# deployed_to: ${6:# The environment code was deployed to. (ie: development, staging, production)}
		# deployed_by: ${7:Ansible}
		# instance_id: ${8:# id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown}
		# msg: ${9:# The contents of the annotation message, in plain text.  Limited to 256 characters. Required for annotation.}
		# event_epoch: ${10:# Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.}
		# revision_id: ${11:# The revision of the code that was deployed. Required for deploy events}
		# event: ${12:annotation|deploy}
$0
endsnippet

snippet statusio_maintenance "Create maintenance windows for your status.io dashboard" b
- name: $1
	statusio_maintenance:
		api_id: ${2:# Your unique API ID from status.io}
		statuspage: ${3:# Your unique StatusPage ID from status.io}
		api_key: ${4:# Your unique API Key from status.io}
		# maintenance_notify_72_hr: ${5:no}
		# maintenance_notify_now: ${6:no}
		# start_time: ${7:# Time maintenance is expected to start (Hour:Minutes) (UTC)}
		# automation: ${8:no}
		# maintenance_notify_24_hr: ${9:no}
		# all_infrastructure_affected: ${10:no}
		# maintenance_id: ${11:# The maintenance id number when deleting a maintenance window}
		# desc: ${12:Created by Ansible}
		# maintenance_notify_1_hr: ${13:no}
		# title: ${14:A new maintenance window}
		# url: ${15:https://api.status.io}
		# state: ${16:#present|absent}
		# components: ${17:# The given name of your component (server name)}
		# minutes: ${18:10}
		# start_date: ${19:# Date maintenance is expected to start (Month/Day/Year) (UTC)}
		# containers: ${20:# The given name of your container (data center)}
$0
endsnippet

snippet uptimerobot "Pause and start Uptime Robot monitoring" b
- name: $1
	uptimerobot:
		monitorid: ${2:}
		state: ${3:started|paused}
		apikey: ${4:}
$0
endsnippet

snippet zabbix_group "Zabbix host groups creates/deletes" b
- name: $1
	zabbix_group:
		login_user: ${2:# Zabbix user name.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		host_groups: ${4:# List of host groups to create or delete.}
		login_password: ${5:# Zabbix user password.}
		# http_login_password: ${6:# Basic Auth password}
		# timeout: ${7:10}
		# http_login_user: ${8:# Basic Auth login}
		# state: ${9:#present|absent}
$0
endsnippet

snippet zabbix_host "Zabbix host creates/updates/deletes" b
- name: $1
	zabbix_host:
		login_user: ${2:# Zabbix user name, used to authenticate against the server.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https).}
		login_password: ${4:# Zabbix user password.}
		host_name: ${5:# Name of the host in Zabbix.}
		# status: ${6:#enabled|disabled}
		# tls_connect: ${7:1}
		# force: ${8:#yes|no}
		# interfaces: ${9:[]}
		# tls_accept: ${10:1}
		# proxy: ${11:# The name of the Zabbix Proxy to be used}
		# host_groups: ${12:# List of host groups the host is part of.}
		# inventory_mode: ${13:automatic|manual|disabled}
		# tls_psk_identity: ${14:# PSK value is a hard to guess string of hexadecimal digits.}
		# tls_issuer: ${15:# Required certificate issuer.}
		# http_login_password: ${16:# Basic Auth password}
		# tls_psk: ${17:# The preshared key, at least 32 hex digits. Required if either tls_connect or tls_accept has PSK enabled.}
		# http_login_user: ${18:# Basic Auth login}
		# visible_name: ${19:# Visible name of the host in Zabbix.}
		# state: ${20:#present|absent}
		# timeout: ${21:10}
		# tls_subject: ${22:# Required certificate subject.}
		# link_templates: ${23:# List of templates linked to the host.}
$0
endsnippet

snippet zabbix_hostmacro "Zabbix host macro creates/updates/deletes" b
- name: $1
	zabbix_hostmacro:
		macro_name: ${2:# Name of the host macro.}
		macro_value: ${3:# Value of the host macro.}
		login_user: ${4:# Zabbix user name.}
		server_url: ${5:# Url of Zabbix server, with protocol (http or https).}
		host_name: ${6:# Name of the host.}
		login_password: ${7:# Zabbix user password.}
		# http_login_password: ${8:# Basic Auth password}
		# http_login_user: ${9:# Basic Auth login}
		# state: ${10:#present|absent}
		# timeout: ${11:10}
$0
endsnippet

snippet zabbix_maintenance "Create Zabbix maintenance windows" b
- name: $1
	zabbix_maintenance:
		name: ${2:# Unique name of maintenance window.}
		login_user: ${3:# Zabbix user name.}
		server_url: ${4:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_password: ${5:# Zabbix user password.}
		desc: ${6:Created by Ansible}
		# http_login_password: ${7:# Basic Auth password}
		# http_login_user: ${8:# Basic Auth login}
		# host_names: ${9:# Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.}
		# host_groups: ${10:# Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.}
		# state: ${11:#present|absent}
		# timeout: ${12:10}
		# collect_data: ${13:true}
		# minutes: ${14:10}
$0
endsnippet

snippet zabbix_screen "Zabbix screen creates/updates/deletes" b
- name: $1
	zabbix_screen:
		screens: ${2:# List of screens to be created/updated/deleted(see example).}
		login_password: ${3:# Zabbix user password.}
		login_user: ${4:# Zabbix user name.}
		server_url: ${5:# Url of Zabbix server, with protocol (http or https).}
		# http_login_password: ${6:# Basic Auth password}
		# timeout: ${7:10}
		# http_login_user: ${8:# Basic Auth login}
$0
endsnippet

snippet cloudflare_dns "manage Cloudflare DNS records" b
- name: $1
	cloudflare_dns:
		account_email: ${2:# Account email.}
		account_api_token: ${3:# Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://www.cloudflare.com/a/account)
}
		zone: ${4:# The name of the Zone to work with (e.g. "example.com"). The Zone must already exist.}
		# solo: ${5:# Whether the record should be the only one for that record type and record name. Only use with C(state=present)}
		# weight: ${6:1}
		# proxied: ${7:no}
		# ttl: ${8:1 (automatic)}
		# port: ${9:# S}
		# service: ${10:# R}
		# proto: ${11:tcp|udp}
		# value: ${12:# The record value. Required for C(state=present)}
		# priority: ${13:1}
		# record: ${14:@}
		# state: ${15:#present|absent}
		# timeout: ${16:30}
		# type: ${17:A|AAAA|CNAME|TXT|SRV|MX|NS|SPF}
$0
endsnippet

snippet dnsimple "Interface with dnsimple.com (a DNS hosting service)." b
- name: $1
	dnsimple:
		# solo: ${2:# Whether the record should be the only one for that record type and record name. Only use with state=present on a record}
		# domain: ${3:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned.}
		# account_email: ${4:# Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_TOKEN will be looked for. If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started)
}
		# record_ids: ${5:# List of records to ensure they either exist or don't exist}
		# value: ${6:# Record value}
		# priority: ${7:# Record priority}
		# record: ${8:# Record to add, if blank a record for the domain will be created, supports the wildcard (*)}
		# state: ${9:present|absent}
		# ttl: ${10:3600 (one hour)}
		# type: ${11:A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
		# account_api_token: ${12:# Account API token. See I(account_email) for info.}
$0
endsnippet

snippet dnsmadeeasy "Interface with dnsmadeeasy.com (a DNS hosting service)." b
- name: $1
	dnsmadeeasy:
		domain: ${2:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution}
		protocol: ${3:TCP|UDP|#HTTP|DNS|SMTP|HTTPS}
		autoFailover: ${4:yes|#no}
		sensitivity: ${5:Low|#Medium|High}
		contactList: ${6:}
		account_key: ${7:# Account API Key.}
		port: ${8:80}
		monitor: ${9:yes|#no}
		failover: ${10:yes|#no}
		maxEmails: ${11:1}
		state: ${12:present|absent}
		systemDescription: ${13:}
		account_secret: ${14:# Account Secret Key.}
		# httpFqdn: ${15:# The fully qualified domain name used by the monitor.}
		# record_ttl: ${16:1800}
		# ip2: ${17:# Secondary IP address for the failover.}
		# record_type: ${18:A|AAAA|CNAME|ANAME|HTTPRED|MX|NS|PTR|SRV|TXT}
		# ip1: ${19:# Primary IP address for the failover.}
		# ip4: ${20:# Quaternary IP address for the failover.}
		# ip5: ${21:# Quinary IP address for the failover.}
		# record_name: ${22:# Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.}
		# ip3: ${23:# Tertiary IP address for the failover.}
		# httpQueryString: ${24:# The string in the httpFile that the monitor queries for HTTP or HTTPS.}
		# record_value: ${25:# Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"
}
		# httpFile: ${26:# The file at the Fqdn that the monitor queries for HTTP or HTTPS.}
		# validate_certs: ${27:#yes|no}
$0
endsnippet

snippet haproxy "Enable, disable, and set weights for HAProxy backend servers using socket commands." b
- name: $1
	haproxy:
		state: ${2:enabled|disabled|drain}
		host: ${3:# Name of the backend host to change.}
		# drain: ${4:no}
		# socket: ${5:/var/run/haproxy.sock}
		# weight: ${6:# The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.}
		# wait_interval: ${7:5}
		# backend: ${8:auto-detected}
		# wait_retries: ${9:25}
		# fail_on_not_found: ${10:no}
		# shutdown_sessions: ${11:no}
		# wait: ${12:no}
$0
endsnippet

snippet ipify_facts "Retrieve the public IP of your internet gateway." b
- name: $1
	ipify_facts:
		# validate_certs: ${2:yes}
		# api_url: ${3:https://api.ipify.org}
		# timeout: ${4:10}
$0
endsnippet

snippet ipinfoio_facts "Retrieve IP geolocation facts of a host's IP address" b
- name: $1
	ipinfoio_facts:
		# http_agent: ${2:ansible-ipinfoio-module/0.0.1}
		# timeout: ${3:10}
$0
endsnippet

snippet lldp "get details reported by lldp" b
- name: $1
	lldp:
$0
endsnippet

snippet nmcli "Manage Networking" b
- name: $1
	nmcli:
		conn_name: ${2:# Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]}
		state: ${3:present|absent}
		# ingress: ${4:# This is only used with VLAN - VLAN ingress priority mapping}
		# slavepriority: ${5:32}
		# path_cost: ${6:100}
		# vlandev: ${7:# This is only used with VLAN - parent device this VLAN is on, can use ifname}
		# forwarddelay: ${8:15}
		# primary: ${9:# This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'}
		# hairpin: ${10:yes}
		# egress: ${11:# This is only used with VLAN - VLAN egress priority mapping}
		# ageingtime: ${12:300}
		# dns4: ${13:# A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: "192.0.2.53 198.51.100.53"}
		# arp_ip_target: ${14:# This is only used with bond - ARP IP target}
		# maxage: ${15:20}
		# vlanid: ${16:# This is only used with VLAN - VLAN ID in range <0-4095>}
		# priority: ${17:128}
		# gw4: ${18:# The IPv4 gateway for this interface using this format ie: "192.0.2.1"}
		# gw6: ${19:# The IPv6 gateway for this interface using this format ie: "2001:db8::1"}
		# master: ${20:# master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.}
		# stp: ${21:# This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge}
		# ifname: ${22:conn_name}
		# type: ${23:ethernet|team|team-slave|bond|bond-slave|bridge|vlan}
		# miimon: ${24:100}
		# hellotime: ${25:2}
		# downdelay: ${26:# This is only used with bond - downdelay}
		# mac: ${27:# This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)
}
		# ip6: ${28:# The IPv6 address to this interface using this format ie: "abbe::cafe"}
		# ip4: ${29:# The IPv4 address to this interface using this format ie: "192.0.2.24/24"}
		# autoconnect: ${30:#yes|no}
		# dns6: ${31:# A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: "2001:4860:4860::8888 2001:4860:4860::8844"}
		# mtu: ${32:1500}
		# arp_interval: ${33:# This is only used with bond - ARP interval}
		# flags: ${34:# This is only used with VLAN - flags}
		# mode: ${35:balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb}
		# updelay: ${36:# This is only used with bond - updelay}
$0
endsnippet

snippet nsupdate "Manage DNS records." b
- name: $1
	nsupdate:
		zone: ${2:# DNS record will be modified on this C(zone).}
		server: ${3:# Apply DNS modification on this server.}
		record: ${4:# Sets the DNS record to modify.}
		# key_algorithm: ${5:HMAC-MD5.SIG-ALG.REG.INT|#hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hamc-sha384|hmac-sha512}
		# key_name: ${6:# Use TSIG key name to authenticate against DNS C(server)}
		# value: ${7:# Sets the record value.}
		# state: ${8:#present|absent}
		# ttl: ${9:3600}
		# type: ${10:A}
		# key_secret: ${11:# Use TSIG key secret, associated with C(key_name), to authenticate against C(server)}
$0
endsnippet

snippet omapi_host "Setup OMAPI hosts." b
- name: $1
	omapi_host:
		macaddr: ${2:# Sets the lease host MAC address.}
		key_name: ${3:# Sets the TSIG key name for authenticating against OMAPI server.}
		state: ${4:present|absent}
		key: ${5:# Sets the TSIG key content for authenticating against OMAPI server.}
		# statements: ${6:[]}
		# name: ${7:# Sets the host lease hostname (mandatory if state=present).}
		# host: ${8:localhost}
		# ddns: ${9:no}
		# ip: ${10:# Sets the lease host IP address.}
		# port: ${11:7911}
$0
endsnippet

snippet snmp_facts "Retrieve facts for a device using SNMP." b
- name: $1
	snmp_facts:
		host: ${2:# Set to target snmp server (normally {{inventory_hostname}})}
		version: ${3:v2|v2c|v3}
		# username: ${4:# Username for SNMPv3, required if version is v3}
		# level: ${5:authPriv|authNoPriv}
		# privacy: ${6:des|aes}
		# community: ${7:# The SNMP community string, required if version is v2/v2c}
		# authkey: ${8:# Authentication key, required if version is v3}
		# integrity: ${9:md5|sha}
		# privkey: ${10:# Encryption key, required if version is authPriv}
$0
endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node" b
- name: $1
	get_url:
		dest: ${2:# Absolute path of where to download the file to.}
		url: ${3:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		# force: ${4:no}
		# timeout: ${5:10}
		# validate_certs: ${6:yes}
		# selevel: ${7:s0}
		# force_basic_auth: ${8:no}
		# sha256sum: ${9:}
		# others: ${10:# all arguments accepted by the M(file) module also work here}
		# owner: ${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# client_key: ${12:# PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.}
		# url_password: ${13:# The password for use in HTTP basic authentication.}
		# group: ${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# use_proxy: ${15:yes}
		# headers: ${16:# Add custom HTTP headers to a request in the format "key:value,key:value".}
		# unsafe_writes: ${17:no}
		# checksum: ${18:}
		# seuser: ${19:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# setype: ${20:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# serole: ${21:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${22:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# url_username: ${23:# The username for use in HTTP basic authentication.}
		# attributes: ${24:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${25:no}
		# client_cert: ${26:# PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.}
		# tmp_dest: ${27:# Absolute path of where temporary file is downloaded to.}
$0
endsnippet

snippet slurp "Slurps a file from remote nodes" b
- name: $1
	slurp:
		src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory.}
$0
endsnippet

snippet uri "Interacts with webservices" b
- name: $1
	uri:
		url: ${2:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}
		# body: ${3:# The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.}
		# dest: ${4:# path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.}
		# follow_redirects: ${5:all|#safe|none}
		# force_basic_auth: ${6:no}
		# removes: ${7:# a filename, when it does not exist, this step will not be run.}
		# user: ${8:# username for the module to use for Digest, Basic or WSSE authentication.}
		# others: ${9:# all arguments accepted by the M(file) module also work here}
		# body_format: ${10:#raw|json}
		# password: ${11:# password for the module to use for Digest, Basic or WSSE authentication.}
		# HEADER_: ${12:# Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and may be removed in a future release. Use I(headers) instead.}
		# client_key: ${13:# PEM formatted file that contains your private key to be used for SSL client authentication. If I(client_cert) contains both the certificate and key, this option is not required.}
		# method: ${14:#GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH}
		# creates: ${15:# a filename, when it already exists, this step will not be run.}
		# headers: ${16:# Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) for I(body_format).}
		# timeout: ${17:30}
		# status_code: ${18:200}
		# return_content: ${19:no}
		# validate_certs: ${20:yes}
		# client_cert: ${21:# PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, I(client_key) is not required}
$0
endsnippet

snippet exo_dns_domain "Manages domain records on Exoscale DNS API." b
- name: $1
	exo_dns_domain:
		name: ${2:# Name of the record.}
		# state: ${3:#present|absent}
		# api_timeout: ${4:10}
		# api_secret: ${5:# Secret key of the Exoscale DNS API.}
		# api_key: ${6:# API key of the Exoscale DNS API.}
		# validate_certs: ${7:yes}
		# api_region: ${8:cloudstack}
$0
endsnippet

snippet exo_dns_record "Manages DNS records on Exoscale DNS." b
- name: $1
	exo_dns_record:
		domain: ${2:# Domain the record is related to.}
		# multiple: ${3:# Whether there are more than one records with similar C(name).}
		# name: ${4:}
		# prio: ${5:# Priority of the record.}
		# api_secret: ${6:# Secret key of the Exoscale DNS API.}
		# api_timeout: ${7:10}
		# api_region: ${8:cloudstack}
		# content: ${9:# Content of the record.}
		# record_type: ${10:#A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
		# state: ${11:#present|absent}
		# ttl: ${12:3600}
		# api_key: ${13:# API key of the Exoscale DNS API.}
		# validate_certs: ${14:yes}
$0
endsnippet

snippet infinity "manage Infinity IPAM using Rest API" b
- name: $1
	infinity:
		username: ${2:# Username to access Infinity}
		server_ip: ${3:# Infinity server_ip with IP address}
		action: ${4:reserve_next_available_ip|release_ip|delete_network|add_network|reserve_network|release_network|get_network_id}
		password: ${5:# Infinity password}
		# network_size: ${6:}
		# network_location: ${7:-1}
		# network_family: ${8:4|6|dual}
		# network_id: ${9:}
		# ip_address: ${10:}
		# network_address: ${11:}
		# network_name: ${12:}
		# network_type: ${13:#lan|shared_lan|supernet}
$0
endsnippet

snippet ldap_attr "Add or remove LDAP attribute values." b
- name: $1
	ldap_attr:
		dn: ${2:# The DN of the entry to modify.}
		name: ${3:# The name of the attribute to modify.}
		values: ${4:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}
		# server_uri: ${5:ldapi:///}
		# start_tls: ${6:yes|#no}
		# bind_dn: ${7:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
		# state: ${8:#present|absent|exact}
		# bind_pw: ${9:# The password to use with I(bind_dn).}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ldap_entry "Add or remove LDAP entries." b
- name: $1
	ldap_entry:
		dn: ${2:# The DN of the entry to add or remove.}
		# objectClass: ${3:# If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.}
		# start_tls: ${4:yes|#no}
		# bind_dn: ${5:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
		# server_uri: ${6:ldapi:///}
		# state: ${7:#present|absent}
		# params: ${8:# List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).}
		# bind_pw: ${9:# The password to use with I(bind_dn).}
		# attributes: ${10:# If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet a10_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' server object." b
- name: $1
	a10_server:
		username: ${2:# An account with administrator privileges.}
		server_name: ${3:# The SLB (Server Load Balancer) server name.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		password: ${5:# Password for the C(username) account.}
		# server_ip: ${6:# The SLB server IPv4 address.}
		# server_ports: ${7:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
		# partition: ${8:# set active-partition}
		# state: ${9:#present|absent}
		# server_status: ${10:#enabled|disabled}
		# write_config: ${11:yes|#no}
		# validate_certs: ${12:#yes|no}
$0
endsnippet

snippet a10_server_axapi3 "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices" b
- name: $1
	a10_server_axapi3:
		username: ${2:# An account with administrator privileges.}
		server_ip: ${3:# The SLB (Server Load Balancer) server IPv4 address.}
		server_name: ${4:# The SLB (Server Load Balancer) server name.}
		host: ${5:# Hostname or IP of the A10 Networks device.}
		password: ${6:# Password for the C(username) account.}
		# server_ports: ${7:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).}
		# server_status: ${8:#enable|disable}
		# write_config: ${9:yes|#no}
		# operation: ${10:#create|update|remove}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet a10_service_group "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' service groups." b
- name: $1
	a10_service_group:
		username: ${2:# An account with administrator privileges.}
		service_group: ${3:# The SLB (Server Load Balancing) service-group name}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		password: ${5:# Password for the C(username) account.}
		# partition: ${6:# set active-partition}
		# service_group_protocol: ${7:#tcp|udp}
		# servers: ${8:# A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.}
		# write_config: ${9:yes|#no}
		# service_group_method: ${10:#round-robin|weighted-rr|least-connection|weighted-least-connection|service-least-connection|service-weighted-least-connection|fastest-response|least-request|round-robin-strict|src-ip-only-hash|src-ip-hash}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet a10_virtual_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' virtual servers." b
- name: $1
	a10_virtual_server:
		username: ${2:# An account with administrator privileges.}
		virtual_server: ${3:# The SLB (Server Load Balancing) virtual server name.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		password: ${5:# Password for the C(username) account.}
		# partition: ${6:# set active-partition}
		# virtual_server_ports: ${7:# A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
		# virtual_server_status: ${8:enabled|disabled}
		# write_config: ${9:yes|#no}
		# virtual_server_ip: ${10:# The SLB virtual server IPv4 address.}
		# validate_certs: ${11:#yes|no}
$0
endsnippet

snippet aci_aep "Manage attachable Access Entity Profile (AEP) on Cisco ACI fabrics (infra:AttEntityP)" b
- name: $1
	aci_aep:
		username: ${2:admin}
		aep: ${3:# The name of the Attachable Access Entity Profile.}
		password: ${4:# The password to use for authentication.}
		hostname: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# state: ${6:absent|#present|query}
		# use_proxy: ${7:yes}
		# timeout: ${8:30}
		# use_ssl: ${9:yes}
		# validate_certs: ${10:yes}
		# description: ${11:# Description for the AEP.}
$0
endsnippet

snippet aci_ap "Manage top level Application Profile (AP) objects on Cisco ACI fabrics (fv:Ap)" b
- name: $1
	aci_ap:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		ap: ${4:# The name of the application network profile.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of an existing tenant.}
		# use_proxy: ${7:yes}
		# descr: ${8:# Description for the AP.}
		# state: ${9:absent|#present|query}
		# timeout: ${10:30}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet aci_bd "Manage Bridge Domains (BD) on Cisco ACI Fabrics (fv:BD)" b
- name: $1
	aci_bd:
		# bd: ${2:# The name of the Bridge Domain.}
		# arp_flooding: ${3:#False|True}
		# endpoint_retention_action: ${4:inherit|#resolve}
		# description: ${5:# Description for the Bridge Domain.}
		# l3_unknown_multicast: ${6:#flood|opt-flood}
		# enable_routing: ${7:False|#True}
		# vrf: ${8:# The name of the VRF.}
		# bd_type: ${9:#ethernet|fc}
		# ip_learning: ${10:False|True}
		# tenant: ${11:# The name of the Tenant.}
		# l2_unknown_unicast: ${12:#proxy|flood}
		# endpoint_retention_policy: ${13:# The name of the End Point Retention Policy the Bridge Domain should use when overriding the default End Point Retention Policy.}
		# multi_dest: ${14:#bd-flood|drop|encap-flood}
		# endpoint_clear: ${15:#False|True}
		# state: ${16:absent|#present|query}
		# ipv6_nd_policy: ${17:# The name of the IPv6 Neighbor Discovery Policy the Bridge Domain should use when overridding the default IPV6 ND Policy.}
		# igmp_snoop_policy: ${18:# The name of the IGMP Snooping Policy the Bridge Domain should use when overriding the default IGMP Snooping Policy.}
		# endpoint_move_detect: ${19:default|#garp}
		# enable_multicast: ${20:#False|True}
		# limit_ip_learn: ${21:False|#True}
$0
endsnippet

snippet aci_bd_subnet "Manage Subnets on Cisco ACI fabrics (fv:Subnet)" b
- name: $1
	aci_bd_subnet:
		# bd: ${2:# The name of the Bridge Domain.}
		# description: ${3:# The description for the Subnet.}
		# nd_prefix_policy: ${4:# The IPv6 Neighbor Discovery Prefix Policy to associate with the Subnet.}
		# enable_vip: ${5:#False|True}
		# mask: ${6:Any 0 to 32 for IPv4 Addresses|0-128 for IPv6 Addresses}
		# preferred: ${7:#False|True}
		# subnet_control: ${8:#nd_ra|no_gw|querier_ip|unspecified}
		# route_profile: ${9:# The Route Profile to the associate with the Subnet.}
		# route_profile_l3_out: ${10:# The L3 Out that contains the assocated Route Profile.}
		# scope: ${11:#private|public|shared}
		# gateway: ${12:# The IPv4 or IPv6 gateway address for the Subnet.}
		# tenant: ${13:# The name of the Tenant.}
		# subnet_name: ${14:# The name of the Subnet.}
$0
endsnippet

snippet aci_bd_to_l3out "Bind Bridge Domain to L3 Out on Cisco ACI fabrics (fv:RsBDToOut)" b
- name: $1
	aci_bd_to_l3out:
		# bd: ${2:# The name of the Bridge Domain.}
		# l3out: ${3:# The name of the l3out to associate with th Bridge Domain.}
		# state: ${4:absent|#present|query}
		# tenant: ${5:# The name of the Tenant.}
$0
endsnippet

snippet aci_config_rollback "Provides rollback and rollback preview functionality for Cisco ACI fabrics (config:ImportP)" b
- name: $1
	aci_config_rollback:
		username: ${2:admin}
		export_policy: ${3:# The export policy that the C(snapshot) is associated to.}
		password: ${4:# The password to use for authentication.}
		hostname: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		snapshot: ${6:# The name of the snapshot to rollback to, or the base snapshot to use for comparison.}
		# import_mode: ${7:#atomic|best-effort}
		# description: ${8:# The description for the Import Policy.}
		# compare_export_policy: ${9:# The export policy that the C(compare_snapshot) is associated to.}
		# import_policy: ${10:# The name of the Import Policy to use for config rollback.}
		# use_ssl: ${11:yes}
		# compare_snapshot: ${12:# The name of the snapshot to compare with C(snapshot).}
		# fail_on_decrypt: ${13:yes}
		# use_proxy: ${14:yes}
		# state: ${15:preview|#rollback}
		# timeout: ${16:30}
		# import_type: ${17:merge|#replace}
		# validate_certs: ${18:yes}
$0
endsnippet

snippet aci_config_snapshot "Manage Config Snapshots on Cisco ACI fabrics (config:Snapshot, config:ExportP)" b
- name: $1
	aci_config_snapshot:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# include_secure: ${5:no|#yes}
		# use_proxy: ${6:yes}
		# format: ${7:#json|xml}
		# export_policy: ${8:# The name of the Export Policy to use for Config Snapshots.}
		# max_count: ${9:range between 1 and 10}
		# state: ${10:absent|#present|query}
		# snapshot: ${11:# The name of the snapshot to delete.}
		# timeout: ${12:30}
		# use_ssl: ${13:yes}
		# validate_certs: ${14:yes}
		# description: ${15:# The description for the Config Export Policy.}
$0
endsnippet

snippet aci_contract "Manage contract resources on Cisco ACI fabrics (vz:BrCP)" b
- name: $1
	aci_contract:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		contract: ${4:# The name of the contract.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# priority: ${8:level1|level2|level3|#unspecified}
		# state: ${9:absent|#present|query}
		# dscp: ${10:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|#unspecified}
		# timeout: ${11:30}
		# scope: ${12:application-profile|#context|global|tenant}
		# use_ssl: ${13:yes}
		# validate_certs: ${14:yes}
		# description: ${15:# Description for the contract.}
$0
endsnippet

snippet aci_contract_subject "Manage initial Contract Subjects on Cisco ACI fabrics (vz:Subj)" b
- name: $1
	aci_contract_subject:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# description: ${5:# Description for the contract subject.}
		# dscp: ${6:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|#unspecified}
		# use_ssl: ${7:yes}
		# tenant: ${8:# The name of the tenant.}
		# subject: ${9:# The contract subject name.}
		# provider_match: ${10:all|#at_least_one|at_most_one|none}
		# use_proxy: ${11:yes}
		# consumer_match: ${12:all|#at_least_one|at_most_one|none}
		# contract: ${13:# The name of the Contract.}
		# priority: ${14:level1|level2|level3|#unspecified}
		# state: ${15:absent|#present|query}
		# timeout: ${16:30}
		# reverse_filter: ${17:#True|False}
		# validate_certs: ${18:yes}
$0
endsnippet

snippet aci_contract_subject_to_filter "Bind Contract Subjects to Filters on Cisco ACI fabrics (vz:RsSubjFiltAtt)" b
- name: $1
	aci_contract_subject_to_filter:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		tenant: ${5:# The name of the tenant.}
		# use_proxy: ${6:yes}
		# subject: ${7:# The name of the Contract Subject.}
		# contract: ${8:# The name of the contract.}
		# filter: ${9:# The name of the Filter to bind to the Subject.}
		# state: ${10:absent|#present|query}
		# timeout: ${11:30}
		# use_ssl: ${12:yes}
		# validate_certs: ${13:yes}
		# log: ${14:log|#none}
$0
endsnippet

snippet aci_epg "Manage End Point Groups (EPG) on Cisco ACI fabrics (fv:AEPg)" b
- name: $1
	aci_epg:
		username: ${2:admin}
		bd: ${3:# Name of the bridge domain being associated with the EPG.}
		ap: ${4:# Name of an existing application network profile, that will contain the EPGs.}
		password: ${5:# The password to use for authentication.}
		hostname: ${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
		epg: ${7:# Name of the end point group.}
		# description: ${8:# Description for the EPG.}
		# fwd_control: ${9:#none|proxy-arp}
		# use_ssl: ${10:yes}
		# intra_epg_isolation: ${11:enforced|#unenforced}
		# tenant: ${12:# Name of an existing tenant.}
		# use_proxy: ${13:yes}
		# priority: ${14:level1|level2|level3|#unspecified}
		# state: ${15:absent|#present|query}
		# timeout: ${16:30}
		# validate_certs: ${17:yes}
$0
endsnippet

snippet aci_epg_monitoring_policy "Manage monitoring policies on Cisco ACI fabrics (mon:EPGPol)" b
- name: $1
	aci_epg_monitoring_policy:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		monitoring_policy: ${4:# The name of the monitoring policy.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# Description for the monitoring policy.}
$0
endsnippet

snippet aci_epg_to_contract "Bind EPGs to Contracts on Cisco ACI fabrics (fv:RsCons and fv:RsProv)" b
- name: $1
	aci_epg_to_contract:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		contract_type: ${4:consumer|proivder}
		password: ${5:# The password to use for authentication.}
		# provider_match: ${6:all|#at_least_one|at_most_one|none}
		# use_proxy: ${7:yes}
		# contract: ${8:# The name of the contract.}
		# priority: ${9:level1|level2|level3|#unspecified}
		# ap: ${10:# Name of an existing application network profile, that will contain the EPGs.}
		# state: ${11:absent|#present|query}
		# timeout: ${12:30}
		# epg: ${13:# The name of the end point group.}
		# use_ssl: ${14:yes}
		# validate_certs: ${15:yes}
		# tenant: ${16:# Name of an existing tenant.}
$0
endsnippet

snippet aci_epg_to_domain "Bind EPGs to Domains on Cisco ACI fabrics (fv:RsDomAtt)" b
- name: $1
	aci_epg_to_domain:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# domain: ${5:# Name of the physical or virtual domain being associated with the EPG.}
		# encap: ${6:range from 1 to 4096}
		# allow_useg: ${7:#encap|useg}
		# domain_type: ${8:phys|vmm}
		# ap: ${9:# Name of an existing application network profile, that will contain the EPGs.}
		# encap_mode: ${10:#auto|vlan|vxlan}
		# use_ssl: ${11:yes}
		# vm_provider: ${12:microsoft|openstack|vmware}
		# resolution_immediacy: ${13:immediate|#lazy|pre-provision}
		# tenant: ${14:# Name of an existing tenant.}
		# use_proxy: ${15:yes}
		# deploy_immediacy: ${16:immediate|#lazy}
		# primary_encap: ${17:range from 1 to 4096}
		# state: ${18:absent|#present|query}
		# netflow: ${19:#disabled|enabled}
		# timeout: ${20:30}
		# epg: ${21:# Name of the end point group.}
		# validate_certs: ${22:yes}
$0
endsnippet

snippet aci_filter "Manages top level filter objects on Cisco ACI fabrics (vz:Filter)" b
- name: $1
	aci_filter:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		filter: ${4:# The name of the filter.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# Description for the filter.}
$0
endsnippet

snippet aci_filter_entry "Manage filter entries on Cisco ACI fabrics (vz:Entry)" b
- name: $1
	aci_filter_entry:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# dst_port_start: ${5:Valid TCP/UDP Port Ranges}
		# dst_port_end: ${6:Valid TCP/UDP Port Ranges}
		# description: ${7:# Description for the Filter Entry.}
		# icmp6_msg_type: ${8:dst_unreachable|echo_request|echo_reply|neighbor_advertisement|neighbor_solicitation|redirect|time_exceeded|#unspecified}
		# arp_flag: ${9:arp_reply|arp_request|#unspecified}
		# ip_protocol: ${10:eigrp|egp|icmp|icmpv6|igmp|igp|l2tp|ospfigp|pim|tcp|udp|#unspecified}
		# stateful: ${11:# Determines the statefulness of the filter entry.}
		# use_ssl: ${12:yes}
		# tenant: ${13:# The name of the tenant.}
		# ether_type: ${14:arp|fcoe|ip|mac_security|mpls_ucast|trill|#unspecified}
		# use_proxy: ${15:yes}
		# icmp_msg_type: ${16:dst_unreachable|echo|echo_reply|src_quench|time_exceeded|#unspecified}
		# filter: ${17:# T}
		# state: ${18:absent|#present|query}
		# dst_port: ${19:Valid TCP/UDP Port Ranges}
		# timeout: ${20:30}
		# entry: ${21:# Then name of the Filter Entry.}
		# validate_certs: ${22:yes}
$0
endsnippet

snippet aci_intf_policy_fc "Manage Fibre Channel interface policies on Cisco ACI fabrics (fc:IfPol)" b
- name: $1
	aci_intf_policy_fc:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		fc_policy: ${4:# The name of the Fiber Channel interface policy.}
		password: ${5:# The password to use for authentication.}
		# use_proxy: ${6:yes}
		# port_mode: ${7:#f|np}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# The description of the Fiber Channel interface policy.}
$0
endsnippet

snippet aci_intf_policy_l2 "Manage Layer 2 interface policies on Cisco ACI fabrics (l2:IfPol)" b
- name: $1
	aci_intf_policy_l2:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		l2_policy: ${4:# The name of the Layer 2 interface policy.}
		password: ${5:# The password to use for authentication.}
		# use_proxy: ${6:yes}
		# vlan_scope: ${7:#global|portlocal}
		# vepa: ${8:#disabled|enabled}
		# state: ${9:absent|#present|query}
		# qinq: ${10:core|#disabled|edge}
		# timeout: ${11:30}
		# use_ssl: ${12:yes}
		# validate_certs: ${13:yes}
		# description: ${14:# The description of the Layer 2 interface policy.}
$0
endsnippet

snippet aci_intf_policy_lldp "Manage LLDP interface policies on Cisco ACI fabrics (lldp:IfPol)" b
- name: $1
	aci_intf_policy_lldp:
		receive_state: ${2:disabled|#enabled}
		lldp_policy: ${3:# The LLDP interface policy name.}
		# transmit_state: ${4:disabled|#enabled}
		# description: ${5:# The description for the LLDP interface policy name.}
		# state: ${6:absent|#present|query}
$0
endsnippet

snippet aci_intf_policy_mcp "Manage MCP interface policies on Cisco ACI fabrics (mcp:IfPol)" b
- name: $1
	aci_intf_policy_mcp:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		mcp: ${4:# The name of the MCP interface.}
		password: ${5:# The password to use for authentication.}
		# use_proxy: ${6:yes}
		# state: ${7:absent|#present|query}
		# admin_state: ${8:disable|#enable}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# The description for the MCP interface.}
$0
endsnippet

snippet aci_intf_policy_port_channel "Manage port channel interface policies on Cisco ACI fabrics (lacp:LagPol)" b
- name: $1
	aci_intf_policy_port_channel:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		port_channel: ${4:# Name of the port channel.}
		hostname: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# description: ${6:# The description for the port channel.}
		# min_links: ${7:Ranges from 1 to 16}
		# use_ssl: ${8:yes}
		# fast_select: ${9:yes}
		# graceful_convergence: ${10:yes}
		# use_proxy: ${11:yes}
		# load_defer: ${12:no}
		# symmetric_hash: ${13:no}
		# suspend_individual: ${14:yes}
		# state: ${15:absent|#present|query}
		# mode: ${16:active|mac-pin|mac-pin-nicload|#False|passive}
		# timeout: ${17:30}
		# validate_certs: ${18:yes}
		# max_links: ${19:Ranges from 1 to 16}
$0
endsnippet

snippet aci_intf_policy_port_security "Manage port security on Cisco ACI fabrics (l2:PortSecurityPol)" b
- name: $1
	aci_intf_policy_port_security:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		port_security: ${4:# The name of the port security.}
		password: ${5:# The password to use for authentication.}
		# max_end_points: ${6:# Maximum number of end points (range 0-12000).}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# The description for the contract.}
$0
endsnippet

snippet aci_l3out_route_tag_policy "Manage route tag policies on Cisco ACI fabrics (l3ext:RouteTagPol)" b
- name: $1
	aci_l3out_route_tag_policy:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		rtp: ${4:# The name of the route tag policy.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# tag: ${9:4294967295}
		# timeout: ${10:30}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
		# description: ${13:# The description for the route tag policy.}
$0
endsnippet

snippet aci_rest "Direct access to the Cisco APIC REST API" b
- name: $1
	aci_rest:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		path: ${4:# URI being used to execute API calls.}
		password: ${5:# The password to use for authentication.}
		method: ${6:delete|#get|post}
		# src: ${7:# Name of the absolute path of the filname that includes the body of the http request being sent to the ACI fabric.}
		# use_proxy: ${8:yes}
		# content: ${9:# When used instead of C(src), sets the content of the API request directly.}
		# timeout: ${10:30}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet aci_taboo_contract "Manage taboo contracts on Cisco ACI fabrics (vz:BrCP)" b
- name: $1
	aci_taboo_contract:
		username: ${2:admin}
		taboo_contract: ${3:# The name of the Taboo Contract.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# scope: ${10:application-profile|#context|global|tenant}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
		# description: ${13:# The description for the Taboo Contract.}
$0
endsnippet

snippet aci_tenant "Manage tenants on Cisco ACI fabrics (fv:Tenant)" b
- name: $1
	aci_tenant:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		tenant: ${5:# The name of the tenant.}
		# state: ${6:absent|#present|query}
		# use_proxy: ${7:yes}
		# timeout: ${8:30}
		# use_ssl: ${9:yes}
		# validate_certs: ${10:yes}
		# description: ${11:# Description for the tenant.}
$0
endsnippet

snippet aci_tenant_action_rule_profile "Manage action rule profiles on Cisco ACI fabrics (rtctrl:AttrP)" b
- name: $1
	aci_tenant_action_rule_profile:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_proxy: ${5:yes}
		# action_rule: ${6:# The name of the action rule profile.}
		# state: ${7:absent|#present|query}
		# timeout: ${8:30}
		# use_ssl: ${9:yes}
		# validate_certs: ${10:yes}
		# tenant: ${11:# The name of the tenant.}
		# description: ${12:# The description for the action rule profile.}
$0
endsnippet

snippet aci_tenant_ep_retention_policy "Manage End Point (EP) retention protocol policies on Cisco ACI fabrics (fv:EpRetPol)" b
- name: $1
	aci_tenant_ep_retention_policy:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# description: ${5:# Description for the End point rentention policy.}
		# epr_policy: ${6:# The name of the end point retention policy.}
		# move_frequency: ${7:256}
		# use_ssl: ${8:yes}
		# remote_ep_interval: ${9:300}
		# bounce_age: ${10:630}
		# use_proxy: ${11:yes}
		# hold_interval: ${12:300}
		# bounce_trigger: ${13:coop}
		# state: ${14:absent|#present|query}
		# local_ep_interval: ${15:900}
		# tenant: ${16:# The name of an existing tenant.}
		# timeout: ${17:30}
		# validate_certs: ${18:yes}
$0
endsnippet

snippet aci_tenant_span_dst_group "Manage SPAN destination groups on Cisco ACI fabrics (span:DestGrp)" b
- name: $1
	aci_tenant_span_dst_group:
		username: ${2:admin}
		dst_group: ${3:# The name of the SPAN destination group.}
		hostname: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# use_proxy: ${7:yes}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# description: ${12:# The description of the SPAN destination group.}
$0
endsnippet

snippet aci_tenant_span_src_group "Manage SPAN source groups on Cisco ACI fabrics (span:SrcGrp)" b
- name: $1
	aci_tenant_span_src_group:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_proxy: ${5:yes}
		# dst_group: ${6:# The Span destination group to associate with the source group.}
		# src_group: ${7:# The name of the Span source group.}
		# state: ${8:absent|#present|query}
		# admin_state: ${9:#enabled|disabled}
		# timeout: ${10:30}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
		# tenant: ${13:# The name of the Tenant.}
		# description: ${14:# The description for Span source group.}
$0
endsnippet

snippet aci_tenant_span_src_group_to_dst_group "Manage SPAN source group to destination group bindings on Cisco ACI fabrics (span:SpanLbl)" b
- name: $1
	aci_tenant_span_src_group_to_dst_group:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_proxy: ${5:yes}
		# dst_group: ${6:# The Span destination group to associate with the source group.}
		# src_group: ${7:# The name of the Span source group.}
		# state: ${8:absent|#present|query}
		# timeout: ${9:30}
		# use_ssl: ${10:yes}
		# validate_certs: ${11:yes}
		# tenant: ${12:# The name of the Tenant.}
		# description: ${13:# The description for Span source group to destination group binding.}
$0
endsnippet

snippet aci_vrf "Manage VRF (private networks aka. contexts) on Cisco ACI fabrics (fv:Ctx)" b
- name: $1
	aci_vrf:
		username: ${2:admin}
		hostname: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_proxy: ${5:yes}
		# description: ${6:# The description for the VRF.}
		# policy_control_direction: ${7:egress|ingress}
		# state: ${8:absent|#present|query}
		# vrf: ${9:# The name of the VRF.}
		# timeout: ${10:30}
		# use_ssl: ${11:yes}
		# validate_certs: ${12:yes}
		# tenant: ${13:# The name of the Tenant the VRF should belong to.}
		# policy_control_preference: ${14:enforced|unenforced}
$0
endsnippet

snippet aireos_command "Run commands on remote devices running Cisco WLC" b
- name: $1
	aireos_command:
		commands: ${2:# List of commands to send to the remote aireos device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# interval: ${4:1}
		# provider: ${5:# A dict object containing connection details.}
		# wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${7:any|#all}
$0
endsnippet

snippet aireos_config "Manage Cisco WLC configurations" b
- name: $1
	aireos_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# diff_ignore_lines: ${3:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured. The commands must be the exact same commands as found in the device run-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# diff_against: ${6:intended|running}
		# intended_config: ${7:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
		# running_config: ${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# provider: ${9:# A dict object containing connection details.}
		# save: ${10:no}
		# backup: ${11:no}
		# match: ${12:#line|none}
		# before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet aos_asn_pool "Manage AOS ASN Pool" b
- name: $1
	aos_asn_pool:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# ranges: ${3:# List of ASNs ranges to add to the ASN Pool. Each range must have 2 values.}
		# content: ${4:# Datastructure of the ASN Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# state: ${5:#present|absent}
		# name: ${6:# Name of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
		# id: ${7:# AOS Id of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_blueprint "Manage AOS blueprint instance" b
- name: $1
	aos_blueprint:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# state: ${3:#present|absent|build-ready}
		# reference_arch: ${4:# When creating a blueprint, this value identifies a known AOS reference architecture value. I(Refer to AOS-server documentation for available values).}
		# name: ${5:# Name of the Blueprint to manage. Only one of I(name) or I(id) can be set.}
		# timeout: ${6:5}
		# id: ${7:# AOS Id of the IP Pool to manage (can't be used to create a new IP Pool). Only one of I(name) or I(id) can be set.}
		# template: ${8:# When creating a blueprint, this value identifies, by name, an existing engineering design template within the AOS-server.}
$0
endsnippet

snippet aos_blueprint_param "Manage AOS blueprint parameter values" b
- name: $1
	aos_blueprint_param:
		blueprint: ${2:# Blueprint Name or Id as defined in AOS.}
		session: ${3:# An existing AOS session as obtained by M(aos_login) module.}
		# state: ${4:#present|absent}
		# name: ${5:# Name of blueprint parameter, as defined by AOS design template. You can use the option I(get_param_list) to get the complete list of supported parameters for your blueprint.}
		# get_param_list: ${6:# Get the complete list of supported parameters for this blueprint and the description of those parameters.}
		# value: ${7:# Blueprint parameter value.  This value may be transformed by using the I(param_map) field; used when the blueprint parameter requires an AOS unique ID value.}
		# param_map: ${8:# Defines the aos-pyez collection that will is used to map the user-defined item name into the AOS unique ID value.  For example, if the caller provides an IP address pool I(param_value) called "Server-IpAddrs", then the aos-pyez collection is 'IpPools'. Some I(param_map) are already defined by default like I(logical_device_maps).}
$0
endsnippet

snippet aos_blueprint_virtnet "Manage AOS blueprint parameter values" b
- name: $1
	aos_blueprint_virtnet:
		blueprint: ${2:# Blueprint Name or Id as defined in AOS.}
		session: ${3:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${4:# Datastructure of the Virtual Network to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# state: ${5:#present|absent}
		# name: ${6:# Name of Virtual Network as part of the Blueprint.}
$0
endsnippet

snippet aos_device "Manage Devices on AOS Server" b
- name: $1
	aos_device:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# state: ${3:#normal}
		# name: ${4:# The device serial-number; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.}
		# approve: ${5:yes|#no}
		# id: ${6:# The AOS internal id for a device; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.}
		# location: ${7:# When approving a device using the I(approve) argument, it's possible define the location of the device.}
$0
endsnippet

snippet aos_external_router "Manage AOS External Router" b
- name: $1
	aos_external_router:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the External Router to create. The format is defined by the I(content_format) parameter. It's the same datastructure that is returned on success in I(value).}
		# state: ${4:#present|absent}
		# name: ${5:# Name of the External Router to manage. Only one of I(name), I(id) or I(content) can be set.}
		# loopback: ${6:# IP address of the Loopback interface of the external_router.}
		# asn: ${7:# ASN id of the external_router.}
		# id: ${8:# AOS Id of the External Router to manage (can't be used to create a new External Router), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_ip_pool "Manage AOS IP Pool" b
- name: $1
	aos_ip_pool:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the IP Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# subnets: ${4:# List of subnet that needs to be part of the IP Pool.}
		# state: ${5:#present|absent}
		# name: ${6:# Name of the IP Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
		# id: ${7:# AOS Id of the IP Pool to manage (can't be used to create a new IP Pool), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_logical_device "Manage AOS Logical Device" b
- name: $1
	aos_logical_device:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the Logical Device to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# state: ${4:#present|absent}
		# name: ${5:# Name of the Logical Device to manage. Only one of I(name), I(id) or I(content) can be set.}
		# id: ${6:# AOS Id of the Logical Device to manage (can't be used to create a new Logical Device), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_logical_device_map "Manage AOS Logical Device Map" b
- name: $1
	aos_logical_device_map:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the Logical Device Map to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value). Only one of I(name), I(id) or I(content) can be set.}
		# state: ${4:#present|absent}
		# name: ${5:# Name of the Logical Device Map to manage. Only one of I(name), I(id) or I(content) can be set.}
		# id: ${6:# AOS Id of the Logical Device Map to manage (can't be used to create a new Logical Device Map), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_login "Login to AOS server for session token" b
- name: $1
	aos_login:
		server: ${2:# Address of the AOS Server on which you want to open a connection.}
		# passwd: ${3:admin}
		# user: ${4:admin}
		# port: ${5:443}
$0
endsnippet

snippet aos_rack_type "Manage AOS Rack Type" b
- name: $1
	aos_rack_type:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the Rack Type to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# state: ${4:#present|absent}
		# name: ${5:# Name of the Rack Type to manage. Only one of I(name), I(id) or I(content) can be set.}
		# id: ${6:# AOS Id of the Rack Type to manage (can't be used to create a new Rack Type), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_template "Manage AOS Template" b
- name: $1
	aos_template:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		# content: ${3:# Datastructure of the Template to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		# state: ${4:#present|absent}
		# name: ${5:# Name of the Template to manage. Only one of I(name), I(id) or I(src) can be set.}
		# id: ${6:# AOS Id of the Template to manage (can't be used to create a new Template), Only one of I(name), I(id) or I(src) can be set.}
$0
endsnippet

snippet aruba_command "Run commands on remote devices running Aruba Mobility Controller" b
- name: $1
	aruba_command:
		commands: ${2:# List of commands to send to the remote aruba device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# interval: ${4:1}
		# provider: ${5:# A dict object containing connection details.}
		# wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${7:any|#all}
$0
endsnippet

snippet aruba_config "Manage Aruba configuration sections" b
- name: $1
	aruba_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# diff_ignore_lines: ${3:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# intended_config: ${6:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
		# diff_against: ${7:startup|intended|running}
		# replace: ${8:#line|block}
		# parents: ${9:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# provider: ${10:# A dict object containing connection details.}
		# running_config: ${11:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# save_when: ${12:always|#never|modified}
		# backup: ${13:no}
		# match: ${14:#line|strict|exact|none}
		# before: ${15:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet asa_acl "Manage access-lists on a Cisco ASA" b
- name: $1
	asa_acl:
		lines: ${2:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# authorize: ${3:yes|no}
		# force: ${4:yes|no}
		# after: ${5:# The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# replace: ${6:#line|block}
		# context: ${7:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		# provider: ${8:# A dict object containing connection details.}
		# config: ${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuruation to use as the base config for comparison.}
		# match: ${10:#line|strict|exact}
		# before: ${11:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet asa_command "Run arbitrary commands on Cisco ASA devices" b
- name: $1
	asa_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# authorize: ${3:yes|no}
		# retries: ${4:10}
		# interval: ${5:1}
		# context: ${6:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		# provider: ${7:# A dict object containing connection details.}
		# wait_for: ${8:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${9:any|#all}
$0
endsnippet

snippet asa_config "Manage configuration sections on Cisco ASA devices" b
- name: $1
	asa_config:
		# authorize: ${2:yes|no}
		# passwords: ${3:yes|no}
		# defaults: ${4:yes|no}
		# after: ${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# update: ${6:#merge|check}
		# replace: ${7:#line|block}
		# before: ${8:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system}
		# src: ${9:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# config: ${10:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		# lines: ${11:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# parents: ${12:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# context: ${13:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		# provider: ${14:# A dict object containing connection details.}
		# commit: ${15:#merge|check}
		# save: ${16:yes|no}
		# backup: ${17:yes|no}
		# match: ${18:#line|strict|exact|none}
$0
endsnippet

snippet avi_actiongroupconfig "Module for setup of ActionGroupConfig Avi RESTful Object" b
- name: $1
	avi_actiongroupconfig:
		external_only: ${2:# Generate alert only to external destinations.}
		name: ${3:# Name of the object.}
		level: ${4:# When an alert is generated, mark its priority via the alert level.}
		# username: ${5:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# snmp_trap_profile_ref: ${6:# Select the snmp trap notification to use when sending alerts via snmp trap.}
		# description: ${7:# User defined description for the object.}
		# autoscale_trigger_notification: ${8:# Trigger notification to autoscale manager.}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# email_config_ref: ${10:# Select the email notification configuration to use when sending alerts via email.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${12:admin}
		# uuid: ${13:# Unique object identifier of the object.}
		# url: ${14:# Avi controller URL of the object.}
		# syslog_config_ref: ${15:# Select the syslog notification configuration to use when sending alerts via syslog.}
		# tenant_ref: ${16:# It is a reference to an object of type tenant.}
		# action_script_config_ref: ${17:# Reference of the action script configuration to be used.}
		# state: ${18:absent|#present}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_alertconfig "Module for setup of AlertConfig Avi RESTful Object" b
- name: $1
	avi_alertconfig:
		category: ${2:# Determines whether an alert is raised immediately when event occurs (realtime) or after specified number of events occurs within rolling time}
		name: ${3:# Name of the alert configuration.}
		source: ${4:# Signifies system events or the type of client logsused in this alert configuration.}
		alert_rule: ${5:# List of filters matching on events or client logs used for triggering alerts.}
		# username: ${6:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${7:# A custom description field.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# object_type: ${9:# The object type to which the alert config is associated with.}
		# autoscale_alert: ${10:# This alert config applies to auto scale alerts.}
		# controller: ${11:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# obj_uuid: ${12:# Uuid of the resource for which alert was raised.}
		# recommendation: ${13:# Recommendation of alertconfig.}
		# threshold: ${14:# An alert is created only when the number of events meets or exceeds this number within the chosen time frame.}
		# expiry_time: ${15:# An alert is expired and deleted after the expiry time has elapsed.}
		# password: ${16:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${17:admin}
		# uuid: ${18:# Unique object identifier of the object.}
		# throttle: ${19:# Alerts are suppressed (throttled) for this duration of time since the last alert was raised for this alert config.}
		# url: ${20:# Avi controller URL of the object.}
		# enabled: ${21:# Enable or disable this alert config from generating new alerts.}
		# summary: ${22:# Summary of reason why alert is generated.}
		# rolling_window: ${23:# Only if the number of events is reached or exceeded within the time window will an alert be generated.}
		# state: ${24:absent|#present}
		# action_group_ref: ${25:# The alert config will trigger the selected alert action, which can send notifications and execute a controlscript.}
		# tenant_uuid: ${26:}
		# api_version: ${27:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_alertemailconfig "Module for setup of AlertEmailConfig Avi RESTful Object" b
- name: $1
	avi_alertemailconfig:
		to_emails: ${2:# Alerts are sent to the comma separated list of  email recipients.}
		name: ${3:# A user-friendly name of the email notification service.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${5:# Unique object identifier of the object.}
		# description: ${6:# User defined description for the object.}
		# url: ${7:# Avi controller URL of the object.}
		# cc_emails: ${8:# Alerts are copied to the comma separated list of  email recipients.}
		# tenant_ref: ${9:# It is a reference to an object of type tenant.}
		# state: ${10:absent|#present}
		# controller: ${11:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${12:# Avi API version of to use for Avi API and objects.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet avi_alertscriptconfig "Module for setup of AlertScriptConfig Avi RESTful Object" b
- name: $1
	avi_alertscriptconfig:
		name: ${2:# A user-friendly name of the script.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# action_script: ${4:# User defined alert action script.}
		# url: ${5:# Avi controller URL of the object.}
		# tenant_ref: ${6:# It is a reference to an object of type tenant.}
		# state: ${7:absent|#present}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${9:# Avi API version of to use for Avi API and objects.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${11:}
		# tenant: ${12:admin}
		# uuid: ${13:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_alertsyslogconfig "Module for setup of AlertSyslogConfig Avi RESTful Object" b
- name: $1
	avi_alertsyslogconfig:
		name: ${2:# A user-friendly name of the syslog notification.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Unique object identifier of the object.}
		# syslog_servers: ${5:# The list of syslog servers.}
		# description: ${6:# User defined description for alert syslog config.}
		# url: ${7:# Avi controller URL of the object.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# state: ${9:absent|#present}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
$0
endsnippet

snippet avi_analyticsprofile "Module for setup of AnalyticsProfile Avi RESTful Object" b
- name: $1
	avi_analyticsprofile:
		name: ${2:# The name of the analytics profile.}
		# disable_se_analytics: ${3:# Disable node (service engine) level analytics forvs metrics.}
		# apdex_server_rtt_tolerated_factor: ${4:# Tolerated client to avi round trip time(rtt) factor.}
		# hs_security_tls12_score: ${5:# Score assigned when supporting tls1.2 encryption protocol.}
		# exclude_no_dns_record_as_error: ${6:# Exclude queries to domains that did not have configured services/records from the list of errors.}
		# conn_server_lossy_zero_win_size_event_threshold: ${7:# A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.}
		# conn_lossy_total_rexmt_threshold: ${8:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.}
		# hs_pscore_traffic_threshold_l4_client: ${9:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
		# exclude_no_valid_gs_member_as_error: ${10:# Exclude queries to gslb services that have no available members from the list of errors.}
		# hs_security_cipherscore_ge128b: ${11:# Score assigned when the minimum cipher strength is greater than equal to 128 bits.}
		# uuid: ${12:# Uuid of the analytics profile.}
		# exclude_invalid_dns_domain_as_error: ${13:# Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.}
		# exclude_http_error_codes: ${14:# List of http status codes to be excluded from being classified as an error.}
		# hs_max_anomaly_penalty: ${15:# Maximum penalty that may be deducted from health score for anomalies.}
		# conn_server_lossy_ooo_threshold: ${16:# A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.}
		# exclude_persistence_change_as_error: ${17:# Exclude persistence server changed while load balancing' from the list of errors.}
		# hs_security_selfsignedcert_penalty: ${18:# Deprecated.}
		# conn_server_lossy_total_rexmt_threshold: ${19:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.}
		# username: ${20:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# hs_security_certscore_le30d: ${21:# Score assigned when the certificate expires in less than or equal to 30 days.}
		# exclude_syn_retransmit_as_error: ${22:# Exclude 'server unanswered syns' from the list of errors.}
		# controller: ${23:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# hs_security_hsts_penalty: ${24:# Penalty for not enabling hsts.}
		# hs_pscore_traffic_threshold_l4_server: ${25:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
		# password: ${26:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# conn_lossy_zero_win_size_event_threshold: ${27:# A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.}
		# hs_security_encalgo_score_rc4: ${28:# Score assigned when rc4 algorithm is used for encryption.}
		# apdex_rtt_threshold: ${29:# Satisfactory client to avi round trip time(rtt).}
		# tenant_ref: ${30:# It is a reference to an object of type tenant.}
		# apdex_response_tolerated_factor: ${31:# Client tolerated response latency factor.}
		# exclude_tcp_reset_as_error: ${32:# Exclude tcp resets by client from the list of potential errors.}
		# hs_max_security_penalty: ${33:# Maximum penalty that may be deducted from health score based on security assessment.}
		# exclude_invalid_dns_query_as_error: ${34:# Exclude invalid dns queries from the list of errors.}
		# conn_lossy_ooo_threshold: ${35:# A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.}
		# hs_security_cipherscore_lt128b: ${36:# Score assigned when the minimum cipher strength is less than 128 bits.}
		# tenant_uuid: ${37:}
		# hs_event_throttle_window: ${38:# Time window (in secs) within which only unique health change events should occur.}
		# hs_security_nonpfs_penalty: ${39:# Penalty for allowing non-pfs handshakes.}
		# hs_security_certscore_gt30d: ${40:# Score assigned when the certificate expires in more than 30 days.}
		# exclude_server_tcp_reset_as_error: ${41:# Exclude server tcp reset from errors.}
		# hs_min_dos_rate: ${42:# Dos connection rate below which the dos security assessment will not kick in.}
		# hs_max_resources_penalty: ${43:# Maximum penalty that may be deducted from health score for high resource utilization.}
		# client_log_streaming_config: ${44:# Configure to stream logs to an external server.}
		# apdex_server_response_threshold: ${45:# A server http response is considered satisfied if latency is less than the satisfactory latency threshold.}
		# hs_performance_boost: ${46:# Adds free performance score credits to health score.}
		# hs_security_ssl30_score: ${47:# Score assigned when supporting ssl3.0 encryption protocol.}
		# hs_security_tls11_score: ${48:# Score assigned when supporting tls1.1 encryption protocol.}
		# exclude_gs_down_as_error: ${49:# Exclude queries to gslb services that are operationally down from the list of errors.}
		# apdex_server_response_tolerated_factor: ${50:# Server tolerated response latency factor.}
		# state: ${51:absent|#present}
		# disable_server_analytics: ${52:# Disable analytics on backend servers.}
		# conn_server_lossy_timeo_rexmt_threshold: ${53:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
		# exclude_client_close_before_request_as_error: ${54:# Exclude client closed connection before an http request could be completed from being classified as an error.}
		# hs_security_weak_signature_algo_penalty: ${55:# Penalty for allowing weak signature algorithm(s).}
		# conn_lossy_timeo_rexmt_threshold: ${56:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
		# api_version: ${57:# Avi API version of to use for Avi API and objects.}
		# apdex_rtt_tolerated_factor: ${58:# Tolerated client to avi round trip time(rtt) factor.}
		# description: ${59:# User defined description for the object.}
		# client_log_config: ${60:# Configure which logs are sent to the avi controller from ses and how they are processed.}
		# apdex_rum_tolerated_factor: ${61:# Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.}
		# hs_security_cipherscore_eq000b: ${62:# Score assigned when the minimum cipher strength is 0 bits.}
		# ranges: ${63:# List of http status code ranges to be excluded from being classified as an error.}
		# apdex_server_rtt_threshold: ${64:# Satisfactory client to avi round trip time(rtt).}
		# exclude_server_dns_error_as_error: ${65:# Exclude server dns error response from the list of errors.}
		# hs_security_certscore_le07d: ${66:# Score assigned when the certificate expires in less than or equal to 7 days.}
		# resp_code_block: ${67:# Block of http response codes to be excluded from being classified as an error.}
		# hs_security_encalgo_score_none: ${68:# Score assigned when no algorithm is used for encryption.}
		# tenant: ${69:admin}
		# apdex_rum_threshold: ${70:# If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.}
		# hs_security_chain_invalidity_penalty: ${71:# Penalty for allowing certificates with invalid chain.}
		# url: ${72:# Avi controller URL of the object.}
		# hs_security_tls10_score: ${73:# Score assigned when supporting tls1.0 encryption protocol.}
		# hs_security_certscore_expired: ${74:# Score assigned when the certificate has expired.}
		# apdex_response_threshold: ${75:# If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.}
		# exclude_unsupported_dns_query_as_error: ${76:# Exclude unsupported dns queries from the list of errors.}
$0
endsnippet

snippet avi_api_session "Avi API Module" b
- name: $1
	avi_api_session:
		http_method: ${2:get|put|post|patch|delete}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# controller: ${4:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# params: ${5:# Query parameters passed to the HTTP API.}
		# api_version: ${6:# Avi API version of to use for Avi API and objects.}
		# timeout: ${7:# Timeout (in seconds) for Avi API calls.}
		# path: ${8:# Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# data: ${10:# HTTP body in YAML or JSON format.}
		# tenant_uuid: ${11:}
		# tenant: ${12:admin}
$0
endsnippet

snippet avi_applicationpersistenceprofile "Module for setup of ApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_applicationpersistenceprofile:
		name: ${2:# A user-friendly name for the persistence profile.}
		persistence_type: ${3:# Method used to persist clients to the same server for a duration of time or a session.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${5:# User defined description for the object.}
		# server_hm_down_recovery: ${6:# Specifies behavior when a persistent server has been marked down by a health monitor.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# ip_persistence_profile: ${8:# Specifies the client ip persistence profile parameters.}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# uuid: ${11:# Uuid of the persistence profile.}
		# app_cookie_persistence_profile: ${12:# Specifies the application cookie persistence profile parameters.}
		# tenant_ref: ${13:# It is a reference to an object of type tenant.}
		# is_federated: ${14:# This field describes the object's replication scope.}
		# http_cookie_persistence_profile: ${15:# Specifies the http cookie persistence profile parameters.}
		# url: ${16:# Avi controller URL of the object.}
		# state: ${17:absent|#present}
		# hdr_persistence_profile: ${18:# Specifies the custom http header persistence profile parameters.}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_applicationprofile "Module for setup of ApplicationProfile Avi RESTful Object" b
- name: $1
	avi_applicationprofile:
		name: ${2:# The name of the application profile.}
		type: ${3:# Specifies which application layer proxy is enabled for the virtual service.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${5:# User defined description for the object.}
		# http_profile: ${6:# Specifies the http application proxy profile parameters.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# dos_rl_profile: ${8:# Specifies various security related controls for virtual service.}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# preserve_client_ip: ${10:# Specifies if client ip needs to be preserved for backend connection.}
		# tenant: ${11:admin}
		# uuid: ${12:# Uuid of the application profile.}
		# tcp_app_profile: ${13:# Specifies the tcp application proxy profile parameters.}
		# dns_service_profile: ${14:# Specifies various dns service related controls for virtual service.}
		# tenant_ref: ${15:# It is a reference to an object of type tenant.}
		# url: ${16:# Avi controller URL of the object.}
		# state: ${17:absent|#present}
		# tenant_uuid: ${18:}
		# api_version: ${19:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_authprofile "Module for setup of AuthProfile Avi RESTful Object" b
- name: $1
	avi_authprofile:
		name: ${2:# Name of the auth profile.}
		type: ${3:# Type of the auth profile.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# http: ${5:# Http user authentication params.}
		# description: ${6:# User defined description for the object.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# tacacs_plus: ${8:# Tacacs+ settings.}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# uuid: ${11:# Uuid of the auth profile.}
		# url: ${12:# Avi controller URL of the object.}
		# tenant_ref: ${13:# It is a reference to an object of type tenant.}
		# state: ${14:absent|#present}
		# ldap: ${15:# Ldap server and directory settings.}
		# tenant_uuid: ${16:}
		# api_version: ${17:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_backup "Module for setup of Backup Avi RESTful Object" b
- name: $1
	avi_backup:
		file_name: ${2:# The file name of backup.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# scheduler_ref: ${4:# Scheduler information.}
		# local_file_url: ${5:# Url to download the backup file.}
		# remote_file_url: ${6:# Url to download the backup file.}
		# backup_config_ref: ${7:# Backupconfiguration information.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# uuid: ${11:# Unique object identifier of the object.}
		# url: ${12:# Avi controller URL of the object.}
		# tenant_ref: ${13:# It is a reference to an object of type tenant.}
		# state: ${14:absent|#present}
		# timestamp: ${15:# Unix timestamp of when the backup file is created.}
		# tenant_uuid: ${16:}
		# api_version: ${17:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_backupconfiguration "Module for setup of BackupConfiguration Avi RESTful Object" b
- name: $1
	avi_backupconfiguration:
		name: ${2:# Name of backup configuration.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# backup_passphrase: ${4:# Passphrase of backup configuration.}
		# controller: ${5:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${6:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${7:admin}
		# uuid: ${8:# Unique object identifier of the object.}
		# ssh_user_ref: ${9:# Access credentials for remote destination.}
		# url: ${10:# Avi controller URL of the object.}
		# tenant_ref: ${11:# It is a reference to an object of type tenant.}
		# remote_hostname: ${12:# Remote destination.}
		# state: ${13:absent|#present}
		# remote_directory: ${14:# Directory at remote destination with write permission for ssh user.}
		# maximum_backups_stored: ${15:# Rotate the backup files based on this count.}
		# upload_to_remote_host: ${16:# Remote backup.}
		# backup_file_prefix: ${17:# Prefix of the exported configuration file.}
		# tenant_uuid: ${18:}
		# api_version: ${19:# Avi API version of to use for Avi API and objects.}
		# save_local: ${20:# Local backup.}
$0
endsnippet

snippet avi_certificatemanagementprofile "Module for setup of CertificateManagementProfile Avi RESTful Object" b
- name: $1
	avi_certificatemanagementprofile:
		name: ${2:# Name of the pki profile.}
		script_path: ${3:# Script_path of certificatemanagementprofile.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# script_params: ${5:# List of customparams.}
		# url: ${6:# Avi controller URL of the object.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
		# uuid: ${14:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_cloud "Module for setup of Cloud Avi RESTful Object" b
- name: $1
	avi_cloud:
		vtype: ${2:# Cloud type.}
		name: ${3:# Name of the object.}
		# vca_configuration: ${4:# Vcloudairconfiguration settings for cloud.}
		# proxy_configuration: ${5:# Proxyconfiguration settings for cloud.}
		# docker_configuration: ${6:# Dockerconfiguration settings for cloud.}
		# oshiftk8s_configuration: ${7:# Oshiftk8sconfiguration settings for cloud.}
		# mtu: ${8:# Mtu setting for the cloud.}
		# rancher_configuration: ${9:# Rancherconfiguration settings for cloud.}
		# uuid: ${10:# Unique object identifier of the object.}
		# linuxserver_configuration: ${11:# Linuxserverconfiguration settings for cloud.}
		# nsx_configuration: ${12:# Configuration parameters for nsx manager.}
		# state: ${13:absent|#present}
		# apic_mode: ${14:# Boolean flag to set apic_mode.}
		# dns_provider_ref: ${15:# Dns profile for the cloud.}
		# api_version: ${16:# Avi API version of to use for Avi API and objects.}
		# username: ${17:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# mesos_configuration: ${18:# Mesosconfiguration settings for cloud.}
		# openstack_configuration: ${19:# Openstackconfiguration settings for cloud.}
		# enable_vip_static_routes: ${20:# Use static routes for vip side network resolution during virtualservice placement.}
		# controller: ${21:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# aws_configuration: ${22:# Awsconfiguration settings for cloud.}
		# cloudstack_configuration: ${23:# Cloudstackconfiguration settings for cloud.}
		# password: ${24:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${25:admin}
		# ipam_provider_ref: ${26:# Ipam profile for the cloud.}
		# url: ${27:# Avi controller URL of the object.}
		# tenant_ref: ${28:# It is a reference to an object of type tenant.}
		# dhcp_enabled: ${29:# Select the ip address management scheme.}
		# east_west_ipam_provider_ref: ${30:# Ipam profile for east-west services.}
		# obj_name_prefix: ${31:# Default prefix for all automatically created objects in this cloud.}
		# apic_configuration: ${32:# Apicconfiguration settings for cloud.}
		# prefer_static_routes: ${33:# Prefer static routes over interface routes during virtualservice placement.}
		# license_type: ${34:# If no license type is specified then default license enforcement for the cloud type is chosen.}
		# vcenter_configuration: ${35:# Vcenterconfiguration settings for cloud.}
		# tenant_uuid: ${36:}
		# east_west_dns_provider_ref: ${37:# Dns profile for east-west services.}
$0
endsnippet

snippet avi_cloudconnectoruser "Module for setup of CloudConnectorUser Avi RESTful Object" b
- name: $1
	avi_cloudconnectoruser:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# public_key: ${4:# Public_key of cloudconnectoruser.}
		# private_key: ${5:# Private_key of cloudconnectoruser.}
		# url: ${6:# Avi controller URL of the object.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
		# uuid: ${14:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_cloudproperties "Module for setup of CloudProperties Avi RESTful Object" b
- name: $1
	avi_cloudproperties:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# info: ${3:# Properties specific to a cloud type.}
		# uuid: ${4:# Unique object identifier of the object.}
		# hyp_props: ${5:# Hypervisor properties.}
		# url: ${6:# Avi controller URL of the object.}
		# state: ${7:absent|#present}
		# cc_vtypes: ${8:# Cloud types supported by cloudconnector.}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
		# cc_props: ${14:# Cloudconnector properties.}
$0
endsnippet

snippet avi_cluster "Module for setup of Cluster Avi RESTful Object" b
- name: $1
	avi_cluster:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# rejoin_nodes_automatically: ${4:# Re-join cluster nodes automatically in the event one of the node is reset to factory.}
		# virtual_ip: ${5:# A virtual ip address.}
		# url: ${6:# Avi controller URL of the object.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# nodes: ${11:# List of clusternode.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
		# uuid: ${15:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_controllerproperties "Module for setup of ControllerProperties Avi RESTful Object" b
- name: $1
	avi_controllerproperties:
		# vs_se_ping_fail: ${2:# Number of vs_se_ping_fail.}
		# vs_se_create_fail: ${3:# Number of vs_se_create_fail.}
		# portal_token: ${4:# Token used for uploading tech-support to portal.}
		# warmstart_se_reconnect_wait_time: ${5:# Number of warmstart_se_reconnect_wait_time.}
		# persistence_key_rotate_period: ${6:# Allowed values are 1-1051200.}
		# unresponsive_se_reboot: ${7:# Number of unresponsive_se_reboot.}
		# attach_ip_retry_interval: ${8:# Number of attach_ip_retry_interval.}
		# vs_se_vnic_fail: ${9:# Number of vs_se_vnic_fail.}
		# attach_ip_retry_limit: ${10:# Number of attach_ip_retry_limit.}
		# se_vnic_cooldown: ${11:# Number of se_vnic_cooldown.}
		# vnic_op_fail_time: ${12:# Number of vnic_op_fail_time.}
		# max_pcap_per_tenant: ${13:# Maximum number of pcap files stored per tenant.}
		# vs_se_bootup_fail: ${14:# Number of vs_se_bootup_fail.}
		# seupgrade_fabric_pool_size: ${15:# Pool size used for all fabric commands during se upgrade.}
		# vs_key_rotate_period: ${16:# Allowed values are 1-1051200.}
		# seupgrade_segroup_min_dead_timeout: ${17:# Time to wait before marking segroup upgrade as stuck.}
		# dns_refresh_period: ${18:# Number of dns_refresh_period.}
		# upgrade_lease_time: ${19:# Number of upgrade_lease_time.}
		# se_create_timeout: ${20:# Number of se_create_timeout.}
		# query_host_fail: ${21:# Number of query_host_fail.}
		# vs_apic_scaleout_timeout: ${22:# Time to wait for the scaled out se to become ready before marking the scaleout done, applies to apic configuration only.}
		# state: ${23:absent|#present}
		# se_offline_del: ${24:# Number of se_offline_del.}
		# max_dead_se_in_grp: ${25:# Number of max_dead_se_in_grp.}
		# upgrade_dns_ttl: ${26:# Time to account for dns ttl during upgrade.}
		# fatal_error_lease_time: ${27:# Number of fatal_error_lease_time.}
		# api_version: ${28:# Avi API version of to use for Avi API and objects.}
		# username: ${29:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# allow_ip_forwarding: ${30:# Field introduced in 17.1.1.}
		# max_seq_vnic_failures: ${31:# Number of max_seq_vnic_failures.}
		# allow_unauthenticated_nodes: ${32:# Boolean flag to set allow_unauthenticated_nodes.}
		# allow_unauthenticated_apis: ${33:# Allow unauthenticated access for special apis.}
		# controller: ${34:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# vs_awaiting_se_timeout: ${35:# Number of vs_awaiting_se_timeout.}
		# cluster_ip_gratuitous_arp_period: ${36:# Number of cluster_ip_gratuitous_arp_period.}
		# password: ${37:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${38:admin}
		# uuid: ${39:# Unique object identifier of the object.}
		# dummy: ${40:# Number of dummy.}
		# secure_channel_cleanup_timeout: ${41:# Number of secure_channel_cleanup_timeout.}
		# vs_se_vnic_ip_fail: ${42:# Number of vs_se_vnic_ip_fail.}
		# ssl_certificate_expiry_warning_days: ${43:# Number of days for ssl certificate expiry warning.}
		# secure_channel_se_token_timeout: ${44:# Number of secure_channel_se_token_timeout.}
		# url: ${45:# Avi controller URL of the object.}
		# secure_channel_controller_token_timeout: ${46:# Number of secure_channel_controller_token_timeout.}
		# api_idle_timeout: ${47:# Allowed values are 0-1440.}
		# crashed_se_reboot: ${48:# Number of crashed_se_reboot.}
		# appviewx_compat_mode: ${49:# Export configuration in appviewx compatibility mode.}
		# se_failover_attempt_interval: ${50:# Interval between attempting failovers to an se.}
		# dead_se_detection_timer: ${51:# Number of dead_se_detection_timer.}
		# tenant_uuid: ${52:}
$0
endsnippet

snippet avi_dnspolicy "Module for setup of DnsPolicy Avi RESTful Object" b
- name: $1
	avi_dnspolicy:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${3:# Uuid of the dns policy.}
		# description: ${4:# Field introduced in 17.1.1.}
		# url: ${5:# Avi controller URL of the object.}
		# created_by: ${6:# Creator name.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# rule: ${9:# Dns rules.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
		# name: ${15:# Name of the dns policy.}
$0
endsnippet

snippet avi_gslb "Module for setup of Gslb Avi RESTful Object" b
- name: $1
	avi_gslb:
		name: ${2:# Name for the gslb object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# User defined description for the object.}
		# view_id: ${5:# The view-id is used in maintenance mode to differentiate partitioned groups while they havethe same gslb namespace.}
		# third_party_sites: ${6:# Third party site member belonging to this gslb.}
		# sites: ${7:# Select avi site member belonging to this gslb.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# dns_configs: ${9:# Sub domain configuration for the gslb.}
		# leader_cluster_uuid: ${10:# Mark this site as leader of gslb configuration.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${12:admin}
		# uuid: ${13:# Uuid of the gslb object.}
		# url: ${14:# Avi controller URL of the object.}
		# tenant_ref: ${15:# It is a reference to an object of type tenant.}
		# is_federated: ${16:# This field indicates that this object is replicated across gslb federation.}
		# clear_on_max_retries: ${17:# Max retries after which the remote site is treatedas a fresh start.}
		# state: ${18:absent|#present}
		# send_interval: ${19:# Frequency with which group members communicate.}
		# client_ip_addr_group: ${20:# Group to specify if the client ip addresses are public or private.}
		# tenant_uuid: ${21:}
		# api_version: ${22:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_gslbapplicationpersistenceprofile "Module for setup of GslbApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_gslbapplicationpersistenceprofile:
		name: ${2:# A user-friendly name for the persistence profile.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the persistence profile.}
		# url: ${5:# Avi controller URL of the object.}
		# tenant_ref: ${6:# It is a reference to an object of type tenant.}
		# state: ${7:absent|#present}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${9:# Avi API version of to use for Avi API and objects.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${11:}
		# tenant: ${12:admin}
		# description: ${13:# Field introduced in 17.1.1.}
$0
endsnippet

snippet avi_gslbgeodbprofile "Module for setup of GslbGeoDbProfile Avi RESTful Object" b
- name: $1
	avi_gslbgeodbprofile:
		name: ${2:# A user-friendly name for the geodb profile.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the geodb profile.}
		# state: ${5:absent|#present}
		# url: ${6:# Avi controller URL of the object.}
		# description: ${7:# Field introduced in 17.1.1.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# is_federated: ${9:# This field indicates that this object is replicated across gslb federation.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# entries: ${12:# List of geodb entries.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet avi_gslbhealthmonitor "Module for setup of GslbHealthMonitor Avi RESTful Object" b
- name: $1
	avi_gslbhealthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# https_monitor: ${5:# Healthmonitorhttp settings for gslbhealthmonitor.}
		# receive_timeout: ${6:# A valid response from the server is expected within the receive timeout window.}
		# description: ${7:# User defined description for the object.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# udp_monitor: ${9:# Healthmonitorudp settings for gslbhealthmonitor.}
		# http_monitor: ${10:# Healthmonitorhttp settings for gslbhealthmonitor.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${12:admin}
		# successful_checks: ${13:# Number of continuous successful health checks before server is marked up.}
		# monitor_port: ${14:# Use this port instead of the port defined for the server in the pool.}
		# uuid: ${15:# Uuid of the health monitor.}
		# url: ${16:# Avi controller URL of the object.}
		# dns_monitor: ${17:# Healthmonitordns settings for gslbhealthmonitor.}
		# tenant_ref: ${18:# It is a reference to an object of type tenant.}
		# failed_checks: ${19:# Number of continuous failed health checks before the server is marked down.}
		# tcp_monitor: ${20:# Healthmonitortcp settings for gslbhealthmonitor.}
		# state: ${21:absent|#present}
		# send_interval: ${22:# Frequency, in seconds, that monitors are sent to a server.}
		# external_monitor: ${23:# Healthmonitorexternal settings for gslbhealthmonitor.}
		# tenant_uuid: ${24:}
		# api_version: ${25:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_gslbservice "Module for setup of GslbService Avi RESTful Object" b
- name: $1
	avi_gslbservice:
		name: ${2:# Name for the gslb service.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# User defined description for the object.}
		# wildcard_match: ${5:# Enable wild-card match of fqdn  if an exact match is not found in the dns table, the longest match is chosen by wild-carding the fqdn in the dns}
		# enabled: ${6:# Enable or disable the gslb service.}
		# domain_names: ${7:# Fully qualified domain name of the gslb service.}
		# is_federated: ${8:# This field indicates that this object is replicated across gslb federation.}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# groups: ${10:# Select list of pools belonging to this gslb service.}
		# ttl: ${11:# Ttl value (in seconds) for records served for this gslb service by the dns service.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# health_monitor_scope: ${13:# Health monitor probe can be executed for all the members or it can be executed only for third-party members.}
		# tenant: ${14:admin}
		# uuid: ${15:# Uuid of the gslb service.}
		# controller_health_status_enabled: ${16:# Gs member's overall health status is derived based on a combination of controller and datapath health-status inputs.}
		# url: ${17:# Avi controller URL of the object.}
		# down_response: ${18:# Response to the client query when the gslb service is down.}
		# tenant_ref: ${19:# It is a reference to an object of type tenant.}
		# use_edns_client_subnet: ${20:# Use the client ip subnet from the edns option as source ipaddress for client geo-location and consistent hash algorithm.}
		# created_by: ${21:# Creator name.}
		# health_monitor_refs: ${22:# Verify vs health by applying one or more health monitors.}
		# state: ${23:absent|#present}
		# num_dns_ip: ${24:# Number of ip addresses of this gslb service to be returned by the dns service.}
		# tenant_uuid: ${25:}
		# api_version: ${26:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_hardwaresecuritymodulegroup "Module for setup of HardwareSecurityModuleGroup Avi RESTful Object" b
- name: $1
	avi_hardwaresecuritymodulegroup:
		hsm: ${2:# Hardware security module configuration.}
		name: ${3:# Name of the hsm group configuration object.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${5:# Uuid of the hsm group configuration object.}
		# url: ${6:# Avi controller URL of the object.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
$0
endsnippet

snippet avi_healthmonitor "Module for setup of HealthMonitor Avi RESTful Object" b
- name: $1
	avi_healthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# https_monitor: ${5:# Healthmonitorhttp settings for healthmonitor.}
		# receive_timeout: ${6:# A valid response from the server is expected within the receive timeout window.}
		# description: ${7:# User defined description for the object.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# udp_monitor: ${9:# Healthmonitorudp settings for healthmonitor.}
		# http_monitor: ${10:# Healthmonitorhttp settings for healthmonitor.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${12:admin}
		# successful_checks: ${13:# Number of continuous successful health checks before server is marked up.}
		# monitor_port: ${14:# Use this port instead of the port defined for the server in the pool.}
		# uuid: ${15:# Uuid of the health monitor.}
		# url: ${16:# Avi controller URL of the object.}
		# dns_monitor: ${17:# Healthmonitordns settings for healthmonitor.}
		# tenant_ref: ${18:# It is a reference to an object of type tenant.}
		# is_federated: ${19:# This field describes the object's replication scope.}
		# failed_checks: ${20:# Number of continuous failed health checks before the server is marked down.}
		# tcp_monitor: ${21:# Healthmonitortcp settings for healthmonitor.}
		# state: ${22:absent|#present}
		# send_interval: ${23:# Frequency, in seconds, that monitors are sent to a server.}
		# external_monitor: ${24:# Healthmonitorexternal settings for healthmonitor.}
		# tenant_uuid: ${25:}
		# api_version: ${26:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_httppolicyset "Module for setup of HTTPPolicySet Avi RESTful Object" b
- name: $1
	avi_httppolicyset:
		name: ${2:# Name of the http policy set.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# User defined description for the object.}
		# controller: ${5:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# http_security_policy: ${6:# Http security policy for the virtual service.}
		# password: ${7:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${8:admin}
		# uuid: ${9:# Uuid of the http policy set.}
		# url: ${10:# Avi controller URL of the object.}
		# tenant_ref: ${11:# It is a reference to an object of type tenant.}
		# created_by: ${12:# Creator name.}
		# state: ${13:absent|#present}
		# cloud_config_cksum: ${14:# Checksum of cloud configuration for pool.}
		# http_request_policy: ${15:# Http request policy for the virtual service.}
		# http_response_policy: ${16:# Http response policy for the virtual service.}
		# tenant_uuid: ${17:}
		# api_version: ${18:# Avi API version of to use for Avi API and objects.}
		# is_internal_policy: ${19:# Boolean flag to set is_internal_policy.}
$0
endsnippet

snippet avi_ipaddrgroup "Module for setup of IpAddrGroup Avi RESTful Object" b
- name: $1
	avi_ipaddrgroup:
		name: ${2:# Name of the ip address group.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# marathon_app_name: ${4:# Populate ip addresses from tasks of this marathon app.}
		# description: ${5:# User defined description for the object.}
		# marathon_service_port: ${6:# Task port associated with marathon service port.}
		# ranges: ${7:# Configure ip address range(s).}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# addrs: ${9:# Configure ip address(es).}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${11:admin}
		# country_codes: ${12:# Populate the ip address ranges from the geo database for this country.}
		# uuid: ${13:# Uuid of the ip address group.}
		# url: ${14:# Avi controller URL of the object.}
		# tenant_ref: ${15:# It is a reference to an object of type tenant.}
		# apic_epg_name: ${16:# Populate ip addresses from members of this cisco apic epg.}
		# prefixes: ${17:# Configure ip address prefix(es).}
		# state: ${18:absent|#present}
		# ip_ports: ${19:# Configure (ip address, port) tuple(s).}
		# tenant_uuid: ${20:}
		# api_version: ${21:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_ipamdnsproviderprofile "Module for setup of IpamDnsProviderProfile Avi RESTful Object" b
- name: $1
	avi_ipamdnsproviderprofile:
		name: ${2:# Name for the ipam/dns provider profile.}
		type: ${3:# Provider type for the ipam/dns provider profile.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# proxy_configuration: ${5:# Field introduced in 17.1.1.}
		# infoblox_profile: ${6:# Provider details if type is infoblox.}
		# internal_profile: ${7:# Provider details if type is avi.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# aws_profile: ${9:# Provider details if type is aws.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${11:admin}
		# uuid: ${12:# Uuid of the ipam/dns provider profile.}
		# openstack_profile: ${13:# Provider details if type is openstack.}
		# gcp_profile: ${14:# Provider details if type is google cloud.}
		# url: ${15:# Avi controller URL of the object.}
		# tenant_ref: ${16:# It is a reference to an object of type tenant.}
		# custom_profile: ${17:# Provider details if type is custom.}
		# state: ${18:absent|#present}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_microservicegroup "Module for setup of MicroServiceGroup Avi RESTful Object" b
- name: $1
	avi_microservicegroup:
		name: ${2:# Name of the microservice group.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the microservice group.}
		# description: ${5:# User defined description for the object.}
		# url: ${6:# Avi controller URL of the object.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# created_by: ${9:# Creator name.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# service_refs: ${12:# Configure microservice(es).}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet avi_network "Module for setup of Network Avi RESTful Object" b
- name: $1
	avi_network:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# dhcp_enabled: ${4:# Select the ip address management scheme for this network.}
		# exclude_discovered_subnets: ${5:# When selected, excludes all discovered subnets in this network from consideration for virtual service placement.}
		# controller: ${6:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${7:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${8:admin}
		# uuid: ${9:# Unique object identifier of the object.}
		# configured_subnets: ${10:# List of subnet.}
		# vrf_context_ref: ${11:# It is a reference to an object of type vrfcontext.}
		# cloud_ref: ${12:# It is a reference to an object of type cloud.}
		# tenant_ref: ${13:# It is a reference to an object of type tenant.}
		# synced_from_se: ${14:# Boolean flag to set synced_from_se.}
		# vimgrnw_ref: ${15:# It is a reference to an object of type vimgrnwruntime.}
		# url: ${16:# Avi controller URL of the object.}
		# state: ${17:absent|#present}
		# vcenter_dvs: ${18:# Boolean flag to set vcenter_dvs.}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_networkprofile "Module for setup of NetworkProfile Avi RESTful Object" b
- name: $1
	avi_networkprofile:
		profile: ${2:# Networkprofileunion settings for networkprofile.}
		name: ${3:# The name of the network profile.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${5:# Uuid of the network profile.}
		# description: ${6:# User defined description for the object.}
		# url: ${7:# Avi controller URL of the object.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# state: ${9:absent|#present}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
$0
endsnippet

snippet avi_networksecuritypolicy "Module for setup of NetworkSecurityPolicy Avi RESTful Object" b
- name: $1
	avi_networksecuritypolicy:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${3:# Unique object identifier of the object.}
		# description: ${4:# User defined description for the object.}
		# rules: ${5:# List of networksecurityrule.}
		# tenant_ref: ${6:# It is a reference to an object of type tenant.}
		# state: ${7:absent|#present}
		# created_by: ${8:# Creator name.}
		# url: ${9:# Avi controller URL of the object.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# cloud_config_cksum: ${11:# Checksum of cloud configuration for network sec policy.}
		# api_version: ${12:# Avi API version of to use for Avi API and objects.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
		# name: ${16:# Name of the object.}
$0
endsnippet

snippet avi_pkiprofile "Module for setup of PKIProfile Avi RESTful Object" b
- name: $1
	avi_pkiprofile:
		name: ${2:# Name of the pki profile.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# crls: ${4:# Certificate revocation lists.}
		# ignore_peer_chain: ${5:# When enabled, avi will not trust intermediate and root certs presented by a client.}
		# validate_only_leaf_crl: ${6:# When enabled, avi will only validate the revocation status of the leaf certificate using crl.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${8:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${9:admin}
		# uuid: ${10:# Unique object identifier of the object.}
		# url: ${11:# Avi controller URL of the object.}
		# tenant_ref: ${12:# It is a reference to an object of type tenant.}
		# is_federated: ${13:# This field describes the object's replication scope.}
		# created_by: ${14:# Creator name.}
		# state: ${15:absent|#present}
		# ca_certs: ${16:# List of certificate authorities (root and intermediate) trusted that is used for certificate validation.}
		# crl_check: ${17:# When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.}
		# tenant_uuid: ${18:}
		# api_version: ${19:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_pool "Module for setup of Pool Avi RESTful Object" b
- name: $1
	avi_pool:
		name: ${2:# The name of the pool.}
		# lb_algorithm: ${3:# The load balancing algorithm will pick a server within the pool's list of available servers.}
		# use_service_port: ${4:# Do not translate the client's destination port when sending the connection to the server.}
		# rewrite_host_header_to_server_name: ${5:# Rewrite incoming host header to server name of the server to which the request is proxied.}
		# host_check_enabled: ${6:# Enable common name check for server certificate.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# rewrite_host_header_to_sni: ${8:# If sni server name is specified, rewrite incoming host header to the sni server name.}
		# capacity_estimation: ${9:# Inline estimation of capacity of servers.}
		# max_conn_rate_per_server: ${10:# Rate limit connections to each server.}
		# servers: ${11:# The pool directs load balanced traffic to this list of destination servers.}
		# fewest_tasks_feedback_delay: ${12:# Periodicity of feedback for fewest tasks server selection algorithm.}
		# server_auto_scale: ${13:# Server autoscale.}
		# east_west: ${14:# Inherited config from virtualservice.}
		# ab_pool: ${15:# A/b pool configuration.}
		# capacity_estimation_ttfb_thresh: ${16:# The maximum time-to-first-byte of a server.}
		# fail_action: ${17:# Enable an action - close connection, http redirect or local http response - when a pool failure happens.}
		# placement_networks: ${18:# Manually select the networks and subnets used to provide reachability to the pool's servers.}
		# networks: ${19:# (internal-use) networks designated as containing servers for this pool.}
		# lb_algorithm_hash: ${20:# Criteria used as a key for determining the hash between the client and  server.}
		# sni_enabled: ${21:# Enable tls sni for server connections.}
		# server_name: ${22:# Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.}
		# lb_algorithm_consistent_hash_hdr: ${23:# Http header name to be used for the hash key.}
		# cloud_ref: ${24:# It is a reference to an object of type cloud.}
		# lb_algorithm_core_nonaffinity: ${25:# Degree of non-affinity for core afffinity based server selection.}
		# autoscale_policy_ref: ${26:# Reference to server autoscale policy.}
		# ssl_profile_ref: ${27:# When enabled, avi re-encrypts traffic to the backend servers.}
		# ipaddrgroup_ref: ${28:# Use list of servers from ip address group.}
		# apic_epg_name: ${29:# Synchronize cisco apic epg members with pool servers.}
		# server_reselect: ${30:# Server reselect configuration for http requests.}
		# state: ${31:absent|#present}
		# nsx_securitygroup: ${32:# A list of nsx service groups where the servers for the pool are created.}
		# a_pool: ${33:# Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.}
		# pki_profile_ref: ${34:# Avi will validate the ssl certificate present by a server against the selected pki profile.}
		# api_version: ${35:# Avi API version of to use for Avi API and objects.}
		# vrf_ref: ${36:# Virtual routing context that the pool is bound to.}
		# username: ${37:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# application_persistence_profile_ref: ${38:# Persistence will ensure the same user sticks to the same server for a desired duration of time.}
		# inline_health_monitor: ${39:# The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.}
		# default_server_port: ${40:# Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.}
		# description: ${41:# A description of the pool.}
		# request_queue_depth: ${42:# Minimum number of requests to be queued when pool is full.}
		# graceful_disable_timeout: ${43:# Used to gracefully disable a server.}
		# domain_name: ${44:# Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.}
		# ab_priority: ${45:# Priority of this pool in a a-b pool pair.}
		# connection_ramp_duration: ${46:# Duration for which new connections will be gradually ramped up to a server recently brought online.}
		# controller: ${47:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${48:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# server_count: ${49:# Number of server_count.}
		# tenant: ${50:admin}
		# uuid: ${51:# Uuid of the pool.}
		# request_queue_enabled: ${52:# Enable request queue when pool is full.}
		# max_concurrent_connections_per_server: ${53:# The maximum number of concurrent connections allowed to each server within the pool.}
		# url: ${54:# Avi controller URL of the object.}
		# autoscale_launch_config_ref: ${55:# If configured then avi will trigger orchestration of pool server creation and deletion.}
		# enabled: ${56:# Enable or disable the pool.}
		# autoscale_networks: ${57:# Network ids for the launch configuration.}
		# health_monitor_refs: ${58:# Verify server health by applying one or more health monitors.}
		# ssl_key_and_certificate_ref: ${59:# Service engines will present a client ssl certificate to the server.}
		# cloud_config_cksum: ${60:# Checksum of cloud configuration for pool.}
		# external_autoscale_groups: ${61:# Names of external auto-scale groups for pool servers.}
		# tenant_uuid: ${62:}
		# created_by: ${63:# Creator name.}
		# prst_hdr_name: ${64:# Header name for custom header persistence.}
$0
endsnippet

snippet avi_poolgroup "Module for setup of PoolGroup Avi RESTful Object" b
- name: $1
	avi_poolgroup:
		name: ${2:# The name of the pool group.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# Description of pool group.}
		# controller: ${5:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# members: ${6:# List of pool group members object of type poolgroupmember.}
		# fail_action: ${7:# Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.}
		# password: ${8:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${9:admin}
		# uuid: ${10:# Uuid of the pool group.}
		# priority_labels_ref: ${11:# Uuid of the priority labels.}
		# cloud_ref: ${12:# It is a reference to an object of type cloud.}
		# tenant_ref: ${13:# It is a reference to an object of type tenant.}
		# created_by: ${14:# Name of the user who created the object.}
		# deployment_policy_ref: ${15:# When setup autoscale manager will automatically promote new pools into production when deployment goals are met.}
		# url: ${16:# Avi controller URL of the object.}
		# state: ${17:absent|#present}
		# cloud_config_cksum: ${18:# Checksum of cloud configuration for poolgroup.}
		# min_servers: ${19:# The minimum number of servers to distribute traffic to.}
		# tenant_uuid: ${20:}
		# api_version: ${21:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_poolgroupdeploymentpolicy "Module for setup of PoolGroupDeploymentPolicy Avi RESTful Object" b
- name: $1
	avi_poolgroupdeploymentpolicy:
		name: ${2:# The name of the pool group deployment policy.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# target_test_traffic_ratio: ${4:# Target traffic ratio before pool is made production.}
		# evaluation_duration: ${5:# Duration of evaluation period for automatic deployment.}
		# description: ${6:# User defined description for the object.}
		# test_traffic_ratio_rampup: ${7:# Ratio of the traffic that is sent to the pool under test.}
		# rules: ${8:# List of pgdeploymentrule.}
		# auto_disable_old_prod_pools: ${9:# It will automatically disable old production pools once there is a new production candidate.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# webhook_ref: ${11:# Webhook configured with url that avi controller will pass back information about pool group, old and new pool information and current deployment}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${13:admin}
		# uuid: ${14:# Uuid of the pool group deployment policy.}
		# cloud_ref: ${15:# It is a reference to an object of type cloud.}
		# tenant_ref: ${16:# It is a reference to an object of type tenant.}
		# url: ${17:# Avi controller URL of the object.}
		# state: ${18:absent|#present}
		# scheme: ${19:# Deployment scheme.}
		# tenant_uuid: ${20:}
		# api_version: ${21:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_prioritylabels "Module for setup of PriorityLabels Avi RESTful Object" b
- name: $1
	avi_prioritylabels:
		name: ${2:# The name of the priority labels.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the priority labels.}
		# description: ${5:# A description of the priority labels.}
		# cloud_ref: ${6:# It is a reference to an object of type cloud.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# url: ${9:# Avi controller URL of the object.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# equivalent_labels: ${12:# Equivalent priority labels in descending order.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet avi_role "Module for setup of Role Avi RESTful Object" b
- name: $1
	avi_role:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Unique object identifier of the object.}
		# url: ${5:# Avi controller URL of the object.}
		# privileges: ${6:# List of permission.}
		# tenant_ref: ${7:# It is a reference to an object of type tenant.}
		# state: ${8:absent|#present}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
$0
endsnippet

snippet avi_scheduler "Module for setup of Scheduler Avi RESTful Object" b
- name: $1
	avi_scheduler:
		name: ${2:# Name of scheduler.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# tenant_ref: ${4:# It is a reference to an object of type tenant.}
		# backup_config_ref: ${5:# Backup configuration to be executed by this scheduler.}
		# controller: ${6:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# frequency: ${7:# Frequency at which custom scheduler will run.}
		# scheduler_action: ${8:# Define scheduler action.}
		# end_date_time: ${9:# Scheduler end date and time.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${11:admin}
		# uuid: ${12:# Unique object identifier of the object.}
		# start_date_time: ${13:# Scheduler start date and time.}
		# url: ${14:# Avi controller URL of the object.}
		# enabled: ${15:# Boolean flag to set enabled.}
		# frequency_unit: ${16:# Unit at which custom scheduler will run.}
		# state: ${17:absent|#present}
		# run_script_ref: ${18:# Control script to be executed by this scheduler.}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
		# run_mode: ${21:# Scheduler run mode.}
$0
endsnippet

snippet avi_seproperties "Module for setup of SeProperties Avi RESTful Object" b
- name: $1
	avi_seproperties:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# se_agent_properties: ${3:# Seagentproperties settings for seproperties.}
		# uuid: ${4:# Unique object identifier of the object.}
		# url: ${5:# Avi controller URL of the object.}
		# se_runtime_properties: ${6:# Seruntimeproperties settings for seproperties.}
		# state: ${7:absent|#present}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# se_bootup_properties: ${9:# Sebootupproperties settings for seproperties.}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${12:}
		# tenant: ${13:admin}
$0
endsnippet

snippet avi_serverautoscalepolicy "Module for setup of ServerAutoScalePolicy Avi RESTful Object" b
- name: $1
	avi_serverautoscalepolicy:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# use_predicted_load: ${4:# Use predicted load rather than current load.}
		# intelligent_autoscale: ${5:# Use avi intelligent autoscale algorithm where autoscale is performed by comparing load on the pool against estimated capacity of all the servers.}
		# description: ${6:# User defined description for the object.}
		# intelligent_scaleout_margin: ${7:# Minimum extra capacity as percentage of load used by the intelligent scheme.}
		# scaleout_alertconfig_refs: ${8:# Trigger scaleout when alerts due to any of these alert configurations are raised.}
		# min_size: ${9:# No scale-in happens once number of operationally up servers reach min_servers.}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# scalein_cooldown: ${11:# Cooldown period during which no new scalein is triggered to allow previous scalein to successfully complete.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${13:admin}
		# uuid: ${14:# Unique object identifier of the object.}
		# scaleout_cooldown: ${15:# Cooldown period during which no new scaleout is triggered to allow previous scaleout to successfully complete.}
		# intelligent_scalein_margin: ${16:# Maximum extra capacity as percentage of load used by the intelligent scheme.}
		# url: ${17:# Avi controller URL of the object.}
		# tenant_ref: ${18:# It is a reference to an object of type tenant.}
		# max_scalein_adjustment_step: ${19:# Maximum number of servers to scalein simultaneously.}
		# state: ${20:absent|#present}
		# scalein_alertconfig_refs: ${21:# Trigger scalein when alerts due to any of these alert configurations are raised.}
		# max_size: ${22:# Maximum number of servers after scaleout.}
		# max_scaleout_adjustment_step: ${23:# Maximum number of servers to scaleout simultaneously.}
		# tenant_uuid: ${24:}
		# api_version: ${25:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_serviceengine "Module for setup of ServiceEngine Avi RESTful Object" b
- name: $1
	avi_serviceengine:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# enable_state: ${3:# Inorder to disable se set this field appropriately.}
		# mgmt_vnic: ${4:# Vnic settings for serviceengine.}
		# data_vnics: ${5:# List of vnic.}
		# controller_created: ${6:# Boolean flag to set controller_created.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# flavor: ${8:# Flavor of serviceengine.}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# name: ${11:# Name of the object.}
		# uuid: ${12:# Unique object identifier of the object.}
		# cloud_ref: ${13:# It is a reference to an object of type cloud.}
		# hypervisor: ${14:# Enum options - default, vmware_esx, kvm, vmware_vsan, xen.}
		# se_group_ref: ${15:# It is a reference to an object of type serviceenginegroup.}
		# container_mode: ${16:# Boolean flag to set container_mode.}
		# tenant_ref: ${17:# It is a reference to an object of type tenant.}
		# container_type: ${18:# Enum options - container_type_bridge, container_type_host, container_type_host_dpdk.}
		# host_ref: ${19:# It is a reference to an object of type vimgrhostruntime.}
		# url: ${20:# Avi controller URL of the object.}
		# state: ${21:absent|#present}
		# resources: ${22:# Seresources settings for serviceengine.}
		# availability_zone: ${23:# Availability_zone of serviceengine.}
		# controller_ip: ${24:# Controller_ip of serviceengine.}
		# tenant_uuid: ${25:}
		# api_version: ${26:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_serviceenginegroup "Module for setup of ServiceEngineGroup Avi RESTful Object" b
- name: $1
	avi_serviceenginegroup:
		name: ${2:# Name of the object.}
		# floating_intf_ip: ${3:# If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.}
		# host_attribute_value: ${4:# Value of a (key, value) pair identifying a label for a set of nodes usually in container clouds.}
		# async_ssl: ${5:# Ssl handshakes will be handled by dedicated ssl threads.}
		# instance_flavor: ${6:# Instance/flavor type for se instance.}
		# auto_redistribute_active_standby_load: ${7:# Redistribution of virtual services from the takeover se to the replacement se can cause momentary traffic loss.}
		# auto_rebalance: ${8:# If set, virtual services will be automatically migrated when load on an se is less than minimum or more than maximum thresholds.}
		# se_tunnel_mode: ${9:# Determines if dsr from secondary se is active or not.}
		# uuid: ${10:# Unique object identifier of the object.}
		# extra_config_multiplier: ${11:# Multiplier for extra config to support large vs/pool config.}
		# se_tunnel_udp_port: ${12:# Udp port for tunneled packets from secondary to primary se in docker bridge mode.}
		# vs_scalein_timeout: ${13:# Time to wait for the scaled in se to drain existing flows before marking the scalein done.}
		# mgmt_subnet: ${14:# Management subnet to use for avi service engines.}
		# se_remote_punt_udp_port: ${15:# Udp port for punted packets in docker bridge mode.}
		# se_udp_encap_ipc: ${16:# Determines if se-se ipc messages are encapsulated in an udp header.}
		# min_cpu_usage: ${17:# When cpu usage on an se falls below the minimum threshold, virtual services hosted on the se may be consolidated onto other underutilized ses.}
		# custom_securitygroups_data: ${18:# Custom security groups to be associated with data vnics for se instances in openstack and aws clouds.}
		# vcenter_clusters: ${19:# Vcenterclusters settings for serviceenginegroup.}
		# enable_vip_on_all_interfaces: ${20:# Enable vip on all interfaces of se.}
		# active_standby: ${21:# Service engines in active/standby mode for ha failover.}
		# username: ${22:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# max_vs_per_se: ${23:# Maximum number of virtual services that can be placed on a single service engine.}
		# connection_memory_percentage: ${24:# Percentage of memory for connection state.}
		# service_ip_subnets: ${25:# Subnets assigned to the se group.}
		# placement_mode: ${26:# If placement mode is 'auto', virtual services are automatically placed on service engines.}
		# max_scaleout_per_vs: ${27:# Maximum number of active service engines for the virtual service.}
		# os_reserved_memory: ${28:# Amount of extra memory to be reserved for use by the operating system on a service engine.}
		# enable_routing: ${29:# Enable routing for this serviceenginegroup .}
		# controller: ${30:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# per_app: ${31:# Per-app se mode is designed for deploying dedicated load balancers per app (vs).}
		# vcenter_datastores_include: ${32:# Boolean flag to set vcenter_datastores_include.}
		# password: ${33:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# se_vs_hb_max_pkts_in_batch: ${34:# Maximum number of aggregated vs heartbeat packets to send in a batch.}
		# tenant_ref: ${35:# It is a reference to an object of type tenant.}
		# host_attribute_key: ${36:# Key of a (key, value) pair identifying a label for a set of nodes usually in container clouds.}
		# url: ${37:# Avi controller URL of the object.}
		# max_se: ${38:# Maximum number of services engines in this group.}
		# hypervisor: ${39:# Override default hypervisor.}
		# cpu_reserve: ${40:# Boolean flag to set cpu_reserve.}
		# se_dos_profile: ${41:# Dosthresholdprofile settings for serviceenginegroup.}
		# enable_vmac: ${42:# Use virtual mac address for interfaces on which floating interface ips are placed.}
		# tenant_uuid: ${43:}
		# iptables: ${44:# Iptable rules.}
		# udf_log_throttle: ${45:# This setting limits the number of udf logs generated per second per core on this se.}
		# vcenter_hosts: ${46:# Vcenterhosts settings for serviceenginegroup.}
		# se_ipc_udp_port: ${47:# Udp port for se_dp ipc in docker bridge mode.}
		# vcpus_per_se: ${48:# Number of vcpus for each of the service engine virtual machines.}
		# hm_on_standby: ${49:# Enable active health monitoring from the standby se for all placed virtual services.}
		# disk_per_se: ${50:# Amount of disk space for each of the service engine virtual machines.}
		# cpu_socket_affinity: ${51:# Allocate all the cpu cores for the service engine virtual machines  on the same cpu socket.}
		# realtime_se_metrics: ${52:# Enable or disable real time se metrics.}
		# archive_shm_limit: ${53:# Amount of se memory in gb until which shared memory is collected in core archive.}
		# hardwaresecuritymodulegroup_ref: ${54:# It is a reference to an object of type hardwaresecuritymodulegroup.}
		# custom_securitygroups_mgmt: ${55:# Custom security groups to be associated with management vnic for se instances in openstack and aws clouds.}
		# custom_tag: ${56:# Custom tag will be used to create the tags for se instance in aws.}
		# floating_intf_ip_se_2: ${57:# If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.}
		# log_disksz: ${58:# Maximum disk capacity (in mb) to be allocated to an se.}
		# non_significant_log_throttle: ${59:# This setting limits the number of non-significant logs generated per second per core on this se.}
		# distribute_load_active_standby: ${60:# Use both the active and standby service engines for virtual service placement in the legacy active standby ha mode.}
		# cloud_ref: ${61:# It is a reference to an object of type cloud.}
		# extra_shared_config_memory: ${62:# Extra config memory to support large geo db configuration.}
		# auto_rebalance_interval: ${63:# Frequency of rebalance, if 'auto rebalance' is enabled.}
		# buffer_se: ${64:# Excess service engine capacity provisioned for ha failover.}
		# vcenter_datastores: ${65:# List of vcenterdatastore.}
		# state: ${66:absent|#present}
		# vs_scaleout_timeout: ${67:# Time to wait for the scaled out se to become ready before marking the scaleout done.}
		# openstack_availability_zones: ${68:# Field introduced in 17.1.1.}
		# mgmt_network_ref: ${69:# Management network to use for avi service engines.}
		# num_flow_cores_sum_changes_to_ignore: ${70:# Number of changes in num flow cores sum to ignore.}
		# api_version: ${71:# Avi API version of to use for Avi API and objects.}
		# se_thread_multiplier: ${72:# Multiplier for se threads based on vcpu.}
		# openstack_mgmt_network_name: ${73:# Avi management network name.}
		# async_ssl_threads: ${74:# Number of async ssl threads per se_dp.}
		# description: ${75:# User defined description for the object.}
		# openstack_mgmt_network_uuid: ${76:# Management network uuid.}
		# vcenter_folder: ${77:# Folder to place all the service engine virtual machines in vcenter.}
		# vs_scalein_timeout_for_upgrade: ${78:# During se upgrade, time to wait for the scaled-in se to drain existing flows before marking the scalein done.}
		# se_deprovision_delay: ${79:# Duration to preserve unused service engine virtual machines before deleting them.}
		# se_vs_hb_max_vs_in_pkt: ${80:# Maximum number of virtualservices for which heartbeat messages are aggregated in one packet.}
		# advertise_backend_networks: ${81:# Advertise reach-ability of backend server networks via adc through bgp for default gateway feature.}
		# tenant: ${82:admin}
		# memory_per_se: ${83:# Amount of memory for each of the service engine virtual machines.}
		# max_cpu_usage: ${84:# When cpu usage on an se exceeds this threshold, virtual services hosted on this se may be rebalanced to other ses to reduce load.}
		# min_scaleout_per_vs: ${85:# Minimum number of active service engines for the virtual service.}
		# se_name_prefix: ${86:# Prefix to use for virtual machine name of service engines.}
		# mem_reserve: ${87:# Boolean flag to set mem_reserve.}
		# ha_mode: ${88:# High availability mode for all the virtual services using this service engine group.}
		# vcenter_datastore_mode: ${89:# Enum options - vcenter_datastore_any, vcenter_datastore_local, vcenter_datastore_shared.}
		# openstack_availability_zone: ${90:# Field deprecated in 17.1.1.}
		# least_load_core_selection: ${91:# Select core with least load for new flow.}
		# aggressive_failure_detection: ${92:# Enable aggressive failover configuration for ha.}
		# significant_log_throttle: ${93:# This setting limits the number of significant logs generated per second per core on this se.}
		# dedicated_dispatcher_core: ${94:# Dedicate the core that handles packet receive/transmit from the network to just the dispatching function.}
		# algo: ${95:# In compact placement, virtual services are placed on existing ses until max_vs_per_se limit is reached.}
		# vs_host_redundancy: ${96:# Ensure primary and secondary service engines are deployed on different physical hosts.}
$0
endsnippet

snippet avi_snmptrapprofile "Module for setup of SnmpTrapProfile Avi RESTful Object" b
- name: $1
	avi_snmptrapprofile:
		name: ${2:# A user-friendly name of the snmp trap configuration.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# url: ${4:# Avi controller URL of the object.}
		# tenant_ref: ${5:# It is a reference to an object of type tenant.}
		# state: ${6:absent|#present}
		# trap_servers: ${7:# The ip address or hostname of the snmp trap destination server.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${9:# Avi API version of to use for Avi API and objects.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${11:}
		# tenant: ${12:admin}
		# uuid: ${13:# Uuid of the snmp trap profile object.}
$0
endsnippet

snippet avi_sslkeyandcertificate "Module for setup of SSLKeyAndCertificate Avi RESTful Object" b
- name: $1
	avi_sslkeyandcertificate:
		name: ${2:# Name of the object.}
		certificate: ${3:# Sslcertificate settings for sslkeyandcertificate.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# status: ${5:# Enum options - ssl_certificate_finished, ssl_certificate_pending.}
		# certificate_management_profile_ref: ${6:# It is a reference to an object of type certificatemanagementprofile.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# key: ${8:# Private key.}
		# key_params: ${9:# Sslkeyparams settings for sslkeyandcertificate.}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${11:admin}
		# uuid: ${12:# Unique object identifier of the object.}
		# enckey_base64: ${13:# Encrypted private key corresponding to the private key (e.g.}
		# dynamic_params: ${14:# Dynamic parameters needed for certificate management profile.}
		# url: ${15:# Avi controller URL of the object.}
		# enckey_name: ${16:# Name of the encrypted private key (e.g.}
		# tenant_ref: ${17:# It is a reference to an object of type tenant.}
		# hardwaresecuritymodulegroup_ref: ${18:# It is a reference to an object of type hardwaresecuritymodulegroup.}
		# created_by: ${19:# Creator name.}
		# state: ${20:absent|#present}
		# ca_certs: ${21:# Ca certificates in certificate chain.}
		# type: ${22:# Enum options - ssl_certificate_type_virtualservice, ssl_certificate_type_system, ssl_certificate_type_ca.}
		# tenant_uuid: ${23:}
		# api_version: ${24:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_sslprofile "Module for setup of SSLProfile Avi RESTful Object" b
- name: $1
	avi_sslprofile:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# accepted_ciphers: ${4:# Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).}
		# prefer_client_cipher_ordering: ${5:# Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.}
		# description: ${6:# User defined description for the object.}
		# tags: ${7:# List of tag.}
		# accepted_versions: ${8:# Set of versions accepted by the server.}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${11:admin}
		# uuid: ${12:# Unique object identifier of the object.}
		# ssl_session_timeout: ${13:# The amount of time before an ssl session expires.}
		# url: ${14:# Avi controller URL of the object.}
		# tenant_ref: ${15:# It is a reference to an object of type tenant.}
		# cipher_enums: ${16:# Enum options - tls_ecdhe_ecdsa_with_aes_128_gcm_sha256, tls_ecdhe_ecdsa_with_aes_256_gcm_sha384, tls_ecdhe_rsa_with_aes_128_gcm_sha256,}
		# enable_ssl_session_reuse: ${17:# Enable ssl session re-use.}
		# state: ${18:absent|#present}
		# send_close_notify: ${19:# Send 'close notify' alert message for a clean shutdown of the ssl connection.}
		# dhparam: ${20:# Dh parameters used in ssl.}
		# ssl_rating: ${21:# Sslrating settings for sslprofile.}
		# tenant_uuid: ${22:}
		# api_version: ${23:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_stringgroup "Module for setup of StringGroup Avi RESTful Object" b
- name: $1
	avi_stringgroup:
		type: ${2:# Type of stringgroup.}
		name: ${3:# Name of the string group.}
		# username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${5:# Uuid of the string group.}
		# description: ${6:# User defined description for the object.}
		# url: ${7:# Avi controller URL of the object.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# state: ${9:absent|#present}
		# controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# password: ${12:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# kv: ${13:# Configure key value in the string group.}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet avi_systemconfiguration "Module for setup of SystemConfiguration Avi RESTful Object" b
- name: $1
	avi_systemconfiguration:
		# username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# docker_mode: ${3:# Boolean flag to set docker_mode.}
		# dns_configuration: ${4:# Dnsconfiguration settings for systemconfiguration.}
		# proxy_configuration: ${5:# Proxyconfiguration settings for systemconfiguration.}
		# ssh_hmacs: ${6:# Allowed hmac list for ssh to the management interface on the controller and service engines.}
		# controller: ${7:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# portal_configuration: ${8:# Portalconfiguration settings for systemconfiguration.}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# email_configuration: ${11:# Emailconfiguration settings for systemconfiguration.}
		# uuid: ${12:# Unique object identifier of the object.}
		# snmp_configuration: ${13:# Snmpconfiguration settings for systemconfiguration.}
		# url: ${14:# Avi controller URL of the object.}
		# linux_configuration: ${15:# Linuxconfiguration settings for systemconfiguration.}
		# global_tenant_config: ${16:# Tenantconfiguration settings for systemconfiguration.}
		# dns_virtualservice_refs: ${17:# Dns virtualservices hosting fqdn records for applications across avi vantage.}
		# state: ${18:absent|#present}
		# ntp_configuration: ${19:# Ntpconfiguration settings for systemconfiguration.}
		# admin_auth_configuration: ${20:# Adminauthconfiguration settings for systemconfiguration.}
		# mgmt_ip_access_control: ${21:# Configure ip access control for controller to restrict open access.}
		# ssh_ciphers: ${22:# Allowed ciphers list for ssh to the management interface on the controller and service engines.}
		# tenant_uuid: ${23:}
		# api_version: ${24:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_tenant "Module for setup of Tenant Avi RESTful Object" b
- name: $1
	avi_tenant:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# url: ${4:# Avi controller URL of the object.}
		# description: ${5:# User defined description for the object.}
		# state: ${6:absent|#present}
		# created_by: ${7:# Creator of this tenant.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# config_settings: ${9:# Tenantconfiguration settings for tenant.}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# local: ${12:# Boolean flag to set local.}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
		# uuid: ${15:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_trafficcloneprofile "Module for setup of TrafficCloneProfile Avi RESTful Object" b
- name: $1
	avi_trafficcloneprofile:
		name: ${2:# Name for the traffic clone profile.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the traffic clone profile.}
		# cloud_ref: ${5:# It is a reference to an object of type cloud.}
		# tenant_ref: ${6:# It is a reference to an object of type tenant.}
		# state: ${7:absent|#present}
		# url: ${8:# Avi controller URL of the object.}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${10:# Avi API version of to use for Avi API and objects.}
		# password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# preserve_client_ip: ${12:# Specifies if client ip needs to be preserved to clone destination.}
		# tenant_uuid: ${13:}
		# tenant: ${14:admin}
		# clone_servers: ${15:# Field introduced in 17.1.1.}
$0
endsnippet

snippet avi_useraccountprofile "Module for setup of UserAccountProfile Avi RESTful Object" b
- name: $1
	avi_useraccountprofile:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# max_concurrent_sessions: ${4:# Maximum number of concurrent sessions allowed.}
		# uuid: ${5:# Unique object identifier of the object.}
		# state: ${6:absent|#present}
		# url: ${7:# Avi controller URL of the object.}
		# account_lock_timeout: ${8:# Lock timeout period (in minutes).}
		# controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# max_login_failure_count: ${10:# Number of login attempts before lockout.}
		# api_version: ${11:# Avi API version of to use for Avi API and objects.}
		# max_password_history_count: ${12:# Maximum number of passwords to be maintained in the password history.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
		# credentials_timeout_threshold: ${16:# The time period after which credentials expire.}
$0
endsnippet

snippet avi_virtualservice "Module for setup of VirtualService Avi RESTful Object" b
- name: $1
	avi_virtualservice:
		name: ${2:# Name for the virtual service.}
		# client_auth: ${3:# Http authentication configuration for protected resources.}
		# port_uuid: ${4:# (internal-use) network port assigned to the virtual service ip address.}
		# availability_zone: ${5:# Availability-zone to place the virtual service.}
		# flow_dist: ${6:# Criteria for flow distribution among ses.}
		# floating_subnet_uuid: ${7:# If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.}
		# delay_fairness: ${8:# Select the algorithm for qos fairness.}
		# vip: ${9:# List of virtual service ips.}
		# snat_ip: ${10:# Nat'ted floating source ip address(es) for upstream connection to servers.}
		# enable_rhi_snat: ${11:# Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.}
		# sideband_profile: ${12:# Sideband configuration to be used for this virtualservice.it can be used for sending traffic to sideband vips for external inspection etc.}
		# requests_rate_limit: ${13:# Rate limit the incoming requests to this virtual service.}
		# analytics_profile_ref: ${14:# Specifies settings related to analytics.}
		# uuid: ${15:# Uuid of the virtualservice.}
		# discovered_subnet: ${16:# (internal-use) discovered subnets providing reachability for client facing virtual service ip.}
		# pool_ref: ${17:# The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.}
		# ssl_profile_ref: ${18:# Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.}
		# created_by: ${19:# Creator name.}
		# ign_pool_net_reach: ${20:# Ignore pool servers network reachability constraints for virtual service placement.}
		# max_cps_per_client: ${21:# Maximum connections per second per client ip.}
		# ssl_sess_cache_avg_size: ${22:# Expected number of ssl session cache entries (may be exceeded).}
		# vs_datascripts: ${23:# Datascripts applied on the data traffic of the virtual service.}
		# username: ${24:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# network_security_policy_ref: ${25:# Network security policies for the virtual service.}
		# http_policies: ${26:# Http policies applied on the data traffic of the virtual service.}
		# application_profile_ref: ${27:# Enable application layer specific features for the virtual service.}
		# microservice_ref: ${28:# Microservice representing the virtual service.}
		# controller: ${29:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${30:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# ip_address: ${31:# Ip address of the virtual service.}
		# pool_group_ref: ${32:# The pool group is an object that contains pools.}
		# east_west_placement: ${33:# Force placement on all se's in service group (mesos mode only).}
		# subnet_uuid: ${34:# It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.}
		# service_pool_select: ${35:# Select pool based on destination port.}
		# type: ${36:# Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.}
		# enable_autogw: ${37:# Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.}
		# discovered_networks: ${38:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
		# enabled: ${39:# Enable or disable the virtual service.}
		# content_rewrite: ${40:# Profile used to match and rewrite strings in request and/or response body.}
		# ssl_key_and_certificate_refs: ${41:# Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.}
		# static_dns_records: ${42:# List of static dns records applied to this virtual service.}
		# analytics_policy: ${43:# Determines analytics settings for the application.}
		# tenant_uuid: ${44:}
		# network_profile_ref: ${45:# Determines network settings such as protocol, tcp or udp, and related options for the protocol.}
		# auto_allocate_ip: ${46:# Auto-allocate vip from the provided subnet.}
		# weight: ${47:# The quality of service weight to assign to traffic transmitted from this virtual service.}
		# tenant_ref: ${48:# It is a reference to an object of type tenant.}
		# ipam_network_subnet: ${49:# Subnet and/or network for allocating virtualservice ip by ipam provider module.}
		# traffic_clone_profile_ref: ${50:# Server network or list of servers for cloning traffic.}
		# avi_allocated_vip: ${51:# (internal-use) vip allocated by avi in the cloud infrastructure.}
		# dns_info: ${52:# Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.}
		# service_metadata: ${53:# Metadata pertaining to the service provided by this virtual service.}
		# vsvip_ref: ${54:# Mostly used during the creation of shared vs, this fieldrefers to entities that can be shared across virtual services.}
		# subnet: ${55:# Subnet providing reachability for client facing virtual service ip.}
		# vrf_context_ref: ${56:# Virtual routing context that the virtual service is bound to.}
		# cloud_type: ${57:# Enum options - cloud_none, cloud_vcenter, cloud_openstack, cloud_aws, cloud_vca, cloud_apic, cloud_mesos, cloud_linuxserver, cloud_docker_ucp,}
		# vh_domain_name: ${58:# The exact name requested from the client's sni-enabled tls hello domain name field.}
		# cloud_ref: ${59:# It is a reference to an object of type cloud.}
		# enable_rhi: ${60:# Enable route health injection using the bgp config in the vrf context.}
		# se_group_ref: ${61:# The service engine group to use for this virtual service.}
		# scaleout_ecmp: ${62:# Disable re-distribution of flows across service engines for a virtual service.}
		# state: ${63:absent|#present}
		# nsx_securitygroup: ${64:# A list of nsx service groups representing the clients which can access the virtual ip of the virtual service.}
		# api_version: ${65:# Avi API version of to use for Avi API and objects.}
		# remove_listening_port_on_vs_down: ${66:# Remove listening port if virtualservice is down.}
		# description: ${67:# User defined description for the object.}
		# performance_limits: ${68:# Optional settings that determine performance limits like max connections or bandwdith etc.}
		# use_bridge_ip_as_vip: ${69:# Use bridge ip as vip on each host in mesos deployments.}
		# floating_ip: ${70:# Floating ip to associate with this virtual service.}
		# auto_allocate_floating_ip: ${71:# Auto-allocate floating/elastic ip from the cloud infrastructure.}
		# host_name_xlate: ${72:# Translate the host name sent to the servers to this value.}
		# services: ${73:# List of services defined for this virtual service.}
		# connections_rate_limit: ${74:# Rate limit the incoming connections to this virtual service.}
		# active_standby_se_tag: ${75:# This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.}
		# server_network_profile_ref: ${76:# Determines the network settings profile for the server side of tcp proxied connections.}
		# discovered_network_ref: ${77:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
		# tenant: ${78:admin}
		# limit_doser: ${79:# Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.}
		# url: ${80:# Avi controller URL of the object.}
		# network_ref: ${81:# Manually override the network on which the virtual service is placed.}
		# fqdn: ${82:# Dns resolvable, fully qualified domain name of the virtualservice.}
		# flow_label_type: ${83:# Criteria for flow labelling.}
		# dns_policies: ${84:# Dns policies applied on the dns traffic of the virtual service.}
		# cloud_config_cksum: ${85:# Checksum of cloud configuration for vs.}
		# avi_allocated_fip: ${86:# (internal-use) fip allocated by avi in the cloud infrastructure.}
		# vh_parent_vs_uuid: ${87:# Specifies the virtual service acting as virtual hosting (sni) parent.}
$0
endsnippet

snippet avi_vrfcontext "Module for setup of VrfContext Avi RESTful Object" b
- name: $1
	avi_vrfcontext:
		name: ${2:# Name of the object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# User defined description for the object.}
		# controller: ${5:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# system_default: ${6:# Boolean flag to set system_default.}
		# password: ${7:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${8:admin}
		# internal_gateway_monitor: ${9:# Configure ping based heartbeat check for all default gateways in service engines of vrf.}
		# static_routes: ${10:# List of staticroute.}
		# cloud_ref: ${11:# It is a reference to an object of type cloud.}
		# tenant_ref: ${12:# It is a reference to an object of type tenant.}
		# uuid: ${13:# Unique object identifier of the object.}
		# debugvrfcontext: ${14:# Configure debug flags for vrf.}
		# url: ${15:# Avi controller URL of the object.}
		# state: ${16:absent|#present}
		# bgp_profile: ${17:# Bgp local and peer info.}
		# gateway_mon: ${18:# Configure ping based heartbeat check for gateway in service engines of vrf.}
		# tenant_uuid: ${19:}
		# api_version: ${20:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_vsdatascriptset "Module for setup of VSDataScriptSet Avi RESTful Object" b
- name: $1
	avi_vsdatascriptset:
		name: ${2:# Name for the virtual service datascript collection.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# description: ${4:# User defined description for the object.}
		# pool_refs: ${5:# Uuid of pools that could be referred by vsdatascriptset objects.}
		# pool_group_refs: ${6:# Uuid of pool groups that could be referred by vsdatascriptset objects.}
		# string_group_refs: ${7:# Uuid of string groups that could be referred by vsdatascriptset objects.}
		# controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${10:admin}
		# datascript: ${11:# Datascripts to execute.}
		# uuid: ${12:# Uuid of the virtual service datascript collection.}
		# url: ${13:# Avi controller URL of the object.}
		# tenant_ref: ${14:# It is a reference to an object of type tenant.}
		# ipgroup_refs: ${15:# Uuid of ip groups that could be referred by vsdatascriptset objects.}
		# state: ${16:absent|#present}
		# tenant_uuid: ${17:}
		# api_version: ${18:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_vsvip "Module for setup of VsVip Avi RESTful Object" b
- name: $1
	avi_vsvip:
		name: ${2:# Name for the vsvip object.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# tenant_ref: ${4:# It is a reference to an object of type tenant.}
		# controller: ${5:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# password: ${6:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant: ${7:admin}
		# uuid: ${8:# Uuid of the vsvip object.}
		# east_west_placement: ${9:# Force placement on all service engines in the service engine group (container clouds only).}
		# vrf_context_ref: ${10:# Virtual routing context that the virtual service is bound to.}
		# cloud_ref: ${11:# It is a reference to an object of type cloud.}
		# dns_info: ${12:# Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.}
		# vip: ${13:# List of virtual service ips and other shareable entities.}
		# url: ${14:# Avi controller URL of the object.}
		# state: ${15:absent|#present}
		# tenant_uuid: ${16:}
		# api_version: ${17:# Avi API version of to use for Avi API and objects.}
$0
endsnippet

snippet avi_webhook "Module for setup of Webhook Avi RESTful Object" b
- name: $1
	avi_webhook:
		name: ${2:# The name of the webhook profile.}
		# username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		# uuid: ${4:# Uuid of the webhook profile.}
		# callback_url: ${5:# Callback url for the webhook.}
		# description: ${6:# Field introduced in 17.1.1.}
		# url: ${7:# Avi controller URL of the object.}
		# tenant_ref: ${8:# It is a reference to an object of type tenant.}
		# state: ${9:absent|#present}
		# verification_token: ${10:# Verification token sent back with the callback asquery parameters.}
		# controller: ${11:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		# api_version: ${12:# Avi API version of to use for Avi API and objects.}
		# password: ${13:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		# tenant_uuid: ${14:}
		# tenant: ${15:admin}
$0
endsnippet

snippet bcf_switch "Create and remove a bcf switch." b
- name: $1
	bcf_switch:
		name: ${2:# The name of the switch.}
		mac: ${3:# The MAC address of the switch.}
		controller: ${4:# The controller IP address.}
		fabric_role: ${5:spine|leaf}
		# access_token: ${6:# Big Cloud Fabric access token. If this isn't set then the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}
		# state: ${7:#present|absent}
		# leaf_group: ${8:# The leaf group of the switch if the switch is a leaf.}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigmon_chain "Create and remove a bigmon inline service chain." b
- name: $1
	bigmon_chain:
		controller: ${2:# The controller IP address.}
		name: ${3:# The name of the chain.}
		# access_token: ${4:# Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}
		# state: ${5:#present|absent}
		# validate_certs: ${6:#True|False}
$0
endsnippet

snippet bigmon_policy "Create and remove a bigmon out-of-band policy." b
- name: $1
	bigmon_policy:
		name: ${2:# The name of the policy.}
		controller: ${3:# The controller address.}
		# policy_description: ${4:# Description of policy.}
		# access_token: ${5:# Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}
		# start_time: ${6:ansible_date_time.iso8601}
		# state: ${7:#present|absent}
		# priority: ${8:100}
		# action: ${9:#forward|drop|flow-gen}
		# duration: ${10:0}
		# validate_certs: ${11:#True|False}
		# delivery_packet_count: ${12:0}
$0
endsnippet

snippet ce_aaa_server "Manages AAA server global configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server:
		# acct_scheme_name: ${2:# Accounting scheme name. The value is a string of 1 to 32 characters.}
		# first_author_mode: ${3:invalid|local|hwtacacs|if-authenticated|none}
		# authen_scheme_name: ${4:# Name of an authentication scheme. The value is a string of 1 to 32 characters.}
		# author_scheme_name: ${5:# Name of an authorization scheme. The value is a string of 1 to 32 characters.}
		# radius_server_group: ${6:# RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.}
		# domain_name: ${7:# Name of a domain. The value is a string of 1 to 64 characters.}
		# first_authen_mode: ${8:invalid|local|hwtacacs|radius|none}
		# state: ${9:#present|absent}
		# local_user_group: ${10:# Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.}
		# hwtacas_template: ${11:# Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.}
		# accounting_mode: ${12:invalid|hwtacacs|radius|none}
$0
endsnippet

snippet ce_aaa_server_host "Manages AAA server host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server_host:
		# radius_server_port: ${2:# Configured server port for a particular server. The value is an integer ranging from 1 to 65535.}
		# hwtacacs_server_ipv6: ${3:# Server IPv6 address. Must be a valid unicast IP address. The total length is 128 bits.}
		# local_service_type: ${4:# The type of local user login through, such as ftp ssh snmp telnet.}
		# radius_server_name: ${5:# Hostname of configured server. The value is a string of 0 to 255 case-sensitive characters.}
		# radius_server_mode: ${6:Secondary-server|Primary-server}
		# hwtacacs_server_type: ${7:Authentication|Authorization|Accounting|Common}
		# radius_vpn_name: ${8:# Set VPN instance. The value is a string of 1 to 31 case-sensitive characters.}
		# radius_server_ipv6: ${9:# IPv6 address of configured server. The total length is 128 bits.}
		# radius_server_type: ${10:Authentication|Accounting}
		# hwtacacs_server_ip: ${11:# Server IPv4 address. Must be a valid unicast IP address. The value is a string of 0 to 255 characters, in dotted decimal notation.}
		# local_user_group: ${12:# Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.}
		# local_user_level: ${13:# Login level of a local user. The value is an integer ranging from 0 to 15.}
		# radius_server_ip: ${14:# IPv4 address of configured server. The value is a string of 0 to 255 characters, in dotted decimal notation.}
		# local_ftp_dir: ${15:# FTP user directory. The value is a string of 1 to 255 characters.}
		# hwtacacs_vpn_name: ${16:# VPN instance name.}
		# hwtacacs_is_secondary_server: ${17:true|false}
		# radius_group_name: ${18:# RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.}
		# hwtacacs_template: ${19:# Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.}
		# local_password: ${20:# Login password of a user. The password can contain letters, numbers, and special characters. The value is a string of 1 to 255 characters.}
		# state: ${21:#present|absent}
		# hwtacacs_server_host_name: ${22:# Hwtacacs server host name.}
		# local_user_name: ${23:# Name of a local user. The value is a string of 1 to 253 characters.}
		# hwtacacs_is_public_net: ${24:true|false}
$0
endsnippet

snippet ce_acl "Manages base ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 2999 indicates a basic ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# acl_step: ${3:# ACL step. The value is an integer ranging from 1 to 20. The default value is 5.}
		# log_flag: ${4:true|false}
		# source_ip: ${5:# Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
		# state: ${6:#present|absent|delete_acl}
		# src_mask: ${7:# Mask of a source IP address. The value is an integer ranging from 1 to 32.}
		# rule_action: ${8:permit|deny}
		# rule_name: ${9:# Name of a basic ACL rule. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces or begin with an underscore (_).}
		# acl_num: ${10:# ACL number. The value is an integer ranging from 2000 to 2999.}
		# vrf_name: ${11:# VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.}
		# acl_description: ${12:# ACL description. The value is a string of 1 to 127 characters.}
		# rule_id: ${13:# ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.}
		# time_range: ${14:# Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces. The name must start with an uppercase or lowercase letter. In addition, the word "all" cannot be specified as a time range name.}
		# rule_description: ${15:# Description about an ACL rule. The value is a string of 1 to 127 characters.}
		# frag_type: ${16:fragment|clear_fragment}
$0
endsnippet

snippet ce_acl_advance "Manages advanced ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_advance:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 3000 to 3999 indicates a advance ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# acl_step: ${3:# ACL step. The value is an integer ranging from 1 to 20. The default value is 5.}
		# protocol: ${4:ip|icmp|igmp|ipinip|tcp|udp|gre|ospf}
		# precedence: ${5:# Data packets can be filtered based on the priority field. The value is an integer ranging from 0 to 7.}
		# src_port_op: ${6:lt|eq|gt|range}
		# log_flag: ${7:true|false}
		# time_range: ${8:# Name of a time range in which an ACL rule takes effect.}
		# src_port_begin: ${9:# Start port number of the source port. The value is an integer ranging from 0 to 65535.}
		# frag_type: ${10:fragment|clear_fragment}
		# dest_port_op: ${11:lt|eq|gt|range}
		# dest_pool_name: ${12:# Name of a destination pool. The value is a string of 1 to 32 characters.}
		# acl_description: ${13:# ACL description. The value is a string of 1 to 127 characters.}
		# ttl_expired: ${14:true|false}
		# icmp_type: ${15:# ICMP type. This parameter is available only when the packet protocol is ICMP. The value is an integer ranging from 0 to 255.}
		# src_mask: ${16:# Source IP address mask. The value is an integer ranging from 1 to 32.}
		# icmp_name: ${17:unconfiged|echo|echo-reply|fragmentneed-DFset|host-redirect|host-tos-redirect|host-unreachable|information-reply|information-request|net-redirect|net-tos-redirect|net-unreachable|parameter-problem|port-unreachable|protocol-unreachable|reassembly-timeout|source-quench|source-route-failed|timestamp-reply|timestamp-request|ttl-exceeded|address-mask-reply|address-mask-request|custom}
		# established: ${18:true|false}
		# igmp_type: ${19:host-query|mrouter-adver|mrouter-solic|mrouter-termi|mtrace-resp|mtrace-route|v1host-report|v2host-report|v2leave-group|v3host-report}
		# tos: ${20:# ToS value on which data packet filtering is based. The value is an integer ranging from 0 to 15.}
		# acl_num: ${21:# ACL number. The value is an integer ranging from 3000 to 3999.}
		# rule_action: ${22:permit|deny}
		# state: ${23:#present|absent|delete_acl}
		# tcp_flag_mask: ${24:# TCP flag mask value. The value is an integer ranging from 0 to 63.}
		# src_port_end: ${25:# End port number of the source port. The value is an integer ranging from 0 to 65535.}
		# dest_ip: ${26:# Destination IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
		# icmp_code: ${27:# ICMP message code. Data packets can be filtered based on the ICMP message code. The value is an integer ranging from 0 to 255.}
		# dest_port_end: ${28:# End port number of the destination port. The value is an integer ranging from 0 to 65535.}
		# dscp: ${29:# Differentiated Services Code Point. The value is an integer ranging from 0 to 63.}
		# rule_name: ${30:# Name of a basic ACL rule. The value is a string of 1 to 32 characters.}
		# rule_description: ${31:# Description about an ACL rule.}
		# dest_mask: ${32:# Destination IP address mask. The value is an integer ranging from 1 to 32.}
		# src_port_pool_name: ${33:# Name of a source port pool. The value is a string of 1 to 32 characters.}
		# source_ip: ${34:# Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
		# syn_flag: ${35:# TCP flag value. The value is an integer ranging from 0 to 63.}
		# vrf_name: ${36:# VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.}
		# src_pool_name: ${37:# Name of a source pool. The value is a string of 1 to 32 characters.}
		# dest_port_begin: ${38:# Start port number of the destination port. The value is an integer ranging from 0 to 65535.}
		# dest_port_pool_name: ${39:# Name of a destination port pool. The value is a string of 1 to 32 characters.}
		# rule_id: ${40:# ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.}
$0
endsnippet

snippet ce_acl_interface "Manages applying ACLs to interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_interface:
		interface: ${2:# Interface name. Only support interface full name, such as "40GE2/0/1".}
		direction: ${3:inbound|outbound}
		acl_name: ${4:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 4999. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# state: ${5:#present|absent}
$0
endsnippet

snippet ce_bfd_global "Manages BFD global configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_global:
		# tos_exp_dynamic: ${2:# Indicates the priority of BFD control packets for dynamic BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.}
		# default_ip: ${3:# Specifies the default multicast IP address. The value ranges from 224.0.0.107 to 224.0.0.250.}
		# damp_init_wait_time: ${4:# Specifies an initial flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 2000.}
		# bfd_enable: ${5:enable|disable}
		# delay_up_time: ${6:# Specifies the delay before a BFD session becomes Up. The value is an integer ranging from 1 to 600, in seconds. The default value is 0, indicating that a BFD session immediately becomes Up.}
		# state: ${7:#present|absent}
		# damp_max_wait_time: ${8:# Specifies a maximum flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 15000.}
		# damp_second_wait_time: ${9:# Specifies a secondary flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 5000.}
		# tos_exp_static: ${10:# Indicates the priority of BFD control packets for static BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.}
$0
endsnippet

snippet ce_bfd_session "Manages BFD session configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_session:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# src_addr: ${3:# Indicates the source IP address carried in BFD packets.}
		# out_if_name: ${4:# Specifies the type and number of the interface bound to the BFD session.}
		# state: ${5:#present|absent}
		# dest_addr: ${6:# Specifies the peer IP address bound to the BFD session.}
		# vrf_name: ${7:# Specifies the name of a Virtual Private Network (VPN) instance that is bound to a BFD session. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value _public_ is reserved and cannot be used as the VPN instance name.}
		# create_type: ${8:static|auto}
		# use_default_ip: ${9:no}
		# addr_type: ${10:ipv4}
$0
endsnippet

snippet ce_bfd_view "Manages BFD session view configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_view:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# local_discr: ${3:# Specifies the local discriminator of a BFD session. The value is an integer that ranges from 1 to 16384.}
		# detect_multi: ${4:# Specifies the local detection multiplier of a BFD session. The value is an integer that ranges from 3 to 50.}
		# remote_discr: ${5:# Specifies the remote discriminator of a BFD session. The value is an integer that ranges from 1 to 4294967295.}
		# description: ${6:# Specifies the description of a BFD session. The value is a string of 1 to 51 case-sensitive characters with spaces.}
		# admin_down: ${7:no}
		# tos_exp: ${8:# Specifies a priority for BFD control packets. The value is an integer ranging from 0 to 7. The default value is 7, which is the highest priority.}
		# min_tx_interval: ${9:# Specifies the minimum interval for receiving BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.}
		# min_rx_interval: ${10:# Specifies the minimum interval for sending BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.}
		# state: ${11:#present|absent}
		# wtr_interval: ${12:# Specifies the WTR time of a BFD session. The value is an integer that ranges from 1 to 60, in minutes. The default value is 0.}
$0
endsnippet

snippet ce_bgp "Manages BGP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp:
		# router_id: ${2:# ID of a router that is in IPv4 address format.}
		# memory_limit: ${3:#no_use|true|false}
		# vrf_rid_auto_sel: ${4:#no_use|true|false}
		# suppress_interval: ${5:# Suppress interval.}
		# as_number: ${6:# Local AS number. The value is a string of 1 to 11 characters.}
		# confed_id_number: ${7:# Confederation ID. The value is a string of 1 to 11 characters.}
		# bgp_rid_auto_sel: ${8:#no_use|true|false}
		# default_af_type: ${9:ipv4uni|ipv6uni}
		# conn_retry_time: ${10:# ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.}
		# is_shutdown: ${11:#no_use|true|false}
		# keepalive_time: ${12:# If the value of a timer changes, the BGP peer relationship between the routers is disconnected. The value is an integer ranging from 0 to 21845. The default value is 60.}
		# confed_peer_as_num: ${13:# Confederation AS number, in two-byte or four-byte format. The value is a string of 1 to 11 characters.}
		# min_hold_time: ${14:# Min hold time, in seconds. The value of the hold time can be 0 or range from 20 to 65535.}
		# ebgp_if_sensitive: ${15:#no_use|true|false}
		# check_first_as: ${16:#no_use|true|false}
		# clear_interval: ${17:# Clear interval.}
		# confed_nonstanded: ${18:#no_use|true|false}
		# time_wait_for_rib: ${19:# Period of waiting for the End-Of-RIB flag. The value is an integer ranging from 3 to 3000. The default value is 600.}
		# hold_time: ${20:# Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535.}
		# as_path_limit: ${21:# Maximum number of AS numbers in the AS_Path attribute. The default value is 255.}
		# hold_interval: ${22:# Hold interval.}
		# state: ${23:#present|absent}
		# vrf_name: ${24:# Name of a BGP instance. The name is a case-sensitive string of characters.}
		# keep_all_routes: ${25:#no_use|true|false}
		# gr_peer_reset: ${26:#no_use|true|false}
		# graceful_restart: ${27:#no_use|true|false}
$0
endsnippet

snippet ce_bgp_af "Manages BGP Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_af:
		af_type: ${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		vrf_name: ${3:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. The value is a string of 1 to 31 case-sensitive characters.}
		# reflector_cluster_id: ${4:# Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. The value is an integer ranging from 1 to 4294967295.}
		# ingress_lsp_policy_name: ${5:# Ingress lsp policy name.}
		# vrf_rid_auto_sel: ${6:#no_use|true|false}
		# preference_internal: ${7:# Set the protocol priority of IBGP routes. The value is an integer ranging from 1 to 255.}
		# maximum_load_balance: ${8:# Specify the maximum number of equal-cost routes in the BGP routing table. The value is an integer ranging from 1 to 65535.}
		# preference_local: ${9:# Set the protocol priority of a local BGP route. The value is an integer ranging from 1 to 255.}
		# preference_external: ${10:# Set the protocol priority of EBGP routes. The value is an integer ranging from 1 to 255.}
		# router_id_neglect: ${11:#no_use|true|false}
		# default_local_pref: ${12:# Set the Local-Preference attribute. The value is an integer. The value is an integer ranging from 0 to 4294967295.}
		# reflector_cluster_ipv4: ${13:# Set a cluster ipv4 address. The value is expressed in the format of an IPv4 address.}
		# prefrence_policy_name: ${14:# Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The value is a string of 1 to 40 characters.}
		# default_rt_import_enable: ${15:#no_use|true|false}
		# nhp_relay_route_policy_name: ${16:# Specify the name of a route-policy for route iteration. The value is a string of 1 to 40 characters.}
		# igp_metric_ignore: ${17:#no_use|true|false}
		# as_path_neglect: ${18:#no_use|true|false}
		# auto_frr_enable: ${19:#no_use|true|false}
		# mask_len: ${20:# Specify the mask length of an IP address. The value is an integer ranging from 0 to 128.}
		# ibgp_ecmp_nexthop_changed: ${21:#no_use|true|false}
		# nexthop_third_party: ${22:#no_use|true|false}
		# state: ${23:#present|absent}
		# default_med: ${24:# Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer ranging from 0 to 4294967295.}
		# add_path_sel_num: ${25:# Number of Add-Path routes. The value is an integer ranging from 2 to 64.}
		# med_none_as_maximum: ${26:#no_use|true|false}
		# ebgp_ecmp_nexthop_changed: ${27:#no_use|true|false}
		# ecmp_nexthop_changed: ${28:#no_use|true|false}
		# lowest_priority: ${29:#no_use|true|false}
		# rr_filter_number: ${30:# Set the number of the extended community filter supported by an RR group. The value is a string of 1 to 51 characters.}
		# import_process_id: ${31:# Process ID of an imported routing protocol. The value is an integer ranging from 0 to 4294967295.}
		# router_id: ${32:# ID of a router that is in IPv4 address format. The value is a string of 0 to 255 characters. The value is in dotted decimal notation.}
		# determin_med: ${33:#no_use|true|false}
		# load_balancing_as_path_ignore: ${34:#no_use|true|false}
		# reflect_chg_path: ${35:#no_use|true|false}
		# always_compare_med: ${36:#no_use|true|false}
		# allow_invalid_as: ${37:#no_use|true|false}
		# relay_delay_enable: ${38:#no_use|true|false}
		# rib_only_policy_name: ${39:# Specify the name of a routing policy. The value is a string of 1 to 40 characters.}
		# max_load_ebgp_num: ${40:# Specify the maximum number of equal-cost EBGP routes. The value is an integer ranging from 1 to 65535.}
		# import_protocol: ${41:direct|ospf|isis|static|rip|ospfv3|ripng}
		# ebgp_if_sensitive: ${42:#no_use|true|false}
		# network_address: ${43:# Specify the IP address advertised by BGP. The value is a string of 0 to 255 characters.}
		# supernet_uni_adv: ${44:#no_use|true|false}
		# next_hop_sel_depend_type: ${45:#default|dependTunnel|dependIp}
		# originator_prior: ${46:#no_use|true|false}
		# active_route_advertise: ${47:#no_use|true|false}
		# reflect_between_client: ${48:#no_use|true|false}
		# policy_vpn_target: ${49:#no_use|true|false}
		# summary_automatic: ${50:#no_use|true|false}
		# rib_only_enable: ${51:#no_use|true|false}
		# max_load_ibgp_num: ${52:# Specify the maximum number of equal-cost IBGP routes. The value is an integer ranging from 1 to 65535.}
		# route_sel_delay: ${53:# Route selection delay. The value is an integer ranging from 0 to 3600.}
		# supernet_label_adv: ${54:#no_use|true|false}
		# policy_ext_comm_enable: ${55:#no_use|true|false}
$0
endsnippet

snippet ce_bgp_neighbor "Manages BGP peer configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor:
		remote_as: ${2:# AS number of a peer. The value is a string of 1 to 11 characters.}
		vrf_name: ${3:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		peer_addr: ${4:# Connection address of a peer, which can be an IPv4 or IPv6 address.}
		# prepend_global_as: ${5:#no_use|true|false}
		# ebgp_max_hop: ${6:# Maximum number of hops in an indirect EBGP connection. The value is an ranging from 1 to 255.}
		# is_ignore: ${7:#no_use|true|false}
		# prepend_fake_as: ${8:#no_use|true|false}
		# fake_as: ${9:# Fake AS number that is specified for a local peer. The value is a string of 1 to 11 characters.}
		# is_single_hop: ${10:#no_use|true|false}
		# conventional: ${11:#no_use|true|false}
		# hold_time: ${12:# Specify the Hold time of a peer or peer group. The value is 0 or an integer ranging from 3 to 65535.}
		# tx_interval: ${13:# Specify the minimum interval at which BFD packets are sent. The value is an integer ranging from 50 to 1000, in milliseconds.}
		# pswd_cipher_text: ${14:# The character string in a password identifies the contents of the password, spaces not supported. The value is a string of 1 to 255 characters.}
		# local_if_name: ${15:# Name of a source interface that sends BGP packets. The value is a string of 1 to 63 characters.}
		# rx_interval: ${16:# Specify the minimum interval at which BFD packets are received. The value is an integer ranging from 50 to 1000, in milliseconds.}
		# state: ${17:#present|absent}
		# dual_as: ${18:#no_use|true|false}
		# connect_mode: ${19:# The value can be Connect-only, Listen-only, or Both.}
		# description: ${20:# Description of a peer, which can be letters or digits. The value is a string of 1 to 80 characters.}
		# is_log_change: ${21:#no_use|true|false}
		# keep_alive_time: ${22:# Specify the Keepalive time of a peer or peer group. The value is an integer ranging from 0 to 21845. The default value is 60.}
		# key_chain_name: ${23:# Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string of 1 to 47 case-insensitive characters.}
		# conn_retry_time: ${24:# ConnectRetry interval. The value is an integer ranging from 1 to 65535.}
		# min_hold_time: ${25:# Specify the Min hold time of a peer or peer group.}
		# multiplier: ${26:# Specify the detection multiplier. The default value is 3. The value is an integer ranging from 3 to 50.}
		# valid_ttl_hops: ${27:# Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. The value is an integer ranging from 1 to 255.}
		# is_bfd_block: ${28:#no_use|true|false}
		# tcp_MSS: ${29:# Maximum TCP MSS value used for TCP connection establishment for a peer. The value is an integer ranging from 176 to 4096.}
		# is_bfd_enable: ${30:#no_use|true|false}
		# route_refresh: ${31:#no_use|true|false}
		# pswd_type: ${32:null|cipher|simple}
		# mpls_local_ifnet_disable: ${33:#no_use|true|false}
$0
endsnippet

snippet ce_bgp_neighbor_af "Manages BGP neighbor Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor_af:
		af_type: ${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		remote_address: ${3:# IPv4 or IPv6 peer connection address.}
		vrf_name: ${4:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		# import_pref_filt_name: ${5:# Specify the IPv4 filtering policy applied to the routes received from a specified peer. The value is a string of 1 to 169 characters.}
		# advertise_irb: ${6:#no_use|true|false}
		# substitute_as_enable: ${7:#no_use|true|false}
		# advertise_ext_community: ${8:#no_use|true|false}
		# default_rt_match_mode: ${9:null|matchall|matchany}
		# redirect_ip: ${10:#no_use|true|false}
		# route_limit: ${11:# Configure the maximum number of routes that can be accepted from a peer. The value is an integer ranging from 1 to 4294967295.}
		# import_as_path_filter: ${12:# Apply an AS_Path-based filtering policy to the routes received from a specified peer. The value is an integer ranging from 1 to 256.}
		# public_as_only_force: ${13:#no_use|true|false}
		# vpls_enable: ${14:#no_use|true|false}
		# allow_as_loop_enable: ${15:#no_use|true|false}
		# advertise_arp: ${16:#no_use|true|false}
		# import_as_path_name_or_num: ${17:# A routing strategy based on the AS path list for routing received by a designated peer.}
		# orf_mode: ${18:null|receive|send|both}
		# nexthop_configure: ${19:null|local|invariable}
		# discard_ext_community: ${20:#no_use|true|false}
		# is_nonstd_ipprefix_mod: ${21:#no_use|true|false}
		# keep_all_routes: ${22:#no_use|true|false}
		# orftype: ${23:# ORF Type. The value is an integer ranging from 0 to 65535.}
		# advertise_community: ${24:#no_use|true|false}
		# export_as_path_name_or_num: ${25:# Application of a AS path list based filtering policy to the routing of a specified peer.}
		# adv_add_path_num: ${26:# The number of addPath advertise route. The value is an integer ranging from 2 to 64.}
		# ipprefix_orf_enable: ${27:#no_use|true|false}
		# route_limit_type: ${28:noparameter|alertOnly|idleForever|idleTimeout}
		# public_as_only_skip_peer_as: ${29:#no_use|true|false}
		# origin_as_valid: ${30:#no_use|true|false}
		# route_limit_idle_timeout: ${31:# Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold. The value is an integer ranging from 1 to 1200.}
		# reflect_client: ${32:#no_use|true|false}
		# import_rt_policy_name: ${33:# Specify the filtering policy applied to the routes learned from a peer. The value is a string of 1 to 40 characters.}
		# route_limit_percent: ${34:# Specify the percentage of routes when a router starts to generate an alarm. The value is an integer ranging from 1 to 100.}
		# export_rt_policy_name: ${35:# Specify the filtering policy applied to the routes to be advertised to a peer. The value is a string of 1 to 40 characters.}
		# public_as_only: ${36:#no_use|true|false}
		# redirect_ip_vaildation: ${37:#no_use|true|false}
		# import_acl_name_or_num: ${38:# Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The value is a string of 1 to 32 characters.}
		# allow_as_loop_limit: ${39:# Set the maximum number of repetitive local AS number. The value is an integer ranging from 1 to 10.}
		# add_path_mode: ${40:null|receive|send|both}
		# export_as_path_filter: ${41:# Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The value is an integer ranging from 1 to 256.}
		# vpls_ad_disable: ${42:#no_use|true|false}
		# public_as_only_replace: ${43:#no_use|true|false}
		# public_as_only_limited: ${44:#no_use|true|false}
		# preferred_value: ${45:# Assign a preferred value for the routes learned from a specified peer. The value is an integer ranging from 0 to 65535.}
		# export_acl_name_or_num: ${46:# Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The value is a string of 1 to 32 characters.}
		# soostring: ${47:# Configure the Site-of-Origin (SoO) extended community attribute. The value is a string of 3 to 21 characters.}
		# update_pkt_standard_compatible: ${48:#no_use|true|false}
		# advertise_remote_nexthop: ${49:#no_use|true|false}
		# default_rt_adv_policy: ${50:# Specify the name of a used policy. The value is a string. The value is a string of 1 to 40 characters.}
		# export_pref_filt_name: ${51:# Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. The value is a string of 1 to 169 characters.}
		# default_rt_adv_enable: ${52:#no_use|true|false}
		# rt_updt_interval: ${53:# Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. The value is an integer ranging from 0 to 600.}
$0
endsnippet

snippet ce_command "Run arbitrary command on HUAWEI CloudEngine devices." b
- name: $1
	ce_command:
		commands: ${2:# The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# retries: ${3:10}
		# wait_for: ${4:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		# match: ${5:all}
		# interval: ${6:1}
$0
endsnippet

snippet ce_config "Manage Huawei CloudEngine configuration sections." b
- name: $1
	ce_config:
		# src: ${2:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
		# backup: ${3:no}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device current-configuration.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# replace: ${6:#line|block}
		# parents: ${7:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# defaults: ${8:no}
		# save: ${9:no}
		# config: ${10:# The module, by default, will connect to the remote device and retrieve the current current-configuration to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current-configuration for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# match: ${11:#line|strict|exact|none}
		# before: ${12:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet ce_dldp "Manages global DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp:
		# reset: ${2:enable|disable}
		# enable: ${3:enable|disable}
		# work_mode: ${4:enhance|normal}
		# auth_pwd: ${5:# Specifies authentication password. The value is a string of 1 to 16 case-sensitive plaintexts or 24/32/48/108/128 case-sensitive encrypted characters. The string excludes a question mark (?).}
		# time_internal: ${6:# Specifies the interval for sending Advertisement packets. The value is an integer ranging from 1 to 100, in seconds. The default interval for sending Advertisement packets is 5 seconds.}
		# auth_mode: ${7:md5|simple|sha|hmac-sha256|none}
$0
endsnippet

snippet ce_dldp_interface "Manages interface DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp_interface:
		interface: ${2:# Must be fully qualified interface name, i.e. GE1/0/1, 10GE1/0/1, 40GE1/0/22, 100GE1/0/1.}
		# reset: ${3:enable|disable}
		# state: ${4:#present|absent}
		# enable: ${5:enable|disable}
		# mode_enable: ${6:enable|disable}
		# local_mac: ${7:# Set the source MAC address for DLDP packets sent in the DLDP-compatible mode. The value of MAC address is in H-H-H format. H contains 1 to 4 hexadecimal digits.}
$0
endsnippet

snippet ce_eth_trunk "Manages Eth-Trunk interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_eth_trunk:
		trunk_id: ${2:# Eth-Trunk interface number. The value is an integer. The value range depends on the assign forward eth-trunk mode command. When 256 is specified, the value ranges from 0 to 255. When 512 is specified, the value ranges from 0 to 511. When 1024 is specified, the value ranges from 0 to 1023.}
		# state: ${3:#present|absent}
		# force: ${4:no}
		# mode: ${5:manual|lacp-dynamic|lacp-static}
		# members: ${6:# List of interfaces that will be managed in a given Eth-Trunk. The interface name must be full name.}
		# min_links: ${7:# Specifies the minimum number of Eth-Trunk member links in the Up state. The value is an integer ranging from 1 to the maximum number of interfaces that can be added to a Eth-Trunk interface.}
		# hash_type: ${8:src-dst-ip|src-dst-mac|enhanced|dst-ip|dst-mac|src-ip|src-mac}
$0
endsnippet

snippet ce_evpn_bd_vni "Manages EVPN VXLAN Network Identifier (VNI) on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bd_vni:
		vpn_target_import: ${2:# Add VPN targets to the import VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}
		bridge_domain_id: ${3:# Specify an existed bridge domain (BD).The value is an integer ranging from 1 to 16777215.}
		# vpn_target_export: ${4:# Add VPN targets to the export VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}
		# state: ${5:#present|absent}
		# route_distinguisher: ${6:# Configures a route distinguisher (RD) for a BD EVPN instance. The format of an RD can be as follows}
		# vpn_target_both: ${7:# Add VPN targets to both the import and export VPN target lists of a BD EVPN instance. The format is the same as route_distinguisher.}
		# evpn: ${8:#enable|disable}
$0
endsnippet

snippet ce_evpn_bgp "Manages BGP EVPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp:
		bgp_instance: ${2:# Name of a BGP instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}
		# as_number: ${3:# Specifies integral AS number. The value is an integer ranging from 1 to 4294967295.}
		# advertise_l2vpn_evpn: ${4:enable|disable}
		# advertise_router_type: ${5:arp|irb}
		# vpn_name: ${6:# Associates a specified VPN instance with the IPv4 address family. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}
		# peer_group_name: ${7:# Specify the name of a peer group that BGP peers need to join. The value is a string of 1 to 47 case-sensitive characters, spaces not supported.}
		# state: ${8:#present|absent}
		# peer_enable: ${9:true|false}
		# peer_address: ${10:# Specifies the IPv4 address of a BGP EVPN peer. The value is in dotted decimal notation.}
$0
endsnippet

snippet ce_evpn_bgp_rr "Manages RR for the VXLAN Network on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp_rr:
		as_number: ${2:# Specifies the number of the AS, in integer format. The value is an integer that ranges from 1 to 4294967295.}
		# bgp_instance: ${3:# Specifies the name of a BGP instance. The value of instance-name can be an integer 1 or a string of 1 to 31.}
		# reflect_client: ${4:enable|disable}
		# peer: ${5:# Specifies the IPv4 address or the group name of a peer.}
		# bgp_evpn_enable: ${6:#enable|disable}
		# policy_vpn_target: ${7:enable|disable}
		# peer_type: ${8:group_name|ipv4_address}
$0
endsnippet

snippet ce_evpn_global "Manages global configuration of EVPN on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_global:
		evpn_overlay_enable: ${2:enable|disable}
$0
endsnippet

snippet ce_facts "Gets facts about HUAWEI CloudEngine switches." b
- name: $1
	ce_facts:
		# gather_subset: ${2:!config}
$0
endsnippet

snippet ce_file_copy "Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches." b
- name: $1
	ce_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist. The maximum length of local_file is 4096.}
		# remote_file: ${3:# Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used. The maximum length of remote_file is 4096.}
		# file_system: ${4:flash:}
$0
endsnippet

snippet ce_info_center_debug "Manages information center debug configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_debug:
		# debug_enable: ${2:#no_use|true|false}
		# state: ${3:#present|absent}
		# debug_level: ${4:emergencies|alert|critical|error|warning|notification|informational|debugging}
		# channel_id: ${5:# Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.}
		# module_name: ${6:# Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].}
		# debug_time_stamp: ${7:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
$0
endsnippet

snippet ce_info_center_global "Manages outputting logs on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_global:
		# server_ip: ${2:# Log server address, IPv4 or IPv6 type. The value is a string of 0 to 255 characters. The value can be an valid IPv4 or IPv6 address.}
		# filter_log_name: ${3:# Name of the filtered log. The value is a string of 1 to 63 case-sensitive characters.}
		# facility: ${4:local0|local1|local2|local3|local4|local5|local6|local7}
		# ssl_policy_name: ${5:# SSL policy name. The value is a string of 1 to 23 case-sensitive characters.}
		# transport_mode: ${6:tcp|udp}
		# channel_cfg_name: ${7:console}
		# suppress_enable: ${8:true|false}
		# channel_out_direct: ${9:console|monitor|trapbuffer|logbuffer|snmp|logfile}
		# channel_id: ${10:# Number for channel. The value is an integer ranging from 0 to 9. The default value is 0.}
		# filter_feature_name: ${11:# Feature name of the filtered log. The value is a string of 1 to 31 case-insensitive characters.}
		# is_default_vpn: ${12:no}
		# server_domain: ${13:# Server name. The value is a string of 1 to 255 case-sensitive characters.}
		# level: ${14:emergencies|alert|critical|error|warning|notification|informational|debugging}
		# packet_priority: ${15:# Set the priority of the syslog packet.The value is an integer ranging from 0 to 7. The default value is 0.}
		# source_ip: ${16:# Log source ip address, IPv4 or IPv6 type. The value is a string of 0 to 255. The value can be an valid IPv4 or IPv6 address.}
		# channel_name: ${17:# Channel name. The value is a string of 1 to 30 case-sensitive characters.}
		# state: ${18:#present|absent}
		# vrf_name: ${19:# VPN name on a log server. The value is a string of 1 to 31 case-sensitive characters. The default value is _public_.}
		# logfile_max_size: ${20:4|8|16|32}
		# server_port: ${21:# Number of a port sending logs.The value is an integer ranging from 1 to 65535. For UDP, the default value is 514. For TCP, the default value is 601. For TSL, the default value is 6514.}
		# timestamp: ${22:UTC|localtime}
		# info_center_enable: ${23:true|false}
		# ip_type: ${24:ipv4|ipv6}
		# logfile_max_num: ${25:# Maximum number of log files of the same type. The default value is 200.}
$0
endsnippet

snippet ce_info_center_log "Manages information center log configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_log:
		# log_level: ${2:emergencies|alert|critical|error|warning|notification|informational|debugging}
		# log_enable: ${3:#no_use|true|false}
		# log_buff_size: ${4:# Specifies the maximum number of logs in the log buffer. The value is an integer that ranges from 0 to 10240. If logbuffer-size is 0, logs are not displayed.}
		# channel_id: ${5:# Specifies a channel ID. The value is an integer ranging from 0 to 9.}
		# state: ${6:#present|absent}
		# log_buff_enable: ${7:#no_use|true|false}
		# log_time_stamp: ${8:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
		# module_name: ${9:# Specifies the name of a module. The value is a module name in registration logs.}
$0
endsnippet

snippet ce_info_center_trap "Manages information center trap configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_trap:
		# trap_time_stamp: ${2:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
		# trap_buff_size: ${3:# Size of a trap buffer. The value is an integer ranging from 0 to 1024. The default value is 256.}
		# channel_id: ${4:# Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.}
		# state: ${5:#present|absent}
		# trap_level: ${6:emergencies|alert|critical|error|warning|notification|informational|debugging}
		# trap_buff_enable: ${7:#no_use|true|false}
		# module_name: ${8:# Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].}
		# trap_enable: ${9:#no_use|true|false}
$0
endsnippet

snippet ce_interface "Manages physical attributes of interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_interface:
		state: ${2:#present|absent|default}
		# admin_state: ${3:up|down}
		# description: ${4:# Specifies an interface description. The value is a string of 1 to 242 case-sensitive characters, spaces supported but question marks (?) not supported.}
		# interface: ${5:# Full name of interface, i.e. 40GE1/0/10, Tunnel1.}
		# interface_type: ${6:ge|10ge|25ge|4x10ge|40ge|100ge|vlanif|loopback|meth|eth-trunk|nve|tunnel|ethernet|fcoe-port|fabric-port|stack-port|null}
		# mode: ${7:layer2|layer3}
		# l2sub: ${8:no}
$0
endsnippet

snippet ce_interface_ospf "Manages configuration of an OSPF interface instanceon HUAWEI CloudEngine switches." b
- name: $1
	ce_interface_ospf:
		area: ${2:# Ospf area associated with this ospf process. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}
		process_id: ${3:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		interface: ${4:# Full name of interface, i.e. 40GE1/0/10.}
		# cost: ${5:# The cost associated with this interface. Valid values are an integer in the range from 1 to 65535.}
		# silent_interface: ${6:no}
		# auth_mode: ${7:none|null|hmac-sha256|md5|hmac-md5|simple}
		# auth_key_id: ${8:# Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.}
		# dead_interval: ${9:# Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer in the range from 1 to 235926000.}
		# auth_text_simple: ${10:# Specifies a password for simple authentication. The value is a string of 1 to 8 characters.}
		# state: ${11:#present|absent}
		# hello_interval: ${12:# Time between sending successive hello packets. Valid values are an integer in the range from 1 to 65535.}
		# auth_text_md5: ${13:# Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.}
$0
endsnippet

snippet ce_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_ip_interface:
		interface: ${2:# Full name of interface, i.e. 40GE1/0/22, vlanif10.}
		# state: ${3:#present|absent}
		# version: ${4:#v4|v6}
		# addr: ${5:# IPv4 or IPv6 Address.}
		# mask: ${6:# Subnet mask for IPv4 or IPv6 Address in decimal format.}
		# ipv4_type: ${7:#main|sub}
$0
endsnippet

snippet ce_link_status "Get interface link status on HUAWEI CloudEngine switches." b
- name: $1
	ce_link_status:
		interface: ${2:# For the interface parameter, you can enter C(all) to display information about all interface, an interface type such as C(40GE) to display information about interfaces of the specified type, or full name of an interface such as C(40GE1/0/22) or C(vlanif10) to display information about the specific interface.}
$0
endsnippet

snippet ce_mlag_config "Manages MLAG configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_config:
		# eth_trunk_id: ${2:# Name of the peer-link interface. The value is in the range from 0 to 511.}
		# pseudo_priority: ${3:# The priority of a pseudo nickname. The value is an integer that ranges from 128 to 255. The default value is 192. A larger value indicates a higher priority.}
		# ip_address: ${4:# IP address bound to the DFS group. The value is in dotted decimal notation.}
		# priority_id: ${5:# Priority of a DFS group. The value is an integer that ranges from 1 to 254. The default value is 100.}
		# vpn_instance_name: ${6:# Name of the VPN instance bound to the DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value _public_ is reserved and cannot be used as the VPN instance name.}
		# peer_link_id: ${7:# Number of the peer-link interface. The value is 1.}
		# state: ${8:#present|absent}
		# dfs_group_id: ${9:present}
		# nickname: ${10:# The nickname bound to a DFS group. The value is an integer that ranges from 1 to 65471.}
		# pseudo_nickname: ${11:# A pseudo nickname of a DFS group. The value is an integer that ranges from 1 to 65471.}
$0
endsnippet

snippet ce_mlag_interface "Manages MLAG interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_interface:
		# eth_trunk_id: ${2:# Name of the local M-LAG interface. The value is ranging from 0 to 511.}
		# mlag_id: ${3:# ID of the M-LAG. The value is an integer that ranges from 1 to 2048.}
		# mlag_error_down: ${4:enable|disable}
		# mlag_system_id: ${5:# M-LAG global LACP system MAC address. The value is a string of 0 to 255 characters. The default value is the MAC address of the Ethernet port of MPU.}
		# state: ${6:#present|absent}
		# dfs_group_id: ${7:present}
		# interface: ${8:# Name of the interface that enters the Error-Down state when the peer-link fails. The value is a string of 1 to 63 characters.}
		# mlag_priority_id: ${9:# M-LAG global LACP system priority. The value is an integer ranging from 0 to 65535. The default value is 32768.}
$0
endsnippet

snippet ce_mtu "Manages MTU settings on HUAWEI CloudEngine switches." b
- name: $1
	ce_mtu:
		# interface: ${2:# Full name of interface, i.e. 40GE1/0/22.}
		# state: ${3:#present|absent}
		# jumbo_max: ${4:# Maximum frame size. The default value is 9216. The value is an integer and expressed in bytes. The value range is 1536 to 12224 for the CE12800 and 1536 to 12288 for ToR switches.}
		# jumbo_min: ${5:# Non-jumbo frame size threshod. The default value is 1518. The value is an integer that ranges from 1518 to jumbo_max, in bytes.}
		# mtu: ${6:# MTU for a specific interface. The value is an integer ranging from 46 to 9600, in bytes.}
$0
endsnippet

snippet ce_netconf "Run an arbitrary netconf command on HUAWEI CloudEngine switches." b
- name: $1
	ce_netconf:
		rpc: ${2:get|edit-config|execute-action|execute-cli}
		cfg_xml: ${3:# The config xml string.}
$0
endsnippet

snippet ce_netstream_aging "Manages timeout mode of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_aging:
		# timeout_type: ${2:active|inactive|tcp-session|manual}
		# state: ${3:#present|absent}
		# type: ${4:ip|vxlan}
		# manual_slot: ${5:# Specifies the slot number of netstream manual timeout.}
		# timeout_interval: ${6:30}
$0
endsnippet

snippet ce_netstream_export "Manages netstream export on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_export:
		type: ${2:ip|vxlan}
		# bgp_nexthop: ${3:enable|#disable}
		# host_port: ${4:# Specifies the destination UDP port number of the exported packets. The value is an integer that ranges from 1 to 65535.}
		# source_ip: ${5:# Specifies source address which can be IPv6 or IPv4 of the exported NetStream packet.}
		# host_ip: ${6:# Specifies destination address which can be IPv6 or IPv4 of the exported NetStream packet.}
		# as_option: ${7:origin|peer}
		# state: ${8:#present|absent}
		# version: ${9:5|9}
		# host_vpn: ${10:# Specifies the VPN instance of the exported packets carrying flow statistics. Ensure the VPN instance has been created on the device.}
$0
endsnippet

snippet ce_netstream_global "Manages global parameters of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_global:
		interface: ${2:# Netstream global interface.}
		# statistics_direction: ${3:inbound|outbound}
		# index_switch: ${4:#16|32}
		# state: ${5:#present|absent}
		# sampler_interval: ${6:# Specifies the netstream sampler interval, length is 1 - 65535.}
		# statistics_record: ${7:# Specifies the flexible netstream statistic record, length is 1 - 32.}
		# sampler_direction: ${8:inbound|outbound}
		# type: ${9:#ip|vxlan}
$0
endsnippet

snippet ce_netstream_template "Manages NetStream template configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_template:
		type: ${2:ip|vxlan}
		# state: ${3:#present|absent}
		# collect_interface: ${4:input|output}
		# record_name: ${5:# Configure the name of netstream record. The value is a string of 1 to 32 case-insensitive characters.}
		# description: ${6:# Configure the description of netstream record. The value is a string of 1 to 80 case-insensitive characters.}
		# collect_counter: ${7:bytes|packets}
		# match: ${8:destination-address|destination-port|tos|protocol|source-address|source-port}
$0
endsnippet

snippet ce_ntp "Manages core NTP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp:
		# state: ${2:#present|absent}
		# is_preferred: ${3:enable|disable}
		# peer: ${4:# Network address of NTP peer.}
		# key_id: ${5:# Authentication key identifier to use with given NTP server or peer.}
		# vpn_name: ${6:_public_}
		# server: ${7:# Network address of NTP server.}
		# source_int: ${8:# Local source interface from which NTP messages are sent. Must be fully qualified interface name, i.e. C(40GE1/0/22), C(vlanif10). Interface types, such as C(10GE), C(40GE), C(100GE), C(Eth-Trunk), C(LoopBack), C(MEth), C(NULL), C(Tunnel), C(Vlanif).}
$0
endsnippet

snippet ce_ntp_auth "Manages NTP authentication configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp_auth:
		key_id: ${2:# Authentication key identifier (numeric).}
		# auth_type: ${3:text|#encrypt}
		# state: ${4:#present|absent}
		# auth_pwd: ${5:# Plain text with length of 1 to 255, encrypted text with length of 20 to 392.}
		# trusted_key: ${6:enable|#disable}
		# auth_mode: ${7:hmac-sha256|md5}
		# authentication: ${8:enable|disable}
$0
endsnippet

snippet ce_ospf "Manages configuration of an OSPF instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf:
		process_id: ${2:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		# addr: ${3:# Specifies the address of the network segment where the interface resides. The value is in dotted decimal notation.}
		# area: ${4:# Specifies the area ID. The area with the area-id being 0 is a backbone area. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}
		# max_load_balance: ${5:# The maximum number of paths for forward packets over multiple paths. Valid value is an integer in the range from 1 to 64.}
		# mask: ${6:# IP network wildcard bits in decimal format between 0 and 32.}
		# auth_mode: ${7:none|hmac-sha256|md5|hmac-md5|simple}
		# auth_key_id: ${8:# Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.}
		# auth_text_simple: ${9:# Specifies a password for simple authentication. The value is a string of 1 to 8 characters.}
		# state: ${10:#present|absent}
		# nexthop_addr: ${11:# IPv4 address for configure next-hop address's weight. Valid values are a string, formatted as an IP address.}
		# auth_text_md5: ${12:# Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.}
		# nexthop_weight: ${13:# Indicates the weight of the next hop. The smaller the value is, the higher the preference of the route is. It is an integer that ranges from 1 to 254.}
$0
endsnippet

snippet ce_ospf_vrf "Manages configuration of an OSPF VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf_vrf:
		ospf: ${2:# The ID of the ospf process. Valid values are an integer, 1 - 4294967295, the default value is 1.}
		# description: ${3:# Specifies the description information of ospf process.}
		# lsaostartinterval: ${4:# Specifies the start interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 1000, the default value is 500.}
		# lsaastartinterval: ${5:# Specifies the start interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.}
		# lsaointerval: ${6:# Specifies the interval of originate LSA . Valid value is an integer, in second, from 0 to 10, the default value is 5.}
		# bandwidth: ${7:# Specifies the reference bandwidth used to assign ospf cost. Valid values are an integer, in Mbps, 1 - 2147483648, the default value is 100.}
		# spfintervalmi: ${8:# Specifies the interval to calculate SPF when use millisecond level  timer. Valid value is an integer, in millisecond, from 1 to 10000.}
		# spfinterval: ${9:# Specifies the interval to calculate SPF when use second level  timer. Valid value is an integer, in second, from 1 to 10.}
		# lsaointervalflag: ${10:no}
		# lsaomaxinterval: ${11:# Specifies the max interval of originate LSA . Valid value is an integer, in millisecond, from 1 to 10000, the default value is 5000.}
		# lsaalflag: ${12:no}
		# lsaamaxinterval: ${13:# Specifies the max interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 1000.}
		# lsaoholdinterval: ${14:# Specifies the hold interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 5000, the default value is 1000.}
		# spfintervaltype: ${15:#intelligent-timer|timer|millisecond}
		# lsaainterval: ${16:# Specifies the interval of arrive LSA when use the general timer. Valid value is an integer, in millisecond, from 0 to 10000.}
		# spfstartinterval: ${17:# Specifies the start interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 1000, the default value is 50.}
		# route_id: ${18:# Specifies the ospf private route id,. Valid values are a string, formatted as an IP address (i.e. "10.1.1.1") the length is 0 - 20.}
		# state: ${19:#present|absent}
		# spfmaxinterval: ${20:# Specifies the max interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 20000, the default value is 5000.}
		# spfholdinterval: ${21:# Specifies the hold interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 5000, the default value is 200.}
		# lsaaholdinterval: ${22:# Specifies the hold interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.}
		# vrf: ${23:_public_}
$0
endsnippet

snippet ce_reboot "Reboot a HUAWEI CloudEngine switches." b
- name: $1
	ce_reboot:
		# save_config: ${2:no}
		# confirm: ${3:no}
$0
endsnippet

snippet ce_rollback "Set a checkpoint or rollback to a checkpoint on HUAWEI CloudEngine switches." b
- name: $1
	ce_rollback:
		action: ${2:rollback|clear|set|display|commit}
		# commit_id: ${3:# Specifies the label of the configuration rollback point to which system configurations are expected to roll back. The value is an integer that the system generates automatically.}
		# oldest: ${4:# Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.}
		# last: ${5:# Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.}
		# filename: ${6:# Specifies a configuration file for configuration rollback. The value is a string of 5 to 64 case-sensitive characters in the format of *.zip, *.cfg, or *.dat, spaces not supported.}
		# label: ${7:# Specifies a user label for a configuration rollback point. The value is a string of 1 to 256 case-sensitive ASCII characters, spaces not supported. The value must start with a letter and cannot be presented in a single hyphen (-).}
$0
endsnippet

snippet ce_sflow "Manages sFlow configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_sflow:
		# agent_ip: ${2:# Specifies the IPv4/IPv6 address of an sFlow agent.}
		# export_route: ${3:enable|disable}
		# counter_collector: ${4:# Indicates the ID list of the counter collector.}
		# rate_limit_slot: ${5:# Specifies the slot where the rate of output sFlow packets is limited. If this parameter is not specified, the rate of sFlow packets sent from all cards to the control plane is limited. The value is an integer or a string of characters.}
		# source_ip: ${6:# Specifies the source IPv4/IPv6 address of sFlow packets.}
		# collector_datagram_size: ${7:# Specifies the maximum length of sFlow packets sent from an sFlow agent to an sFlow collector. The value is an integer, in bytes. It ranges from 1024 to 8100. The default value is 1400.}
		# sample_collector: ${8:# Indicates the ID list of the collector.}
		# rate_limit: ${9:# Specifies the rate of sFlow packets sent from a card to the control plane. The value is an integer that ranges from 100 to 1500, in pps.}
		# sample_direction: ${10:inbound|outbound|both}
		# collector_meth: ${11:meth|enhanced}
		# collector_ip_vpn: ${12:# Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
		# forward_enp_slot: ${13:# Enable the Embedded Network Processor (ENP) chip function. The switch uses the ENP chip to perform sFlow sampling, and the maximum sFlow sampling interval is 65535. If you set the sampling interval to be larger than 65535, the switch automatically restores it to 65535. The value is an integer or 'all'.}
		# collector_ip: ${14:# Specifies the IPv4/IPv6 address of the sFlow collector.}
		# sflow_interface: ${15:# Full name of interface for Flow Sampling or Counter. It must be a physical interface, Eth-Trunk, or Layer 2 subinterface.}
		# sample_length: ${16:# Specifies the maximum length of sampled packets. The value is an integer and ranges from 18 to 512, in bytes. The default value is 128.}
		# state: ${17:#present|absent}
		# collector_id: ${18:1|2}
		# sample_rate: ${19:# Specifies the flow sampling rate in the format 1/rate. The value is an integer and ranges from 1 to 4294967295. The default value is 8192.}
		# collector_udp_port: ${20:# Specifies the UDP destination port number of sFlow packets. The value is an integer that ranges from 1 to 65535. The default value is 6343.}
		# counter_interval: ${21:# Indicates the counter sampling interval. The value is an integer that ranges from 10 to 4294967295, in seconds. The default value is 20.}
		# collector_description: ${22:# Specifies the description of an sFlow collector. The value is a string of 1 to 255 case-sensitive characters without spaces.}
$0
endsnippet

snippet ce_snmp_community "Manages SNMP community configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_community:
		# notify_view: ${2:# Mib view name for notification.}
		# community_name: ${3:# Unique name to identify the community.}
		# community_mib_view: ${4:# Mib view name.}
		# read_view: ${5:# Mib view name for read.}
		# acl_number: ${6:# Access control list number.}
		# group_name: ${7:# Unique name to identify the SNMPv3 group.}
		# write_view: ${8:# Mib view name for write.}
		# state: ${9:#present|absent}
		# security_level: ${10:noAuthNoPriv|authentication|privacy}
		# access_right: ${11:read|write}
$0
endsnippet

snippet ce_snmp_contact "Manages SNMP contact configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_contact:
		contact: ${2:# Contact information.}
		# state: ${3:#present|absent}
$0
endsnippet

snippet ce_snmp_location "Manages SNMP location configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_location:
		location: ${2:# Location information.}
		# state: ${3:#present|absent}
$0
endsnippet

snippet ce_snmp_target_host "Manages SNMP target host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_target_host:
		# security_name_v3: ${2:# Security Name V3.}
		# recv_port: ${3:# UDP Port number used by network management to receive alarm messages.}
		# security_model: ${4:v1|v2c|v3}
		# vpn_name: ${5:# VPN instance Name.}
		# address: ${6:# Network Address.}
		# security_name: ${7:# Security Name.}
		# notify_type: ${8:trap|inform}
		# connect_port: ${9:# Udp port used by SNMP agent to connect the Network management.}
		# version: ${10:none|v1|v2c|v3|v1v2c|v1v3|v2cv3|all}
		# host_name: ${11:# Unique name to identify target host entry.}
		# security_level: ${12:noAuthNoPriv|authentication|privacy}
		# interface_name: ${13:# Name of the interface to send the trap message.}
		# is_public_net: ${14:#no_use|true|false}
$0
endsnippet

snippet ce_snmp_traps "Manages SNMP traps configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_traps:
		# feature_name: ${2:aaa|arp|bfd|bgp|cfg|configuration|dad|devm|dhcpsnp|dldp|driver|efm|erps|error-down|fcoe|fei|fei_comm|fm|ifnet|info|ipsg|ipv6|isis|l3vpn|lacp|lcs|ldm|ldp|ldt|lldp|mpls_lspm|msdp|mstp|nd|netconf|nqa|nvo3|openflow|ospf|ospfv3|pim|pim-std|qos|radius|rm|rmon|securitytrap|smlktrap|snmp|ssh|stackmng|sysclock|sysom|system|tcp|telnet|trill|trunk|tty|vbst|vfs|virtual-perception|vrrp|vstm|all}
		# interface_type: ${3:Ethernet|Eth-Trunk|Tunnel|NULL|LoopBack|Vlanif|100GE|40GE|MTunnel|10GE|GE|MEth|Vbdif|Nve}
		# trap_name: ${4:# Alarm trap name.}
		# port_number: ${5:# Source port number.}
		# interface_number: ${6:# Interface number.}
$0
endsnippet

snippet ce_snmp_user "Manages SNMP user configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_user:
		# priv_key: ${2:# The encryption password. Password length 8-255 characters.}
		# aaa_local_user: ${3:# Unique name to identify the local user.}
		# auth_key: ${4:# The authentication password. Password length, 8-255 characters.}
		# usm_user_name: ${5:# Unique name to identify the USM user.}
		# acl_number: ${6:# Access control list number.}
		# auth_protocol: ${7:noAuth|md5|sha}
		# remote_engine_id: ${8:# Remote engine id of the USM user.}
		# priv_protocol: ${9:noPriv|des56|3des168|aes128|aes192|aes256}
		# user_group: ${10:# Name of the group where user belongs to.}
$0
endsnippet

snippet ce_startup "Manages a system startup information on HUAWEI CloudEngine switches." b
- name: $1
	ce_startup:
		# slot: ${2:# Position of the device.The value is a string of 1 to 32 characters. The possible value of slot is all, slave-board, or the specific slotID.}
		# action: ${3:display}
		# cfg_file: ${4:present}
		# patch_file: ${5:# Name of the patch file that is applied for the next startup.}
		# software_file: ${6:# File name of the system software that is applied for the next startup. The value is a string of 5 to 255 characters.}
$0
endsnippet

snippet ce_static_route "Manages static route configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_static_route:
		prefix: ${2:# Destination ip address of static route.}
		aftype: ${3:v4|v6}
		mask: ${4:# Destination ip mask of static route.}
		# description: ${5:# Name of the route. Used with the name parameter on the CLI.}
		# pref: ${6:# Preference or administrative difference of route (range 1-255).}
		# destvrf: ${7:# VPN instance of next hop ip address.}
		# nhp_interface: ${8:# Next hop interface full name of static route.}
		# state: ${9:#present|absent}
		# next_hop: ${10:# Next hop address of static route.}
		# vrf: ${11:# VPN instance of destination ip address.}
		# tag: ${12:# Route tag value (numeric).}
$0
endsnippet

snippet ce_stp "Manages STP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_stp:
		# loop_protection: ${2:enable|disable}
		# tc_protection_threshold: ${3:# Set the maximum number of TC BPDUs that the MSTP can handle. The value is an integer ranging from 1 to 255. The default value is 1 on the switch.}
		# bpdu_filter: ${4:enable|disable}
		# stp_converge: ${5:fast|normal}
		# stp_mode: ${6:stp|rstp|mstp}
		# bpdu_protection: ${7:enable|disable}
		# root_protection: ${8:enable|disable}
		# state: ${9:#present|absent}
		# cost: ${10:# Set the path cost of the current port. The default instance is 0.}
		# stp_enable: ${11:enable|disable}
		# interface: ${12:# Interface name. If the value is C(all), will apply configuration to all interfaces. if the value is a special name, only support input the full name.}
		# tc_protection: ${13:enable|disable}
		# edged_port: ${14:enable|disable}
		# tc_protection_interval: ${15:# Set the time the MSTP device takes to handle the maximum number of TC BPDUs and immediately refresh forwarding entries. The value is an integer ranging from 1 to 600, in seconds.}
$0
endsnippet

snippet ce_switchport "Manages Layer 2 switchport interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_switchport:
		interface: ${2:# Full name of the interface, i.e. 40GE1/0/22.}
		# native_vlan: ${3:# If C(mode=trunk), used as the trunk native VLAN ID, in the range from 1 to 4094.}
		# access_vlan: ${4:# If C(mode=access), used as the access VLAN ID, in the range from 1 to 4094.}
		# state: ${5:#present|absent|unconfigured}
		# mode: ${6:access|trunk}
		# trunk_vlans: ${7:# If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.}
$0
endsnippet

snippet ce_vlan "Manages VLAN resources and attributes on Huawei CloudEngine switches." b
- name: $1
	ce_vlan:
		# state: ${2:#present|absent}
		# vlan_range: ${3:# Range of VLANs such as C(2-10) or C(2,5,10-15), etc.}
		# name: ${4:# Name of VLAN, in the range from 1 to 31.}
		# vlan_id: ${5:# Single VLAN ID, in the range from 1 to 4094.}
		# description: ${6:# Specify VLAN description, in the range from 1 to 80.}
$0
endsnippet

snippet ce_vrf "Manages VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf:
		vrf: ${2:# VPN instance, the length of vrf name is 1 - 31, i.e. "test", but can not be C(_public_).}
		# state: ${3:#present|absent}
		# description: ${4:# Description of the vrf, the string length is 1 - 242 .}
$0
endsnippet

snippet ce_vrf_af "Manages VPN instance address family on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_af:
		vrf: ${2:# VPN instance.}
		# vpn_target_type: ${3:export_extcommunity|import_extcommunity}
		# vpn_target_state: ${4:present|absent}
		# vrf_aftype: ${5:#v4|v6}
		# state: ${6:#present|absent}
		# route_distinguisher: ${7:# VPN instance route distinguisher,the RD used to distinguish same route prefix from different vpn. The RD must be setted before setting vpn_target_value.}
		# evpn: ${8:true|false}
		# vpn_target_value: ${9:# VPN instance target value. Such as X.X.X.X:number<0-65535> or number<0-65535>:number<0-4294967295> or number<0-65535>.number<0-65535>:number<0-65535> or number<65536-4294967295>:number<0-65535> but not support 0:0 and 0.0:0.}
$0
endsnippet

snippet ce_vrf_interface "Manages interface specific VPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_interface:
		vrf: ${2:# VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_).}
		vpn_interface: ${3:# An interface that can binding VPN instance, i.e. 40GE1/0/22, Vlanif10. Must be fully qualified interface name. Interface types, such as 10GE, 40GE, 100GE, LoopBack, MEth, Tunnel, Vlanif....}
		# state: ${4:#present|absent}
$0
endsnippet

snippet ce_vrrp "Manages VRRP interfaces on HUAWEI CloudEngine devices." b
- name: $1
	ce_vrrp:
		# vrrp_type: ${2:normal|member|admin}
		# auth_mode: ${3:simple|md5|none}
		# is_plain: ${4:no}
		# interface: ${5:# Name of an interface. The value is a string of 1 to 63 characters.}
		# preempt_timer_delay: ${6:# Preemption delay. The value is an integer ranging from 0 to 3600. The default value is 0.}
		# gratuitous_arp_interval: ${7:# Interval at which gratuitous ARP packets are sent, in seconds. The value ranges from 30 to 1200.The default value is 300.}
		# auth_key: ${8:# This object is set based on the authentication type. When noAuthentication is specified, the value is empty. When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters in plaintext and displayed as a blank text for security.}
		# vrid: ${9:present}
		# priority: ${10:# Configured VRRP priority. The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.}
		# recover_delay: ${11:# Delay in recovering after an interface goes Up. The delay is used for interface flapping suppression. The value is an integer ranging from 0 to 3600. The default value is 0 seconds.}
		# state: ${12:#present|absent}
		# version: ${13:v2|v3}
		# virtual_ip: ${14:# Virtual IP address. The value is a string of 0 to 255 characters.}
		# admin_interface: ${15:# Tracked mVRRP interface name. The value is a string of 1 to 63 characters.}
		# admin_ignore_if_down: ${16:no}
		# fast_resume: ${17:enable|disable}
		# admin_flowdown: ${18:no}
		# holding_multiplier: ${19:# The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.}
		# admin_vrid: ${20:# Tracked mVRRP ID. The value is an integer ranging from 1 to 255.}
		# advertise_interval: ${21:# Configured interval between sending advertisements, in milliseconds. Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.}
$0
endsnippet

snippet ce_vxlan_arp "Manages ARP attributes of VXLAN on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_arp:
		# evn_bgp: ${2:enable|disable}
		# vbdif_name: ${3:# Full name of VBDIF interface, i.e. Vbdif100.}
		# bridge_domain_id: ${4:# Specifies a BD(bridge domain) ID. The value is an integer ranging from 1 to 16777215.}
		# state: ${5:#present|absent}
		# evn_server: ${6:enable|disable}
		# evn_peer_ip: ${7:# Specifies the IP address of an EVN BGP peer. The value is in dotted decimal notation.}
		# evn_source_ip: ${8:# Specifies the source address of an EVN BGP peer. The value is in dotted decimal notation.}
		# arp_collect_host: ${9:enable|disable}
		# arp_suppress: ${10:enable|disable}
		# evn_reflect_client: ${11:enable|disable}
		# host_collect_protocol: ${12:bgp|none}
$0
endsnippet

snippet ce_vxlan_gateway "Manages gateway for the VXLAN network on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_gateway:
		# dfs_source_vpn: ${2:# Specifies the name of a VPN instance bound to a DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
		# dfs_id: ${3:# Specifies the ID of a DFS group. The value must be 1.}
		# arp_direct_route: ${4:enable|disable}
		# dfs_peer_vpn: ${5:# Specifies the name of the VPN instance that is associated with all-active gateway peer. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
		# vbdif_name: ${6:# Full name of VBDIF interface, i.e. Vbdif100.}
		# vpn_vni: ${7:# Specifies a VNI ID. Binds a VXLAN network identifier (VNI) to a virtual private network (VPN) instance. The value is an integer ranging from 1 to 16000000.}
		# vbdif_mac: ${8:# Specifies a MAC address for a VBDIF interface. The value is in the format of H-H-H. Each H is a 4-digit hexadecimal number, such as C(00e0) or C(fc01). If an H contains less than four digits, 0s are added ahead. For example,  C(e0) is equal to C(00e0). A MAC address cannot be all 0s or 1s or a multicast MAC address.}
		# vbdif_bind_vpn: ${9:# Specifies the name of the VPN instance that is associated with the interface. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
		# dfs_source_ip: ${10:# Specifies the IPv4 address bound to a DFS group. The value is in dotted decimal notation.}
		# dfs_udp_port: ${11:# Specifies the UDP port number of the DFS group. The value is an integer that ranges from 1025 to 65535.}
		# arp_distribute_gateway: ${12:enable|disable}
		# state: ${13:#present|absent}
		# dfs_all_active: ${14:enable|disable}
		# vpn_instance: ${15:# Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
		# dfs_peer_ip: ${16:# Configure the IP address of an all-active gateway peer. The value is in dotted decimal notation.}
$0
endsnippet

snippet ce_vxlan_global "Manages global attributes of VXLAN and bridge domain on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_global:
		# nvo3_prevent_loops: ${2:enable|disable}
		# nvo3_eth_trunk_hash: ${3:enable|disable}
		# tunnel_mode_vxlan: ${4:enable|disable}
		# nvo3_acl_extend: ${5:enable|disable}
		# bridge_domain_id: ${6:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
		# nvo3_gw_enhanced: ${7:l2|l3}
		# state: ${8:#present|absent}
		# nvo3_ecmp_hash: ${9:enable|disable}
		# nvo3_service_extend: ${10:enable|disable}
$0
endsnippet

snippet ce_vxlan_tunnel "Manages VXLAN tunnel configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_tunnel:
		# vni_id: ${2:# Specifies a VXLAN network identifier (VNI) ID. The value is an integer ranging from 1 to 16000000.}
		# nve_mode: ${3:mode-l2|mode-l3}
		# source_ip: ${4:# Specifies an IP address for a source VTEP. The value is in dotted decimal notation.}
		# bridge_domain_id: ${5:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
		# peer_list_ip: ${6:# Specifies the IP address of a remote VXLAN tunnel endpoints (VTEP). The value is in dotted decimal notation.}
		# state: ${7:#present|absent}
		# nve_name: ${8:# Specifies the number of an NVE interface. The value ranges from 1 to 2.}
		# protocol_type: ${9:bgp|null}
$0
endsnippet

snippet ce_vxlan_vap "Manages VXLAN virtual access point on HUAWEI CloudEngine Devices." b
- name: $1
	ce_vxlan_vap:
		# state: ${2:#present|absent}
		# pe_vid: ${3:# When I(encapsulation) is 'qinq', specifies an inner VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.}
		# l2_sub_interface: ${4:# Specifies an Sub-Interface full name, i.e. "10GE1/0/41.1". The value is a string of 1 to 63 case-insensitive characters, spaces supported.}
		# ce_vid: ${5:# When I(encapsulation) is 'dot1q', specifies a VLAN ID in the outer VLAN tag. When I(encapsulation) is 'qinq', specifies an outer VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.}
		# encapsulation: ${6:dot1q|default|untag|qinq|none}
		# bind_vlan_id: ${7:# Specifies the VLAN binding to a BD(Bridge Domain). The value is an integer ranging ranging from 1 to 4094.}
		# bridge_domain_id: ${8:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
$0
endsnippet

snippet cv_server_provision "Provision server port by applying or removing template configuration to an Arista CloudVision Portal configlet that is applied to a switch." b
- name: $1
	cv_server_provision:
		username: ${2:# The user that will be used to connect to CVP for making API calls.}
		switch_port: ${3:# The physical port number on the switch that the new server is connected to.}
		server_name: ${4:# The hostname or identifier for the server that is having it's switch port provisioned.}
		host: ${5:# The hostname or IP address of the CVP node being connected to.}
		template: ${6:# A path to a Jinja formatted template file that contains the configuration block that will be applied to the specified switch port. This template will have variable fields replaced by the module before being applied to the switch configuration.}
		password: ${7:# The password of the user that will be used to connect to CVP for API calls.}
		switch_name: ${8:# The hostname of the switch is being configured for the server being provisioned.}
		# port_vlan: ${9:# The vlan that should be applied to the port for this server. This parameter is dependent on a proper template that supports single vlan provisioning with it. If a port vlan is specified by the template specified does not support this the module will exit out with no changes. If a template is specified that requires a port vlan but no port vlan is specified the module will exit out with no changes.}
		# protocol: ${10:#https|http}
		# port: ${11:# The port number to use when making API calls to the CVP node. This will default to the default port for the specified protocol. Port 80 for http and port 443 for https.}
		# auto_run: ${12:no}
		# action: ${13:#show|add|remove}
$0
endsnippet

snippet nclu "Configure network interfaces using NCLU" b
- name: $1
	nclu:
		# commands: ${2:# A list of strings containing the net commands to run. Mutually exclusive with I(template).}
		# abort: ${3:no}
		# description: ${4:Ansible-originated commit}
		# template: ${5:# A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).}
		# commit: ${6:no}
		# atomic: ${7:no}
$0
endsnippet

snippet dellos10_command "Run commands on remote devices running Dell OS10" b
- name: $1
	dellos10_command:
		commands: ${2:# List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		# interval: ${5:1}
		# provider: ${6:# A dict object containing connection details.}
$0
endsnippet

snippet dellos10_config "Manage Dell EMC Networking OS10 configuration sections" b
- name: $1
	dellos10_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		# backup: ${3:yes|no}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook designer can use this argument  to append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		# update: ${6:#merge|check}
		# replace: ${7:#line|block}
		# parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.}
		# provider: ${9:# A dict object containing connection details.}
		# save: ${10:yes|no}
		# config: ${11:# The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node.}
		# match: ${12:#line|strict|exact|none}
		# before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can  use this argument to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos10_facts "Collect facts from remote devices running Dell EMC Networking OS10" b
- name: $1
	dellos10_facts:
		# gather_subset: ${2:!config}
		# provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet dellos6_command "Run commands on remote devices running Dell OS6" b
- name: $1
	dellos6_command:
		commands: ${2:# List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) as expired.}
		# retries: ${3:10}
		# wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		# interval: ${5:1}
		# provider: ${6:# A dict object containing connection details.}
$0
endsnippet

snippet dellos6_config "Manage Dell EMC Networking OS6 configuration sections" b
- name: $1
	dellos6_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		# backup: ${3:yes|no}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook desinger can use this to append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		# update: ${6:#merge|check}
		# replace: ${7:#line|block}
		# parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you do not specify the parents argument, the commands are checked against the set of top level or global commands.}
		# provider: ${9:# A dict object containing connection details.}
		# save: ${10:yes|no}
		# config: ${11:# The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node.}
		# match: ${12:#line|strict|exact|none}
		# before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos6_facts "Collect facts from remote devices running Dell EMC Networking OS6" b
- name: $1
	dellos6_facts:
		# gather_subset: ${2:!config}
		# provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet dellos9_command "Run commands on remote devices running Dell OS9" b
- name: $1
	dellos9_command:
		commands: ${2:# List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		# interval: ${5:1}
		# provider: ${6:# A dict object containing connection details.}
$0
endsnippet

snippet dellos9_config "Manage Dell EMC Networking OS9 configuration sections" b
- name: $1
	dellos9_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		# backup: ${3:yes|no}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made. As with I(before), this the playbook designer can append a set of commands to be executed after the command set.}
		# lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		# update: ${6:#merge|check}
		# replace: ${7:#line|block}
		# parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.}
		# provider: ${9:# A dict object containing connection details.}
		# save: ${10:yes|no}
		# config: ${11:# The playbook designer can use the  C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you provide this argument, the module does not download the running-config from the remote node.}
		# match: ${12:#line|strict|exact|none}
		# before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can use this opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos9_facts "Collect facts from remote devices running Dell EMC Networking OS9" b
- name: $1
	dellos9_facts:
		# gather_subset: ${2:!config}
		# provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet eos_banner "Manage multiline banners on Arista EOS devices" b
- name: $1
	eos_banner:
		banner: ${2:login|motd}
		# authorize: ${3:yes|no}
		# state: ${4:#present|absent}
		# provider: ${5:# A dict object containing connection details.}
		# text: ${6:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).}
		# auth_pass: ${7:none}
$0
endsnippet

snippet eos_command "Run arbitrary commands on an Arista EOS device" b
- name: $1
	eos_command:
		commands: ${2:# The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# authorize: ${3:yes|no}
		# retries: ${4:10}
		# interval: ${5:1}
		# auth_pass: ${6:none}
		# provider: ${7:# A dict object containing connection details.}
		# wait_for: ${8:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		# match: ${9:any|#all}
$0
endsnippet

snippet eos_config "Manage Arista EOS configuration sections" b
- name: $1
	eos_config:
		# authorize: ${2:yes|no}
		# force: ${3:no}
		# after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# diff_against: ${5:startup|running|intended|#session}
		# replace: ${6:#line|block|config}
		# running_config: ${7:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for this module.}
		# diff_ignore_lines: ${8:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
		# src: ${9:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments. It can be a Jinja2 template as well.}
		# save_when: ${10:always|#never|modified}
		# auth_pass: ${11:none}
		# lines: ${12:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# intended_config: ${13:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
		# parents: ${14:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# defaults: ${15:no}
		# provider: ${16:# A dict object containing connection details.}
		# before: ${17:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
		# save: ${18:no}
		# backup: ${19:no}
		# match: ${20:#line|strict|exact|none}
$0
endsnippet

snippet eos_eapi "Manage and configure Arista EOS eAPI." b
- name: $1
	eos_eapi:
		# authorize: ${2:yes|no}
		# local_http_port: ${3:8080}
		# http_port: ${4:80}
		# http: ${5:yes|no}
		# https_port: ${6:443}
		# auth_pass: ${7:none}
		# state: ${8:#started|stopped}
		# vrf: ${9:default}
		# https: ${10:yes|no}
		# provider: ${11:# A dict object containing connection details.}
		# config: ${12:nul}
		# local_http: ${13:yes|no}
		# socket: ${14:yes|no}
$0
endsnippet

snippet eos_facts "Collect facts from remote devices running Arista EOS" b
- name: $1
	eos_facts:
		# authorize: ${2:yes|no}
		# gather_subset: ${3:!config}
		# auth_pass: ${4:none}
		# provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet eos_logging "Manage logging on network devices" b
- name: $1
	eos_logging:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# name: ${4:# If value of C(dest) is I(host) C(name) should be specified, which indicates hostname or IP address.}
		# level: ${5:emergencies|alerts|critical|errors|warnings|notifications|informational|debugging}
		# dest: ${6:on|host|console'|monitor|buffered}
		# facility: ${7:# Set logging facility.}
		# size: ${8:# Size of buffer. The acceptable value is in range from 10 to 2147483647 bytes.}
$0
endsnippet

snippet eos_system "Manage the system attributes on Arista EOS devices" b
- name: $1
	eos_system:
		# authorize: ${2:yes|no}
		# hostname: ${3:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# lookup_source: ${4:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.}
		# domain_search: ${5:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		# auth_pass: ${6:none}
		# domain_name: ${7:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
		# state: ${8:#present|absent}
		# provider: ${9:# A dict object containing connection details.}
		# name_servers: ${10:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.}
$0
endsnippet

snippet eos_user "Manage the collection of local users on EOS devices" b
- name: $1
	eos_user:
		# authorize: ${2:yes|no}
		# update_password: ${3:on_create|#always}
		# configured_password: ${4:# The password to be configured on the remote Arista EOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# name: ${5:# The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
		# auth_pass: ${6:none}
		# nopassword: ${7:# Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.}
		# purge: ${8:no}
		# privilege: ${9:# The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.}
		# state: ${10:#present|absent}
		# role: ${11:# Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
		# provider: ${12:# A dict object containing connection details.}
		# aggregate: ${13:# The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument. alias C(users).}
		# sshkey: ${14:# Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.}
$0
endsnippet

snippet eos_vlan "Manage VLANs on Arista EOS network devices" b
- name: $1
	eos_vlan:
		vlan_id: ${2:# ID of the VLAN.}
		# purge: ${3:no}
		# delay: ${4:10}
		# state: ${5:#present|absent|active|suspend}
		# name: ${6:# Name of the VLAN.}
		# aggregate: ${7:# L}
		# interfaces: ${8:# List of interfaces that should be associated to the VLAN.}
$0
endsnippet

snippet eos_vrf "Manage VRFs on Arista EOS network devices" b
- name: $1
	eos_vrf:
		name: ${2:# Name of the VRF.}
		# delay: ${3:10}
		# rd: ${4:# Route distinguisher of the VRF}
		# state: ${5:#present|absent}
		# purge: ${6:no}
		# aggregate: ${7:# L}
		# interfaces: ${8:# List of interfaces to check the VRF has been configured correctly.}
$0
endsnippet

snippet bigip_command "Run arbitrary command on F5 devices." b
- name: $1
	bigip_command:
		commands: ${2:# The commands to send to the remote BIG-IP device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries as expired.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# retries: ${6:10}
		# wait_for: ${7:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails. See examples.}
		# interval: ${8:1}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
		# match: ${11:all}
$0
endsnippet

snippet bigip_config "Manage BIG-IP configuration sections." b
- name: $1
	bigip_config:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# reset: ${5:True|#False}
		# save: ${6:True|#False}
		# merge_content: ${7:# Loads the specified configuration that you want to merge into the running configuration. This is equivalent to using the C(tmsh) command C(load sys config from-terminal merge). If you need to read configuration from a file or template, use Ansible's C(file) or C(template) lookup plugins respectively.}
		# verify: ${8:#True|False}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet bigip_configsync_action "Perform different actions related to config-sync." b
- name: $1
	bigip_configsync_action:
		device_group: ${2:# The device group that you want to perform config-sync actions on.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# sync_most_recent_to_device: ${6:True|False}
		# sync_device_to_group: ${7:True|False}
		# server_port: ${8:443}
		# overwrite_config: ${9:True|#False}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet bigip_configsync_action "Perform different actions related to config-sync." b
- name: $1
	bigip_configsync_action:
		device_group: ${2:# The device group that you want to perform config-sync actions on.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# sync_most_recent_to_device: ${6:True|False}
		# sync_device_to_group: ${7:True|False}
		# server_port: ${8:443}
		# overwrite_config: ${9:True|#False}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings" b
- name: $1
	bigip_device_dns:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# search: ${5:# A list of domains that the system searches for local domain lookups, to resolve local host names.}
		# cache: ${6:enable|#disable}
		# ip_version: ${7:4|6}
		# state: ${8:absent|#present}
		# server_port: ${9:443}
		# forwarders: ${10:# A list of BIND servers that the system can use to perform DNS lookups}
		# name_servers: ${11:# A list of name serverz that the system uses to validate DNS lookups}
		# validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP" b
- name: $1
	bigip_device_ntp:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# ntp_servers: ${5:[]}
		# state: ${6:absent|#present}
		# server_port: ${7:443}
		# timezone: ${8:UTC}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP" b
- name: $1
	bigip_device_sshd:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# log_level: ${5:debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose}
		# allow: ${6:all|IP address, such as 172.27.1.10|IP range, such as 172.27.*.* or 172.27.0.0/255.255.0.0}
		# banner_text: ${7:# Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.}
		# banner: ${8:enabled|disabled}
		# server_port: ${9:443}
		# inactivity_timeout: ${10:# Specifies the number of seconds before inactivity causes an SSH session to log out.}
		# login: ${11:enabled|disabled}
		# validate_certs: ${12:#True|False}
		# port: ${13:# Port that you want the SSH daemon to run on.}
$0
endsnippet

snippet bigip_facts "Collect facts from F5 BIG-IP devices" b
- name: $1
	bigip_facts:
		include: ${2:address_class|certificate|client_ssl_profile|device|device_group|interface|key|node|pool|provision|rule|self_ip|software|system_info|traffic_group|trunk|virtual_address|virtual_server|vlan}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# filter: ${6:}
		# session: ${7:}
		# server_port: ${8:443}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP" b
- name: $1
	bigip_gtm_datacenter:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# The name of the data center.}
		# description: ${6:# The description of the data center.}
		# enabled: ${7:True|False}
		# location: ${8:# The location of the data center.}
		# state: ${9:present|absent}
		# contact: ${10:# The name of the contact for the data center.}
		# server_port: ${11:443}
		# validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_gtm_facts "Collect facts from F5 BIG-IP GTM devices." b
- name: $1
	bigip_gtm_facts:
		include: ${2:pool|wide_ip|virtual_server}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# filter: ${6:# Perform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module.}
		# server_port: ${7:443}
		# validate_certs: ${8:#True|False}
$0
endsnippet

snippet bigip_gtm_pool "Manages F5 BIG-IP GTM pools." b
- name: $1
	bigip_gtm_pool:
		name: ${2:# Name of the GTM pool.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		state: ${4:present|absent|enabled|disabled}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# alternate_lb_method: ${7:round-robin|return-to-dns|none|ratio|topology|static-persistence|global-availability|virtual-server-capacity|packet-rate|drop-packet|fallback-ip|virtual-server-score}
		# type: ${8:a|aaaa|cname|mx|naptr|srv}
		# fallback_ip: ${9:# Specifies the IPv4, or IPv6 address of the server to which the system directs requests when it cannot use one of its pools to do so. Note that the system uses the fallback IP only if you select the C(fallback_ip) load balancing method.}
		# fallback_lb_method: ${10:round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score}
		# server_port: ${11:443}
		# preferred_lb_method: ${12:round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score}
		# validate_certs: ${13:#True|False}
$0
endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers" b
- name: $1
	bigip_gtm_virtual_server:
		virtual_server_name: ${2:# Virtual server name}
		virtual_server_server: ${3:# Virtual server server}
		server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# state: ${7:#present|absent|enabled|disabled}
		# host: ${8:# Virtual server host}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
		# port: ${11:# Virtual server port}
$0
endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip." b
- name: $1
	bigip_gtm_wide_ip:
		lb_method: ${2:round-robin|ratio|topology|global-availability}
		name: ${3:# Wide IP name. This name must be formatted as a fully qualified domain name (FQDN). You can also use the alias C(wide_ip) but this is deprecated and will be removed in a future Ansible version.}
		server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# type: ${7:a|aaaa|cname|mx|naptr|srv}
		# state: ${8:#present|absent|disabled|enabled}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
$0
endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP." b
- name: $1
	bigip_hostname:
		hostname: ${2:# Hostname of the BIG-IP host.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# server_port: ${6:443}
		# validate_certs: ${7:#True|False}
$0
endsnippet

snippet bigip_iapp_service "Manages TCL iApp services on a BIG-IP." b
- name: $1
	bigip_iapp_service:
		name: ${2:# The name of the iApp service that you want to deploy.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# force: ${6:no}
		# parameters: ${7:# A hash of all the required template variables for the iApp template. If your parameters are stored in a file (the more common scenario) it is recommended you use either the `file` or `template` lookups to supply the expected parameters.}
		# state: ${8:#present|absent}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
		# template: ${11:# The iApp template from which to instantiate a new service. This template must exist on your BIG-IP before you can successfully create a service. This parameter is required if the C(state) parameter is C(present).}
$0
endsnippet

snippet bigip_iapp_template "Manages TCL iApp templates on a BIG-IP." b
- name: $1
	bigip_iapp_template:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# force: ${5:True|False}
		# name: ${6:# The name of the iApp template that you want to delete. This option is only available when specifying a C(state) of C(absent) and is provided as a way to delete templates that you may no longer have the source of.}
		# partition: ${7:Common}
		# content: ${8:# Sets the contents of an iApp template directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. C(content) must be provided when creating new templates.}
		# state: ${9:#present|absent}
		# server_port: ${10:443}
		# validate_certs: ${11:#True|False}
$0
endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP." b
- name: $1
	bigip_irule:
		src: ${2:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}
		name: ${3:# The name of the iRule.}
		module: ${4:ltm|gtm}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${7:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# content: ${8:# When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.}
		# state: ${9:#present|absent}
		# server_port: ${10:443}
		# validate_certs: ${11:#True|False}
$0
endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors" b
- name: $1
	bigip_monitor_http:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		receive_disable: ${4:none}
		name: ${5:# Monitor name}
		receive: ${6:none}
		send: ${7:none}
		server: ${8:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# interval: ${9:none}
		# timeout: ${10:none}
		# parent: ${11:http}
		# ip: ${12:none}
		# port: ${13:none}
		# partition: ${14:Common}
		# state: ${15:#present|absent}
		# time_until_up: ${16:none}
		# server_port: ${17:443}
		# parent_partition: ${18:Common}
		# validate_certs: ${19:#True|False}
$0
endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors." b
- name: $1
	bigip_monitor_tcp:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# parent: ${6:/Common/tcp}
		# receive: ${7:# The receive string for the monitor call.}
		# ip: ${8:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
		# interval: ${9:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
		# timeout: ${10:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
		# send: ${11:# The send string for the monitor call.}
		# time_until_up: ${12:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
		# server_port: ${13:443}
		# type: ${14:#tcp|tcp_echo|tcp_half_open|TTYPE_TCP|TTYPE_TCP_ECHO|TTYPE_TCP_HALF_OPEN}
		# validate_certs: ${15:#True|False}
		# port: ${16:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
$0
endsnippet

snippet bigip_monitor_tcp_echo "Manages F5 BIG-IP LTM tcp monitors." b
- name: $1
	bigip_monitor_tcp_echo:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# parent: ${6:/Common/tcp}
		# ip: ${7:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
		# interval: ${8:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
		# timeout: ${9:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
		# time_until_up: ${10:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
		# server_port: ${11:443}
		# validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_monitor_tcp_half_open "Manages F5 BIG-IP LTM tcp monitors." b
- name: $1
	bigip_monitor_tcp_half_open:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# parent: ${6:/Common/tcp}
		# ip: ${7:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
		# interval: ${8:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
		# timeout: ${9:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
		# time_until_up: ${10:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
		# server_port: ${11:443}
		# validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes" b
- name: $1
	bigip_node:
		host: ${2:}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		state: ${4:#present|absent}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# monitors: ${7:}
		# session_state: ${8:enabled|disabled}
		# name: ${9:}
		# monitor_state: ${10:enabled|disabled}
		# description: ${11:}
		# partition: ${12:}
		# server_port: ${13:443}
		# validate_certs: ${14:#True|False}
		# monitor_type: ${15:and_list|m_of_n}
		# quorum: ${16:}
$0
endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools." b
- name: $1
	bigip_pool:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Pool name}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# lb_method: ${6:dynamic-ratio-member|dynamic-ratio-node|fastest-app-response|fastest-node|least-connections-member|least-connections-node|least-sessions|observed-member|observed-node|predictive-member|predictive-node|ratio-least-connections-member|ratio-least-connections-node|ratio-member|ratio-node|ratio-session|round-robin|weighted-least-connections-member|weighted-least-connections-nod}
		# reselect_tries: ${7:# Sets the number of times the system tries to contact a pool member after a passive failure.}
		# description: ${8:# Specifies descriptive text that identifies the pool.}
		# service_down_action: ${9:none|reset|drop|reselect}
		# host: ${10:# Pool member IP.}
		# monitors: ${11:# Monitor template name list. If the partition is not provided as part of the monitor name, then the C(partition) option will be used instead.}
		# quorum: ${12:# Monitor quorum value when C(monitor_type) is C(m_of_n).}
		# slow_ramp_time: ${13:# Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members.}
		# port: ${14:# Pool member port.}
		# server_port: ${15:443}
		# validate_certs: ${16:#True|False}
		# monitor_type: ${17:and_list|m_of_n}
$0
endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members" b
- name: $1
	bigip_pool_member:
		host: ${2:# Pool member IP}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		port: ${5:# Pool member port}
		pool: ${6:# Pool name. This pool must exist.}
		server: ${7:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		state: ${8:#present|absent}
		# description: ${9:# Pool member description}
		# monitor_state: ${10:enabled|disabled}
		# rate_limit: ${11:# Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.}
		# session_state: ${12:enabled|disabled}
		# ratio: ${13:# Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.}
		# partition: ${14:Common}
		# connection_limit: ${15:# Pool member connection limit. Setting this to 0 disables the limit.}
		# preserve_node: ${16:True|False}
		# server_port: ${17:443}
		# priority_group: ${18:# Sets priority group for a pool member.}
		# validate_certs: ${19:#True|False}
$0
endsnippet

snippet bigip_provision "Manage BIG-IP module provisioning." b
- name: $1
	bigip_provision:
		module: ${2:am|afm|apm|asm|avr|fps|gtm|ilx|lc|ltm|pem|sam|swg}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# level: ${6:dedicated|#nominal|minimum}
		# state: ${7:#present|absent}
		# server_port: ${8:443}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_qkview "Manage qkviews on the device." b
- name: $1
	bigip_qkview:
		dest: ${2:# Destination on your local filesystem when you want to save the qkview.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# max_file_size: ${6:0}
		# force: ${7:#True|False}
		# complete_information: ${8:#True|False}
		# asm_request_log: ${9:True|#False}
		# filename: ${10:localhost.localdomain.qkview}
		# exclude_core: ${11:True|#False}
		# server_port: ${12:443}
		# exclude: ${13:all|audit|secure|bash_history}
		# validate_certs: ${14:#True|False}
$0
endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP" b
- name: $1
	bigip_routedomain:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		id: ${4:# The unique identifying integer representing the route domain.}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# flow_eviction_policy: ${6:# The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.}
		# service_policy: ${7:# Service policy to associate with the route domain.}
		# description: ${8:# Specifies descriptive text that identifies the route domain.}
		# parent: ${9:# S}
		# vlans: ${10:# VLANs for the system to use in the route domain}
		# connection_limit: ${11:# The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.}
		# strict: ${12:enabled|disabled}
		# state: ${13:#present|absent}
		# routing_protocol: ${14:BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng}
		# server_port: ${15:443}
		# bwc_policy: ${16:# The bandwidth controller for the route domain.}
		# validate_certs: ${17:#True|False}
$0
endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system" b
- name: $1
	bigip_selfip:
		name: ${2:Value of C(address)}
		vlan: ${3:# The VLAN that the new self IPs will be on.}
		server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		netmask: ${5:# The netmasks for the self IP.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${7:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# state: ${8:absent|#present}
		# allow_service: ${9:# Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.}
		# route_domain: ${10:none}
		# server_port: ${11:443}
		# address: ${12:# The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.}
		# traffic_group: ${13:# The traffic group for the self IP addresses in an active-active, redundant load balancer configuration.}
		# validate_certs: ${14:#True|False}
$0
endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP." b
- name: $1
	bigip_snat_pool:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# T}
		# members: ${6:# List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.}
		# state: ${7:#present|absent}
		# server_port: ${8:443}
		# validate_certs: ${9:#True|False}
		# append: ${10:True|#False}
$0
endsnippet

snippet bigip_snmp "Manipulate general SNMP settings on a BIG-IP." b
- name: $1
	bigip_snmp:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# agent_status_traps: ${5:enabled|disabled}
		# agent_authentication_traps: ${6:enabled|disabled}
		# device_warning_traps: ${7:enabled|disabled}
		# contact: ${8:# Specifies the name of the person who administers the SNMP service for this system.}
		# server_port: ${9:443}
		# validate_certs: ${10:#True|False}
		# location: ${11:# Specifies the description of this system's physical location.}
$0
endsnippet

snippet bigip_snmp_trap "Manipulate SNMP trap information on a BIG-IP." b
- name: $1
	bigip_snmp_trap:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# Name of the SNMP configuration endpoint.}
		# snmp_version: ${6:1|2c}
		# network: ${7:other|management|default}
		# destination: ${8:# Specifies the address for the trap destination. This can be either an IP address or a hostname.}
		# community: ${9:# Specifies the community name for the trap destination.}
		# state: ${10:#present|absent}
		# server_port: ${11:443}
		# validate_certs: ${12:#True|False}
		# port: ${13:# Specifies the port for the trap destination.}
$0
endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP." b
- name: $1
	bigip_ssl_certificate:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partition:name.cer_11111_1 and :Partition_name.key_11111_1).}
		# key_src: ${6:# This is the local filename of the private key. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		# key_content: ${7:# When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		# cert_src: ${8:# This is the local filename of the certificate. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		# state: ${9:#present|absent}
		# server_port: ${10:443}
		# cert_content: ${11:# When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		# validate_certs: ${12:#True|False}
		# passphrase: ${13:# Passphrase on certificate private key}
$0
endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables" b
- name: $1
	bigip_sys_db:
		key: ${2:# The database variable to manipulate.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# value: ${6:# The value to set the key to. At least one of value and state C(reset) are required.}
		# state: ${7:#present|reset}
		# server_port: ${8:443}
		# validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings." b
- name: $1
	bigip_sys_global:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# security_banner: ${5:enabled|disabled}
		# net_reboot: ${6:enabled|disabled}
		# banner_text: ${7:# Specifies the text to present in the advisory banner.}
		# console_timeout: ${8:# Specifies the number of seconds of inactivity before the system logs off a user that is logged on.}
		# quiet_boot: ${9:# Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.}
		# mgmt_dhcp: ${10:enabled|disabled}
		# state: ${11:#present}
		# server_port: ${12:443}
		# gui_setup: ${13:enabled|disabled}
		# validate_certs: ${14:#True|False}
		# lcd_display: ${15:enabled|disabled}
$0
endsnippet

snippet bigip_ucs "Manage upload, installation and removal of UCS files." b
- name: $1
	bigip_ucs:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# no_license: ${5:True|False}
		# force: ${6:True|False}
		# reset_trust: ${7:True|False}
		# no_platform_check: ${8:True|False}
		# state: ${9:absent|installed|#present}
		# include_chassis_level_config: ${10:True|False}
		# server_port: ${11:443}
		# ucs: ${12:# The path to the UCS file to install. The parameter must be provided if the C(state) is either C(installed) or C(activated). When C(state) is C(absent), the full path for this parameter will be ignored and only the filename will be used to select a UCS for removal. Therefore you could specify C(/mickey/mouse/test.ucs) and this module would only look for C(test.ucs).}
		# validate_certs: ${13:#True|False}
		# passphrase: ${14:True|False}
$0
endsnippet

snippet bigip_user "Manage user accounts and user attributes on a BIG-IP." b
- name: $1
	bigip_user:
		username_credential: ${2:# Name of the user to create, remove or modify.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# update_password: ${6:always|#on_create}
		# shell: ${7:bash|none|tmsh}
		# full_name: ${8:# Full name of the user.}
		# password_credential: ${9:# Set the users password to this unencrypted value. C(password_credential) is required when creating a new account.}
		# partition_access: ${10:# Specifies the administrative partition to which the user has access. C(partition_access) is required when creating a new account. Should be in the form "partition:role". Valid roles include C(acceleration-policy-editor), C(admin), C(application-editor), C(auditor) C(certificate-manager), C(guest), C(irule-manager), C(manager), C(no-access) C(operator), C(resource-admin), C(user-manager), C(web-application-security-administrator), and C(web-application-security-editor). Partition portion of tuple should be an existing partition or the value 'all'.}
		# state: ${11:#present|absent}
		# server_port: ${12:443}
		# validate_certs: ${13:#True|False}
$0
endsnippet

snippet bigip_virtual_address "Manage LTM virtual addresses on a BIG-IP." b
- name: $1
	bigip_virtual_address:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		address: ${4:# Virtual address. This value cannot be modified after it is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# icmp_echo: ${6:enabled|disabled|selective}
		# auto_delete: ${7:enabled|disabled}
		# connection_limit: ${8:# Specifies the number of concurrent connections that the system allows on this virtual address.}
		# state: ${9:#present|absent|enabled|disabled}
		# netmask: ${10:255.255.255.255}
		# arp_state: ${11:enabled|disabled}
		# server_port: ${12:443}
		# validate_certs: ${13:#True|False}
		# use_route_advertisement: ${14:True|False}
		# advertise_route: ${15:always|when_all_available|when_any_available}
$0
endsnippet

snippet bigip_virtual_server "Manages F5 BIG-IP LTM virtual servers" b
- name: $1
	bigip_virtual_server:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Virtual server name}
		destination: ${5:# Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist.}
		server: ${6:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		# route_advertisement_state: ${7:disabled}
		# partition: ${8:Common}
		# description: ${9:# Virtual server description}
		# fallback_persistence_profile: ${10:# Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.}
		# default_persistence_profile: ${11:# Default Profile which manages the session persistence}
		# all_rules: ${12:# List of rules to be applied in priority order}
		# enabled_vlans: ${13:# List of vlans to be enabled. When a VLAN named C(ALL) is used, all VLANs will be allowed.}
		# port: ${14:# Port of the virtual server. Required when state=present and vs does not exist. If you specify a value for this field, it must be a number between 0 and 65535.}
		# all_policies: ${15:# List of all policies enabled for the virtual server.}
		# snat: ${16:#None|Automap|Name of a SNAT pool (eg "/Common/snat_pool_name") to enable SNAT with the specific pool}
		# all_profiles: ${17:# List of all Profiles (HTTP,ClientSSL,ServerSSL,etc) that must be used by the virtual server}
		# state: ${18:#present|absent|enabled|disabled}
		# pool: ${19:# Default pool for the virtual server}
		# server_port: ${20:443}
		# validate_certs: ${21:#True|False}
$0
endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system" b
- name: $1
	bigip_vlan:
		name: ${2:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		# tagged_interfaces: ${6:# Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.}
		# untagged_interfaces: ${7:# Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.}
		# state: ${8:absent|#present}
		# tag: ${9:# Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.}
		# server_port: ${10:443}
		# validate_certs: ${11:#True|False}
		# description: ${12:# The description to give to the VLAN.}
$0
endsnippet

snippet fortios_address "Manage fortios firewall address objects" b
- name: $1
	fortios_address:
		state: ${2:present|absent}
		name: ${3:# Name of the address to add or delete.}
		# username: ${4:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
		# comment: ${5:# free text to describe address.}
		# config_file: ${6:# Path to configuration file. Required when I(file_mode) is True.}
		# file_mode: ${7:no}
		# backup_path: ${8:# Specifies where to store backup files. Required if I(backup=yes).}
		# country: ${9:# 2 letter country code (like FR).}
		# value: ${10:# Address value, based on type. If type=fqdn, somthing like www.google.com. If type=ipmask, you can use simple ip (192.168.0.1), ip+mask (192.168.0.1 255.255.255.0) or CIDR (192.168.0.1/32).}
		# interface: ${11:any}
		# host: ${12:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
		# end_ip: ${13:# Last ip in range (used only with type=iprange).}
		# backup_filename: ${14:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}
		# timeout: ${15:60}
		# type: ${16:iprange|fqdn|ipmask|geography}
		# start_ip: ${17:# First ip in range (used only with type=iprange).}
		# password: ${18:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
		# backup: ${19:yes|no}
		# vdom: ${20:# Specifies on which vdom to apply configuration}
$0
endsnippet

snippet fortios_config "Manage config on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_config:
		# username: ${2:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
		# src: ${3:# The I(src) argument provides a path to the configuration template to load into the remote device.}
		# config_file: ${4:# Path to configuration file. Required when I(file_mode) is True.}
		# file_mode: ${5:no}
		# backup_path: ${6:# Specifies where to store backup files. Required if I(backup=yes).}
		# filter: ${7:}
		# host: ${8:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
		# backup_filename: ${9:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}
		# timeout: ${10:60}
		# password: ${11:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
		# backup: ${12:yes|no}
		# vdom: ${13:# Specifies on which vdom to apply configuration}
$0
endsnippet

snippet fortios_ipv4_policy "Manage IPv4 policy objects on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_ipv4_policy:
		id: ${2:# Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns}
		# comment: ${3:# free text to describe policy.}
		# application_list: ${4:# Specifies Application Control name.}
		# service_negate: ${5:true|false}
		# ips_sensor: ${6:# Specifies IPS Sensor profile name.}
		# backup_filename: ${7:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}
		# fixedport: ${8:true|false}
		# src_addr: ${9:# Specifies source address (or group) object name(s). Required when I(state=present).}
		# service: ${10:# Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).}
		# poolname: ${11:# Specifies NAT pool name.}
		# state: ${12:#present|absent}
		# nat: ${13:true|false}
		# src_addr_negate: ${14:true|false}
		# username: ${15:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
		# config_file: ${16:# Path to configuration file. Required when I(file_mode) is True.}
		# file_mode: ${17:no}
		# schedule: ${18:always}
		# src_intf: ${19:any}
		# dst_addr_negate: ${20:true|false}
		# host: ${21:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
		# password: ${22:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
		# vdom: ${23:# Specifies on which vdom to apply configuration}
		# webfilter_profile: ${24:# Specifies Webfilter profile name.}
		# logtraffic_start: ${25:true|false}
		# backup_path: ${26:# Specifies where to store backup files. Required if I(backup=yes).}
		# policy_action: ${27:accept|deny}
		# dst_intf: ${28:any}
		# av_profile: ${29:# Specifies Antivirus profile name.}
		# timeout: ${30:60}
		# backup: ${31:yes|no}
		# dst_addr: ${32:# Specifies destination address (or group) object name(s). Required when I(state=present).}
		# logtraffic: ${33:disable|#utm|all}
$0
endsnippet

snippet dladm_etherstub "Manage etherstubs on Solaris/illumos systems." b
- name: $1
	dladm_etherstub:
		name: ${2:# Etherstub name.}
		# state: ${3:#present|absent}
		# temporary: ${4:true|false}
$0
endsnippet

snippet dladm_iptun "Manage IP tunnel interfaces on Solaris/illumos systems." b
- name: $1
	dladm_iptun:
		name: ${2:# IP tunnel interface name.}
		# state: ${3:#present|absent}
		# temporary: ${4:no}
		# local_address: ${5:# Literat IP address or hostname corresponding to the tunnel source.}
		# type: ${6:#ipv4|ipv6|6to4}
		# remote_address: ${7:# Literal IP address or hostname corresponding to the tunnel destination.}
$0
endsnippet

snippet dladm_linkprop "Manage link properties on Solaris/illumos systems." b
- name: $1
	dladm_linkprop:
		link: ${2:# Link interface name.}
		property: ${3:# Specifies the name of the property we want to manage.}
		# state: ${4:#present|absent|reset}
		# temporary: ${5:no}
		# value: ${6:# Specifies the value we want to set for the link property.}
$0
endsnippet

snippet dladm_vlan "Manage VLAN interfaces on Solaris/illumos systems." b
- name: $1
	dladm_vlan:
		link: ${2:# VLAN underlying link name.}
		name: ${3:# VLAN interface name.}
		# state: ${4:#present|absent}
		# temporary: ${5:no}
		# vlan_id: ${6:no}
$0
endsnippet

snippet dladm_vnic "Manage VNICs on Solaris/illumos systems." b
- name: $1
	dladm_vnic:
		name: ${2:# VNIC name.}
		link: ${3:# VNIC underlying link name.}
		# state: ${4:#present|absent}
		# temporary: ${5:true|false}
		# vlan: ${6:no}
		# mac: ${7:no}
$0
endsnippet

snippet flowadm "Manage bandwidth resource control and priority for protocols, services and zones on Solaris/illumos systems" b
- name: $1
	flowadm:
		name: ${2:# -}
		# dsfield: ${3:# -}
		# temporary: ${4:true|false}
		# maxbw: ${5:# -}
		# local_port: ${6:# Identifies a service specified by the local port.}
		# local_ip: ${7:# Identifies a network flow by the local IP address.}
		# remove_ip: ${8:# Identifies a network flow by the remote IP address.}
		# priority: ${9:low|#medium|high}
		# state: ${10:absent|#present|resetted}
		# link: ${11:# Specifiies a link to configure flow on.}
		# transport: ${12:# -}
$0
endsnippet

snippet ipadm_addr "Manage IP addresses on an interface on Solaris/illumos systems" b
- name: $1
	ipadm_addr:
		addrobj: ${2:# Specifies an unique IP address on the system.}
		# addrtype: ${3:#static|dhcp|addrconf}
		# state: ${4:absent|#present|up|down|enabled|disabled|refreshed}
		# temporary: ${5:no}
		# address: ${6:# Specifiies an IP address to configure in CIDR notation.}
		# wait: ${7:60}
$0
endsnippet

snippet ipadm_addrprop "Manage IP address properties on Solaris/illumos systems." b
- name: $1
	ipadm_addrprop:
		property: ${2:# Specifies the name of the address property we want to manage.}
		addrobj: ${3:# Specifies the address object we want to manage.}
		# state: ${4:#present|absent|reset}
		# temporary: ${5:no}
		# value: ${6:# Specifies the value we want to set for the address property.}
$0
endsnippet

snippet ipadm_if "Manage IP interfaces  on Solaris/illumos systems." b
- name: $1
	ipadm_if:
		name: ${2:# IP interface name.}
		# state: ${3:#present|absent|enabled|disabled}
		# temporary: ${4:true|false}
$0
endsnippet

snippet ipadm_ifprop "Manage IP interface properties on Solaris/illumos systems." b
- name: $1
	ipadm_ifprop:
		interface: ${2:# Specifies the IP interface we want to manage.}
		protocol: ${3:# Specifies the procotol for which we want to manage properties.}
		property: ${4:# Specifies the name of the property we want to manage.}
		# state: ${5:#present|absent|reset}
		# temporary: ${6:no}
		# value: ${7:# Specifies the value we want to set for the property.}
$0
endsnippet

snippet ipadm_prop "Manage protocol properties on Solaris/illumos systems." b
- name: $1
	ipadm_prop:
		protocol: ${2:# Specifies the procotol for which we want to manage properties.}
		property: ${3:# Specifies the name of property we want to manage.}
		# state: ${4:#present|absent|reset}
		# temporary: ${5:true|false}
		# value: ${6:# Specifies the value we want to set for the property.}
$0
endsnippet

snippet net_interface "Manage Interface on network devices" b
- name: $1
	net_interface:
		name: ${2:# Name of the Interface.}
		# rx_rate: ${3:# Receiver rate in bits per second (bps).}
		# duplex: ${4:full|half|#auto}
		# enabled: ${5:# Configure interface link status.}
		# mtu: ${6:# Maximum size of transmit packet.}
		# delay: ${7:10}
		# purge: ${8:no}
		# state: ${9:#present|absent|up|down}
		# aggregate: ${10:# L}
		# speed: ${11:# Interface link speed.}
		# tx_rate: ${12:# Transmit rate in bits per second (bps).}
		# description: ${13:# Description of Interface.}
$0
endsnippet

snippet net_linkagg "Manage link aggregation groups on network devices" b
- name: $1
	net_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# purge: ${4:no}
		# state: ${5:#present|absent|up|down}
		# min_links: ${6:# Minimum members that should be up before bringing up the link aggregation group.}
		# aggregate: ${7:# L}
		# mode: ${8:on|active|passive}
$0
endsnippet

snippet net_lldp_interface "Manage LLDP interfaces configuration on network devices" b
- name: $1
	net_lldp_interface:
		# aggregate: ${2:# L}
		# purge: ${3:no}
		# state: ${4:#present|absent|enabled|disabled}
		# name: ${5:# Name of the interface LLDP should be configured on.}
$0
endsnippet

snippet ios_banner "Manage multiline banners on Cisco IOS devices" b
- name: $1
	ios_banner:
		banner: ${2:login|motd}
		# authorize: ${3:yes|no}
		# state: ${4:#present|absent}
		# provider: ${5:# A dict object containing connection details.}
		# text: ${6:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# auth_pass: ${7:none}
$0
endsnippet

snippet ios_command "Run commands on remote devices running Cisco IOS" b
- name: $1
	ios_command:
		commands: ${2:# List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# authorize: ${3:yes|no}
		# retries: ${4:10}
		# interval: ${5:1}
		# auth_pass: ${6:none}
		# provider: ${7:# A dict object containing connection details.}
		# wait_for: ${8:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${9:any|#all}
$0
endsnippet

snippet ios_config "Manage Cisco IOS configuration sections" b
- name: $1
	ios_config:
		# authorize: ${2:yes|no}
		# multiline_delimiter: ${3:@}
		# force: ${4:no}
		# after: ${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# diff_against: ${6:running|startup|intended}
		# replace: ${7:#line|block}
		# running_config: ${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# diff_ignore_lines: ${9:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
		# src: ${10:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# save_when: ${11:always|#never|modified}
		# auth_pass: ${12:none}
		# lines: ${13:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# intended_config: ${14:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
		# parents: ${15:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# defaults: ${16:no}
		# provider: ${17:# A dict object containing connection details.}
		# before: ${18:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
		# save: ${19:no}
		# backup: ${20:no}
		# match: ${21:#line|strict|exact|none}
$0
endsnippet

snippet ios_facts "Collect facts from remote devices running Cisco IOS" b
- name: $1
	ios_facts:
		# authorize: ${2:yes|no}
		# gather_subset: ${3:!config}
		# auth_pass: ${4:none}
		# provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet ios_interface "Manage Interface on Cisco IOS network devices" b
- name: $1
	ios_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: ${3:# Check the operational state of given interface C(name) for LLDP neighbor.}
		# rx_rate: ${4:# Receiver rate in bits per second (bps).}
		# duplex: ${5:full|half|#auto}
		# enabled: ${6:# Interface link status.}
		# mtu: ${7:# Maximum size of transmit packet.}
		# delay: ${8:10}
		# state: ${9:#present|absent|up|down}
		# aggregate: ${10:# L}
		# speed: ${11:# Interface link speed.}
		# tx_rate: ${12:# Transmit rate in bits per second (bps).}
		# description: ${13:# Description of Interface.}
$0
endsnippet

snippet ios_logging "Manage logging on network devices" b
- name: $1
	ios_logging:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# name: ${4:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
		# level: ${5:# Set logging severity levels.}
		# dest: ${6:on|host|console'|monitor|buffered}
		# facility: ${7:# Set logging facility.}
		# size: ${8:# Size of buffer. The acceptable value is in range from 4096 to 4294967295 bytes.}
$0
endsnippet

snippet ios_ping "Tests reachability using ping from IOS switch" b
- name: $1
	ios_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# authorize: ${3:yes|no}
		# count: ${4:5}
		# auth_pass: ${5:none}
		# source: ${6:# The source IP Address.}
		# state: ${7:absent|#present}
		# vrf: ${8:default}
		# provider: ${9:# A dict object containing connection details.}
$0
endsnippet

snippet ios_static_route "Manage static IP routes on Cisco IOS network devices" b
- name: $1
	ios_static_route:
		# state: ${2:#present|absent}
		# next_hop: ${3:# Next hop IP of the static route.}
		# aggregate: ${4:# L}
		# mask: ${5:# Network prefix mask of the static route.}
		# prefix: ${6:# Network prefix of the static route.}
		# admin_distance: ${7:1}
$0
endsnippet

snippet ios_system "Manage the system attributes on Cisco IOS devices" b
- name: $1
	ios_system:
		# authorize: ${2:yes|no}
		# hostname: ${3:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# lookup_source: ${4:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
		# domain_search: ${5:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		# auth_pass: ${6:none}
		# domain_name: ${7:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
		# state: ${8:#present|absent}
		# provider: ${9:# A dict object containing connection details.}
		# name_servers: ${10:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
		# lookup_enabled: ${11:# Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
$0
endsnippet

snippet ios_user "Manage the aggregate of local users on Cisco IOS device" b
- name: $1
	ios_user:
		# update_password: ${2:on_create|#always}
		# configured_password: ${3:# The password to be configured on the Cisco IOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# aggregate: ${4:# The set of username objects to be configured on the remote Cisco IOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument. alias C(users).}
		# name: ${5:# The username to be configured on the Cisco IOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
		# purge: ${6:no}
		# privilege: ${7:# The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.}
		# state: ${8:#present|absent}
		# nopassword: ${9:# Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.}
		# view: ${10:# Configures the view for the username in the device running configuration. The argument accepts a string value defining the view name. This argument does not check if the view has been configured on the device.}
$0
endsnippet

snippet ios_vrf "Manage the collection of VRF definitions on Cisco IOS devices" b
- name: $1
	ios_vrf:
		# authorize: ${2:yes|no}
		# delay: ${3:10}
		# description: ${4:# Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.}
		# interfaces: ${5:# Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.}
		# auth_pass: ${6:none}
		# rd: ${7:# The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.}
		# purge: ${8:no}
		# state: ${9:#present|absent}
		# vrfs: ${10:# The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.}
		# provider: ${11:# A dict object containing connection details.}
		# name: ${12:# The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument}
$0
endsnippet

snippet iosxr_banner "Manage multiline banners on Cisco IOS XR devices" b
- name: $1
	iosxr_banner:
		banner: ${2:login|motd}
		# text: ${3:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# state: ${4:#present|absent}
$0
endsnippet

snippet iosxr_command "Run commands on remote devices running Cisco IOS XR" b
- name: $1
	iosxr_command:
		commands: ${2:# List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# interval: ${4:1}
		# provider: ${5:# A dict object containing connection details.}
		# wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${7:any|#all}
$0
endsnippet

snippet iosxr_config "Manage Cisco IOS XR configuration sections" b
- name: $1
	iosxr_config:
		# comment: ${2:configured by iosxr_config}
		# src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# force: ${4:yes|no}
		# admin: ${5:yes|no}
		# backup: ${6:yes|no}
		# after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# lines: ${8:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# replace: ${9:#line|block|config}
		# parents: ${10:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# provider: ${11:# A dict object containing connection details.}
		# config: ${12:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# match: ${13:#line|strict|exact|none}
		# before: ${14:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet iosxr_facts "Collect facts from remote devices running IOS XR" b
- name: $1
	iosxr_facts:
		# gather_subset: ${2:!config}
		# provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet iosxr_interface "Manage Interface on Cisco IOS XR network devices" b
- name: $1
	iosxr_interface:
		name: ${2:# Name of the Interface.}
		# rx_rate: ${3:# Receiver rate in bits per second (bps).}
		# duplex: ${4:full|half}
		# enabled: ${5:# Interface link status.}
		# mtu: ${6:# Maximum size of transmit packet.}
		# delay: ${7:10}
		# state: ${8:#present|absent|up|down}
		# aggregate: ${9:# L}
		# speed: ${10:# Interface link speed.}
		# tx_rate: ${11:# Transmit rate in bits per second (bps).}
		# description: ${12:# Description of Interface.}
$0
endsnippet

snippet iosxr_logging "Manage logging on network devices" b
- name: $1
	iosxr_logging:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# name: ${4:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
		# level: ${5:debugging}
		# dest: ${6:on|hostnameprefix|console'|monitor|buffered}
		# facility: ${7:local7}
		# size: ${8:307200}
$0
endsnippet

snippet iosxr_system "Manage the system attributes on Cisco IOS XR devices" b
- name: $1
	iosxr_system:
		# lookup_source: ${2:# The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
		# domain_search: ${3:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		# hostname: ${4:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# domain_name: ${5:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
		# state: ${6:#present|absent}
		# provider: ${7:# A dict object containing connection details.}
		# name_servers: ${8:# The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.}
		# lookup_enabled: ${9:# Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
$0
endsnippet

snippet iosxr_user "Manage the aggregate of local users on Cisco IOS XR device" b
- name: $1
	iosxr_user:
		# purge: ${2:no}
		# update_password: ${3:on_create|#always}
		# configured_password: ${4:# The password to be configured on the Cisco IOS XR device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# group: ${5:# Configures the group for the username in the device running configuration. The argument accepts a string value defining the group name. This argument does not check if the group has been configured on the device, alias C(role).}
		# name: ${6:# The username to be configured on the Cisco IOS XR device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
		# aggregate: ${7:# The set of username objects to be configured on the remote Cisco IOS XR device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument, alias C(users).}
		# state: ${8:#present|absent}
$0
endsnippet

snippet junos_banner "Manage multiline banners on Juniper JUNOS devices" b
- name: $1
	junos_banner:
		banner: ${2:login|motd}
		# active: ${3:#True|False}
		# text: ${4:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# state: ${5:#present|absent}
$0
endsnippet

snippet junos_command "Run arbitrary commands on an Juniper JUNOS device" b
- name: $1
	junos_command:
		# retries: ${2:10}
		# commands: ${3:# The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# rpcs: ${4:# The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.}
		# interval: ${5:1}
		# provider: ${6:# A dict object containing connection details.}
		# wait_for: ${7:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		# display: ${8:text|json|xml|set}
		# match: ${9:any|#all}
$0
endsnippet

snippet junos_config "Manage configuration on devices running Juniper JUNOS" b
- name: $1
	junos_config:
		# comment: ${2:configured by junos_config}
		# src: ${3:# The I(src) argument provides a path to the configuration file to load into the remote system. The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.}
		# rollback: ${4:# The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.}
		# confirm: ${5:0}
		# lines: ${6:# This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.}
		# update: ${7:#merge|override|replace}
		# replace: ${8:yes|no}
		# confirm_commit: ${9:yes|no}
		# zeroize: ${10:# The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.}
		# src_format: ${11:xml|set|text|json}
		# provider: ${12:# A dict object containing connection details.}
		# backup: ${13:yes|no}
$0
endsnippet

snippet junos_facts "Collect facts from remote devices running Juniper Junos" b
- name: $1
	junos_facts:
		# config_format: ${2:xml|set|#text|json}
		# gather_subset: ${3:!config}
		# provider: ${4:# A dict object containing connection details.}
$0
endsnippet

snippet junos_interface "Manage Interface on Juniper JUNOS network devices" b
- name: $1
	junos_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: ${3:# Check the operational state of given interface C(name) for LLDP neighbor.}
		# rx_rate: ${4:# Receiver rate in bits per second (bps).}
		# duplex: ${5:full|half|#auto}
		# enabled: ${6:# Configure interface link status.}
		# mtu: ${7:# Maximum size of transmit packet.}
		# delay: ${8:10}
		# aggregate: ${9:# L}
		# state: ${10:#present|absent|up|down}
		# active: ${11:#True|False}
		# speed: ${12:# Interface link speed.}
		# tx_rate: ${13:# Transmit rate in bits per second (bps).}
		# description: ${14:# Description of Interface.}
$0
endsnippet

snippet junos_l3_interface "Manage L3 interfaces on Juniper JUNOS network devices" b
- name: $1
	junos_l3_interface:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# name: ${4:# Name of the L3 interface.}
		# ipv6: ${5:# IPv6 of the L3 interface.}
		# active: ${6:#True|False}
		# unit: ${7:0}
		# ipv4: ${8:# IPv4 of the L3 interface.}
$0
endsnippet

snippet junos_linkagg "Manage link aggregation groups on Juniper JUNOS network devices" b
- name: $1
	junos_linkagg:
		members: ${2:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		name: ${3:# Name of the link aggregation group.}
		# description: ${4:# Description of Interface.}
		# device_count: ${5:# Number of aggregated ethernet devices that can be configured. Acceptable integer value is between 1 and 128.}
		# aggregate: ${6:# L}
		# state: ${7:#present|absent|up|down}
		# mode: ${8:on|off|active|passive}
		# min_links: ${9:# Minimum members that should be up before bringing up the link aggregation group.}
		# active: ${10:#True|False}
$0
endsnippet

snippet junos_lldp "Manage LLDP configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp:
		# state: ${2:#present|absent|enabled|disabled}
		# enable: ${3:True|False}
		# active: ${4:#True|False}
		# interval: ${5:# Frequency at which LLDP advertisements are sent (in seconds).}
		# hold_multiplier: ${6:# Specify the number of seconds that LLDP information is held before it is discarded. The multiplier value is used in combination with the C(interval) value.}
		# transmit_delay: ${7:# Specify the number of seconds the device waits before sending advertisements to neighbors after a change is made in local system.}
$0
endsnippet

snippet junos_lldp_interface "Manage LLDP interfaces configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp_interface:
		# active: ${2:#True|False}
		# state: ${3:#present|absent|enabled|disabled}
		# name: ${4:# Name of the interface LLDP should be configured on.}
$0
endsnippet

snippet junos_logging "Manage logging on network devices" b
- name: $1
	junos_logging:
		# files: ${2:# Number of files to be archived, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 1 to 1000.}
		# name: ${3:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
		# level: ${4:# Set logging severity levels.}
		# dest: ${5:console|host|file|user}
		# facility: ${6:# Set logging facility.}
		# aggregate: ${7:# L}
		# state: ${8:#present|absent}
		# active: ${9:#True|False}
		# rotate_frequency: ${10:# Rotate log frequency in minutes, this is applicable if value of I(dest) is C(file). The acceptable value is in range of 1 to 59. This controls the frequency after which log file is rotated.}
		# size: ${11:# Size of the file in archive, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 65536 to 1073741824 bytes.}
$0
endsnippet

snippet junos_netconf "Configures the Junos Netconf system service" b
- name: $1
	junos_netconf:
		# state: ${2:#present|absent}
		# netconf_port: ${3:830}
		# provider: ${4:# A dict object containing connection details.}
$0
endsnippet

snippet junos_package "Installs packages on remote devices running Junos" b
- name: $1
	junos_package:
		src: ${2:# The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install.}
		force: ${3:true|false}
		reboot: ${4:true|false}
		# version: ${5:# The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename.}
		# provider: ${6:# A dict object containing connection details.}
		# no_copy: ${7:true|false}
$0
endsnippet

snippet junos_rpc "Runs an arbitrary RPC over NetConf on an Juniper JUNOS device" b
- name: $1
	junos_rpc:
		rpc: ${2:# The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.}
		# output: ${3:xml}
		# args: ${4:# The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.}
		# provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet junos_static_route "Manage static IP routes on Juniper JUNOS network devices" b
- name: $1
	junos_static_route:
		next_hop: ${2:# Next hop IP of the static route.}
		address: ${3:# Network address with prefix of the static route.}
		# qualified_next_hop: ${4:# Qualified next hop IP of the static route. Qualified next hops allow to associate preference with a particular next-hop address.}
		# aggregate: ${5:# L}
		# state: ${6:#present|absent}
		# preference: ${7:# Global admin preference of the static route.}
		# qualified_preference: ${8:# Assign preference for qualified next hop.}
		# active: ${9:#True|False}
$0
endsnippet

snippet junos_system "Manage the system attributes on Juniper JUNOS devices" b
- name: $1
	junos_system:
		# name_servers: ${2:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
		# state: ${3:#present|absent}
		# active: ${4:#True|False}
		# domain_search: ${5:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		# hostname: ${6:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# domain_name: ${7:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
$0
endsnippet

snippet junos_user "Manage local user accounts on Juniper JUNOS devices" b
- name: $1
	junos_user:
		# name: ${2:# The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(aggregate) argument.}
		# purge: ${3:no}
		# active: ${4:#True|False}
		# state: ${5:#present|absent}
		# role: ${6:operator|read-only|super-user|unauthorized}
		# full_name: ${7:# The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value.}
		# provider: ${8:# A dict object containing connection details.}
		# aggregate: ${9:# The C(aggregate) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument. alias C(users).}
		# sshkey: ${10:# The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key}
$0
endsnippet

snippet junos_vlan "Manage VLANs on Juniper JUNOS network devices" b
- name: $1
	junos_vlan:
		name: ${2:# Name of the VLAN.}
		vlan_id: ${3:# ID of the VLAN.}
		# aggregate: ${4:# L}
		# state: ${5:#present|absent}
		# active: ${6:#True|False}
		# interfaces: ${7:# List of interfaces to check the VLAN has been configured correctly.}
		# description: ${8:# Text description of VLANs.}
$0
endsnippet

snippet junos_vrf "Manage the VRF definitions on Juniper JUNOS devices" b
- name: $1
	junos_vrf:
		# target: ${2:# It configures VRF target community configuration. The target value takes the form of C(target:A:B) where C(A) and C(B) are both numeric values.}
		# interfaces: ${3:# Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF.}
		# name: ${4:# The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(aggregate) argument}
		# rd: ${5:# The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.}
		# table_label: ${6:# Causes JUNOS to allocate a VPN label per VRF rather than per VPN FEC. This allows for forwarding of traffic to directly connected subnets, COS Egress filtering etc.}
		# state: ${7:#present|absent}
		# aggregate: ${8:# The set of VRF definition objects to be configured on the remote JUNOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.}
		# active: ${9:#True|False}
		# description: ${10:# Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.}
$0
endsnippet

snippet net_l2_interface "Manage Layer-2 interface on network devices" b
- name: $1
	net_l2_interface:
		# native_vlan: ${2:# Native VLAN to be configured in trunk port.}
		# access_vlan: ${3:# Configure given VLAN in access port.}
		# name: ${4:# Name of the interface excluding any logical unit number.}
		# trunk_vlans: ${5:# List of VLANs to be configured in trunk port.}
		# state: ${6:#present|absent}
		# trunk_allowed_vlans: ${7:# List of allowed VLAN's in a given trunk port.}
		# mode: ${8:#access|trunk}
		# aggregate: ${9:# List of Layer-2 interface definitions.}
$0
endsnippet

snippet net_vlan "Manage VLANs on network devices" b
- name: $1
	net_vlan:
		# purge: ${2:no}
		# state: ${3:#present|absent|active|suspend}
		# name: ${4:# Name of the VLAN.}
		# aggregate: ${5:# L}
		# interfaces: ${6:# List of interfaces the VLAN should be configured on.}
		# vlan_id: ${7:# ID of the VLAN.}
$0
endsnippet

snippet net_l3_interface "Manage L3 interfaces on network devices" b
- name: $1
	net_l3_interface:
		# purge: ${2:no}
		# state: ${3:#present|absent}
		# name: ${4:# Name of the L3 interface.}
		# ipv6: ${5:# IPv6 of the L3 interface.}
		# aggregate: ${6:# L}
		# ipv4: ${7:# IPv4 of the L3 interface.}
$0
endsnippet

snippet net_vrf "Manage VRFs on network devices" b
- name: $1
	net_vrf:
		# aggregate: ${2:# L}
		# purge: ${3:no}
		# interfaces: ${4:# List of interfaces the VRF should be configured on.}
		# name: ${5:# Name of the VRF.}
		# state: ${6:#present|absent}
$0
endsnippet

snippet cnos_backup "Backup the current running or startup configuration to a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_backup:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		serverpassword: ${3:# Specify the password for the server relating to the protocol used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${5:SFTP|SCP|FTP|TFTP}
		configType: ${6:running-config|startup-config}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		password: ${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${11:# -}
		rcpath: ${12:# This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		# enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_bgp "Manage BGP resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_bgp:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		asNum: ${4:# AS number}
		bgpArg1: ${5:address-family|bestpath|bgp|cluster-id|confederation|enforce-first-as|fast-external-failover|graceful-restart|graceful-restart-helper|log-neighbor-changes|maxas-limit|neighbor|router-id|shutdown|synchronization|timers|vrf}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# bgpArg8: ${9:Un-reachability Half-life time for the penalty(minutes)|backdoor}
		# bgpArg4: ${10:Aggregate prefix|Reachability Half-life time|route-map|Distance for routes external|ebgp or ibgp|IP prefix <network>|IP prefix <network>/<length>|synchronization|Delay value|direct|ospf|static|memory}
		# bgpArg5: ${11:as-set|summary-only|Value to start reusing a route|Distance for routes internal|Supported multipath numbers|backdoor|map|route-map}
		# bgpArg6: ${12:summary-only|as-set|route-map name|Value to start suppressing a route|Distance for local routes|Network mask|Pointer to route-map entries}
		# bgpArg7: ${13:Maximum duration to suppress a stable route(minutes)|backdoor|route-map|Name of the route map}
		# bgpArg2: ${14:ipv4 or ipv6|always-compare-med|compare-confed-aspath|compare-routerid|dont-compare-originator-id|tie-break-on-age|as-path|med|identifier|peers}
		# bgpArg3: ${15:aggregate-address|client-to-client|dampening|distance|maximum-paths|network|nexthop|redistribute|save|synchronization|ignore or multipath-relax|confed or missing-as-worst or non-deterministic or remove-recv-med or remove-send-med}
		# enablePassword: ${16:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_command "Execute a single command on devices running Lenovo CNOS" b
- name: $1
	cnos_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		clicommand: ${6:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${8:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_conditional_command "Execute a single command based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		clicommand: ${6:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		flag: ${8:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		condition: ${9:# If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.}
		# enablePassword: ${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_conditional_template "Manage switch configuration using templates based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		condition: ${6:# If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		flag: ${8:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		commandfile: ${9:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_LP21_commands.txt}
		# enablePassword: ${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_factory "Reset the switch's startup configuration to default (factory) on devices running Lenovo CNOS" b
- name: $1
	cnos_factory:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_facts "Collect facts on devices running Lenovo CNOS" b
- name: $1
	cnos_facts:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_image "Perform firmware upgrade/download from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_image:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${4:SFTP|SCP|FTP|TFTP}
		serverip: ${5:# This specifies the IP Address of the remote server from where the software image will be downloaded.}
		imgpath: ${6:# This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		imgtype: ${10:all|boot|os|onie}
		password: ${11:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# serverpassword: ${12:# Specify the password for the server relating to the protocol used.}
		# enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_interface "Manage interface configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_interface:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		interfaceOption: ${4:None|ethernet|loopback|mgmt|port-aggregation|vlan}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		interfaceRange: ${7:# This specifies the interface range in which the port aggregation is envisaged}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		interfaceArg1: ${9:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		# interfaceArg7: ${10:Authentication key string|admin-down}
		# interfaceArg4: ${11:key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface}
		# interfaceArg5: ${12:name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32}
		# interfaceArg6: ${13:Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent}
		# enablePassword: ${14:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# interfaceArg2: ${15:aggregation-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port}
		# interfaceArg3: ${16:active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6}
$0
endsnippet

snippet cnos_portchannel "Manage portchannel (port aggregation) configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_portchannel:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		interfaceRange: ${6:# This specifies the interface range in which the port aggregation is envisaged}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		interfaceArg1: ${8:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		# interfaceArg7: ${9:Authentication key string|admin-down}
		# interfaceArg4: ${10:key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface}
		# interfaceArg5: ${11:name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32}
		# interfaceArg6: ${12:Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent}
		# enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# interfaceArg2: ${14:aggregation-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port}
		# interfaceArg3: ${15:active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6}
$0
endsnippet

snippet cnos_reload "Perform switch restart on devices running Lenovo CNOS" b
- name: $1
	cnos_reload:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_rollback "Roll back the running or startup configuration from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_rollback:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		serverpassword: ${3:# Specify the password for the server relating to the protocol used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${5:SFTP|SCP|FTP|TFTP}
		configType: ${6:running-config|startup-config}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		password: ${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${11:# This specifies the IP Address of the remote server from where the backup configuration will be downloaded.}
		rcpath: ${12:# This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		# enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_save "Save the running configuration as the startup configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_save:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_showrun "Collect the current running configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_showrun:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_template "Manage switch configuration using templates on devices running Lenovo CNOS" b
- name: $1
	cnos_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		commandfile: ${7:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt}
		# enablePassword: ${8:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_vlag "Manage VLAG resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlag:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		vlagArg1: ${6:enable|auto-recovery|config-consistency|isl|mac-address-table|peer-gateway|priority|startup-delay|tier-id|vrrp|instance|hlthchk}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# vlagArg2: ${8:Interval in seconds|disable or strict|Port Aggregation Number|VLAG priority|Delay time in seconds|VLAG tier-id value|VLAG instance number|keepalive-attempts|keepalive-interval|retry-interval|peer-ip}
		# vlagArg3: ${9:enable or port-aggregation|Number of keepalive attempts|Interval in seconds|Interval in seconds|VLAG health check peer IP4 address}
		# enablePassword: ${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# vlagArg4: ${11:Port Aggregation Number|default or management}
$0
endsnippet

snippet cnos_vlan "Manage VLAN resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlan:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		vlanArg1: ${6:access-map|dot1q|filter|<1-3999> VLAN ID 1-3999 or range}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# vlanArg5: ${8:access-list name|Slot/chassis number|Port Aggregation Number}
		# vlanArg4: ${9:drop or forward or redirect|ip or mac|Interval in seconds|ethernet|port-aggregation|Querier IP address|Querier Timeout in seconds|Query Interval in seconds|Query Max Response Time in seconds|Robustness Variable value|Number of queries sent at startup|Query Interval at startup}
		# vlanArg2: ${10:VLAN Access Map name|egress-only|name|flood|state|ip}
		# vlanArg3: ${11:action|match|statistics|enter VLAN id or range of vlan|ascii name for the VLAN|ipv4 or ipv6|active or suspend|fast-leave|last-member-query-interval|mrouter|querier|querier-timeout|query-interval|query-max-response-time|report-suppression|robustness-variable|startup-query-count|startup-query-interval|static-group}
		# enablePassword: ${12:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet netconf_config "netconf device configuration" b
- name: $1
	netconf_config:
		username: ${2:# the username to authenticate with}
		host: ${3:# the hostname or ip address of the netconf device}
		password: ${4:# password of the user to authenticate with}
		# xml: ${5:# the XML content to send to the device}
		# save: ${6:no}
		# allow_agent: ${7:yes}
		# src: ${8:# Specifies the source path to the xml file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(xml).}
		# look_for_keys: ${9:yes}
		# hostkey_verify: ${10:yes}
		# datastore: ${11:auto}
		# port: ${12:830}
$0
endsnippet

snippet netscaler_cs_action "Manage content switching actions" b
- name: $1
	netscaler_cs_action:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Comments associated with this cs action.}
		# name: ${6:# Name for the content switching action. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the content switching action is created.}
		# save_config: ${7:yes}
		# targetlbvserver: ${8:# Name of the load balancing virtual server to which the content is switched.}
		# nitro_protocol: ${9:#http|https}
		# state: ${10:#present|absent}
		# targetvserver: ${11:# Name of the VPN virtual server to which the content is switched.}
		# validate_certs: ${12:yes}
		# nitro_timeout: ${13:310}
		# targetvserverexpr: ${14:# Information about this content switching action.}
$0
endsnippet

snippet netscaler_cs_policy "Manage content switching policy" b
- name: $1
	netscaler_cs_policy:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# policyname: ${5:# Name for the content switching policy. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Cannot be changed after a policy is created.}
		# domain: ${6:# The domain name. The string value can range to 63 characters.}
		# url: ${7:# URL string that is matched with the URL of a request. Can contain a wildcard character. Specify the string value in the following format: C([[prefix] [*]] [.suffix]).}
		# save_config: ${8:yes}
		# rule: ${9:# Expression, or name of a named expression, against which traffic is evaluated. Written in the classic or default syntax.}
		# nitro_protocol: ${10:#http|https}
		# state: ${11:#present|absent}
		# action: ${12:# Content switching action that names the target load balancing virtual server to which the traffic is switched.}
		# validate_certs: ${13:yes}
		# nitro_timeout: ${14:310}
$0
endsnippet

snippet netscaler_cs_vserver "Manage content switching vserver" b
- name: $1
	netscaler_cs_vserver:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Information about this virtual server.}
		# precedence: ${6:RULE|URL}
		# mysqlcharacterset: ${7:# The character set returned by the mysql vserver.}
		# rtspnat: ${8:# Enable network address translation (NAT) for real-time streaming protocol (RTSP) connections.}
		# authn401: ${9:# Enable HTTP 401-response based authentication.}
		# disabled: ${10:no}
		# listenpolicy: ${11:# String specifying the listen policy for the content switching virtual server. Can be either the name of an existing expression or an in-line expression.}
		# ttl: ${12:# .}
		# redirecturl: ${13:# URL to which traffic is redirected if the virtual server becomes unavailable. The service type of the virtual server should be either C(HTTP) or C(SSL).}
		# ipmask: ${14:# IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.}
		# insertvserveripport: ${15:OFF|VIPADDR|V6TOV4MAPPING}
		# redirectportrewrite: ${16:enabled|disabled}
		# clttimeout: ${17:# Idle time, in seconds, after which the client connection is terminated. The default values are:}
		# authenticationhost: ${18:# FQDN of the authentication virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).}
		# servicetype: ${19:HTTP|SSL|TCP|FTP|RTSP|SSL_TCP|UDP|DNS|SIP_UDP|SIP_TCP|SIP_SSL|ANY|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|DNS_TCP|ORACLE|SMPP}
		# mysqlservercapabilities: ${20:# The server capabilities returned by the mysql vserver.}
		# authentication: ${21:# Authenticate users who request a connection to the content switching virtual server.}
		# vipheader: ${22:# Name of virtual server IP and port header, for use with the VServer IP Port Insertion parameter.}
		# pushvserver: ${23:# Name of the load balancing virtual server, of type C(PUSH) or C(SSL_PUSH), to which the server pushes updates received on the client-facing load balancing virtual server.}
		# td: ${24:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
		# nitro_timeout: ${25:310}
		# cookietimeout: ${26:# .}
		# appflowlog: ${27:enabled|disabled}
		# dbprofilename: ${28:# Name of the DB profile.}
		# cookiedomain: ${29:# .}
		# name: ${30:# Name for the content switching virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters.}
		# tcpprofilename: ${31:# Name of the TCP profile containing TCP configuration settings for the virtual server.}
		# downstateflush: ${32:enabled|disabled}
		# httpprofilename: ${33:# Name of the HTTP profile containing HTTP configuration settings for the virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).}
		# casesensitive: ${34:# Consider case in URLs (for policies that use URLs instead of RULES). For example, with the C(on) setting, the URLs /a/1.html and /A/1.HTML are treated differently and can have different targets (set by content switching policies). With the C(off) setting, /a/1.html and /A/1.HTML are switched to the same target.}
		# validate_certs: ${35:yes}
		# dnsprofilename: ${36:# Name of the DNS profile to be associated with the VServer. DNS profile properties will applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.}
		# icmpvsrresponse: ${37:PASSIVE|ACTIVE}
		# domainname: ${38:# Domain name for which to change the time to live (TTL) and/or backup service IP address.}
		# save_config: ${39:yes}
		# somethod: ${40:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
		# nitro_protocol: ${41:#http|https}
		# mysqlprotocolversion: ${42:# The protocol version returned by the mysql vserver.}
		# oracleserverversion: ${43:10G|11G}
		# stateupdate: ${44:enabled|disabled}
		# authnprofile: ${45:# Name of the authentication profile to be used when authentication is turned on.}
		# port: ${46:# Port number for content switching virtual server.}
		# cacheable: ${47:# Use this option to specify whether a virtual server, used for load balancing or content switching, routes requests to the cache redirection virtual server before sending it to the configured servers.}
		# mysqlserverversion: ${48:# The server version string returned by the mysql vserver.}
		# backupvserver: ${49:# Name of the backup virtual server that you are configuring. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the backup virtual server is created. You can assign a different backup virtual server or rename the existing virtual server.}
		# backupip: ${50:# .}
		# state: ${51:#present|absent}
		# authnvsname: ${52:# Name of authentication virtual server that authenticates the incoming user requests to this content switching virtual server. .}
		# netprofile: ${53:# The name of the network profile.}
		# pushmulticlients: ${54:# Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.}
		# rhistate: ${55:PASSIVE|ACTIVE}
		# targettype: ${56:GSLB}
		# sothreshold: ${57:# Depending on the spillover method, the maximum number of connections or the maximum total bandwidth (Kbps) that a virtual server can handle before spillover occurs.}
		# sopersistence: ${58:enabled|disabled}
		# sobackupaction: ${59:DROP|ACCEPT|REDIRECT}
		# l2conn: ${60:# Use L2 Parameters to identify a connection.}
		# range: ${61:# Number of consecutive IP addresses, starting with the address specified by the IP Address parameter, to include in a range of addresses assigned to this virtual server.}
		# ipv46: ${62:# IP address of the content switching virtual server.}
		# ippattern: ${63:# IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.}
		# disableprimaryondown: ${64:enabled|disabled}
		# pushlabel: ${65:# Expression for extracting the label from the response received from server. This string can be either an existing rule name or an inline expression. The service type of the virtual server should be either C(HTTP) or C(SSL).}
		# mssqlserverversion: ${66:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
		# sitedomainttl: ${67:# .}
		# sopersistencetimeout: ${68:# Time-out value, in minutes, for spillover persistence.}
		# push: ${69:enabled|disabled}
$0
endsnippet

snippet netscaler_gslb_service "Manage gslb service entities in Netscaler." b
- name: $1
	netscaler_gslb_service:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Any comments that you might want to associate with the GSLB service.}
		# cnameentry: ${6:# Canonical name of the GSLB service. Used in CNAME-based GSLB.}
		# servername: ${7:# Name of the server hosting the GSLB service.}
		# save_config: ${8:yes}
		# nitro_protocol: ${9:#http|https}
		# servicename: ${10:# Name for the GSLB service. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the GSLB service is created.}
		# sitepersistence: ${11:ConnectionProxy|HTTPRedirect|NONE}
		# monitor_bindings: ${12:# Bind monitors to this gslb service}
		# maxbandwidth: ${13:# Integer specifying the maximum bandwidth allowed for the service. A GSLB service whose bandwidth reaches the maximum is not considered when a GSLB decision is made, until its bandwidth consumption drops below the maximum.}
		# publicport: ${14:# The public port associated with the GSLB service's public IP address. The port is mapped to the service's private port number. Applicable to the local GSLB service. Optional.}
		# port: ${15:# Port on which the load balancing entity represented by this GSLB service listens.}
		# clttimeout: ${16:# Idle time, in seconds, after which a client connection is terminated. Applicable if connection proxy based site persistence is used.}
		# servicetype: ${17:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE}
		# monthreshold: ${18:# Monitoring threshold value for the GSLB service. If the sum of the weights of the monitors that are bound to this GSLB service and are in the UP state is not equal to or greater than this threshold value, the service is marked as DOWN.}
		# maxaaausers: ${19:# Maximum number of SSL VPN users that can be logged on concurrently to the VPN virtual server that is represented by this GSLB service. A GSLB service whose user count reaches the maximum is not considered when a GSLB decision is made, until the count drops below the maximum.}
		# maxclient: ${20:# The maximum number of open connections that the service can support at any given time. A GSLB service whose connection count reaches the maximum is not considered when a GSLB decision is made, until the connection count drops below the maximum.}
		# sitename: ${21:# Name of the GSLB site to which the service belongs.}
		# publicip: ${22:# The public IP address that a NAT device translates to the GSLB service's private IP address. Optional.}
		# state: ${23:#present|absent}
		# nitro_timeout: ${24:310}
		# appflowlog: ${25:enabled|disabled}
		# hashid: ${26:# Unique hash identifier for the GSLB service, used by hash based load balancing methods.}
		# ipaddress: ${27:# IP address for the GSLB service. Should represent a load balancing, content switching, or VPN virtual server on the NetScaler appliance, or the IP address of another load balancing device.}
		# downstateflush: ${28:enabled|disabled}
		# cipheader: ${29:# Name for the HTTP header that stores the client's IP address. Used with the Client IP option. If client IP header insertion is enabled on the service and a name is not specified for the header, the NetScaler appliance uses the name specified by the cipHeader parameter in the set ns param command or, in the GUI, the Client IP Header parameter in the Configure HTTP Parameters dialog box.}
		# siteprefix: ${30:# The site's prefix string. When the service is bound to a GSLB virtual server, a GSLB site domain is generated internally for each bound service-domain pair by concatenating the site prefix of the service and the name of the domain. If the special string NONE is specified, the site-prefix string is unset. When implementing HTTP redirect site persistence, the NetScaler appliance redirects GSLB requests to GSLB services by using their site domains.}
		# cip: ${31:enabled|disabled}
		# healthmonitor: ${32:# Monitor the health of the GSLB service.}
		# validate_certs: ${33:yes}
$0
endsnippet

snippet netscaler_gslb_site "Manage gslb site entities in Netscaler." b
- name: $1
	netscaler_gslb_site:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# naptrreplacementsuffix: ${5:# The naptr replacement suffix configured here will be used to construct the naptr replacement field in NAPTR record.}
		# siteipaddress: ${6:# IP address for the GSLB site. The GSLB site uses this IP address to communicate with other GSLB sites. For a local site, use any IP address that is owned by the appliance (for example, a SNIP or MIP address, or the IP address of the ADNS service).}
		# metricexchange: ${7:enabled|disabled}
		# nwmetricexchange: ${8:enabled|disabled}
		# sitename: ${9:# Name for the GSLB site. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the virtual server is created.}
		# sitetype: ${10:REMOTE|LOCAL}
		# save_config: ${11:yes}
		# sessionexchange: ${12:enabled|disabled}
		# publicclip: ${13:# IP address to be used to globally access the remote cluster when it is deployed behind a NAT. It can be same as the normal cluster IP address.}
		# publicip: ${14:# Public IP address for the local site. Required only if the appliance is deployed in a private address space and the site has a public IP address hosted on an external firewall or a NAT device.}
		# nitro_protocol: ${15:#http|https}
		# state: ${16:#present|absent}
		# parentsite: ${17:# Parent site of the GSLB site, in a parent-child topology.}
		# clip: ${18:# Cluster IP address. Specify this parameter to connect to the remote cluster site for GSLB auto-sync. Note: The cluster IP address is defined when creating the cluster.}
		# triggermonitor: ${19:ALWAYS|MEPDOWN|MEPDOWN_SVCDOWN}
		# validate_certs: ${20:yes}
		# nitro_timeout: ${21:310}
$0
endsnippet

snippet netscaler_gslb_vserver "Configure gslb vserver entities in Netscaler." b
- name: $1
	netscaler_gslb_vserver:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Any comments that you might want to associate with the GSLB virtual server.}
		# save_config: ${6:yes}
		# disabled: ${7:no}
		# nitro_protocol: ${8:#http|https}
		# domain_bindings: ${9:# List of bindings for domains for this glsb vserver.}
		# service_bindings: ${10:# List of bindings for gslb services bound to this gslb virtual server.}
		# state: ${11:#present|absent}
		# mir: ${12:enabled|disabled}
		# tolerance: ${13:# Site selection tolerance, in milliseconds, for implementing the RTT load balancing method. If a site's RTT deviates from the lowest RTT by more than the specified tolerance, the site is not considered when the NetScaler appliance makes a GSLB decision. The appliance implements the round robin method of global server load balancing between sites whose RTT values are within the specified tolerance. If the tolerance is 0 (zero), the appliance always sends clients the IP address of the site with the lowest RTT.}
		# nitro_timeout: ${14:310}
		# sothreshold: ${15:# Threshold at which spillover occurs. Specify an integer for the CONNECTION spillover method, a bandwidth value in kilobits per second for the BANDWIDTH method (do not enter the units), or a percentage for the HEALTH method (do not enter the percentage symbol).}
		# sopersistence: ${16:enabled|disabled}
		# appflowlog: ${17:enabled|disabled}
		# persistenceid: ${18:# The persistence ID for the GSLB virtual server. The ID is a positive integer that enables GSLB sites to identify the GSLB virtual server, and is required if source IP address based or spill over based persistence is enabled on the virtual server.}
		# sobackupaction: ${19:DROP|ACCEPT|REDIRECT}
		# servicetype: ${20:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE}
		# dnsrecordtype: ${21:A|AAAA|CNAME|NAPTR}
		# considereffectivestate: ${22:NONE|STATE_ONLY}
		# netmask: ${23:# IPv4 network mask for use in the SOURCEIPHASH load balancing method.}
		# v6netmasklen: ${24:# Number of bits to consider, in an IPv6 source IP address, for creating the hash that is required by the C(SOURCEIPHASH) load balancing method.}
		# persistencetype: ${25:SOURCEIP|NONE}
		# name: ${26:# Name for the GSLB virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.}
		# disableprimaryondown: ${27:enabled|disabled}
		# backuplbmethod: ${28:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD}
		# dynamicweight: ${29:SERVICECOUNT|SERVICEWEIGHT|DISABLED}
		# somethod: ${30:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
		# lbmethod: ${31:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD}
		# sopersistencetimeout: ${32:# Timeout for spillover persistence, in minutes.}
		# persistmask: ${33:# The optional IPv4 network mask applied to IPv4 addresses to establish source IP address based persistence.}
		# timeout: ${34:# Idle time, in minutes, after which a persistence entry is cleared.}
		# v6persistmasklen: ${35:# Number of bits to consider in an IPv6 source IP address when creating source IP address based persistence sessions.}
		# validate_certs: ${36:yes}
$0
endsnippet

snippet netscaler_lb_monitor "Manage load balancing monitors" b
- name: $1
	netscaler_lb_monitor:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# lasversion: ${5:# Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS) monitor.}
		# secure: ${6:# Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure connection by default.}
		# radnasip: ${7:# Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).}
		# Snmpoid: ${8:# SNMP OID for C(SNMP) monitors.}
		# storefrontacctservice: ${9:# Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For multi-tenancy configuration users my skip account service.}
		# radnasid: ${10:# NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).}
		# firmwarerevision: ${11:# Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
		# query: ${12:# Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).}
		# storedb: ${13:enabled|disabled}
		# vendorid: ${14:# Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
		# authapplicationid: ${15:# List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring CER message.}
		# group: ${16:# Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is found on the server, the service is marked as UP. If the newsgroup does not exist or if the search fails, the service is marked as DOWN. Applicable to NNTP monitors.}
		# tos: ${17:# Probe the service by encoding the destination IP address in the IP TOS (6) bits.}
		# maxforwards: ${18:# Maximum number of hops that the SIP request used for monitoring can traverse to reach the server. Applicable only to monitors of type C(SIP-UDP).}
		# querytype: ${19:Address|Zone|AAAA}
		# send: ${20:# String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.}
		# transparent: ${21:# The monitor is bound to a transparent device such as a firewall or router. The state of a transparent device depends on the responsiveness of the services behind it. If a transparent device is being monitored, a destination IP address must be specified. The probe is sent to the specified IP address by using the MAC address of the transparent device.}
		# recv: ${22:# String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.}
		# binddn: ${23:# The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server. Optional. Applicable to C(LDAP) monitors.}
		# rtsprequest: ${24:# RTSP request to send to the server (for example, C("OPTIONS *")).}
		# trofscode: ${25:# Code expected when the server is under maintenance.}
		# successretries: ${26:# Number of consecutive successful probes required to transition a service's state from DOWN to UP.}
		# iptunnel: ${27:# Send the monitoring probe to the service through an IP tunnel. A destination IP address must be specified.}
		# monitorname: ${28:# Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.}
		# nitro_timeout: ${29:310}
		# units1: ${30:SEC|MSEC|MIN}
		# units3: ${31:SEC|MSEC|MIN}
		# units2: ${32:SEC|MSEC|MIN}
		# units4: ${33:SEC|MSEC|MIN}
		# scriptargs: ${34:# String of arguments for the script. The string is copied verbatim into the request.}
		# resptimeout: ${35:# Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than the value specified for the Interval parameter.}
		# downtime: ${36:# Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in milliseconds, seconds, or minutes.}
		# tosid: ${37:# The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.}
		# password: ${38:# Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in conjunction with the user name specified for the C(username) parameter.}
		# sipreguri: ${39:# SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method parameter is set to C(REGISTER).}
		# retries: ${40:# Maximum number of probes to send to establish the state of a service for which a monitoring probe failed.}
		# failureretries: ${41:# Number of retries that must fail, out of the number specified for the Retries parameter, for a service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the service is to be marked as DOWN.}
		# snmpthreshold: ${42:# Threshold for C(SNMP) monitors.}
		# destip: ${43:# IP address of the service to which to send probes. If the parameter is set to 0, the IP address of the server to which the monitor is bound is considered the destination IP address.}
		# radkey: ${44:# Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).}
		# type: ${45:PING|TCP|HTTP|TCP-ECV|HTTP-ECV|UDP-ECV|DNS|FTP|LDNS-PING|LDNS-TCP|LDNS-DNS|RADIUS|USER|HTTP-INLINE|SIP-UDP|SIP-TCP|LOAD|FTP-EXTENDED|SMTP|SNMP|NNTP|MYSQL|MYSQL-ECV|MSSQL-ECV|ORACLE-ECV|LDAP|POP3|CITRIX-XML-SERVICE|CITRIX-WEB-INTERFACE|DNS-TCP|RTSP|ARP|CITRIX-AG|CITRIX-AAC-LOGINPAGE|CITRIX-AAC-LAS|CITRIX-XD-DDC|ND6|CITRIX-WI-EXTENDED|DIAMETER|RADIUS_ACCOUNTING|STOREFRONT|APPC|SMPP|CITRIX-XNC-ECV|CITRIX-XDM|CITRIX-STA-SERVICE|CITRIX-STA-SERVICE-NHOP}
		# storename: ${46:# Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront service store name. Applicable to C(STOREFRONT) monitors.}
		# scriptname: ${47:# Path and name of the script to execute. The script must be available on the NetScaler appliance, in the /nsconfig/monitors/ directory.}
		# validatecred: ${48:# Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type C(CITRIX-XD-DDC).}
		# productname: ${49:# Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
		# metrictable: ${50:# Metric table to which to bind metrics.}
		# acctapplicationid: ${51:# List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message.}
		# oraclesid: ${52:# Name of the service identifier that is used to connect to the Oracle database during authentication.}
		# validate_certs: ${53:yes}
		# username: ${54:# User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.}
		# domain: ${55:# Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers and Web Interface servers, respectively.}
		# interval: ${56:# Time interval between two successive probes. Must be greater than the value of Response Time-out.}
		# resptimeoutthresh: ${57:# Response time threshold, specified as a percentage of the Response Time-out parameter. If the response to a monitor probe has not arrived when the threshold is reached, the appliance generates an SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be generated, the "MONITOR-RTO-THRESHOLD" alarm must also be enabled.}
		# hostipaddress: ${58:# Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP) address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.}
		# sipuri: ${59:# SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of type C(SIP-UDP).}
		# attribute: ${60:# Attribute to evaluate when the LDAP server responds to the query. Success or failure of the monitoring probe depends on whether the attribute exists in the response. Optional.}
		# save_config: ${61:yes}
		# vendorspecificvendorid: ${62:# Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the Vendor-Specific-Application-Id AVPs in a CER monitoring message.}
		# nitro_protocol: ${63:#http|https}
		# snmpcommunity: ${64:# Community name for C(SNMP) monitors.}
		# originrealm: ${65:# Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
		# radmsisdn: ${66:# Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
		# secondarypassword: ${67:# Secondary password that users might have to provide to log on to the Access Gateway server. Applicable to C(CITRIX-AG) monitors.}
		# action: ${68:NONE|LOG|DOWN}
		# respcode: ${69:# Response codes for which to mark the service as UP. For any other response code, the action performed depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.}
		# trofsstring: ${70:# String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV monitors.}
		# logonpointname: ${71:# Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control software. Required if you want to monitor the associated login page or Logon Agent. Applicable to C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.}
		# kcdaccount: ${72:# KCD Account used by C(MSSQL) monitor.}
		# radapn: ${73:# Called Station Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
		# hostname: ${74:# Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.}
		# radframedip: ${75:# Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).}
		# filename: ${76:# Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.}
		# application: ${77:# Name of the application used to determine the state of the service. Applicable to monitors of type C(CITRIX-XML-SERVICE).}
		# state: ${78:enabled|disabled}
		# netprofile: ${79:# Name of the network profile.}
		# alertretries: ${80:# Number of consecutive probe failures after which the appliance generates an SNMP trap called monProbeFailed.}
		# radaccountsession: ${81:# Account Session ID to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
		# deviation: ${82:# Time value added to the learned average response time in dynamic response time monitoring (DRTM). When a deviation is specified, the appliance learns the average response time of bound services and adds the deviation to the average. The final value is then continually adjusted to accommodate response time variations over time. Specified in milliseconds, seconds, or minutes.}
		# httprequest: ${83:# HTTP request to send to the server (for example, C("HEAD /file.html")).}
		# supportedvendorids: ${84:# List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a monitoring message.}
		# inbandsecurityid: ${85:NO_INBAND_SECURITY|TLS}
		# basedn: ${86:# The base distinguished name of the LDAP service, from where the LDAP server can begin the search for the attributes in the monitoring query. Required for C(LDAP) service monitoring.}
		# sitepath: ${87:# URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE), C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.}
		# storefrontcheckbackendservices: ${88:# This option will enable monitoring of services running on storefront server. Storefront services are monitored by probing to a Windows service that runs on the Storefront server and exposes details of which storefront services are running.}
		# sqlquery: ${89:# SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server authenticates the connection.}
		# evalrule: ${90:# Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV monitoring query. Must produce a Boolean result. The result determines the state of the server. If the expression returns TRUE, the probe succeeds.}
		# sipmethod: ${91:OPTIONS|INVITE|REGISTER}
		# customheaders: ${92:# Custom header string to include in the monitoring probes.}
		# mssqlprotocolversion: ${93:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
		# lrtm: ${94:enabled|disabled}
		# ipaddress: ${95:# Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A or AAAA. Applicable to C(DNS) monitors.}
		# destport: ${96:# TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the service to which the monitor is bound is considered the destination port. For a monitor of type C(USER), however, the destination port is the port number that is included in the HTTP request sent to the dispatcher. Does not apply to monitors of type C(PING).}
		# dispatcherport: ${97:# Port number on which the dispatcher listens for the monitoring probe.}
		# reverse: ${98:# Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN when probe criteria are not satisfied.}
		# database: ${99:# Name of the database to connect to during authentication.}
		# radaccounttype: ${100:# Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
		# vendorspecificacctapplicationids: ${101:# List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.}
		# originhost: ${102:# Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
		# filter: ${103:# Filter criteria for the LDAP query. Optional.}
		# vendorspecificauthapplicationids: ${104:# List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.}
		# snmpversion: ${105:V1|V2}
		# dispatcherip: ${106:# IP address of the dispatcher to which to send the probe.}
$0
endsnippet

snippet netscaler_lb_vserver "Manage load balancing vserver configuration" b
- name: $1
	netscaler_lb_vserver:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# servicebindings: ${5:# List of services along with the weights that are load balanced.}
		# comment: ${6:# Any comments that you might want to associate with the virtual server.}
		# rtspnat: ${7:# Use network address translation (NAT) for RTSP data connections.}
		# disabled: ${8:no}
		# macmoderetainvlan: ${9:enabled|disabled}
		# dbslb: ${10:enabled|disabled}
		# listenpolicy: ${11:# Default syntax expression identifying traffic accepted by the virtual server. Can be either an expression (for example, C(CLIENT.IP.DST.IN_SUBNET(192.0.2.0/24)) or the name of a named expression. In the above example, the virtual server accepts all requests whose destination IP address is in the 192.0.2.0/24 subnet.}
		# ipmask: ${12:# IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.}
		# insertvserveripport: ${13:OFF|VIPADDR|V6TOV4MAPPING}
		# redirectportrewrite: ${14:enabled|disabled}
		# cacheable: ${15:# Route cacheable requests to a cache redirection virtual server. The load balancing virtual server can forward requests only to a transparent cache redirection virtual server that has an IP address and port combination of *:80, so such a cache redirection virtual server must be configured on the appliance.}
		# clttimeout: ${16:# Idle time, in seconds, after which a client connection is terminated.}
		# authenticationhost: ${17:# Fully qualified domain name (FQDN) of the authentication virtual server to which the user must be redirected for authentication. Make sure that the Authentication parameter is set to C(yes).}
		# servicetype: ${18:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|DNS|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|RTSP|PUSH|SSL_PUSH|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|TFTP|ORACLE|SMPP|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
		# mysqlservercapabilities: ${19:# Server capabilities that the virtual server advertises to clients.}
		# authentication: ${20:# Enable or disable user authentication.}
		# vipheader: ${21:# Name for the inserted header. The default name is vip-header.}
		# pushvserver: ${22:# Name of the load balancing virtual server, of type PUSH or SSL_PUSH, to which the server pushes updates received on the load balancing virtual server that you are configuring.}
		# dataoffset: ${23:# Offset to be considered when extracting a token from the TCP payload. Applicable to virtual servers, of type TCP, using the token method of load balancing. Must be within the first 24 KB of the TCP payload.}
		# datalength: ${24:# Length of the token to be extracted from the data segment of an incoming packet, for use in the token method of load balancing. The length of the token, specified in bytes, must not be greater than 24 KB. Applicable to virtual servers of type TCP.}
		# healththreshold: ${25:# Threshold in percent of active services below which vserver state is made down. If this threshold is 0, vserver state will be up even if one bound service is up.}
		# td: ${26:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
		# nitro_timeout: ${27:310}
		# newservicerequestincrementinterval: ${28:# Interval, in seconds, between successive increments in the load on a new service or a service whose state has just changed from DOWN to UP. A value of 0 (zero) specifies manual slow start.}
		# appflowlog: ${29:enabled|disabled}
		# disableprimaryondown: ${30:enabled|disabled}
		# netmask: ${31:# IPv4 subnet mask to apply to the destination IP address or source IP address when the load balancing method is C(DESTINATIONIPHASH) or C(SOURCEIPHASH).}
		# redirurl: ${32:# URL to which to redirect traffic if the virtual server becomes unavailable.}
		# processlocal: ${33:enabled|disabled}
		# minautoscalemembers: ${34:# Minimum number of members expected to be present when vserver is used in Autoscale.}
		# name: ${35:# Name for the virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.}
		# backuplbmethod: ${36:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|CUSTOMLOAD}
		# tcpprofilename: ${37:# Name of the TCP profile whose settings are to be applied to the virtual server.}
		# downstateflush: ${38:enabled|disabled}
		# httpprofilename: ${39:# Name of the HTTP profile whose settings are to be applied to the virtual server.}
		# persistmask: ${40:# Persistence mask for IP based persistence types, for IPv4 virtual servers.}
		# timeout: ${41:# Time period for which a persistence session is in effect.}
		# v6persistmasklen: ${42:# Persistence mask for IP based persistence types, for IPv6 virtual servers.}
		# persistavpno: ${43:# Persist AVP number for Diameter Persistency.}
		# recursionavailable: ${44:# When set to YES, this option causes the DNS replies from this vserver to have the RA bit turned on. Typically one would set this option to YES, when the vserver is load balancing a set of DNS servers thatsupport recursive queries.}
		# validate_certs: ${45:yes}
		# dnsprofilename: ${46:# Name of the DNS profile to be associated with the VServer. DNS profile properties will be applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.}
		# maxautoscalemembers: ${47:# Maximum number of members expected to be present when vserver is used in Autoscale.}
		# oracleserverversion: ${48:10G|11G}
		# save_config: ${49:yes}
		# bypassaaaa: ${50:# If this option is enabled while resolving DNS64 query AAAA queries are not sent to back end dns server.}
		# somethod: ${51:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
		# nitro_protocol: ${52:#http|https}
		# mysqlprotocolversion: ${53:# MySQL protocol version that the virtual server advertises to clients.}
		# rhistate: ${54:PASSIVE|ACTIVE}
		# pushlabel: ${55:# Expression for extracting a label from the server's response. Can be either an expression or the name of a named expression.}
		# port: ${56:# Port number for the virtual server.}
		# sopersistencetimeout: ${57:# Timeout for spillover persistence, in minutes.}
		# authnprofile: ${58:# Name of the authentication profile to be used when authentication is turned on.}
		# persistencebackup: ${59:SOURCEIP|NONE}
		# mysqlserverversion: ${60:# MySQL server version string that the virtual server advertises to clients.}
		# mysqlcharacterset: ${61:# Character set that the virtual server advertises to clients.}
		# authn401: ${62:# Enable or disable user authentication with HTTP 401 responses.}
		# state: ${63:#present|absent}
		# authnvsname: ${64:# Name of an authentication virtual server with which to authenticate users.}
		# netprofile: ${65:# Name of the network profile to associate with the virtual server. If you set this parameter, the virtual server uses only the IP addresses in the network profile as source IP addresses when initiating connections with servers.}
		# pushmulticlients: ${66:# Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.}
		# lbmethod: ${67:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|URLHASH|DOMAINHASH|DESTINATIONIPHASH|SOURCEIPHASH|SRCIPDESTIPHASH|LEASTBANDWIDTH|LEASTPACKETS|TOKEN|SRCIPSRCPORTHASH|LRTM|CALLIDHASH|CUSTOMLOAD|LEASTREQUEST|AUDITLOGHASH|STATICPROXIMITY}
		# hashlength: ${68:# Number of bytes to consider for the hash value used in the URLHASH and DOMAINHASH load balancing methods.}
		# resrule: ${69:# Default syntax expression specifying which part of a server's response to use for creating rule based persistence sessions (persistence type RULE). Can be either an expression or the name of a named expression.}
		# connfailover: ${70:DISABLED|STATEFUL|STATELESS}
		# sothreshold: ${71:# Threshold at which spillover occurs. Specify an integer for the C(CONNECTION) spillover method, a bandwidth value in kilobits per second for the C(BANDWIDTH) method (do not enter the units), or a percentage for the C(HEALTH) method (do not enter the percentage symbol).}
		# sopersistence: ${72:enabled|disabled}
		# dns64: ${73:enabled|disabled}
		# sobackupaction: ${74:DROP|ACCEPT|REDIRECT}
		# skippersistency: ${75:Bypass|ReLb|None}
		# ssl_certkey: ${76:# The name of the ssl certificate that is bound to this service.}
		# l2conn: ${77:# Use Layer 2 parameters (channel number, MAC address, and VLAN ID) in addition to the 4-tuple (<source IP>:<source port>::<destination IP>:<destination port>) that is used to identify a connection. Allows multiple TCP and non-TCP connections with the same 4-tuple to co-exist on the NetScaler appliance.}
		# range: ${78:# Number of IP addresses that the appliance must generate and assign to the virtual server. The virtual server then functions as a network virtual server, accepting traffic on any of the generated IP addresses. The IP addresses are generated automatically, as follows:}
		# v6netmasklen: ${79:# Number of bits to consider in an IPv6 destination or source IP address, for creating the hash that is required by the C(DESTINATIONIPHASH) and C(SOURCEIPHASH) load balancing methods.}
		# sessionless: ${80:enabled|disabled}
		# ipv46: ${81:# IPv4 or IPv6 address to assign to the virtual server.}
		# persistencetype: ${82:SOURCEIP|COOKIEINSERT|SSLSESSION|RULE|URLPASSIVE|CUSTOMSERVERID|DESTIP|SRCIPDESTIP|CALLID|RTSPSID|DIAMETER|FIXSESSION|NONE}
		# tosid: ${83:# TOS ID of the virtual server. Applicable only when the load balancing redirection mode is set to TOS.}
		# ippattern: ${84:# IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.}
		# dbprofilename: ${85:# Name of the DB profile whose settings are to be applied to the virtual server.}
		# backuppersistencetimeout: ${86:# Time period for which backup persistence is in effect.}
		# newservicerequestunit: ${87:PER_SECOND|PERCENT}
		# m: ${88:IP|MAC|IPTUNNEL|TOS}
		# mssqlserverversion: ${89:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
		# listenpriority: ${90:# Integer specifying the priority of the listen policy. A higher number specifies a lower priority. If a request matches the listen policies of more than one virtual server the virtual server whose listen policy has the highest priority (the lowest priority number) accepts the request.}
		# servicegroupbindings: ${91:# List of service groups along with the weights that are load balanced.}
		# newservicerequest: ${92:# Number of requests, or percentage of the load on existing services, by which to increase the load on a new service at each interval in slow-start mode. A non-zero value indicates that slow-start is applicable. A zero value indicates that the global RR startup parameter is applied. Changing the value to zero will cause services currently in slow start to take the full traffic as determined by the LB method. Subsequently, any new services added will use the global RR factor.}
		# push: ${93:enabled|disabled}
		# icmpvsrresponse: ${94:PASSIVE|ACTIVE}
		# cookiename: ${95:# Use this parameter to specify the cookie name for C(COOKIE) peristence type. It specifies the name of cookie with a maximum of 32 characters. If not specified, cookie name is internally generated.}
$0
endsnippet

snippet netscaler_save_config "Save Netscaler configuration." b
- name: $1
	netscaler_save_config:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# nitro_protocol: ${5:#http|https}
		# validate_certs: ${6:yes}
		# nitro_timeout: ${7:310}
$0
endsnippet

snippet netscaler_server "Manage server configuration" b
- name: $1
	netscaler_server:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Any information about the server.}
		# domain: ${6:# Domain name of the server. For a domain based configuration, you must create the server first.}
		# td: ${7:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
		# name: ${8:# Name for the server.}
		# ipv6address: ${9:no}
		# ipaddress: ${10:# IPv4 or IPv6 address of the server. If you create an IP address based server, you can specify the name of the server, instead of its IP address, when creating a service. Note: If you do not create a server entry, the server IP address that you enter when you create a service becomes the name of the server.}
		# save_config: ${11:yes}
		# domainresolveretry: ${12:5}
		# disabled: ${13:no}
		# nitro_protocol: ${14:#http|https}
		# state: ${15:#present|absent}
		# translationip: ${16:# IP address used to transform the server's DNS-resolved IP address.}
		# validate_certs: ${17:yes}
		# nitro_timeout: ${18:310}
		# translationmask: ${19:# The netmask of the translation ip.}
$0
endsnippet

snippet netscaler_service "Manage service configuration in Netscaler" b
- name: $1
	netscaler_service:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Any information about the service.}
		# tcpb: ${6:# Enable TCP buffering for the service.}
		# cachetype: ${7:TRANSPARENT|REVERSE|FORWARD}
		# ip: ${8:# IP to assign to the service.}
		# servername: ${9:# Name of the server that hosts the service.}
		# save_config: ${10:yes}
		# disabled: ${11:no}
		# nitro_protocol: ${12:#http|https}
		# maxreq: ${13:# Maximum number of requests that can be sent on a persistent connection to the service.}
		# monitor_bindings: ${14:# A list of load balancing monitors to bind to this service.}
		# maxbandwidth: ${15:# Maximum bandwidth, in Kbps, allocated to the service.}
		# svrtimeout: ${16:# Time, in seconds, after which to terminate an idle server connection.}
		# port: ${17:# Port number of the service.}
		# clttimeout: ${18:# Time, in seconds, after which to terminate an idle client connection.}
		# servicetype: ${19:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
		# cacheable: ${20:no}
		# pathmonitor: ${21:# Path monitoring for clustering.}
		# maxclient: ${22:# Maximum number of simultaneous open connections to the service.}
		# ipaddress: ${23:# The new IP address of the service.}
		# graceful: ${24:no}
		# state: ${25:#present|absent}
		# usip: ${26:# Use the client's IP address as the source IP address when initiating a connection to the server. When creating a service, if you do not set this parameter, the service inherits the global Use Source IP setting (available in the enable ns mode and disable ns mode CLI commands, or in the System > Settings > Configure modes > Configure Modes dialog box). However, you can override this setting after you create the service.}
		# netprofile: ${27:# Network profile to use for the service.}
		# customserverid: ${28:# Unique identifier for the service. Used when the persistency type for the virtual server is set to Custom Server ID.}
		# td: ${29:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
		# nitro_timeout: ${30:310}
		# pathmonitorindv: ${31:# Individual Path monitoring decisions.}
		# cleartextport: ${32:# Port to which clear text data must be sent after the appliance decrypts incoming SSL traffic. Applicable to transparent SSL services.}
		# appflowlog: ${33:enabled|disabled}
		# rtspsessionidremap: ${34:no}
		# monthreshold: ${35:# Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.}
		# hashid: ${36:# A numerical identifier that can be used by hash based load balancing methods. Must be unique for each service.}
		# serverid: ${37:# The identifier for the service. This is used when the persistency type is set to Custom Server ID.}
		# processlocal: ${38:enabled|disabled}
		# accessdown: ${39:no}
		# name: ${40:# Name for the service. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the service has been created.}
		# tcpprofilename: ${41:# Name of the TCP profile that contains TCP configuration settings for the service.}
		# sp: ${42:# Enable surge protection for the service.}
		# downstateflush: ${43:enabled|disabled}
		# cipheader: ${44:# Name for the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If you set the Client IP parameter, and you do not specify a name for the header, the appliance uses the header name specified for the global Client IP Header parameter (the cipHeader parameter in the set ns param CLI command or the Client IP Header parameter in the Configure HTTP Parameters dialog box at System > Settings > Change HTTP parameters). If the global Client IP Header parameter is not specified, the appliance inserts a header with the name "client-ip.".}
		# httpprofilename: ${45:# Name of the HTTP profile that contains HTTP configuration settings for the service.}
		# cip: ${46:enabled|disabled}
		# healthmonitor: ${47:yes}
		# useproxyport: ${48:# Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.}
		# cka: ${49:# Enable client keep-alive for the service.}
		# dnsprofilename: ${50:# Name of the DNS profile to be associated with the service. DNS profile properties will applied to the transactions processed by a service. This parameter is valid only for ADNS and ADNS-TCP services.}
		# validate_certs: ${51:yes}
		# cmp: ${52:# Enable compression for the service.}
$0
endsnippet

snippet netscaler_servicegroup "Manage service group configuration in Netscaler" b
- name: $1
	netscaler_servicegroup:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: ${5:# Any information about the service group.}
		# tcpb: ${6:# Enable TCP buffering for the service group.}
		# cachetype: ${7:TRANSPARENT|REVERSE|FORWARD}
		# save_config: ${8:yes}
		# disabled: ${9:no}
		# nitro_protocol: ${10:#http|https}
		# maxreq: ${11:# Maximum number of requests that can be sent on a persistent connection to the service group.}
		# graceful: ${12:# Wait for all existing connections to the service to terminate before shutting down the service.}
		# maxbandwidth: ${13:# Maximum bandwidth, in Kbps, allocated for all the services in the service group.}
		# svrtimeout: ${14:# Time, in seconds, after which to terminate an idle server connection.}
		# clttimeout: ${15:# Time, in seconds, after which to terminate an idle client connection.}
		# servicetype: ${16:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
		# cacheable: ${17:# Use the transparent cache redirection virtual server to forward the request to the cache server.}
		# autoscale: ${18:DISABLED|DNS|POLICY}
		# maxclient: ${19:# Maximum number of simultaneous open connections for the service group.}
		# monitorbindings: ${20:# A list of monitornames to bind to this service}
		# servicegroupname: ${21:# Name of the service group. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the name is created.}
		# state: ${22:#present|absent}
		# usip: ${23:# Use client's IP address as the source IP address when initiating connection to the server. With the NO setting, which is the default, a mapped IP (MIP) address or subnet IP (SNIP) address is used as the source IP address to initiate server side connections.}
		# netprofile: ${24:# Network profile for the service group.}
		# rtspsessionidremap: ${25:# Enable RTSP session ID mapping for the service group.}
		# nitro_timeout: ${26:310}
		# pathmonitorindv: ${27:# Individual Path monitoring decisions.}
		# pathmonitor: ${28:# Path monitoring for clustering.}
		# appflowlog: ${29:enabled|disabled}
		# servicemembers: ${30:# A list of dictionaries describing each service member of the service group.}
		# monthreshold: ${31:# Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.}
		# memberport: ${32:# member port.}
		# cka: ${33:# Enable client keep-alive for the service group.}
		# tcpprofilename: ${34:# Name of the TCP profile that contains TCP configuration settings for the service group.}
		# sp: ${35:# Enable surge protection for the service group.}
		# downstateflush: ${36:enabled|disabled}
		# cipheader: ${37:# Name of the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If client IP insertion is enabled, and the client IP header is not specified, the value of Client IP Header parameter or the value set by the set ns config command is used as client's IP header name.}
		# httpprofilename: ${38:# Name of the HTTP profile that contains HTTP configuration settings for the service group.}
		# cip: ${39:enabled|disabled}
		# healthmonitor: ${40:# Monitor the health of this service. Available settings function as follows:}
		# useproxyport: ${41:# Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.}
		# validate_certs: ${42:yes}
		# cmp: ${43:# Enable compression for the specified service.}
$0
endsnippet

snippet netscaler_ssl_certkey "Manage ssl cerificate keys." b
- name: $1
	netscaler_ssl_certkey:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# certkey: ${5:# Name for the certificate and private-key pair. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the certificate-key pair is created.}
		# inform: ${6:DER|PEM|PFX}
		# passplain: ${7:# Pass phrase used to encrypt the private-key. Required when adding an encrypted private-key in PEM format.}
		# cert: ${8:# Name of and, optionally, path to the X509 certificate file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.}
		# save_config: ${9:yes}
		# nitro_protocol: ${10:#http|https}
		# state: ${11:#present|absent}
		# key: ${12:# Name of and, optionally, path to the private-key file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.}
		# notificationperiod: ${13:# Time, in number of days, before certificate expiration, at which to generate an alert that the certificate is about to expire.}
		# expirymonitor: ${14:enabled|disabled}
		# password: ${15:# Passphrase that was used to encrypt the private-key. Use this option to load encrypted private-keys in PEM format.}
		# validate_certs: ${16:yes}
		# nitro_timeout: ${17:310}
$0
endsnippet

snippet pn_cluster "CLI command to create/delete a cluster." b
- name: $1
	pn_cluster:
		pn_name: ${2:# Specify the name of the cluster.}
		state: ${3:present|absent}
		# pn_cluster_node1: ${4:# Specify the name of the first switch in the cluster.}
		# pn_clipassword: ${5:# Provide login password if user is not root.}
		# pn_cliusername: ${6:# Provide login username if user is not root.}
		# pn_validate: ${7:validate|no-validate}
		# pn_cliswitch: ${8:# Target switch to run the cli on.}
		# pn_cluster_node2: ${9:# Specify the name of the second switch in the cluster.}
$0
endsnippet

snippet pn_ospf "CLI command to add/remove ospf protocol to a vRouter." b
- name: $1
	pn_ospf:
		state: ${2:#present|absent}
		pn_vrouter_name: ${3:# Specify the name of the vRouter.}
		pn_network_ip: ${4:# Specify the network IP (IPv4 or IPv6) address.}
		# pn_clipassword: ${5:# Provide login password if user is not root.}
		# pn_ospf_area: ${6:# Stub area number for the configuration. Required for vrouter-ospf-add.}
		# pn_cliswitch: ${7:# Target switch to run the CLI on.}
		# pn_cliusername: ${8:# Provide login username if user is not root.}
$0
endsnippet

snippet pn_ospfarea "CLI command to add/remove ospf area to/from a vrouter." b
- name: $1
	pn_ospfarea:
		pn_ospf_area: ${2:# Specify the OSPF area number.}
		pn_clipassword: ${3:# Login password.}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		pn_cliusername: ${5:# Login username.}
		state: ${6:present|absent|update}
		# pn_prefix_listin: ${7:# OSPF prefix list for filtering incoming packets.}
		# pn_prefix_listout: ${8:# OSPF prefix list for filtering outgoing packets.}
		# pn_stub_type: ${9:none|stub|stub-no-summary|nssa|nssa-no-summary}
		# pn_cliswitch: ${10:# Target switch(es) to run the CLI on.}
		# pn_quiet: ${11:yes}
$0
endsnippet

snippet pn_show "Run show commands on nvOS device." b
- name: $1
	pn_show:
		pn_command: ${2:# The C(pn_command) takes a CLI show command as value.}
		# pn_parameters: ${3:# Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.}
		# pn_options: ${4:# Specify formatting options.}
		# pn_clipassword: ${5:# Provide login password if user is not root.}
		# pn_cliswitch: ${6:# Target switch(es) to run the cli on.}
		# pn_cliusername: ${7:# Provide login username if user is not root.}
$0
endsnippet

snippet pn_trunk "CLI command to create/delete/modify a trunk." b
- name: $1
	pn_trunk:
		pn_name: ${2:# Specify the name for the trunk configuration.}
		state: ${3:present|absent|update}
		# pn_unknown_mcast_level: ${4:# Specify an unknown multicast level in percent. The default value is 100%.}
		# pn_jumbo: ${5:# Specify if the port can receive jumbo frames.}
		# pn_lacp_fallback_timeout: ${6:# Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.}
		# pn_unknown_ucast_level: ${7:# Specify an unknown unicast level in percent. The default value is 100%.}
		# pn_lacp_timeout: ${8:slow|fast}
		# pn_loopback: ${9:# Specify loopback if you want to use loopback.}
		# pn_speed: ${10:disable|10m|100m|1g|2.5g|10g|40g}
		# pn_edge_switch: ${11:# Specify if the switch is an edge switch.}
		# pn_host: ${12:# Host facing port control setting.}
		# pn_port_macaddr: ${13:# Specify the MAC address of the port.}
		# pn_lacp_fallback: ${14:bundle|individual}
		# pn_routing: ${15:# Specify if the port participates in routing on the network.}
		# pn_clipassword: ${16:# Provide login password if user is not root.}
		# pn_mirror_receive: ${17:# Specify if the configuration receives mirrored traffic.}
		# pn_egress_rate_limit: ${18:# Specify an egress port data rate limit for the configuration.}
		# pn_cliusername: ${19:# Provide login username if user is not root.}
		# pn_lacp_mode: ${20:off|passive|active}
		# pn_ports: ${21:# Specify the port number(s) for the link(s) to aggregate into the trunk.}
		# pn_lacp_priority: ${22:# Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.}
		# pn_broadcast_level: ${23:# Specify a broadcast level in percent. The default value is 100%.}
		# pn_pause: ${24:# Specify if pause frames are sent.}
		# pn_cliswitch: ${25:# Target switch(es) to run the cli on.}
		# pn_loopvlans: ${26:# Specify a list of looping vlans.}
		# pn_description: ${27:# Specify a description for the trunk configuration.}
$0
endsnippet

snippet pn_vlag "CLI command to create/delete/modify vlag." b
- name: $1
	pn_vlag:
		pn_name: ${2:# The C(pn_name) takes a valid name for vlag configuration.}
		state: ${3:present|absent|update}
		# pn_lacp_fallback: ${4:bundle|individual}
		# pn_lacp_fallback_timeout: ${5:# Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.}
		# pn_clipassword: ${6:# Provide login password if user is not root.}
		# pn_lacp_timeout: ${7:slow|fast}
		# pn_cliusername: ${8:# Provide login username if user is not root.}
		# pn_lacp_mode: ${9:off|passive|active}
		# pn_failover_action: ${10:move|ignore}
		# pn_peer_port: ${11:# Specify the peer VLAG port.}
		# pn_peer_switch: ${12:# Specify the fabric-name of the peer switch.}
		# pn_port: ${13:# Specify the local VLAG port.}
		# pn_cliswitch: ${14:# Target switch(es) to run this command on.}
		# pn_mode: ${15:active-active|active-standby}
$0
endsnippet

snippet pn_vlan "CLI command to create/delete a VLAN." b
- name: $1
	pn_vlan:
		pn_vlanid: ${2:# Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.}
		state: ${3:present|absent}
		# pn_scope: ${4:fabric|local}
		# pn_clipassword: ${5:# Provide login password if user is not root.}
		# pn_cliusername: ${6:# Provide login username if user is not root.}
		# pn_ports: ${7:# Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.}
		# pn_untagged_ports: ${8:# Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.}
		# pn_cliswitch: ${9:# Target switch(es) to run the cli on.}
		# pn_stats: ${10:# Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.}
		# pn_description: ${11:# Specify a description for the VLAN.}
$0
endsnippet

snippet pn_vrouter "CLI command to create/delete/modify a vrouter." b
- name: $1
	pn_vrouter:
		pn_name: ${2:# Specify the name of the vRouter.}
		state: ${3:present|absent|update}
		# pn_rip_redistribute: ${4:static|connected|ospf|bgp}
		# pn_bgp_options: ${5:# Specify other BGP options as a whitespaces separated string within single quotes ''.}
		# pn_router_id: ${6:# Specify the vRouter IP address.}
		# pn_ospf_options: ${7:# Specify other OSPF options as a whitespaces separated string within single quotes ''.}
		# pn_bgp_as: ${8:# Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).}
		# pn_ospf_redistribute: ${9:static|connected|bgp|rip}
		# pn_clipassword: ${10:# Provide login password if user is not root.}
		# pn_bgp_redistribute: ${11:static|connected|rip|ospf}
		# pn_router_type: ${12:hardware|software}
		# pn_hw_vrrp_id: ${13:# Specifies the VRRP ID for a hardware vrouter.}
		# pn_vnet: ${14:# Specify the name of the VNET.}
		# pn_cliusername: ${15:# Provide login username if user is not root.}
		# pn_service_state: ${16:enable|disable}
		# pn_service_type: ${17:dedicated|shared}
		# pn_cliswitch: ${18:# Target switch(es) to run the CLI on.}
		# pn_bgp_max_paths: ${19:# Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.}
$0
endsnippet

snippet pn_vrouterbgp "CLI command to add/remove/modify vrouter-bgp." b
- name: $1
	pn_vrouterbgp:
		pn_vrouter_name: ${2:# Specify a name for the vRouter service.}
		state: ${3:present|absent|update}
		# pn_max_prefix: ${4:# Specify the maximum number of prefixes.}
		# pn_route_mapout: ${5:# Specify outbound route map for neighbor.}
		# pn_neighbor: ${6:# Specify a neighbor IP address to use for BGP.}
		# pn_override_capability: ${7:# Specify if you want to override capability.}
		# pn_route_mapin: ${8:# Specify inbound route map for neighbor.}
		# pn_soft_reconfig: ${9:# Specify if you want a soft reconfiguration of inbound traffic.}
		# pn_ebgp: ${10:# Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.}
		# pn_prefix_listin: ${11:# Specify the prefix list to filter traffic inbound.}
		# pn_bfd: ${12:# Specify if you want BFD protocol support for fault detection.}
		# pn_password: ${13:# Specify a password, if desired.}
		# pn_route_reflector: ${14:# Specify if a route reflector client is used.}
		# pn_keepalive: ${15:# Specify BGP neighbor keepalive interval in seconds.}
		# pn_max_prefix_warn: ${16:# Specify if you want a warning message when the maximum number of prefixes is exceeded.}
		# pn_multiprotocol: ${17:ipv4-unicast|ipv6-unicast}
		# pn_clipassword: ${18:# Provide login password if user is not root.}
		# pn_default_originate: ${19:# Specify if you want announce default routes to the neighbor or not.}
		# pn_cliusername: ${20:# Provide login username if user is not root.}
		# pn_weight: ${21:# Specify a default weight value between 0 and 65535 for the neighbor routes.}
		# pn_prefix_listout: ${22:# Specify the prefix list to filter traffic outbound.}
		# pn_remote_as: ${23:# Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.}
		# pn_cliswitch: ${24:# Target switch(es) to run the cli on.}
		# pn_holdtime: ${25:# Specify BGP neighbor holdtime in seconds.}
		# pn_next_hop_self: ${26:# Specify if the next-hop is the same router or not.}
$0
endsnippet

snippet pn_vrouterif "CLI command to add/remove/modify vrouter-interface." b
- name: $1
	pn_vrouterif:
		pn_vrouter_name: ${2:# Specify the name of the vRouter interface.}
		state: ${3:present|absent|update}
		# pn_nic_enable: ${4:# Specify if the NIC is enabled or not}
		# pn_vrrp_adv_int: ${5:# Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.}
		# pn_vrrp_priority: ${6:# Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).}
		# pn_alias: ${7:# Specify an alias for the interface.}
		# pn_secondary_macs: ${8:# Specify a secondary MAC address for the interface.}
		# pn_interface_ip: ${9:# Specify the IP address of the interface in x.x.x.x/n format.}
		# pn_vlan: ${10:# Specify the VLAN identifier. This is a value between 1 and 4092.}
		# pn_vxlan: ${11:# Specify the VXLAN identifier. This is a value between 1 and 16777215.}
		# pn_exclusive: ${12:# Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.}
		# pn_nic_str: ${13:# Specify the type of NIC. Used for vrouter-interface remove/modify.}
		# pn_clipassword: ${14:# Provide login password if user is not root.}
		# pn_vrrp_id: ${15:# Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.}
		# pn_cliusername: ${16:# Provide login username if user is not root.}
		# pn_interface: ${17:mgmt|data|span}
		# pn_l3port: ${18:# Specify a Layer 3 port for the interface.}
		# pn_cliswitch: ${19:# Target switch to run the cli on.}
		# pn_assignment: ${20:none|dhcp|dhcpv6|autov6}
$0
endsnippet

snippet pn_vrouterlbif "CLI command to add/remove vrouter-loopback-interface." b
- name: $1
	pn_vrouterlbif:
		pn_interface_ip: ${2:# Specify the IP address.}
		state: ${3:present|absent}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		# pn_clipassword: ${5:# Provide login password if user is not root.}
		# pn_cliusername: ${6:# Provide login username if user is not root.}
		# pn_cliswitch: ${7:# Target switch(es) to run the cli on.}
		# pn_index: ${8:# Specify the interface index from 1 to 255.}
$0
endsnippet

snippet nuage_vspk "Manage Nuage VSP environments" b
- name: $1
	nuage_vspk:
		auth: ${2:# Dict with the authentication information required to connect to a Nuage VSP environment.}
		type: ${3:# The type of entity you want to work on (example Enterprise).}
		# parent_type: ${4:# The type of parent the ID is specified for (example Enterprise).}
		# properties: ${5:# Properties are the key, value pairs of the different properties an entity has.}
		# match_filter: ${6:# A filter used when looking (both in I(command) and I(state) for entities, in the format the Nuage VSP API expects.}
		# parent_id: ${7:# The ID of the parent of the entity you want to work on.}
		# state: ${8:present|absent}
		# command: ${9:find|change_password|wait_for_job|get_csp_enterprise}
		# id: ${10:# The ID of the entity you want to work on.}
		# children: ${11:# Can be used to specify a set of child entities.}
$0
endsnippet

snippet nxos_aaa_server "Manages AAA server global configuration." b
- name: $1
	nxos_aaa_server:
		server_type: ${2:radius|tacacs}
		state: ${3:#present|default}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# directed_request: ${8:enabled|disabled}
		# encrypt_type: ${9:0|7}
		# global_key: ${10:# Global AAA shared secret.}
		# server_timeout: ${11:# Global AAA server timeout period, in seconds. Range is 1-60. Device default is 5.}
		# deadtime: ${12:# Duration for which a non-reachable AAA server is skipped, in minutes. Range is 1-1440. Device default is 0.}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_aaa_server_host "Manages AAA server host-specific configuration." b
- name: $1
	nxos_aaa_server_host:
		server_type: ${2:radius|tacacs}
		address: ${3:# Address or name of the radius or tacacs host.}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# key: ${8:# Shared secret for the specified host.}
		# encrypt_type: ${9:0|7}
		# auth_port: ${10:# Alternate UDP port for RADIUS authentication.}
		# host_timeout: ${11:# Timeout period for specified host, in seconds. Range is 1-60.}
		# tacacs_port: ${12:# Alternate TCP port TACACS Server.}
		# state: ${13:#present|absent}
		# timeout: ${14:10}
		# provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# acct_port: ${16:# Alternate UDP port for RADIUS accounting.}
		# use_ssl: ${17:yes|no}
		# password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${19:yes|no}
		# port: ${20:0 (use common port)}
$0
endsnippet

snippet nxos_acl "Manages access list entries for ACLs." b
- name: $1
	nxos_acl:
		transport: ${2:cli}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		name: ${4:# Case sensitive name of the access list (ACL).}
		# seq: ${5:# Sequence number of the entry (ACE).}
		# time-range: ${6:# Name of time-range to apply.}
		# dest_port_op: ${7:any|eq|gt|lt|neq|range}
		# use_ssl: ${8:yes|no}
		# port: ${9:0 (use common port)}
		# established: ${10:enable}
		# log: ${11:enable}
		# proto: ${12:# Port number or protocol (as supported by the switch).}
		# state: ${13:#present|absent|delete_acl}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# fragments: ${15:enable}
		# src_port1: ${16:# Port/protocol and also first (lower) port when using range operand.}
		# src_port2: ${17:# Second (end) port when using range operand.}
		# username: ${18:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# src_port_op: ${19:any|eq|gt|lt|neq|range}
		# psh: ${20:enable}
		# dest: ${21:# Destination ip and mask using IP/MASK notation and supports the keyword 'any'.}
		# syn: ${22:enable}
		# dscp: ${23:af11|af12|af13|af21|af22|af23|af31|af32|af33|af41|af42|af43|cs1|cs2|cs3|cs4|cs5|cs6|cs7|default|ef}
		# urg: ${24:enable}
		# rst: ${25:enable}
		# password: ${26:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# src: ${27:# Source ip and mask using IP/MASK notation and supports keyword 'any'.}
		# remark: ${28:# If action is set to remark, this is the description.}
		# ssh_keyfile: ${29:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# ack: ${30:enable}
		# fin: ${31:enable}
		# precedence: ${32:critical|flash|flash-override|immediate|internet|network|priority|routine}
		# timeout: ${33:10}
		# action: ${34:permit|deny|remark}
		# dest_port1: ${35:# Port/protocol and also first (lower) port when using range operand.}
		# dest_port2: ${36:# Second (end) port when using range operand.}
		# validate_certs: ${37:yes|no}
$0
endsnippet

snippet nxos_acl_interface "Manages applying ACLs to interfaces." b
- name: $1
	nxos_acl_interface:
		direction: ${2:ingress|egress}
		name: ${3:# Case sensitive name of the access list (ACL).}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${5:# Full name of interface, e.g. I(Ethernet1/1).}
		transport: ${6:cli}
		# username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${9:#present|absent}
		# timeout: ${10:10}
		# provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${12:yes|no}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${14:yes|no}
		# port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_banner "Manage multiline banners on Cisco NXOS devices" b
- name: $1
	nxos_banner:
		banner: ${2:exec|motd}
		# text: ${3:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# state: ${4:#present|absent}
$0
endsnippet

snippet nxos_bgp "Manages BGP configuration." b
- name: $1
	nxos_bgp:
		transport: ${2:cli}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		asn: ${4:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		# neighbor_down_fib_accelerate: ${5:true|false}
		# confederation_peers: ${6:# AS confederation parameters.}
		# confederation_id: ${7:# Routing domain confederation AS.}
		# graceful_restart_helper: ${8:true|false}
		# bestpath_always_compare_med: ${9:true|false}
		# cluster_id: ${10:# Route Reflector Cluster-ID.}
		# shutdown: ${11:true|false}
		# timer_bgp_hold: ${12:# Set BGP hold timer.}
		# use_ssl: ${13:yes|no}
		# bestpath_aspath_multipath_relax: ${14:true|false}
		# port: ${15:0 (use common port)}
		# graceful_restart_timers_stalepath_time: ${16:true|false}
		# maxas_limit: ${17:# Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.}
		# bestpath_med_confed: ${18:true|false}
		# isolate: ${19:true|false}
		# timer_bgp_keepalive: ${20:# Set BGP keepalive timer.}
		# bestpath_cost_community_ignore: ${21:true|false}
		# fast_external_fallover: ${22:true|false}
		# state: ${23:#present|absent}
		# disable_policy_batching: ${24:true|false}
		# disable_policy_batching_ipv6_prefix_list: ${25:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
		# provider: ${26:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# bestpath_med_missing_as_worst: ${27:true|false}
		# username: ${28:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# timer_bestpath_limit: ${29:# Specify timeout for the first best path after a restart, in seconds.}
		# suppress_fib_pending: ${30:true|false}
		# local_as: ${31:# Local AS number to be used within a VRF instance.}
		# event_history_periodic: ${32:size_small|size_medium|size_large|size_disable|default}
		# timer_bestpath_limit_always: ${33:true|false}
		# disable_policy_batching_ipv4_prefix_list: ${34:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
		# vrf: ${35:# Name of the VRF. The name 'default' is a valid VRF representing the global BGP.}
		# event_history_cli: ${36:size_small|size_medium|size_large|size_disable|default}
		# log_neighbor_changes: ${37:true|false}
		# password: ${38:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# event_history_events: ${39:size_small|size_medium|size_large|size_disable|default}
		# event_history_detail: ${40:size_small|size_medium|size_large|size_disable|default}
		# ssh_keyfile: ${41:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# graceful_restart: ${42:true|false}
		# flush_routes: ${43:true|false}
		# enforce_first_as: ${44:true|false}
		# bestpath_med_non_deterministic: ${45:true|false}
		# reconnect_interval: ${46:# The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.}
		# router_id: ${47:# Router Identifier (ID) of the BGP router VRF instance.}
		# timeout: ${48:10}
		# graceful_restart_timers_restart: ${49:true|false}
		# validate_certs: ${50:yes|no}
		# bestpath_compare_routerid: ${51:true|false}
$0
endsnippet

snippet nxos_bgp_af "Manages BGP Address-family configuration." b
- name: $1
	nxos_bgp_af:
		transport: ${2:cli}
		afi: ${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${4:unicast|multicast|evpn}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${6:# Name of the VRF. The name 'default' is a valid VRF representing the global bgp.}
		asn: ${7:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		# table_map_filter: ${8:true|false}
		# dampening_max_suppress_time: ${9:# Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.}
		# additional_paths_send: ${10:true|false}
		# additional_paths_install: ${11:true|false}
		# networks: ${12:# Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']].}
		# dampening_state: ${13:true|false}
		# additional_paths_receive: ${14:true|false}
		# suppress_inactive: ${15:true|false}
		# dampening_routemap: ${16:# Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.}
		# use_ssl: ${17:yes|no}
		# port: ${18:0 (use common port)}
		# distance_local: ${19:# Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.}
		# advertise_l2vpn_evpn: ${20:true|false}
		# state: ${21:#present|absent}
		# distance_ibgp: ${22:# Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.}
		# default_information_originate: ${23:true|false}
		# next_hop_route_map: ${24:# Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.}
		# provider: ${25:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# username: ${26:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# table_map: ${27:# Apply table-map to filter routes downloaded into URIB. Valid values are a string.}
		# default_metric: ${28:# Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'}
		# client_to_client: ${29:true|false}
		# dampen_igp_metric: ${30:# Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.}
		# additional_paths_selection: ${31:# Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.}
		# maximum_paths_ibgp: ${32:# Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
		# distance_ebgp: ${33:# Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.}
		# password: ${34:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# redistribute: ${35:# A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].}
		# ssh_keyfile: ${36:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# dampening_reuse_time: ${37:# Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.}
		# maximum_paths: ${38:# Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
		# inject_map: ${39:# An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].}
		# dampening_suppress_time: ${40:# Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.}
		# timeout: ${41:10}
		# dampening_half_time: ${42:# Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.}
		# validate_certs: ${43:yes|no}
$0
endsnippet

snippet nxos_bgp_neighbor "Manages BGP neighbors configurations." b
- name: $1
	nxos_bgp_neighbor:
		transport: ${2:cli}
		asn: ${3:# BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		neighbor: ${5:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		# update_source: ${6:# Specify source interface of BGP session and updates.}
		# capability_negotiation: ${7:true|false}
		# pwd_type: ${8:3des|cisco_type_7}
		# dynamic_capability: ${9:true|false}
		# shutdown: ${10:true|false}
		# low_memory_exempt: ${11:true|false}
		# use_ssl: ${12:yes|no}
		# remove_private_as: ${13:enable|disable|all|replace-as}
		# port: ${14:0 (use common port)}
		# connected_check: ${15:true|false}
		# remote_as: ${16:# Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
		# ebgp_multihop: ${17:# Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.}
		# state: ${18:#present|absent}
		# timers_holdtime: ${19:# Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.}
		# provider: ${20:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# username: ${21:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# description: ${22:# Description of the neighbor.}
		# local_as: ${23:# Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
		# timers_keepalive: ${24:# Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.}
		# vrf: ${25:default}
		# log_neighbor_changes: ${26:enable|disable|inherit}
		# password: ${27:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# maximum_peers: ${28:# Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit.}
		# suppress_4_byte_as: ${29:true|false}
		# ssh_keyfile: ${30:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# pwd: ${31:# Specify the password for neighbor. Valid value is string.}
		# transport_passive_only: ${32:true|false}
		# timeout: ${33:10}
		# validate_certs: ${34:yes|no}
$0
endsnippet

snippet nxos_bgp_neighbor_af "Manages BGP address-family's neighbors configuration." b
- name: $1
	nxos_bgp_neighbor_af:
		transport: ${2:cli}
		afi: ${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		asn: ${4:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${5:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		safi: ${6:unicast|multicast|evpn}
		host: ${7:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		# default_originate: ${8:true|false}
		# next_hop_self: ${9:true|false}
		# suppress_inactive: ${10:true|false|default}
		# additional_paths_send: ${11:enable|disable|inherit}
		# soo: ${12:# Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.}
		# additional_paths_receive: ${13:enable|disable|inherit}
		# route_reflector_client: ${14:true|false}
		# prefix_list_out: ${15:# Valid values are a string defining a prefix-list name, or 'default'.}
		# use_ssl: ${16:yes|no}
		# as_override: ${17:true|false}
		# port: ${18:0 (use common port)}
		# filter_list_out: ${19:# Valid values are a string defining a filter-list name, or 'default'.}
		# allowas_in: ${20:# Activate allowas-in property}
		# max_prefix_warning: ${21:true|false}
		# state: ${22:#present|absent}
		# provider: ${23:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# advertise_map_non_exist: ${24:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.}
		# username: ${25:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# default_originate_route_map: ${26:# Optional route-map for the default_originate property. Can be used independently or in conjunction with C(default_originate). Valid values are a string defining a route-map name, or 'default'.}
		# filter_list_in: ${27:# Valid values are a string defining a filter-list name, or 'default'.}
		# weight: ${28:# Weight value. Valid values are an integer value or 'default'.}
		# soft_reconfiguration_in: ${29:enable|always|inherit}
		# vrf: ${30:default}
		# unsuppress_map: ${31:# unsuppress-map. Valid values are a string defining a route-map name or 'default'.}
		# max_prefix_limit: ${32:# maximum-prefix limit value. Valid values are an integer value or 'default'.}
		# password: ${33:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# max_prefix_threshold: ${34:# Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.}
		# route_map_in: ${35:# Valid values are a string defining a route-map name, or 'default'.}
		# ssh_keyfile: ${36:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# max_prefix_interval: ${37:# Optional restart interval. Valid values are an integer. Requires max_prefix_limit. May not be combined with max_prefix_warning.}
		# route_map_out: ${38:# Valid values are a string defining a route-map name, or 'default'.}
		# send_community: ${39:none|both|extended|standard|default}
		# prefix_list_in: ${40:# Valid values are a string defining a prefix-list name, or 'default'.}
		# timeout: ${41:10}
		# next_hop_third_party: ${42:true|false}
		# advertise_map_exist: ${43:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.}
		# validate_certs: ${44:yes|no}
		# allowas_in_max: ${45:# Optional max-occurrences value for allowas_in. Valid values are an integer value or 'default'. Can be used independently or in conjunction with allowas_in.}
$0
endsnippet

snippet nxos_command "Run arbitrary command on Cisco NXOS devices" b
- name: $1
	nxos_command:
		commands: ${2:# The commands to send to the remote NXOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# retries: ${6:10}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# interval: ${8:1}
		# wait_for: ${9:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		# match: ${10:all}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_config "Manage Cisco NXOS configuration sections" b
- name: $1
	nxos_config:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# force: ${5:no}
		# defaults: ${6:no}
		# after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# diff_against: ${8:#startup|intended|running}
		# replace: ${9:line|block}
		# running_config: ${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		# save_when: ${11:always|#never|modified}
		# use_ssl: ${12:yes|no}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# port: ${14:0 (use common port)}
		# diff_ignore_lines: ${15:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
		# src: ${16:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
		# ssh_keyfile: ${17:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# backup: ${18:no}
		# lines: ${19:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# intended_config: ${20:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
		# parents: ${21:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# timeout: ${22:10}
		# provider: ${23:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# before: ${24:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
		# save: ${25:no}
		# validate_certs: ${26:yes|no}
		# match: ${27:#line|strict|exact|none}
$0
endsnippet

snippet nxos_evpn_global "Handles the EVPN control plane for VXLAN." b
- name: $1
	nxos_evpn_global:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		nv_overlay_evpn: ${3:true|false}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_evpn_vni "Manages Cisco EVPN VXLAN Network Identifier (VNI)." b
- name: $1
	nxos_evpn_vni:
		vni: ${2:# The EVPN VXLAN Network Identifier.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		route_distinguisher: ${4:# The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# route_target_export: ${8:# Sets the route-target 'import' extended communities.}
		# route_target_both: ${9:# Enables/Disables route-target settings for both import and export target communities using a single property.}
		# state: ${10:#present|absent}
		# route_target_import: ${11:# Sets the route-target 'import' extended communities.}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_facts "Gets facts about NX-OS switches" b
- name: $1
	nxos_facts:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# gather_subset: ${6:!config}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_feature "Manage features in NX-OS switches." b
- name: $1
	nxos_feature:
		feature: ${2:# Name of feature.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#enabled|disabled}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_file_copy "Copy a file to a remote NXOS device over SCP." b
- name: $1
	nxos_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# remote_file: ${7:# Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used.}
		# file_system: ${8:# The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.}
		# timeout: ${9:10}
		# provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${11:yes|no}
		# password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${13:yes|no}
		# port: ${14:0 (use common port)}
$0
endsnippet

snippet nxos_gir "Trigger a graceful removal or insertion (GIR) of the switch." b
- name: $1
	nxos_gir:
		state: ${2:#present|absent}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# system_mode_maintenance_dont_generate_profile: ${7:true|false}
		# system_mode_maintenance_shutdown: ${8:true|false}
		# system_mode_maintenance_timeout: ${9:# Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.}
		# system_mode_maintenance_on_reload_reset_reason: ${10:hw_error|svc_failure|kern_failure|wdog_timeout|fatal_error|lc_failure|match_any|manual_reload}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# system_mode_maintenance: ${13:true|false}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_gir_profile_management "Create a maintenance-mode or normal-mode profile for GIR." b
- name: $1
	nxos_gir_profile_management:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		mode: ${3:maintenance|normal}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# commands: ${6:# List of commands to be included into the profile.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# config: ${8:# Specify the configuration string to be used for module operations.}
		# state: ${9:#present|absent}
		# include_defaults: ${10:true|false}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_hsrp "Manages HSRP configuration on NX-OS switches." b
- name: $1
	nxos_hsrp:
		group: ${2:# HSRP group number.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of interface that is being managed for HSRP.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# auth_type: ${7:text|md5}
		# ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${9:#present|absent}
		# auth_string: ${10:# Authentication string.}
		# vip: ${11:# HSRP virtual IP address.}
		# priority: ${12:# HSRP priority.}
		# version: ${13:1|2}
		# timeout: ${14:10}
		# provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${16:yes|no}
		# password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${18:yes|no}
		# port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_igmp "Manages IGMP global configuration." b
- name: $1
	nxos_igmp:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# enforce_rtr_alert: ${6:true|false}
		# flush_routes: ${7:true|false}
		# state: ${8:#present|default}
		# restart: ${9:true|false}
		# timeout: ${10:10}
		# provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${12:yes|no}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${14:yes|no}
		# port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_igmp_interface "Manages IGMP interface configuration." b
- name: $1
	nxos_igmp_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# The full interface name for IGMP configuration. e.g. I(Ethernet1/2).}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# startup_query_interval: ${6:# Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31.}
		# group_timeout: ${7:# Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds.}
		# oif_routemap: ${8:# Configure a routemap for static outgoing interface (OIF).}
		# oif_prefix: ${9:# Configure a prefix for static outgoing interface (OIF).}
		# use_ssl: ${10:yes|no}
		# querier_timeout: ${11:# Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds.}
		# password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# port: ${13:0 (use common port)}
		# report_llg: ${14:true|false}
		# ssh_keyfile: ${15:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# last_member_qrt: ${16:# Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second.}
		# robustness: ${17:# Sets the robustness variable. Values can range from 1 to 7. The default is 2.}
		# startup_query_count: ${18:# Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2.}
		# immediate_leave: ${19:true|false}
		# last_member_query_count: ${20:# Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2.}
		# state: ${21:#present|default}
		# version: ${22:2|3}
		# restart: ${23:true|false}
		# timeout: ${24:10}
		# provider: ${25:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# oif_source: ${26:# Configure a source for static outgoing interface (OIF).}
		# query_interval: ${27:# Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. he default is 125 seconds.}
		# validate_certs: ${28:yes|no}
		# query_mrt: ${29:# Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds.}
$0
endsnippet

snippet nxos_igmp_snooping "Manages IGMP snooping global configuration." b
- name: $1
	nxos_igmp_snooping:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# link_local_grp_supp: ${5:true|false}
		# report_supp: ${6:# Global IGMPv1/IGMPv2 Report Suppression.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# snooping: ${8:true|false}
		# group_timeout: ${9:# Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).}
		# v3_report_supp: ${10:true|false}
		# state: ${11:#present|default}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_install_os "Set boot options like boot image and kickstart image." b
- name: $1
	nxos_install_os:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		system_image_file: ${3:# Name of the system (or combined) image file on flash.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# kickstart_image_file: ${7:# Name of the kickstart image file on flash.}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_interface "Manages physical attributes of interfaces." b
- name: $1
	nxos_interface:
		state: ${2:#present|absent|default}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of interface, i.e. Ethernet1/1, port-channel10.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# description: ${8:# Interface description.}
		# ip_forward: ${9:enable|disable}
		# interface_type: ${10:loopback|portchannel|svi|nve}
		# fabric_forwarding_anycast_gateway: ${11:true|false}
		# admin_state: ${12:#up|down}
		# mode: ${13:layer2|layer3}
		# timeout: ${14:10}
		# provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${16:yes|no}
		# password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${18:yes|no}
		# port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_interface_ospf "Manages configuration of an OSPF interface instance." b
- name: $1
	nxos_interface_ospf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Name of this cisco_interface resource. Valid value is a string.}
		transport: ${4:cli}
		area: ${5:# Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.}
		ospf: ${6:# Name of the ospf instance.}
		# username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# passive_interface: ${8:true|false}
		# message_digest_password: ${9:# Specifies the message_digest password. Valid value is a string.}
		# message_digest_encryption_type: ${10:cisco_type_7|3des}
		# dead_interval: ${11:# Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.}
		# hello_interval: ${12:# Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# port: ${15:0 (use common port)}
		# ssh_keyfile: ${16:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# message_digest_algorithm_type: ${17:md5}
		# message_digest_key_id: ${18:# Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.}
		# state: ${19:#present|absent}
		# cost: ${20:# The cost associated with this cisco_interface_ospf instance.}
		# timeout: ${21:10}
		# provider: ${22:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# validate_certs: ${23:yes|no}
		# message_digest: ${24:true|false}
$0
endsnippet

snippet nxos_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces." b
- name: $1
	nxos_ip_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Full name of interface, i.e. Ethernet1/1, vlan10.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# addr: ${7:# IPv4 or IPv6 Address.}
		# mask: ${8:# Subnet mask for IPv4 or IPv6 Address in decimal format.}
		# state: ${9:#present|absent}
		# allow_secondary: ${10:no}
		# tag: ${11:0}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_logging "Manage logging on network devices" b
- name: $1
	nxos_logging:
		# facility_level: ${2:# Set logging serverity levels for facility based log messages.}
		# name: ${3:# If value of C(dest) is I(logfile) it indicates file-name.}
		# facility: ${4:# Facility name for logging.}
		# dest: ${5:console|logfile|module|monitor}
		# dest_level: ${6:# Set logging severity levels. C(alias level).}
		# purge: ${7:no}
		# state: ${8:#present|absent}
		# aggregate: ${9:# L}
$0
endsnippet

snippet nxos_ntp "Manages core NTP configuration." b
- name: $1
	nxos_ntp:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# source_addr: ${6:# Local source address from which NTP messages are sent.}
		# key_id: ${7:# Authentication key identifier to use with given NTP server or peer.}
		# prefer: ${8:enabled|disabled}
		# state: ${9:#present|absent}
		# source_int: ${10:# Local source interface from which NTP messages are sent. Must be fully qualified interface name.}
		# server: ${11:# Network address of NTP server.}
		# vrf_name: ${12:# Makes the device communicate with the given NTP server or peer over a specific VRF.}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# peer: ${15:# Network address of NTP peer.}
		# use_ssl: ${16:yes|no}
		# password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${18:yes|no}
		# port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_ntp_auth "Manages NTP authentication." b
- name: $1
	nxos_ntp_auth:
		key_id: ${2:# Authentication key identifier (numeric).}
		md5string: ${3:# MD5 String.}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# auth_type: ${7:#text|encrypt}
		# ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${9:#present|absent}
		# authentication: ${10:on|off}
		# trusted_key: ${11:true|false}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_ntp_options "Manages NTP options." b
- name: $1
	nxos_ntp_options:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# logging: ${6:true|false}
		# stratum: ${7:# If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.}
		# state: ${8:#present|absent}
		# master: ${9:true|false}
		# timeout: ${10:10}
		# provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${12:yes|no}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${14:yes|no}
		# port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_nxapi "Manage NXAPI configuration on an NXOS device." b
- name: $1
	nxos_nxapi:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# http: ${6:yes|no}
		# https_port: ${7:443}
		# state: ${8:#present|absent}
		# sandbox: ${9:yes|no}
		# http_port: ${10:80}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# https: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_ospf "Manages configuration of an ospf instance." b
- name: $1
	nxos_ospf:
		ospf: ${2:# Name of the ospf instance.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#present|absent}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_ospf_vrf "Manages a VRF for an OSPF router." b
- name: $1
	nxos_ospf_vrf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		ospf: ${4:# Name of the OSPF instance.}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# router_id: ${6:# Router Identifier (ID) of the OSPF router VRF instance.}
		# auto_cost: ${7:# Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.}
		# default_metric: ${8:# Specify the default Metric value. Valid values are an integer or the keyword 'default'.}
		# passive_interface: ${9:true|false}
		# timer_throttle_spf_max: ${10:# Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# vrf: ${11:default}
		# timer_throttle_spf_start: ${12:# Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# port: ${15:0 (use common port)}
		# timer_throttle_lsa_max: ${16:# Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# ssh_keyfile: ${17:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timer_throttle_lsa_hold: ${18:# Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# log_adjacency: ${19:log|detail|default}
		# timer_throttle_lsa_start: ${20:# Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# timer_throttle_spf_hold: ${21:# Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		# timeout: ${22:10}
		# provider: ${23:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# validate_certs: ${24:yes|no}
$0
endsnippet

snippet nxos_overlay_global "Configures anycast gateway MAC of the switch." b
- name: $1
	nxos_overlay_global:
		anycast_gateway_mac: ${2:# Anycast gateway mac of the switch.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_pim "Manages configuration of a PIM instance." b
- name: $1
	nxos_pim:
		ssm_range: ${2:# Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword 'none'.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_pim_interface "Manages PIM interface configuration." b
- name: $1
	nxos_pim_interface:
		jp_policy_out: ${2:# Policy for join-prune messages (outbound).}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of the interface such as Ethernet1/33.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# sparse: ${7:true|false}
		# neighbor_policy: ${8:# Configures a neighbor policy for filtering adjacencies.}
		# hello_interval: ${9:true|false}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# border: ${12:true|false}
		# port: ${13:0 (use common port)}
		# ssh_keyfile: ${14:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# jp_type_in: ${15:prefix|routemap}
		# state: ${16:#present|default}
		# neighbor_type: ${17:prefix|routemap}
		# hello_auth_key: ${18:# Authentication for hellos on this interface.}
		# timeout: ${19:10}
		# provider: ${20:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# jp_policy_in: ${21:# Policy for join-prune messages (inbound).}
		# validate_certs: ${22:yes|no}
		# jp_type_out: ${23:prefix|routemap}
$0
endsnippet

snippet nxos_pim_rp_address "Manages configuration of an PIM static RP address instance." b
- name: $1
	nxos_pim_rp_address:
		rp_address: ${2:# Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# bidir: ${6:true|false}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# route_map: ${8:# Route map policy for static RP. Valid values are route-map policy names.}
		# group_list: ${9:# Group range for static RP. Valid values are multicast addresses.}
		# prefix_list: ${10:# Prefix list policy for static RP. Valid values are prefix-list policy names.}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_ping "Tests reachability using ping from Nexus switch." b
- name: $1
	nxos_ping:
		dest: ${2:# IP address or hostname (resolvable by switch) of remote node.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# count: ${6:2}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${8:absent|#present}
		# source: ${9:# Source IP Address.}
		# vrf: ${10:# Outgoing VRF.}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_portchannel "Manages port-channel interfaces." b
- name: $1
	nxos_portchannel:
		group: ${2:# Channel-group number for the port-channel.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# force: ${7:true|false}
		# members: ${8:# List of interfaces that will be managed in a given portchannel.}
		# min_links: ${9:# Min links required to keep portchannel up.}
		# state: ${10:#present|absent}
		# mode: ${11:active|passive|on}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_reboot "Reboot a network device." b
- name: $1
	nxos_reboot:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# confirm: ${6:no}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_rollback "Set a checkpoint or rollback to a checkpoint." b
- name: $1
	nxos_rollback:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# checkpoint_file: ${5:# Name of checkpoint file to create. Mutually exclusive with rollback_to.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# rollback_to: ${7:# Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_smu "Perform SMUs on Cisco NX-OS devices." b
- name: $1
	nxos_smu:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		pkg: ${3:# Name of the remote package.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# file_system: ${7:# The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snapshot "Manage snapshots of the running states of selected features." b
- name: $1
	nxos_snapshot:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		action: ${4:create|add|compare|delete}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# description: ${6:# Snapshot description to be used when C(action=create).}
		# snapshot1: ${7:# First snapshot to be used when C(action=compare).}
		# snapshot2: ${8:# Second snapshot to be used when C(action=compare).}
		# snapshot_name: ${9:# Snapshot name, to be used when C(action=create) or C(action=delete).}
		# path: ${10:./}
		# use_ssl: ${11:yes|no}
		# password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# port: ${13:0 (use common port)}
		# ssh_keyfile: ${14:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# section: ${15:# Used to name the show command output, to be used when C(action=add).}
		# comparison_results_file: ${16:# Name of the file where snapshots comparison will be store.}
		# show_command: ${17:# Specify a new show command, to be used when C(action=add).}
		# element_key1: ${18:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
		# element_key2: ${19:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
		# timeout: ${20:10}
		# provider: ${21:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# row_id: ${22:# Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).}
		# validate_certs: ${23:yes|no}
		# save_snapshot_locally: ${24:true|false}
		# compare_option: ${25:summary|ipv4routes|ipv6routes}
$0
endsnippet

snippet nxos_snmp_community "Manages SNMP community configs." b
- name: $1
	nxos_snmp_community:
		state: ${2:#present|absent}
		community: ${3:# Case-sensitive community string.}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# group: ${8:# Group to which the community belongs.}
		# acl: ${9:1}
		# access: ${10:ro|rw}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_contact "Manages SNMP contact info." b
- name: $1
	nxos_snmp_contact:
		state: ${2:#present|absent}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		contact: ${4:# Contact information.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_host "Manages SNMP host configuration." b
- name: $1
	nxos_snmp_host:
		snmp_host: ${2:# IP address of hostname of target host.}
		state: ${3:#present|absent}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# vrf_filter: ${7:# Name of VRF to filter.}
		# udp: ${8:# UDP port number (0-65535).}
		# ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# type: ${10:trap|inform}
		# src_intf: ${11:# Source interface.}
		# community: ${12:# Community string or v3 username.}
		# version: ${13:#v2c|v3}
		# vrf: ${14:# VRF to use to source traffic to source.}
		# timeout: ${15:10}
		# provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${17:yes|no}
		# password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${19:yes|no}
		# port: ${20:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_location "Manages SNMP location information." b
- name: $1
	nxos_snmp_location:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		location: ${3:# Location information.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#present|absent}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_traps "Manages SNMP traps." b
- name: $1
	nxos_snmp_traps:
		group: ${2:aaa|bridge|callhome|cfs|config|entity|feature-control|hsrp|license|link|lldp|ospf|pim|rf|rmon|snmp|storm-control|stpx|sysmgr|system|upgrade|vtp|all}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#enabled|disabled}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_user "Manages SNMP users for monitoring." b
- name: $1
	nxos_snmp_user:
		group: ${2:# Group to which the user will belong to.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		user: ${4:# Name of the user.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# encrypt: ${8:true|false}
		# privacy: ${9:# Privacy password for the user.}
		# state: ${10:#present|absent}
		# auth: ${11:md5|sha}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# pwd: ${15:# Auth password when using md5 or sha.}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_static_route "Manages static route configuration" b
- name: $1
	nxos_static_route:
		next_hop: ${2:# Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.}
		state: ${3:present|absent}
		prefix: ${4:# Destination prefix of static route.}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${6:cli}
		# username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# pref: ${9:# Preference or administrative difference of route (range 1-255).}
		# route_name: ${10:# Name of the route. Used with the name parameter on the CLI.}
		# tag: ${11:# Route tag value (numeric).}
		# vrf: ${12:default}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_switchport "Manages Layer 2 switchport interfaces." b
- name: $1
	nxos_switchport:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Full name of the interface, i.e. Ethernet1/1.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# native_vlan: ${6:# If C(mode=trunk), used as the trunk native VLAN ID.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# access_vlan: ${8:# If C(mode=access), used as the access VLAN ID.}
		# state: ${9:#present|absent|unconfigured}
		# trunk_allowed_vlans: ${10:# if C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".}
		# trunk_vlans: ${11:# If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.}
		# mode: ${12:access|trunk}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_system "Manage the system attributes on Cisco NXOS devices" b
- name: $1
	nxos_system:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# domain_search: ${6:# Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.}
		# hostname: ${7:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# system_mtu: ${8:# Specifies the mtu, must be an integer.}
		# state: ${9:#present|absent}
		# domain_name: ${10:# Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.}
		# name_servers: ${11:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# domain_lookup: ${14:# Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_udld "Manages UDLD global configuration params." b
- name: $1
	nxos_udld:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# reset: ${5:true|false}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#present|absent}
		# msg_time: ${8:# Message time in seconds for UDLD packets.}
		# timeout: ${9:10}
		# provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${11:yes|no}
		# aggressive: ${12:enabled|disabled}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${14:yes|no}
		# port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_udld_interface "Manages UDLD interface configuration params." b
- name: $1
	nxos_udld_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		mode: ${3:enabled|disabled|aggressive}
		interface: ${4:# FULL name of the interface, i.e. Ethernet1/1-}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${8:#present|absent}
		# timeout: ${9:10}
		# provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${11:yes|no}
		# password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${13:yes|no}
		# port: ${14:0 (use common port)}
$0
endsnippet

snippet nxos_user "Manage the collection of local users on Nexus devices" b
- name: $1
	nxos_user:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# update_password: ${5:on_create|#always}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# name: ${7:# The username to be configured on the remote Cisco Nexus device.  This argument accepts a stringv value and is mutually exclusive with the C(aggregate) argument.}
		# state: ${8:#present|absent}
		# purge: ${9:no}
		# configured_password: ${10:# The password to be configured on the network device. The password needs to be provided in cleartext and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# role: ${11:# The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# aggregate: ${14:# The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument. alias C(users).}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
		# sshkey: ${19:# The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.}
$0
endsnippet

snippet nxos_vlan "Manages VLAN resources and attributes." b
- name: $1
	nxos_vlan:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# vlan_range: ${5:# Range of VLANs such as 2-10 or 2,5,10-15, etc.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# vlan_id: ${7:# Single VLAN ID.}
		# name: ${8:# Name of VLAN.}
		# mapped_vni: ${9:# The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'.}
		# state: ${10:#present|absent}
		# vlan_state: ${11:#active|suspend}
		# admin_state: ${12:#up|down}
		# mode: ${13:ce|fabricpath}
		# timeout: ${14:10}
		# provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${16:yes|no}
		# password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${18:yes|no}
		# port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_vpc "Manages global VPC configuration" b
- name: $1
	nxos_vpc:
		domain: ${2:# VPC domain}
		state: ${3:present|absent}
		auto_recovery: ${4:true|false}
		peer_gw: ${5:true|false}
		host: ${6:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${7:cli}
		# username: ${8:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# system_priority: ${10:# System priority device.  Remember they must match between peers.}
		# role_priority: ${11:# Role priority for device. Remember lower is better.}
		# pkl_vrf: ${12:management}
		# delay_restore: ${13:# manages delay restore command and config value in seconds}
		# pkl_src: ${14:# Source IP address used for peer keepalive link}
		# timeout: ${15:10}
		# provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${17:yes|no}
		# password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${19:yes|no}
		# port: ${20:0 (use common port)}
		# pkl_dest: ${21:# Destination (remote) IP address used for peer keepalive link}
$0
endsnippet

snippet nxos_vpc_interface "Manages interface VPC configuration" b
- name: $1
	nxos_vpc_interface:
		state: ${2:present|absent}
		portchannel: ${3:# Group number of the portchannel that will be configured.}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# vpc: ${8:# VPC group/id that will be configured on associated portchannel.}
		# peer_link: ${9:# Set to true/false for peer link config on associated portchannel.}
		# timeout: ${10:10}
		# provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${12:yes|no}
		# password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${14:yes|no}
		# port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_vrf "Manages global VRF configuration." b
- name: $1
	nxos_vrf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${3:# Name of VRF to be managed.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# description: ${7:# Description of the VRF.}
		# state: ${8:#present|absent}
		# vni: ${9:# Specify virtual network identifier. Valid values are Integer or keyword 'default'.}
		# route_distinguisher: ${10:# VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.}
		# admin_state: ${11:#up|down}
		# timeout: ${12:10}
		# provider: ${13:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${14:yes|no}
		# password: ${15:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${16:yes|no}
		# port: ${17:0 (use common port)}
$0
endsnippet

snippet nxos_vrf_af "Manages VRF AF." b
- name: $1
	nxos_vrf_af:
		afi: ${2:ipv4|ipv6}
		safi: ${3:unicast|multicast}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${5:# Name of the VRF.}
		transport: ${6:cli}
		# username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${9:#present|absent}
		# route_target_both_auto_evpn: ${10:true|false}
		# timeout: ${11:10}
		# provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${13:yes|no}
		# password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${15:yes|no}
		# port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_vrf_interface "Manages interface specific VRF configuration." b
- name: $1
	nxos_vrf_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${3:# Name of VRF to be managed.}
		interface: ${4:# Full name of interface to be managed, i.e. Ethernet1/1.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${8:#present|absent}
		# timeout: ${9:10}
		# provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${11:yes|no}
		# password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${13:yes|no}
		# port: ${14:0 (use common port)}
$0
endsnippet

snippet nxos_vrrp "Manages VRRP configuration on NX-OS switches." b
- name: $1
	nxos_vrrp:
		group: ${2:# VRRP group number.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of interface that is being managed for VRRP.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# vip: ${8:# VRRP virtual IP address.}
		# state: ${9:#present|absent}
		# authentication: ${10:# Clear text authentication string.}
		# priority: ${11:# VRRP priority.}
		# admin_state: ${12:shutdown|#no shutdown}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_vtp_domain "Manages VTP domain configuration." b
- name: $1
	nxos_vtp_domain:
		domain: ${2:# VTP domain name.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_vtp_password "Manages VTP password configuration." b
- name: $1
	nxos_vtp_password:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		# username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# vtp_password: ${5:# VTP password}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# state: ${7:#present|absent}
		# timeout: ${8:10}
		# provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${10:yes|no}
		# password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${12:yes|no}
		# port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_vtp_version "Manages VTP version configuration." b
- name: $1
	nxos_vtp_version:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		version: ${3:1|2}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# timeout: ${7:10}
		# provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${9:yes|no}
		# password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${11:yes|no}
		# port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_vxlan_vtep "Manages VXLAN Network Virtualization Endpoint (NVE)." b
- name: $1
	nxos_vxlan_vtep:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Interface name for the VXLAN Network Virtualization Endpoint.}
		transport: ${4:cli}
		# username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# shutdown: ${6:true|false}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# description: ${8:# Description of the NVE interface.}
		# source_interface_hold_down_time: ${9:# Suppresses advertisement of the NVE loopback address until the overlay has converged.}
		# source_interface: ${10:# Specify the loopback interface whose IP address should be used for the NVE interface.}
		# state: ${11:#present|absent}
		# host_reachability: ${12:true|false}
		# timeout: ${13:10}
		# provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${15:yes|no}
		# password: ${16:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${17:yes|no}
		# port: ${18:0 (use common port)}
$0
endsnippet

snippet nxos_vxlan_vtep_vni "Creates a Virtual Network Identifier member (VNI)" b
- name: $1
	nxos_vxlan_vtep_vni:
		vni: ${2:# ID of the Virtual Network Identifier.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Interface name for the VXLAN Network Virtualization Endpoint.}
		transport: ${5:cli}
		# username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		# ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		# peer_list: ${8:# Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.}
		# ingress_replication: ${9:bgp|static}
		# suppress_arp: ${10:true|false}
		# state: ${11:#present|absent}
		# multicast_group: ${12:# The multicast group (range) of the VNI. Valid values are string and keyword 'default'.}
		# assoc_vrf: ${13:true|false}
		# timeout: ${14:10}
		# provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		# use_ssl: ${16:yes|no}
		# password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		# validate_certs: ${18:yes|no}
		# port: ${19:0 (use common port)}
$0
endsnippet

snippet ordnance_config "Manage Ordnance configuration sections" b
- name: $1
	ordnance_config:
		# multiline_delimiter: ${2:@}
		# src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# commands: ${4:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# backup: ${5:yes|no}
		# after: ${6:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# replace: ${7:#line|block}
		# parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# defaults: ${9:yes|no}
		# save: ${10:yes|no}
		# config: ${11:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		# match: ${12:#line|strict|exact|none}
		# before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet ordnance_facts "Collect facts from Ordnance Virtual Routers over SSH" b
- name: $1
	ordnance_facts:
		# gather_subset: ${2:!config}
$0
endsnippet

snippet openvswitch_bridge "Manage Open vSwitch bridges" b
- name: $1
	openvswitch_bridge:
		bridge: ${2:# Name of bridge or fake bridge to manage}
		# fail_mode: ${3:secure|standalone}
		# parent: ${4:# Bridge parent of the fake bridge to manage}
		# vlan: ${5:# The VLAN id of the fake bridge to manage (must be between 0 and 4095). This parameter is required if I(parent) parameter is set.}
		# state: ${6:#present|absent}
		# set: ${7:# Run set command after bridge configuration. This parameter is non-idempotent, play will always return I(changed) state if present}
		# timeout: ${8:5}
		# external_ids: ${9:# A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.}
$0
endsnippet

snippet openvswitch_db "Configure open vswitch database." b
- name: $1
	openvswitch_db:
		record: ${2:# Identifies the recoard in the table.}
		key: ${3:# Identifies the key in the record column}
		column: ${4:# Identifies the column in the record.}
		table: ${5:# Identifies the table in the database.}
		value: ${6:# Expected value for the table, record, column and key.}
		# state: ${7:#present|absent}
		# timeout: ${8:5}
$0
endsnippet

snippet openvswitch_port "Manage Open vSwitch ports" b
- name: $1
	openvswitch_port:
		bridge: ${2:# Name of bridge to manage}
		port: ${3:# Name of port to manage on the bridge}
		# state: ${4:#present|absent}
		# set: ${5:# Set a single property on a port.}
		# timeout: ${6:5}
		# external_ids: ${7:{}}
		# tag: ${8:# VLAN tag for this port. Must be a value between 0 and 4095.}
$0
endsnippet

snippet panos_admin "Add or modify PAN-OS user accounts password." b
- name: $1
	panos_admin:
		admin_password: ${2:# password for admin user}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: ${5:admin}
		# role: ${6:# role for admin user}
		# commit: ${7:yes}
		# admin_username: ${8:admin}
$0
endsnippet

snippet panos_admpwd "change admin password of PAN-OS device using SSH with SSH key" b
- name: $1
	panos_admpwd:
		newpassword: ${2:# password to configure for admin on the PAN-OS device}
		key_filename: ${3:# filename of the SSH Key to use for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: ${5:admin}
$0
endsnippet

snippet panos_cert_gen_ssh "generates a self-signed certificate using SSH protocol with SSH key" b
- name: $1
	panos_cert_gen_ssh:
		password: ${2:# Password credentials to use for auth. Either I(key_filename) or I(password) is required.}
		cert_cn: ${3:# Certificate CN (common name) embedded in the certificate signature.}
		cert_friendly_name: ${4:# Human friendly certificate name (not CN but just a friendly name).}
		key_filename: ${5:# Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.}
		ip_address: ${6:# IP address (or hostname) of PAN-OS device being configured.}
		signed_by: ${7:# Undersigning authority (CA) that MUST already be presents on the device.}
		# rsa_nbits: ${8:2048}
$0
endsnippet

snippet panos_check "check if PAN-OS device is ready for configuration" b
- name: $1
	panos_check:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: ${4:admin}
		# timeout: ${5:0}
		# interval: ${6:0}
$0
endsnippet

snippet panos_commit "commit firewall's candidate configuration" b
- name: $1
	panos_commit:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: ${4:admin}
		# timeout: ${5:# timeout for commit job}
		# interval: ${6:0.5}
		# sync: ${7:yes}
$0
endsnippet

snippet panos_dag "create a dynamic address group" b
- name: $1
	panos_dag:
		dag_name: ${2:# name of the dynamic address group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		dag_filter: ${5:# dynamic filter user by the dynamic address group}
		# username: ${6:admin}
		# commit: ${7:yes}
$0
endsnippet

snippet panos_import "import file on PAN-OS devices" b
- name: $1
	panos_import:
		password: ${2:# Password for device authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		# username: ${4:admin}
		# category: ${5:software}
		# file: ${6:# Location of the file to import into device.}
		# url: ${7:# URL of the file that will be imported to device.}
$0
endsnippet

snippet panos_interface "configure data-port network interface for DHCP" b
- name: $1
	panos_interface:
		zone_name: ${2:# N}
		password: ${3:# Password credentials to use for auth.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		if_name: ${5:# Name of the interface to configure.}
		# username: ${6:admin}
		# create_default_route: ${7:false}
		# commit: ${8:yes}
$0
endsnippet

snippet panos_lic "apply authcode to a device/instance" b
- name: $1
	panos_lic:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device}
		password: ${3:# password for authentication}
		auth_code: ${4:# authcode to be applied}
		# username: ${5:admin}
		# force: ${6:false}
$0
endsnippet

snippet panos_loadcfg "load configuration on PAN-OS device" b
- name: $1
	panos_loadcfg:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: ${4:admin}
		# commit: ${5:yes}
		# file: ${6:# configuration file to load}
$0
endsnippet

snippet panos_mgtconfig "configure management settings of device" b
- name: $1
	panos_mgtconfig:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: ${4:admin}
		# panorama_primary: ${5:# address of primary Panorama server}
		# dns_server_secondary: ${6:# address of secondary DNS server}
		# dns_server_primary: ${7:# address of primary DNS server}
		# panorama_secondary: ${8:# address of secondary Panorama server}
		# commit: ${9:yes}
$0
endsnippet

snippet panos_nat_rule "create a policy NAT rule" b
- name: $1
	panos_nat_rule:
		rule_name: ${2:# name of the SNAT rule}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		source_zone: ${5:# list of source zones}
		destination_zone: ${6:# destination zone}
		# username: ${7:admin}
		# destination_ip: ${8:[u'any']}
		# dnat_port: ${9:# dnat translated port}
		# snat_bidirectional: ${10:false}
		# snat_interface_address: ${11:# snat interface address}
		# snat_address_type: ${12:translated-address}
		# operation: ${13:# The action to be taken.  Supported values are I(add)/I(update)/I(find)/I(delete).}
		# dnat_address: ${14:# dnat translated address}
		# service: ${15:any}
		# snat_type: ${16:# type of source translation}
		# snat_static_address: ${17:# Source NAT translated address. Used with Static-IP translation.}
		# source_ip: ${18:[u'any']}
		# snat_dynamic_address: ${19:# Source NAT translated address. Used with Dynamic-IP and Dynamic-IP-and-Port.}
		# commit: ${20:yes}
		# api_key: ${21:# API key that can be used instead of I(username)/I(password) credentials.}
		# snat_interface: ${22:# snat interface}
$0
endsnippet

snippet panos_object "create/read/update/delete object in PAN-OS or Panorama" b
- name: $1
	panos_object:
		password: ${2:# Password credentials to use for authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device or Panorama management console being configured.}
		operation: ${4:# The operation to be performed.  Supported values are I(add)/I(delete)/I(find).}
		# username: ${5:admin}
		# static_value: ${6:# A group of address objects to be used in an addressgroup definition.}
		# description: ${7:# The description of the object.}
		# color: ${8:# -}
		# address: ${9:# The IP address of the host or network in CIDR notation.}
		# services: ${10:# The group of service objects used in a servicegroup definition.}
		# devicegroup: ${11:# -}
		# destination_port: ${12:# The destination port to be used in a service object definition.}
		# servicegroup: ${13:# A group of service objects.}
		# api_key: ${14:# API key that can be used instead of I(username)/I(password) credentials.}
		# protocol: ${15:# The IP protocol to be used in a service object definition.  Valid values are I(tcp) or I(udp).}
		# addressobject: ${16:# The name of the address object.}
		# tag_name: ${17:# The name of an object or rule tag.}
		# serviceobject: ${18:# The name of the service object.}
		# source_port: ${19:# The source port to be used in a service object definition.}
		# address_type: ${20:# The type of address object definition.  Valid types are I(ip-netmask) and I(ip-range).}
		# dynamic_value: ${21:# The filter match criteria to be used in a dynamic addressgroup definition.}
		# addressgroup: ${22:# A static group of address objects or dynamic address group.}
$0
endsnippet

snippet panos_pg "create a security profiles group" b
- name: $1
	panos_pg:
		pg_name: ${2:# name of the security profile group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: ${5:admin}
		# wildfire: ${6:# name of the wildfire analysis profile}
		# data_filtering: ${7:# name of the data filtering profile}
		# file_blocking: ${8:# name of the file blocking profile}
		# vulnerability: ${9:# name of the vulnerability profile}
		# spyware: ${10:# name of the spyware profile}
		# url_filtering: ${11:# name of the url filtering profile}
		# virus: ${12:# name of the anti-virus profile}
		# commit: ${13:yes}
$0
endsnippet

snippet panos_restart "restart a device" b
- name: $1
	panos_restart:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: ${4:admin}
$0
endsnippet

snippet panos_sag "Create a static address group." b
- name: $1
	panos_sag:
		static_match_filter: ${2:# Static filter user by the address group}
		sag_name: ${3:# name of the dynamic address group}
		operation: ${4:# The operation to perform Supported values are I(add)/I(list)/I(delete).}
		password: ${5:# password for authentication}
		ip_address: ${6:# IP address (or hostname) of PAN-OS device}
		# username: ${7:admin}
		# api_key: ${8:# API key that can be used instead of I(username)/I(password) credentials.}
		# devicegroup: ${9:# -}
		# description: ${10:# The purpose / objective of the static Address Group}
		# tags: ${11:# Tags to be associated with the address group}
		# commit: ${12:yes}
$0
endsnippet

snippet panos_security_rule "Create security rule policy on PAN-OS devices or Panorama management console." b
- name: $1
	panos_security_rule:
		password: ${2:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device being configured.}
		rule_name: ${4:# Name of the security rule.}
		# wildfire_analysis: ${5:# Name of the already defined wildfire_analysis profile.}
		# username: ${6:admin}
		# destination_ip: ${7:any}
		# source_zone: ${8:any}
		# devicegroup: ${9:# -}
		# data_filtering: ${10:# Name of the already defined data_filtering profile.}
		# spyware: ${11:# Name of the already defined spyware profile.}
		# hip_profiles: ${12:any}
		# file_blocking: ${13:# Name of the already defined file_blocking profile.}
		# antivirus: ${14:# Name of the already defined antivirus profile.}
		# log_start: ${15:no}
		# operation: ${16:add}
		# description: ${17:# Description for the security rule.}
		# rule_type: ${18:universal}
		# log_end: ${19:yes}
		# service: ${20:application-default}
		# application: ${21:any}
		# vulnerability: ${22:# Name of the already defined vulnerability profile.}
		# source_ip: ${23:any}
		# source_user: ${24:any}
		# url_filtering: ${25:# Name of the already defined url_filtering profile.}
		# tag_name: ${26:# Administrative tags that can be added to the rule. Note, tags must be already defined.}
		# destination_zone: ${27:any}
		# group_profile: ${28:# -}
		# action: ${29:allow}
		# commit: ${30:yes}
		# api_key: ${31:# API key that can be used instead of I(username)/I(password) credentials.}
$0
endsnippet

snippet net_lldp "Manage LLDP service configuration on network devices" b
- name: $1
	net_lldp:
		# state: ${2:#present|absent}
$0
endsnippet

snippet vdirect_file "Uploads a new or updates an existing runnable file into Radware vDirect server" b
- name: $1
	vdirect_file:
		vdirect_user: ${2:# vDirect server username, may be set as VDIRECT_USER environment variable.}
		file_name: ${3:# vDirect runnable file name to be uploaded.}
		vdirect_ip: ${4:# Primary vDirect server IP address, may be set as VDIRECT_IP environment variable.}
		vdirect_password: ${5:# vDirect server password, may be set as VDIRECT_PASSWORD environment variable.}
		# vdirect_wait: ${6:yes}
		# vdirect_https_port: ${7:2189}
		# vdirect_validate_certs: ${8:yes}
		# vdirect_timeout: ${9:60}
		# vdirect_http_port: ${10:2188}
		# vdirect_secondary_ip: ${11:# Secondary vDirect server IP address, may be set as VDIRECT_SECONDARY_IP environment variable.}
		# vdirect_use_ssl: ${12:yes}
$0
endsnippet

snippet net_static_route "Manage static IP routes on network devices" b
- name: $1
	net_static_route:
		next_hop: ${2:# Next hop IP of the static route.}
		mask: ${3:# Network prefix mask of the static route.}
		prefix: ${4:# Network prefix of the static route.}
		# purge: ${5:no}
		# state: ${6:#present|absent}
		# aggregate: ${7:# L}
		# admin_distance: ${8:# Admin distance of the static route.}
$0
endsnippet

snippet sros_command "Run commands on remote devices running Nokia SR OS" b
- name: $1
	sros_command:
		commands: ${2:# List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: ${3:10}
		# interval: ${4:1}
		# provider: ${5:# A dict object containing connection details.}
		# wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		# match: ${7:any|#all}
$0
endsnippet

snippet sros_config "Manage Nokia SR OS device configuration" b
- name: $1
	sros_config:
		# src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		# force: ${3:true|false}
		# config: ${4:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		# after: ${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		# lines: ${6:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.  The I(lines) argument only supports current context lines.  See EXAMPLES}
		# replace: ${7:#line|block}
		# parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		# defaults: ${9:yes|no}
		# provider: ${10:# A dict object containing connection details.}
		# save: ${11:yes|no}
		# backup: ${12:yes|no}
		# match: ${13:#line|strict|exact|none}
		# before: ${14:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet sros_rollback "Configure Nokia SR OS rollback" b
- name: $1
	sros_rollback:
		# state: ${2:#present|absent}
		# rescue_location: ${3:# The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS}
		# remote_max_checkpoints: ${4:# The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50}
		# provider: ${5:# A dict object containing connection details.}
		# local_max_checkpoints: ${6:# The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50}
		# rollback_location: ${7:# The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS}
$0
endsnippet

snippet net_banner "Manage multiline banners on network devices" b
- name: $1
	net_banner:
		banner: ${2:login|motd}
		# text: ${3:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# state: ${4:#present|absent}
$0
endsnippet

snippet net_logging "Manage logging on network devices" b
- name: $1
	net_logging:
		# purge: ${2:no}
		# aggregate: ${3:# L}
		# state: ${4:#present|absent}
		# name: ${5:# If value of C(dest) is I(host) it indicates file-name the host name to be notified.}
		# level: ${6:# Set logging severity levels.}
		# dest: ${7:console|host}
		# facility: ${8:# Set logging facility.}
$0
endsnippet

snippet net_ping "Tests reachability using ping from a network device" b
- name: $1
	net_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# count: ${3:5}
		# state: ${4:absent|#present}
		# vrf: ${5:default}
		# source: ${6:# The source IP Address.}
$0
endsnippet

snippet net_system "Manage the system attributes on network devices" b
- name: $1
	net_system:
		# state: ${2:#present|absent}
		# lookup_source: ${3:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
		# name_servers: ${4:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
		# domain_search: ${5:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		# hostname: ${6:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# domain_name: ${7:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
$0
endsnippet

snippet net_user "Manage the aggregate of local users on network device" b
- name: $1
	net_user:
		# update_password: ${2:on_create|#always}
		# configured_password: ${3:# The password to be configured on the remote network device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# aggregate: ${4:# The set of username objects to be configured on the remote network device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.}
		# name: ${5:# The username to be configured on the remote network device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
		# purge: ${6:no}
		# privilege: ${7:# The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.}
		# state: ${8:#present|absent}
		# role: ${9:# Configures the role for the username in the device running configuration. The argument accepts a string value defining the role name. This argument does not check if the role has been configured on the device.}
		# nopassword: ${10:# Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.}
		# sshkey: ${11:# Specifies the SSH public key to configure for the given username. This argument accepts a valid SSH key value.}
$0
endsnippet

snippet vyos_banner "Manage multiline banners on VyOS devices" b
- name: $1
	vyos_banner:
		banner: ${2:pre-login|post-login}
		# text: ${3:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
		# state: ${4:#present|absent}
$0
endsnippet

snippet vyos_command "Run one or more commands on VyOS devices" b
- name: $1
	vyos_command:
		commands: ${2:# The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.}
		# retries: ${3:10}
		# interval: ${4:1}
		# provider: ${5:# A dict object containing connection details.}
		# wait_for: ${6:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.}
		# match: ${7:any|#all}
$0
endsnippet

snippet vyos_config "Manage VyOS configuration on remote device" b
- name: $1
	vyos_config:
		# comment: ${2:configured by vyos_config}
		# src: ${3:# The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.}
		# backup: ${4:yes|no}
		# lines: ${5:# The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.}
		# provider: ${6:# A dict object containing connection details.}
		# save: ${7:yes|no}
		# config: ${8:# The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.}
		# match: ${9:#line|none}
$0
endsnippet

snippet vyos_facts "Collect facts from remote devices running VyOS" b
- name: $1
	vyos_facts:
		# gather_subset: ${2:!config}
		# provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet vyos_interface "Manage Interface on VyOS network devices" b
- name: $1
	vyos_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: ${3:# Check the operational state of given interface C(name) for LLDP neighbor.}
		# duplex: ${4:full|half|#auto}
		# enabled: ${5:# Interface link status.}
		# mtu: ${6:# Maximum size of transmit packet.}
		# delay: ${7:10}
		# state: ${8:#present|absent|up|down}
		# aggregate: ${9:# L}
		# speed: ${10:# Interface link speed.}
		# description: ${11:# Description of Interface.}
$0
endsnippet

snippet vyos_l3_interface "Manage L3 interfaces on VyOS network devices" b
- name: $1
	vyos_l3_interface:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# ipv4: ${4:# IPv4 of the L3 interface.}
		# name: ${5:# Name of the L3 interface.}
		# ipv6: ${6:# IPv6 of the L3 interface.}
$0
endsnippet

snippet vyos_linkagg "Manage link aggregation groups on VyOS network devices" b
- name: $1
	vyos_linkagg:
		name: ${2:# Name of the link aggregation group.}
		# aggregate: ${3:# L}
		# state: ${4:#present|absent|up|down}
		# members: ${5:# List of members of the link aggregation group.}
		# mode: ${6:802.3ad|active-backup|broadcast|round-robin|transmit-load-balance|adaptive-load-balance|xor-hash|on}
$0
endsnippet

snippet vyos_lldp "Manage LLDP configuration on VyOS network devices" b
- name: $1
	vyos_lldp:
		# state: ${2:#present|absent}
$0
endsnippet

snippet vyos_lldp_interface "Manage LLDP interfaces configuration on VyOS network devices" b
- name: $1
	vyos_lldp_interface:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent|enabled|disabled}
		# name: ${4:# Name of the interface LLDP should be configured on.}
$0
endsnippet

snippet vyos_logging "Manage logging on network devices" b
- name: $1
	vyos_logging:
		# aggregate: ${2:# L}
		# state: ${3:#present|absent}
		# name: ${4:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
		# level: ${5:# Set logging severity levels.}
		# dest: ${6:console|file|global|host|user}
		# facility: ${7:# Set logging facility.}
$0
endsnippet

snippet vyos_static_route "Manage static IP routes on Cisco VyOS network devices" b
- name: $1
	vyos_static_route:
		# state: ${2:#present|absent}
		# next_hop: ${3:# Next hop IP of the static route.}
		# aggregate: ${4:# L}
		# mask: ${5:# Network prefix mask of the static route.}
		# prefix: ${6:# Network prefix of the static route. C(mask) param should be ignored if C(prefix) is provided with C(mask) value C(prefix/mask).}
		# admin_distance: ${7:# Admin distance of the static route.}
$0
endsnippet

snippet vyos_system "Run `set system` commands on VyOS devices" b
- name: $1
	vyos_system:
		# state: ${2:#present|absent}
		# name_server: ${3:# A list of name servers to use with the device. Mutually exclusive with I(domain_search)}
		# provider: ${4:# A dict object containing connection details.}
		# domain_search: ${5:# A list of domain names to search. Mutually exclusive with I(name_server)}
		# hostname: ${6:# Configure the device hostname parameter. This option takes an ASCII string value.}
		# domain_name: ${7:# The new domain name to apply to the device.}
$0
endsnippet

snippet vyos_user "Manage the collection of local users on VyOS device" b
- name: $1
	vyos_user:
		# update_password: ${2:on_create|#always}
		# configured_password: ${3:# The password to be configured on the VyOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
		# name: ${4:# The username to be configured on the VyOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
		# level: ${5:# The C(level) argument configures the level of the user when logged into the system. This argument accepts string values admin or operator.}
		# purge: ${6:no}
		# state: ${7:#present|absent}
		# full_name: ${8:# The C(full_name) argument provides the full name of the user account to be created on the remote device. This argument accepts any text string value.}
		# aggregate: ${9:# The set of username objects to be configured on the remote VyOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument. alias C(users).}
$0
endsnippet

snippet bearychat "Send BearyChat notifications" b
- name: $1
	bearychat:
		url: ${2:# BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like C(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).}
		# text: ${3:# Message to send.}
		# markdown: ${4:#yes}
		# attachments: ${5:# Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments}
		# channel: ${6:# Channel to send the message to. If absent, the message goes to the default channel selected by the I(url).}
$0
endsnippet

snippet campfire "Send a message to Campfire" b
- name: $1
	campfire:
		msg: ${2:# The message body.}
		token: ${3:# API token.}
		subscription: ${4:# The subscription name to use.}
		room: ${5:# Room number to which the message should be sent.}
		# notify: ${6:56k|bell|bezos|bueller|clowntown|cottoneyejoe|crickets|dadgummit|dangerzone|danielsan|deeper|drama|greatjob|greyjoy|guarantee|heygirl|horn|horror|inconceivable|live|loggins|makeitso|noooo|nyan|ohmy|ohyeah|pushit|rimshot|rollout|rumble|sax|secret|sexyback|story|tada|tmyk|trololo|trombone|unix|vuvuzela|what|whoomp|yeah|yodel}
$0
endsnippet

snippet catapult "Send a sms / mms using the catapult bandwidth api" b
- name: $1
	catapult:
		src: ${2:# One of your catapult telephone numbers the message should come from (must be in E.164 format, like C(+19195551212)).}
		user_id: ${3:# User Id from Api account page.}
		api_secret: ${4:# Api Secret from Api account page.}
		dest: ${5:# The phone number or numbers the message should be sent to (must be in E.164 format, like C(+19195551212)).}
		api_token: ${6:# Api Token from Api account page.}
		msg: ${7:# The contents of the text message (must be 2048 characters or less).}
		# media: ${8:# For MMS messages, a media url to the location of the media to be sent with the message.}
$0
endsnippet

snippet cisco_spark "Send a message to a Cisco Spark Room or Individual." b
- name: $1
	cisco_spark:
		personal_token: ${2:# Your personal access token required to validate the Spark API.}
		message: ${3:# The message you would like to send.}
		recipient_id: ${4:# The unique identifier associated with the supplied C(recipient_type).}
		recipient_type: ${5:roomId|toPersonEmail|toPersonId}
		# message_type: ${6:#text|markdown}
$0
endsnippet

snippet flowdock "Send a message to a flowdock" b
- name: $1
	flowdock:
		type: ${2:inbox|chat}
		token: ${3:# API token.}
		msg: ${4:# Content of the message}
		# from_name: ${5:# (inbox only) Name of the message sender}
		# from_address: ${6:# (inbox only - required) Email address of the message sender}
		# tags: ${7:# tags of the message, separated by commas}
		# external_user_name: ${8:# (chat only - required) Name of the "user" sending the message}
		# project: ${9:# (inbox only) Human readable identifier for more detailed message categorization}
		# source: ${10:# (inbox only - required) Human readable identifier of the application that uses the Flowdock API}
		# link: ${11:# (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.}
		# reply_to: ${12:# (inbox only) Email address for replies}
		# subject: ${13:# (inbox only - required) Subject line of the message}
		# validate_certs: ${14:#yes|no}
$0
endsnippet

snippet grove "Sends a notification to a grove.io channel" b
- name: $1
	grove:
		message: ${2:# Message content}
		channel_token: ${3:# Token of the channel to post to.}
		# service: ${4:ansible}
		# url: ${5:# Service URL for the web client}
		# icon_url: ${6:# Icon for the service}
		# validate_certs: ${7:#yes|no}
$0
endsnippet

snippet hall "Send notification to Hall" b
- name: $1
	hall:
		msg: ${2:# The message you wish to deliver as a notification}
		room_token: ${3:# Room token provided to you by setting up the Ansible room integation on U(https://hall.com)}
		title: ${4:# The title of the message}
		# picture: ${5:# The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)
}
$0
endsnippet

snippet hipchat "Send a message to Hipchat." b
- name: $1
	hipchat:
		room: ${2:# ID or name of the room.}
		token: ${3:# API token.}
		msg: ${4:# The message body.}
		# from: ${5:Ansible}
		# color: ${6:#yellow|red|green|purple|gray|random}
		# msg_format: ${7:#text|html}
		# api: ${8:https://api.hipchat.com/v1}
		# notify: ${9:#yes|no}
		# validate_certs: ${10:#yes|no}
$0
endsnippet

snippet irc "Send a message to an IRC channel" b
- name: $1
	irc:
		msg: ${2:# The message body.}
		channel: ${3:# Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.}
		# style: ${4:bold|underline|reverse|italic}
		# key: ${5:# Channel key}
		# passwd: ${6:# Server password}
		# color: ${7:#none|white|black|blue|green|red|brown|purple|orange|yellow|light_green|teal|light_cyan|light_blue|pink|gray|light_gray}
		# server: ${8:localhost}
		# topic: ${9:# Set the channel topic}
		# nick: ${10:ansible}
		# part: ${11:yes}
		# nick_to: ${12:# A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.}
		# timeout: ${13:30}
		# use_ssl: ${14:no}
		# port: ${15:6667}
$0
endsnippet

snippet jabber "Send a message to jabber user or chat room" b
- name: $1
	jabber:
		to: ${2:# user ID or name of the room, when using room use a slash to indicate your nick.}
		user: ${3:# User as which to connect}
		msg: ${4:# The message body.}
		password: ${5:# password for user to connect}
		# host: ${6:# host to connect, overrides user info}
		# encoding: ${7:# message encoding}
		# port: ${8:5222}
$0
endsnippet

snippet mail "Send an email" b
- name: $1
	mail:
		subject: ${2:# The subject of the email being sent.}
		# body: ${3:$subject}
		# username: ${4:# If SMTP requires username}
		# secure: ${5:always|never|#try|starttls}
		# cc: ${6:# The email-address(es) the mail is being copied to. This is a comma-separated list, which may contain address and phrase portions.}
		# host: ${7:localhost}
		# password: ${8:# If SMTP requires password}
		# port: ${9:25}
		# to: ${10:root}
		# from: ${11:root}
		# headers: ${12:# A vertical-bar-separated list of headers which should be added to the message. Each individual header is specified as C(header=value) (see example below).}
		# charset: ${13:us-ascii}
		# bcc: ${14:# The email-address(es) the mail is being 'blind' copied to. This is a comma-separated list, which may contain address and phrase portions.}
		# attach: ${15:# A space-separated list of pathnames of files to attach to the message. Attached files will have their content-type set to C(application/octet-stream).}
		# timeout: ${16:20}
		# subtype: ${17:plain}
$0
endsnippet

snippet mattermost "Send Mattermost notifications" b
- name: $1
	mattermost:
		url: ${2:# Mattermost url (i.e. http://mattermost.yourcompany.com).}
		text: ${3:# Text to send. Note that the module does not handle escaping characters.}
		api_key: ${4:# Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)}
		# username: ${5:Ansible}
		# icon_url: ${6:https://www.ansible.com/favicon.ico}
		# validate_certs: ${7:yes|no}
		# channel: ${8:# Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).}
$0
endsnippet

snippet mqtt "Publish a message on an MQTT topic for the IoT" b
- name: $1
	mqtt:
		topic: ${2:# MQTT topic name}
		payload: ${3:# Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.}
		# username: ${4:# Username to authenticate against the broker.}
		# certfile: ${5:# The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
		# port: ${6:1883}
		# server: ${7:localhost}
		# client_id: ${8:hostname + pid}
		# ca_certs: ${9:# The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.}
		# retain: ${10:no}
		# password: ${11:# Password for C(username) to authenticate against the broker.}
		# keyfile: ${12:# The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
		# qos: ${13:0|1|2}
$0
endsnippet

snippet nexmo "Send a SMS via nexmo" b
- name: $1
	nexmo:
		src: ${2:# Nexmo Number to send from}
		dest: ${3:# Phone number(s) to send SMS message to}
		api_secret: ${4:# Nexmo API Secret}
		api_key: ${5:# Nexmo API Key}
		msg: ${6:# Message to text to send. Messages longer than 160 characters will be split into multiple messages}
		# validate_certs: ${7:#yes|no}
$0
endsnippet

snippet office_365_connector_card "Use webhooks to create Connector Card messages within an Office 365 group" b
- name: $1
	office_365_connector_card:
		webhook: ${2:# The webhook URL is given to you when you create a new Connector.}
		# sections: ${3:# Contains a list of sections to display in the card.}
		# title: ${4:# A title for the Connector message. Shown at the top of the message.}
		# color: ${5:# Accent color used for branding or indicating status in the card.}
		# text: ${6:# The main text of the card.}
		# actions: ${7:# This array of objects will power the action links}
		# summary: ${8:# A string used for summarizing card content.}
$0
endsnippet

snippet osx_say "Makes an OSX computer to speak." b
- name: $1
	osx_say:
		msg: ${2:# W}
		# voice: ${3:# W}
$0
endsnippet

snippet pushbullet "Sends notifications to Pushbullet" b
- name: $1
	pushbullet:
		title: ${2:# Title of the notification.}
		api_key: ${3:# Push bullet API token}
		# body: ${4:# Body of the notification, e.g. Details of the fault you're alerting.}
		# device: ${5:# The device NAME you wish to send a push notification, as seen on the Pushbullet main page.}
		# push_type: ${6:#note|link}
		# channel: ${7:# The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.}
$0
endsnippet

snippet pushover "Send notifications via U(https://pushover.net)" b
- name: $1
	pushover:
		msg: ${2:# What message you wish to send.}
		user_key: ${3:# Pushover issued authentication key for your user.}
		app_token: ${4:# Pushover issued token identifying your pushover app.}
		# pri: ${5:# Message priority (see U(https://pushover.net) for details.)}
$0
endsnippet

snippet rocketchat "Send notifications to Rocket Chat" b
- name: $1
	rocketchat:
		domain: ${2:# The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))}
		token: ${3:# Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.}
		# username: ${4:Ansible}
		# protocol: ${5:http|#https}
		# attachments: ${6:# Define a list of attachments.}
		# color: ${7:#normal|good|warning|danger}
		# icon_url: ${8:https://www.ansible.com/favicon.ico}
		# icon_emoji: ${9:# Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)}
		# link_names: ${10:#1|0}
		# msg: ${11:# Message to be sent.}
		# validate_certs: ${12:#yes|no}
		# channel: ${13:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specified during the creation of webhook.}
$0
endsnippet

snippet sendgrid "Sends an email with the SendGrid API" b
- name: $1
	sendgrid:
		from_address: ${2:# the address in the "from" field for the email}
		subject: ${3:# the desired subject for the email}
		to_addresses: ${4:# a list with one or more recipient email addresses}
		# username: ${5:# username for logging into the SendGrid account.}
		# from_name: ${6:# the name you want to appear in the from field, i.e 'John Doe'}
		# cc: ${7:# a list of email addresses to cc}
		# bcc: ${8:# a list of email addresses to bcc}
		# headers: ${9:# a dict to pass on as headers}
		# html_body: ${10:no}
		# api_key: ${11:# sendgrid API key to use instead of username/password}
		# password: ${12:# password that corresponds to the username}
		# attachments: ${13:# a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)}
$0
endsnippet

snippet slack "Send Slack notifications" b
- name: $1
	slack:
		token: ${2:# Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.}
		# username: ${3:Ansible}
		# domain: ${4:# Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.}
		# attachments: ${5:# Define a list of attachments. This list mirrors the Slack JSON API. For more information, see https://api.slack.com/docs/attachments}
		# color: ${6:#normal|good|warning|danger}
		# icon_url: ${7:# Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))}
		# parse: ${8:full|none}
		# icon_emoji: ${9:# Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)}
		# link_names: ${10:#1|0}
		# msg: ${11:# Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.}
		# validate_certs: ${12:#yes|no}
		# channel: ${13:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token).}
$0
endsnippet

snippet syslogger "Log messages in the syslog" b
- name: $1
	syslogger:
		msg: ${2:# This is the message to place in syslog}
		# priority: ${3:emerg|alert|crit|err|warning|notice|#info|debug}
		# facility: ${4:kern|user|mail|#daemon|auth|lpr|news|uucp|cron|syslog|local0|local1|local2|local3|local4|local5|local6|local7}
		# log_pid: ${5:no}
$0
endsnippet

snippet telegram "module for sending notifications via telegram" b
- name: $1
	telegram:
		msg: ${2:# What message you wish to send.}
		token: ${3:# Token identifying your telegram bot.}
		chat_id: ${4:# Telegram group or user chat_id}
		# msg_format: ${5:#plain|markdown|html}
$0
endsnippet

snippet twilio "Sends a text message to a mobile phone through Twilio." b
- name: $1
	twilio:
		from_number: ${2:# t}
		msg: ${3:# t}
		auth_token: ${4:# u}
		to_number: ${5:# o}
		account_sid: ${6:# u}
		# media_url: ${7:# a}
$0
endsnippet

snippet typetalk "Send a message to typetalk" b
- name: $1
	typetalk:
		topic: ${2:# topic id to post message}
		client_secret: ${3:# OAuth2 client secret}
		client_id: ${4:# OAuth2 client ID}
		msg: ${5:# message body}
$0
endsnippet

snippet bower "Manage bower packages with bower" b
- name: $1
	bower:
		path: ${2:# The base path where to install the bower packages}
		# state: ${3:#present|absent|latest}
		# production: ${4:yes|no}
		# name: ${5:# The name of a bower package to install}
		# version: ${6:# The version to be installed}
		# relative_execpath: ${7:# Relative path to bower executable from install path}
		# offline: ${8:yes|no}
$0
endsnippet

snippet bundler "Manage Ruby Gem dependencies with Bundler" b
- name: $1
	bundler:
		# executable: ${2:# The path to the bundler executable}
		# chdir: ${3:temporary working directory}
		# gemfile: ${4:Gemfile in current directory}
		# clean: ${5:True|False}
		# user_install: ${6:True|False}
		# extra_args: ${7:# A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information}
		# state: ${8:#present|latest}
		# deployment_mode: ${9:True|False}
		# binstub_directory: ${10:# Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)}
		# exclude_groups: ${11:# A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set}
		# local: ${12:True|False}
		# gem_path: ${13:RubyGems gem paths}
$0
endsnippet

snippet composer "Dependency Manager for PHP" b
- name: $1
	composer:
		# executable: ${2:# Path to PHP Executable on the remote host, if PHP is not in PATH}
		# no_scripts: ${3:True|#False}
		# prefer_source: ${4:True|#False}
		# prefer_dist: ${5:True|#False}
		# working_dir: ${6:# Directory of your project (see --working-dir). This is required when the command is not run globally.}
		# global_command: ${7:True|#False}
		# command: ${8:install}
		# arguments: ${9:# Composer arguments like required package, version and so on.}
		# ignore_platform_reqs: ${10:True|#False}
		# no_dev: ${11:#True|False}
		# no_plugins: ${12:True|#False}
		# optimize_autoloader: ${13:#True|False}
$0
endsnippet

snippet cpanm "Manages Perl library dependencies." b
- name: $1
	cpanm:
		# executable: ${2:# Override the path to the cpanm executable}
		# name: ${3:# The name of the Perl library to install. You may use the "full distribution path", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz}
		# installdeps: ${4:no}
		# system_lib: ${5:no}
		# mirror_only: ${6:no}
		# from_path: ${7:# The local directory from where to install}
		# version: ${8:no}
		# mirror: ${9:no}
		# locallib: ${10:no}
		# notest: ${11:no}
$0
endsnippet

snippet easy_install "Installs Python libraries" b
- name: $1
	easy_install:
		name: ${2:# A Python library name}
		# virtualenv: ${3:# an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically}
		# virtualenv_site_packages: ${4:yes|#no}
		# virtualenv_command: ${5:virtualenv}
		# state: ${6:#present|latest}
		# executable: ${7:# The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.}
$0
endsnippet

snippet gem "Manage Ruby gems" b
- name: $1
	gem:
		name: ${2:# The name of the gem to be managed.}
		# include_dependencies: ${3:#yes|no}
		# executable: ${4:# Override the path to the gem executable}
		# repository: ${5:# The repository from which the gem will be installed}
		# build_flags: ${6:# Allow adding build flags for gem compilation}
		# include_doc: ${7:no}
		# user_install: ${8:#yes|no}
		# pre_release: ${9:no}
		# env_shebang: ${10:no}
		# state: ${11:#present|absent|latest}
		# version: ${12:# Version of the gem to be installed/removed.}
		# gem_source: ${13:# The path to a local gem used as installation source.}
$0
endsnippet

snippet maven_artifact "Downloads an Artifact from a Maven Repository" b
- name: $1
	maven_artifact:
		artifact_id: ${2:# The maven artifactId coordinate}
		state: ${3:#present|absent}
		dest: ${4:no}
		group_id: ${5:# The Maven groupId coordinate}
		# username: ${6:# The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3}
		# selevel: ${7:s0}
		# repository_url: ${8:http://repo1.maven.org/maven2}
		# owner: ${9:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# password: ${10:# The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3}
		# keep_name: ${11:yes|#no}
		# group: ${12:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# extension: ${13:jar}
		# unsafe_writes: ${14:no}
		# seuser: ${15:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# setype: ${16:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# serole: ${17:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# version: ${18:latest}
		# mode: ${19:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# timeout: ${20:10}
		# attributes: ${21:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# validate_certs: ${22:#yes|no}
		# classifier: ${23:# The maven classifier coordinate}
$0
endsnippet

snippet npm "Manage node.js packages with npm" b
- name: $1
	npm:
		# executable: ${2:# The executable location for npm.}
		# name: ${3:# The name of a node.js library to install}
		# global: ${4:yes|no}
		# ignore_scripts: ${5:yes|no}
		# state: ${6:#present|absent|latest}
		# production: ${7:yes|no}
		# registry: ${8:# The registry to install modules from.}
		# version: ${9:# The version to be installed}
		# path: ${10:# The base path where to install the node.js libraries}
$0
endsnippet

snippet pear "Manage pear/pecl packages" b
- name: $1
	pear:
		name: ${2:# Name of the package to install, upgrade, or remove.}
		# state: ${3:#present|absent|latest}
		# executable: ${4:# Path to the pear executable}
$0
endsnippet

snippet pip "Manages Python library dependencies." b
- name: $1
	pip:
		# virtualenv: ${2:# An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.}
		# virtualenv_site_packages: ${3:yes|#no}
		# virtualenv_command: ${4:virtualenv}
		# chdir: ${5:# cd into this directory before running the command}
		# requirements: ${6:# The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.}
		# name: ${7:# The name of a Python library to install or the url of the remote package.}
		# virtualenv_python: ${8:# The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.}
		# editable: ${9:no}
		# umask: ${10:# The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077).}
		# executable: ${11:# The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.}
		# extra_args: ${12:# Extra arguments passed to pip.}
		# state: ${13:#present|absent|latest|forcereinstall}
		# version: ${14:# The version number to install of the Python library specified in the I(name) parameter}
$0
endsnippet

snippet apk "Manages apk packages" b
- name: $1
	apk:
		# available: ${2:yes|no}
		# state: ${3:#present|absent|latest}
		# upgrade: ${4:yes|no}
		# update_cache: ${5:yes|no}
		# name: ${6:# A package name, like C(foo), or multiple packages, like C(foo, bar).}
		# repository: ${7:# A package repository or multiple repositories}
$0
endsnippet

snippet apt "Manages apt-packages" b
- name: $1
	apt:
		# autoremove: ${2:yes|no}
		# force: ${3:yes|#no}
		# force_apt_get: ${4:no}
		# update_cache: ${5:yes|no}
		# only_upgrade: ${6:no}
		# deb: ${7:# Path to a .deb package on the remote machine.}
		# cache_valid_time: ${8:0}
		# dpkg_options: ${9:force-confdef,force-confold}
		# upgrade: ${10:#no|yes|safe|full|dist}
		# name: ${11:# A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have "fo" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)}
		# autoclean: ${12:yes|no}
		# purge: ${13:yes|no}
		# allow_unauthenticated: ${14:yes|#no}
		# state: ${15:latest|absent|#present|build-dep}
		# default_release: ${16:# Corresponds to the C(-t) option for I(apt) and sets pin priorities}
		# install_recommends: ${17:yes|no}
$0
endsnippet

snippet apt_key "Add or remove an apt key" b
- name: $1
	apt_key:
		# keyserver: ${2:# The keyserver to retrieve key from.}
		# url: ${3:# The URL to retrieve key from.}
		# data: ${4:# The keyfile contents to add to the keyring.}
		# keyring: ${5:# -}
		# state: ${6:absent|#present}
		# file: ${7:# The path to a keyfile on the remote server to add to the keyring.}
		# validate_certs: ${8:yes}
		# id: ${9:# The identifier of the key.}
$0
endsnippet

snippet apt_repository "Add and remove APT repositories" b
- name: $1
	apt_repository:
		repo: ${2:none}
		# state: ${3:absent|#present}
		# update_cache: ${4:#yes|no}
		# mode: ${5:420}
		# codename: ${6:# Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)}
		# validate_certs: ${7:#yes|no}
		# filename: ${8:# Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.}
$0
endsnippet

snippet apt_rpm "apt_rpm package manager" b
- name: $1
	apt_rpm:
		pkg: ${2:# name of package to install, upgrade or remove.}
		# state: ${3:absent|#present}
		# update_cache: ${4:yes|no}
$0
endsnippet

snippet dnf "Manages packages with the I(dnf) package manager" b
- name: $1
	dnf:
		name: ${2:# Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.
}
		# autoremove: ${3:yes|no}
		# list: ${4:# Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.}
		# disable_gpg_check: ${5:yes|#no}
		# conf_file: ${6:# The remote dnf configuration file to use for the transaction.}
		# state: ${7:#present|latest|absent}
		# disablerepo: ${8:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		# enablerepo: ${9:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		# installroot: ${10:/}
$0
endsnippet

snippet dpkg_selections "Dpkg package selection selections" b
- name: $1
	dpkg_selections:
		selection: ${2:install|hold|deinstall|purge}
		name: ${3:# Name of the package}
$0
endsnippet

snippet homebrew "Package manager for Homebrew" b
- name: $1
	homebrew:
		# install_options: ${2:# options flags to install a package}
		# state: ${3:head|latest|#present|absent|linked|unlinked}
		# name: ${4:# name of package to install/remove}
		# update_homebrew: ${5:yes|no}
		# path: ${6:/usr/local/bin}
		# upgrade_all: ${7:yes|no}
$0
endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks." b
- name: $1
	homebrew_cask:
		name: ${2:# name of cask to install/remove}
		# update_homebrew: ${3:yes|no}
		# path: ${4:/usr/local/bin}
		# state: ${5:#present|absent}
		# install_options: ${6:# options flags to install a package}
$0
endsnippet

snippet homebrew_tap "Tap a Homebrew repository." b
- name: $1
	homebrew_tap:
		name: ${2:# The GitHub user/organization repository to tap.}
		# url: ${3:# The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.}
		# state: ${4:#present|absent}
$0
endsnippet

snippet layman "Manage Gentoo overlays" b
- name: $1
	layman:
		name: ${2:# The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated)).}
		# list_url: ${3:# An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration.}
		# validate_certs: ${4:#yes|no}
		# state: ${5:#present|absent|updated}
$0
endsnippet

snippet macports "Package manager for MacPorts" b
- name: $1
	macports:
		name: ${2:# name of package to install/remove}
		# state: ${3:#present|absent|active|inactive}
		# update_cache: ${4:yes|#no}
$0
endsnippet

snippet openbsd_pkg "Manage packages on OpenBSD" b
- name: $1
	openbsd_pkg:
		name: ${2:# Name of the package.}
		# state: ${3:absent|latest|#present}
		# ports_dir: ${4:/usr/ports}
		# clean: ${5:no}
		# quick: ${6:no}
		# build: ${7:no}
$0
endsnippet

snippet opkg "Package manager for OpenWrt" b
- name: $1
	opkg:
		name: ${2:# name of package to install/remove}
		# force: ${3:|depends|maintainer|reinstall|overwrite|downgrade|space|postinstall|remove|checksum|removal-of-dependent-packages}
		# state: ${4:#present|absent}
		# update_cache: ${5:yes|#no}
$0
endsnippet

snippet package "Generic OS package manager" b
- name: $1
	package:
		state: ${2:# Whether to install (C(present), C(latest)), or remove (C(absent)) a package.}
		name: ${3:# Package name, or package specifier with version, like C(name-1.0).}
		# use: ${4:auto}
$0
endsnippet

snippet pacman "Manage packages with I(pacman)" b
- name: $1
	pacman:
		# state: ${2:#present|absent|latest}
		# upgrade: ${3:yes|no}
		# force: ${4:yes|no}
		# name: ${5:# Name of the package to install, upgrade, or remove.}
		# update_cache: ${6:yes|no}
		# recurse: ${7:yes|no}
$0
endsnippet

snippet pkg5 "Manages packages with the Solaris 11 Image Packaging System" b
- name: $1
	pkg5:
		name: ${2:# An FRMI of the package(s) to be installed/removed/updated.}
		# accept_licenses: ${3:True|#False}
		# state: ${4:#present|latest|absent}
$0
endsnippet

snippet pkg5_publisher "Manages Solaris 11 Image Packaging System publishers" b
- name: $1
	pkg5_publisher:
		name: ${2:# The publisher's name.}
		# origin: ${3:# A path or URL to the repository.}
		# state: ${4:#present|absent}
		# mirror: ${5:# A path or URL to the repository mirror.}
		# enabled: ${6:True|False}
		# sticky: ${7:True|False}
$0
endsnippet

snippet pkgin "Package manager for SmartOS, NetBSD, et al." b
- name: $1
	pkgin:
		# state: ${2:#present|absent}
		# upgrade: ${3:yes|no}
		# force: ${4:yes|no}
		# name: ${5:# Name of package to install/remove;}
		# full_upgrade: ${6:yes|no}
		# update_cache: ${7:yes|no}
		# clean: ${8:yes|no}
$0
endsnippet

snippet pkgng "Package manager for FreeBSD >= 9.0" b
- name: $1
	pkgng:
		name: ${2:# Name of package to install/remove.}
		# chroot: ${3:# Pkg will chroot in the specified environment.}
		# cached: ${4:yes|no}
		# pkgsite: ${5:# For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).}
		# state: ${6:#present|absent}
		# rootdir: ${7:# For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.}
		# autoremove: ${8:yes|no}
		# jail: ${9:# Pkg will execute in the given jail name or id.}
		# annotation: ${10:# A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.}
$0
endsnippet

snippet pkgutil "Manage CSW-Packages on Solaris" b
- name: $1
	pkgutil:
		state: ${2:present|absent|latest}
		name: ${3:# Package name, e.g. (C(CSWnrpe))}
		# site: ${4:# Specifies the repository path to install the package from.}
		# update_catalog: ${5:no}
$0
endsnippet

snippet portage "Package manager for Gentoo" b
- name: $1
	portage:
		# nodeps: ${2:yes|no}
		# onlydeps: ${3:yes|no}
		# newuse: ${4:yes|no}
		# oneshot: ${5:yes|no}
		# update: ${6:yes|no}
		# deep: ${7:yes|no}
		# sync: ${8:web|yes|no}
		# keepgoing: ${9:yes|no}
		# depclean: ${10:yes|no}
		# jobs: ${11:# Specifies the number of packages to build simultaneously.}
		# noreplace: ${12:yes|no}
		# loadavg: ${13:# Specifies that no new builds should be started if there are}
		# verbose: ${14:yes|no}
		# getbinpkg: ${15:yes|no}
		# package: ${16:# Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)}
		# quiet: ${17:yes|no}
		# state: ${18:#present|installed|emerged|absent|removed|unmerged|latest}
		# changed_use: ${19:yes|no}
		# usepkgonly: ${20:yes|no}
$0
endsnippet

snippet portinstall "Installing packages from FreeBSD's ports system" b
- name: $1
	portinstall:
		name: ${2:# name of package to install/remove}
		# state: ${3:#present|absent}
		# use_packages: ${4:yes|no}
$0
endsnippet

snippet pulp_repo "Add or remove Pulp repos from a remote host." b
- name: $1
	pulp_repo:
		relative_url: ${2:# Relative URL for the local repository.}
		name: ${3:# Name of the repo to add or remove. This correlates to repo-id in Pulp.}
		# feed: ${4:# Upstream feed URL to receive updates from.}
		# repo_type: ${5:rpm}
		# pulp_host: ${6:http://127.0.0.1}
		# force_basic_auth: ${7:yes|#no}
		# importer_ssl_client_cert: ${8:# Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.}
		# proxy_port: ${9:# Proxy port setting for the pulp repository importer.}
		# serve_http: ${10:no}
		# wait_for_completion: ${11:yes|#no}
		# add_export_distributor: ${12:no}
		# url_password: ${13:# The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used.}
		# importer_ssl_client_key: ${14:# Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.}
		# publish_distributor: ${15:# Distributor to use when state is C(publish). The default is to publish all distributors.}
		# proxy_host: ${16:# Proxy url setting for the pulp repository importer. This is in the format scheme://host.}
		# state: ${17:#present|absent|sync|publish}
		# serve_https: ${18:yes}
		# importer_ssl_ca_cert: ${19:# CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file.}
		# url_username: ${20:# The username for use in HTTP basic authentication to the pulp API.}
		# validate_certs: ${21:#yes|no}
$0
endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command" b
- name: $1
	redhat_subscription:
		# username: ${2:# access.redhat.com or Sat6  username}
		# server_hostname: ${3:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# pool_ids: ${4:[]}
		# consumer_id: ${5:# References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.
}
		# server_insecure: ${6:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# activationkey: ${7:# supply an activation key for use with registration}
		# server_proxy_password: ${8:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# consumer_name: ${9:# Name of the system to register, defaults to the hostname}
		# rhsm_baseurl: ${10:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# pool: ${11:^$}
		# server_proxy_port: ${12:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# password: ${13:# access.redhat.com or Sat6 password}
		# consumer_type: ${14:# The type of unit to register, defaults to system}
		# org_id: ${15:# Organization ID to use in conjunction with activationkey}
		# environment: ${16:# Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello}
		# force_register: ${17:no}
		# state: ${18:#present|absent}
		# server_proxy_user: ${19:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# server_proxy_hostname: ${20:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		# autosubscribe: ${21:no}
$0
endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels" b
- name: $1
	rhn_channel:
		sysname: ${2:# Name of the system as it is known in RHN/Satellite.}
		name: ${3:# Name of the software channel.}
		url: ${4:# The full URL to the RHN/Satellite API.}
		password: ${5:# RHN/Satellite password}
		user: ${6:# RHN/Satellite login}
		# state: ${7:present}
$0
endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command" b
- name: $1
	rhn_register:
		# username: ${2:# Red Hat Network username}
		# systemorgid: ${3:# supply an organizational id for use with registration}
		# enable_eus: ${4:no}
		# server_url: ${5:Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default}
		# channels: ${6:[]}
		# state: ${7:#present|absent}
		# sslcacert: ${8:# supply a custom ssl CA certificate file for use with registration}
		# activationkey: ${9:# supply an activation key for use with registration}
		# profilename: ${10:# supply an profilename for use with registration}
		# password: ${11:# Red Hat Network password}
		# nopackages: ${12:no}
$0
endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db" b
- name: $1
	rpm_key:
		key: ${2:# Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.}
		# state: ${3:#present|absent}
		# validate_certs: ${4:#yes|no}
$0
endsnippet

snippet slackpkg "Package manager for Slackware >= 12.2" b
- name: $1
	slackpkg:
		name: ${2:# name of package to install/remove}
		# state: ${3:#present|absent|latest}
		# update_cache: ${4:True|#False}
$0
endsnippet

snippet sorcery "Package manager for Source Mage GNU/Linux" b
- name: $1
	sorcery:
		# depends: ${2:# Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)}
		# update_cache: ${3:yes|#no}
		# name: ${4:# Name of the spell}
		# state: ${5:#present|latest|absent|cast|dispelled|rebuild}
		# update: ${6:yes|#no}
		# cache_valid_time: ${7:# Time in seconds to invalidate grimoire collection on update}
$0
endsnippet

snippet svr4pkg "Manage Solaris SVR4 packages" b
- name: $1
	svr4pkg:
		state: ${2:present|absent}
		name: ${3:# Package name, e.g. C(SUNWcsr)}
		# category: ${4:true|false}
		# src: ${5:# Specifies the location to install the package from. Required when C(state=present).}
		# zone: ${6:current|#all}
		# response_file: ${7:# Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)}
		# proxy: ${8:# HTTP[s] proxy to be used if C(src) is a URL.}
$0
endsnippet

snippet swdepot "Manage packages with swdepot package manager (HP-UX)" b
- name: $1
	swdepot:
		state: ${2:present|latest|absent}
		name: ${3:}
		# depot: ${4:}
$0
endsnippet

snippet swupd "Manages updates and bundles in ClearLinux systems." b
- name: $1
	swupd:
		# contenturl: ${2:# URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.}
		# name: ${3:# Name of the (I)bundle to install or remove.}
		# format: ${4:# The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.}
		# url: ${5:# Overrides both I(contenturl) and I(versionurl).}
		# verify: ${6:# Verify content for OS version.}
		# update: ${7:no}
		# manifest: ${8:# The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.}
		# state: ${9:#present|absent}
		# versionurl: ${10:# URL for version string download.}
$0
endsnippet

snippet urpmi "Urpmi manager" b
- name: $1
	urpmi:
		pkg: ${2:# name of package to install, upgrade or remove.}
		# no-recommends: ${3:yes|no}
		# force: ${4:yes|no}
		# update_cache: ${5:yes|no}
		# root: ${6:/}
		# state: ${7:absent|#present}
$0
endsnippet

snippet xbps "Manage packages with XBPS" b
- name: $1
	xbps:
		# recurse: ${2:yes|no}
		# state: ${3:#present|absent|latest}
		# upgrade: ${4:yes|no}
		# update_cache: ${5:yes|no}
		# name: ${6:# Name of the package to install, upgrade, or remove.}
$0
endsnippet

snippet yum "Manages packages with the I(yum) package manager" b
- name: $1
	yum:
		name: ${2:# Package name, or package specifier with version, like C(name-1.0). If a previous version is specified, the task also needs to turn C(allow_downgrade) on. See the C(allow_downgrade) documentation for caveats with downgrading packages. When using state=latest, this can be '*' which means run C(yum -y update).  You can also pass a url or a local path to a rpm file (using state=present). To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.}
		# allow_downgrade: ${3:yes|#no}
		# exclude: ${4:# Package name(s) to exclude when state=present, or latest}
		# list: ${5:# Package name to run the equivalent of yum list <package> against.}
		# disable_gpg_check: ${6:yes|#no}
		# conf_file: ${7:# The remote yum configuration file to use for the transaction.}
		# state: ${8:#present|installed|latest|absent|removed}
		# disablerepo: ${9:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		# update_cache: ${10:yes|#no}
		# enablerepo: ${11:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		# skip_broken: ${12:yes|#no}
		# security: ${13:yes|#no}
		# validate_certs: ${14:#yes|no}
		# installroot: ${15:/}
$0
endsnippet

snippet yum_repository "Add or remove YUM repositories" b
- name: $1
	yum_repository:
		name: ${2:# Unique repository ID.}
		# metalink: ${3:# Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).}
		# ip_resolve: ${4:4|6|IPv4|IPv6|#whatever}
		# reposdir: ${5:/etc/yum.repos.d}
		# proxy_password: ${6:# Username to use for proxy.}
		# mirrorlist_expire: ${7:21600}
		# bandwidth: ${8:0}
		# cost: ${9:1000}
		# file: ${10:# File to use to save the repo in. Defaults to the value of I(name).}
		# owner: ${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# exclude: ${12:# List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.}
		# keepalive: ${13:yes|#no}
		# repo_gpgcheck: ${14:yes|#no}
		# group: ${15:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# failovermethod: ${16:#roundrobin|priority}
		# unsafe_writes: ${17:no}
		# deltarpm_metadata_percentage: ${18:100}
		# gpgkey: ${19:# A URL pointing to the ASCII-armored GPG key file for the repository.}
		# setype: ${20:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# http_caching: ${21:#all|packages|none}
		# priority: ${22:99}
		# serole: ${23:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mirrorlist: ${24:# Specifies a URL to a file containing a list of baseurls.}
		# params: ${25:# Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).}
		# gpgcheck: ${26:yes|#no}
		# include: ${27:# Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.}
		# proxy_username: ${28:# Password for this proxy.}
		# username: ${29:# Username to use for basic authentication to a repo or really any url.}
		# ui_repoid_vars: ${30:releasever basearch}
		# metadata_expire: ${31:21600}
		# description: ${32:# A human readable string describing the repository.}
		# state: ${33:absent|#present}
		# selevel: ${34:s0}
		# sslclientcert: ${35:# Path to the SSL client certificate yum should use to connect to repos/remote sites.}
		# baseurl: ${36:# URL to the directory where the yum repository's 'repodata' directory lives.}
		# gpgcakey: ${37:# A URL pointing to the ASCII-armored CA key file for the repository.}
		# s3_enabled: ${38:yes|#no}
		# async: ${39:#yes|no}
		# sslcacert: ${40:# Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.}
		# includepkgs: ${41:# List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.}
		# enablegroups: ${42:#yes|no}
		# sslverify: ${43:#yes|no}
		# password: ${44:# Password to use with the username for basic authentication.}
		# retries: ${45:10}
		# protect: ${46:yes|#no}
		# ssl_check_cert_permissions: ${47:yes|#no}
		# throttle: ${48:# Enable bandwidth throttling for downloads.}
		# deltarpm_percentage: ${49:75}
		# sslclientkey: ${50:# Path to the SSL client key yum should use to connect to repos/remote sites.}
		# seuser: ${51:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# enabled: ${52:#yes|no}
		# skip_if_unavailable: ${53:yes|#no}
		# keepcache: ${54:0|#1}
		# mode: ${55:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# timeout: ${56:30}
		# attributes: ${57:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# metadata_expire_filter: ${58:never|read-only:past|#read-only:present|read-only:future}
		# proxy: ${59:# URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.}
$0
endsnippet

snippet zypper "Manage packages on SUSE and openSUSE" b
- name: $1
	zypper:
		name: ${2:# Package name C(name) or package specifier.}
		# force: ${3:yes|#no}
		# disable_gpg_check: ${4:yes|#no}
		# extra_args: ${5:# Add additional options to C(zypper) command.}
		# state: ${6:#present|latest|absent|dist-upgrade}
		# oldpackage: ${7:yes|#no}
		# update_cache: ${8:yes|#no}
		# disable_recommends: ${9:#yes|no}
		# type: ${10:#package|patch|pattern|product|srcpackage|application}
$0
endsnippet

snippet zypper_repository "Add and remove Zypper repositories" b
- name: $1
	zypper_repository:
		# repo: ${2:none}
		# name: ${3:none}
		# auto_import_keys: ${4:yes|#no}
		# enabled: ${5:#yes|no}
		# disable_gpg_check: ${6:yes|#no}
		# priority: ${7:# Set priority of repository. Packages will always be installed from the repository with the smallest priority number.}
		# state: ${8:absent|#present}
		# autorefresh: ${9:#yes|no}
		# overwrite_multiple: ${10:yes|#no}
		# runrefresh: ${11:yes|#no}
		# description: ${12:none}
$0
endsnippet

snippet wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: ${3:255.255.255.255}
		# port: ${4:7}
$0
endsnippet

snippet foreman "Manage Foreman Resources" b
- name: $1
	foreman:
		username: ${2:# Username on Foreman server}
		password: ${3:# Password for user accessing Foreman server}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)}
		server_url: ${5:# URL of Foreman server}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host)}
$0
endsnippet

snippet katello "Manage Katello Resources" b
- name: $1
	katello:
		username: ${2:# Username on Foreman server}
		password: ${3:# Password for user accessing Foreman server}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)}
		server_url: ${5:# URL of Foreman server}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host)}
$0
endsnippet

snippet hpilo_boot "Boot system using specific media through HP iLO interface" b
- name: $1
	hpilo_boot:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# force: ${3:yes|no}
		# media: ${4:cdrom|floppy|hdd|#network|normal|usb}
		# image: ${5:# The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename}
		# ssl_version: ${6:SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2}
		# state: ${7:boot_always|#boot_once|connect|disconnect|no_boot|poweroff}
		# login: ${8:Administrator}
		# password: ${9:admin}
$0
endsnippet

snippet hpilo_facts "Gather facts through an HP iLO interface" b
- name: $1
	hpilo_facts:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# password: ${3:admin}
		# ssl_version: ${4:SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2}
		# login: ${5:Administrator}
$0
endsnippet

snippet hponcfg "Configure HP iLO interface using hponcfg" b
- name: $1
	hponcfg:
		path: ${2:# The XML file as accepted by hponcfg.}
		# executable: ${3:hponcfg}
		# minfw: ${4:# The minimum firmware level needed.}
		# verbose: ${5:no}
$0
endsnippet

snippet imc_rest "Manage Cisco IMC hardware through its REST API" b
- name: $1
	imc_rest:
		hostname: ${2:# IP Address or hostname of Cisco IMC, resolvable by Ansible control host.}
		# username: ${3:admin}
		# protocol: ${4:http|#https}
		# content: ${5:# When used instead of C(path), sets the content of the API requests directly.}
		# timeout: ${6:60}
		# path: ${7:# Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.}
		# password: ${8:password}
		# validate_certs: ${9:yes}
$0
endsnippet

snippet ipmi_boot "Management of order of boot devices" b
- name: $1
	ipmi_boot:
		bootdev: ${2:network -- Request network boot|hd -- Boot from hard drive|safe -- Boot from hard drive, requesting 'safe mode'|optical -- boot from CD/DVD/BD drive|setup -- Boot into setup utility|default -- remove any IPMI directed boot device request}
		name: ${3:# Hostname or ip address of the BMC.}
		user: ${4:# Username to use to connect to the BMC.}
		password: ${5:# Password to connect to the BMC.}
		# persistent: ${6:no}
		# uefiboot: ${7:no}
		# state: ${8:present -- Request system turn on|absent -- Request system turn on}
		# port: ${9:623}
$0
endsnippet

snippet ipmi_power "Power management for machine" b
- name: $1
	ipmi_power:
		state: ${2:on -- Request system turn on|off -- Request system turn off without waiting for OS to shutdown|shutdown -- Have system request OS proper shutdown|reset -- Request system reset without waiting for OS|boot -- If system is off, then 'on', else 'reset'}
		name: ${3:# Hostname or ip address of the BMC.}
		password: ${4:# Password to connect to the BMC.}
		user: ${5:# Username to use to connect to the BMC.}
		# timeout: ${6:300}
		# port: ${7:623}
$0
endsnippet

snippet manageiq_provider "Management of provider in ManageIQ." b
- name: $1
	manageiq_provider:
		name: ${2:# T}
		manageiq_connection: ${3:# ManageIQ connection configuration information.}
		type: ${4:Openshift|Amazon}
		# zone: ${5:default}
		# alerts: ${6:# A}
		# metrics: ${7:# M}
		# state: ${8:absent|#present}
		# provider: ${9:# D}
		# provider_region: ${10:# T}
$0
endsnippet

snippet manageiq_user "Management of users in ManageIQ." b
- name: $1
	manageiq_user:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		userid: ${3:# The unique userid in manageiq, often mentioned as username.}
		# state: ${4:absent|#present}
		# group: ${5:# The name of the group to which the user belongs.}
		# name: ${6:# The users' full name.}
		# password: ${7:# The users' password.}
		# email: ${8:# The users' E-mail address.}
$0
endsnippet

snippet oneview_ethernet_network "Manage OneView Ethernet Network resources" b
- name: $1
	oneview_ethernet_network:
		data: ${2:# List with Ethernet Network properties.}
		# config: ${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# state: ${4:#present|absent|default_bandwidth_reset}
		# validate_etag: ${5:true|false}
$0
endsnippet

snippet oneview_ethernet_network_facts "Retrieve the facts about one or more of the OneView Ethernet Networks" b
- name: $1
	oneview_ethernet_network_facts:
		# config: ${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# params: ${3:# List of params to delimit, filter and sort the list of resources.}
		# name: ${4:# Ethernet Network name.}
		# options: ${5:# List with options to gather additional facts about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).}
$0
endsnippet

snippet oneview_fc_network "Manage OneView Fibre Channel Network resources." b
- name: $1
	oneview_fc_network:
		data: ${2:# List with the Fibre Channel Network properties.}
		# config: ${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# state: ${4:present|absent}
		# validate_etag: ${5:true|false}
$0
endsnippet

snippet oneview_fc_network_facts "Retrieve the facts about one or more of the OneView Fibre Channel Networks" b
- name: $1
	oneview_fc_network_facts:
		# config: ${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# params: ${3:# List of params to delimit, filter and sort the list of resources.}
		# name: ${4:# Fibre Channel Network name.}
$0
endsnippet

snippet oneview_fcoe_network "Manage OneView FCoE Network resources" b
- name: $1
	oneview_fcoe_network:
		data: ${2:# List with FCoE Network properties.}
		# config: ${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# state: ${4:#present|absent}
		# validate_etag: ${5:true|false}
$0
endsnippet

snippet oneview_fcoe_network_facts "Retrieve the facts about one or more of the OneView FCoE Networks" b
- name: $1
	oneview_fcoe_network_facts:
		# config: ${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# params: ${3:# List of params to delimit, filter and sort the list of resources.}
		# name: ${4:# FCoE Network name.}
$0
endsnippet

snippet oneview_network_set "Manage HPE OneView Network Set resources" b
- name: $1
	oneview_network_set:
		data: ${2:# List with the Network Set properties.}
		# config: ${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# state: ${4:#present|absent}
		# validate_etag: ${5:true|false}
$0
endsnippet

snippet oneview_network_set_facts "Retrieve facts about the OneView Network Sets" b
- name: $1
	oneview_network_set_facts:
		# config: ${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# params: ${3:# List of params to delimit, filter and sort the list of resources.}
		# name: ${4:# Network Set name.}
		# options: ${5:# List with options to gather facts about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.}
$0
endsnippet

snippet oneview_san_manager "Manage OneView SAN Manager resources" b
- name: $1
	oneview_san_manager:
		data: ${2:# List with SAN Manager properties.}
		# config: ${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
		# state: ${4:#present|absent|connection_information_set}
		# validate_etag: ${5:true|false}
$0
endsnippet

snippet oneview_san_manager_facts "Retrieve facts about one or more of the OneView SAN Managers" b
- name: $1
	oneview_san_manager_facts:
		# params: ${2:# List of params to delimit, filter and sort the list of resources.}
		# provider_display_name: ${3:# Provider Display Name.}
		# config: ${4:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
$0
endsnippet

snippet stacki_host "Add or remove host to stacki front-end" b
- name: $1
	stacki_host:
		name: ${2:# Name of the host to be added to Stacki.}
		stacki_user: ${3:# Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.}
		stacki_endpoint: ${4:# URL for the Stacki API Endpoint.}
		stacki_password: ${5:# Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.}
		# prim_intf_ip: ${6:# IP Address for the primary network interface.}
		# prim_intf: ${7:# Name of the primary network interface.}
		# force_install: ${8:# Set value to True to force node into install state if it already exists in stacki.}
		# prim_intf_mac: ${9:# MAC Address for the primary PXE boot network interface.}
$0
endsnippet

snippet bzr "Deploy software (or files) from bzr branches" b
- name: $1
	bzr:
		dest: ${2:# Absolute path of where the branch should be cloned to.}
		name: ${3:# SSH or HTTP protocol address of the parent branch.}
		# executable: ${4:# Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		# version: ${5:head}
		# force: ${6:yes|#no}
$0
endsnippet

snippet git "Deploy software (or files) from git checkouts" b
- name: $1
	git:
		dest: ${2:# The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no).}
		repo: ${3:# git, SSH, or HTTP(S) protocol address of the git repository.}
		# force: ${4:yes|#no}
		# track_submodules: ${5:yes|#no}
		# reference: ${6:# Reference repository (see "git clone --reference ...")}
		# accept_hostkey: ${7:yes|#no}
		# clone: ${8:#yes|no}
		# update: ${9:#yes|no}
		# ssh_opts: ${10:# Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"}
		# bare: ${11:yes|#no}
		# verify_commit: ${12:yes|#no}
		# archive: ${13:# Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats ["zip", "tar.gz", "tar", "tgz"]}
		# recursive: ${14:#yes|no}
		# executable: ${15:# Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		# remote: ${16:origin}
		# refspec: ${17:# Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".}
		# umask: ${18:# The umask to set before doing any checkouts, or any other repository maintenance.}
		# depth: ${19:# Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.}
		# version: ${20:HEAD}
		# key_file: ${21:# Specify an optional private key file to use for the checkout.}
$0
endsnippet

snippet git_config "Read and write git configuration" b
- name: $1
	git_config:
		# repo: ${2:# Path to a git repository for reading and writing values from a specific repo.}
		# scope: ${3:local|global|system}
		# list_all: ${4:yes|no}
		# name: ${5:# The name of the setting. If no value is supplied, the value will be read from the config if it has been set.}
		# value: ${6:# When specifying the name of a single setting, supply a value to set that setting to the given value.}
$0
endsnippet

snippet github_deploy_key "Manages deploy keys for GitHub repositories." b
- name: $1
	github_deploy_key:
		name: ${2:# The name for the deploy key.}
		repo: ${3:# The name of the GitHub repository.}
		owner: ${4:# The name of the individual account or organization that owns the GitHub repository.}
		key: ${5:# The SSH public key to add to the repository as a deploy key.}
		# read_only: ${6:yes}
		# username: ${7:# The username to authenticate with.}
		# force: ${8:no}
		# state: ${9:#present|absent}
		# token: ${10:# The OAuth2 token or personal access token to authenticate with. Mutually exclusive with I(password).}
		# otp: ${11:# The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password).}
		# password: ${12:# The password to authenticate with. A personal access token can be used here in place of a password.}
$0
endsnippet

snippet github_hooks "Manages GitHub service hooks." b
- name: $1
	github_hooks:
		repo: ${2:# This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.
}
		oauthkey: ${3:# The oauth key provided by GitHub. It can be found/generated on GitHub under "Edit Your Profile" >> "Developer settings" >> "Personal Access Tokens"}
		user: ${4:# Github username.}
		action: ${5:create|cleanall|list|clean504}
		# content_type: ${6:#json|form}
		# validate_certs: ${7:#yes|no}
		# hookurl: ${8:# When creating a new hook, this is the url that you want GitHub to post to. It is only required when creating a new hook.}
$0
endsnippet

snippet github_issue "View GitHub issue." b
- name: $1
	github_issue:
		repo: ${2:none}
		organization: ${3:none}
		issue: ${4:none}
		# action: ${5:[u'get_status']}
$0
endsnippet

snippet github_key "Manage GitHub access keys." b
- name: $1
	github_key:
		token: ${2:# GitHub Access Token with permission to list and create public keys.}
		name: ${3:# SSH key name}
		# pubkey: ${4:none}
		# force: ${5:#yes|no}
		# state: ${6:#present|absent}
$0
endsnippet

snippet github_release "Interact with GitHub Releases" b
- name: $1
	github_release:
		repo: ${2:# Repository name}
		user: ${3:# The GitHub account that owns the repository}
		action: ${4:latest_release|create_release}
		# body: ${5:# Description of the release when creating a release}
		# target: ${6:# Target of release when creating a release}
		# token: ${7:# GitHub Personal Access Token for authenticating}
		# tag: ${8:# Tag name when creating a release. Required when using action is set to C(create_release).}
		# draft: ${9:True|False}
		# prerelease: ${10:True|False}
		# password: ${11:# The GitHub account password for the user}
		# name: ${12:# Name of release when creating a release}
$0
endsnippet

snippet gitlab_group "Creates/updates/deletes Gitlab Groups" b
- name: $1
	gitlab_group:
		name: ${2:# Name of the group you want to create.}
		server_url: ${3:# Url of Gitlab server, with protocol (http or https).}
		# login_user: ${4:# Gitlab user name.}
		# login_token: ${5:# Gitlab token for logging in.}
		# state: ${6:#present|absent}
		# login_password: ${7:# Gitlab password for login_user}
		# path: ${8:# The path of the group you want to create, this will be server_url/group_path}
		# validate_certs: ${9:yes}
$0
endsnippet

snippet gitlab_project "Creates/updates/deletes Gitlab Projects" b
- name: $1
	gitlab_project:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# The name of the project}
		# merge_requests_enabled: ${4:yes}
		# import_url: ${5:no}
		# login_user: ${6:# Gitlab user name.}
		# login_password: ${7:# Gitlab password for login_user}
		# group: ${8:# The name of the group of which this projects belongs to.}
		# wiki_enabled: ${9:yes}
		# visibility_level: ${10:0}
		# description: ${11:# An description for the project.}
		# snippets_enabled: ${12:yes}
		# login_token: ${13:# Gitlab token for logging in.}
		# state: ${14:#present|absent}
		# issues_enabled: ${15:yes}
		# path: ${16:# The path of the project you want to create, this will be server_url/<group>/path}
		# validate_certs: ${17:yes}
		# public: ${18:no}
$0
endsnippet

snippet gitlab_user "Creates/updates/deletes Gitlab Users" b
- name: $1
	gitlab_user:
		username: ${2:# The username of the user.}
		name: ${3:# Name of the user you want to create}
		server_url: ${4:# Url of Gitlab server, with protocol (http or https).}
		password: ${5:# The password of the user.}
		email: ${6:# The email that belongs to the user.}
		# group: ${7:# Add user as an member to this group.}
		# sshkey_file: ${8:# The ssh key itself.}
		# sshkey_name: ${9:# The name of the sshkey}
		# login_user: ${10:# Gitlab user name.}
		# login_token: ${11:# Gitlab token for logging in.}
		# confirm: ${12:yes}
		# access_level: ${13:# The access level to the group. One of the following can be used.}
		# state: ${14:#present|absent}
		# login_password: ${15:# Gitlab password for login_user}
		# validate_certs: ${16:yes}
$0
endsnippet

snippet hg "Manages Mercurial (hg) repositories." b
- name: $1
	hg:
		repo: ${2:# The repository address.}
		dest: ${3:# Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no}
		# executable: ${4:# Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		# force: ${5:yes|#no}
		# clone: ${6:#yes|no}
		# update: ${7:#yes|no}
		# purge: ${8:yes|#no}
		# revision: ${9:# Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.}
$0
endsnippet

snippet subversion "Deploys a subversion repository." b
- name: $1
	subversion:
		dest: ${2:# Absolute path where the repository should be deployed.}
		repo: ${3:# The subversion URL to the repository.}
		# username: ${4:# --username parameter passed to svn.}
		# executable: ${5:# Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		# force: ${6:yes|#no}
		# update: ${7:#yes|no}
		# switch: ${8:#yes|no}
		# export: ${9:yes|#no}
		# password: ${10:# --password parameter passed to svn.}
		# checkout: ${11:#yes|no}
		# revision: ${12:HEAD}
$0
endsnippet

snippet infini_export "Create, Delete or Modify NFS Exports on Infinibox" b
- name: $1
	infini_export:
		name: ${2:# Export name. Should always start with C(/). (ex. name=/data)}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		filesystem: ${4:# Name of exported file system.}
		# inner_path: ${5:/}
		# client_list: ${6:All Hosts(*), RW, no_root_squash: True}
		# state: ${7:#present|absent}
		# user: ${8:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${9:# Infinibox User password.}
$0
endsnippet

snippet infini_export_client "Create, Delete or Modify NFS Client(s) for existing exports on Infinibox" b
- name: $1
	infini_export_client:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		client: ${3:# Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.}
		export: ${4:# Name of the export.}
		# no_root_squash: ${5:yes|no}
		# access_mode: ${6:#RW|RO}
		# state: ${7:#present|absent}
		# user: ${8:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${9:# Infinibox User password.}
$0
endsnippet

snippet infini_fs "Create, Delete or Modify filesystems on Infinibox" b
- name: $1
	infini_fs:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		pool: ${3:# Pool that will host file system.}
		name: ${4:# File system name.}
		# size: ${5:# File system size in MB, GB or TB units. See examples.}
		# state: ${6:#present|absent}
		# user: ${7:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${8:# Infinibox User password.}
$0
endsnippet

snippet infini_host "Create, Delete and Modify Hosts on Infinibox" b
- name: $1
	infini_host:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		name: ${3:# Host Name}
		# volume: ${4:# Volume name to map to the host}
		# state: ${5:#present|absent}
		# wwns: ${6:# List of wwns of the host}
		# user: ${7:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${8:# Infinibox User password.}
$0
endsnippet

snippet infini_pool "Create, Delete and Modify Pools on Infinibox" b
- name: $1
	infini_pool:
		name: ${2:# Pool Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		# ssd_cache: ${4:yes|no}
		# state: ${5:#present|absent}
		# user: ${6:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${7:# Infinibox User password.}
		# vsize: ${8:# Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.}
		# size: ${9:# Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.}
$0
endsnippet

snippet infini_vol "Create, Delete or Modify volumes on Infinibox" b
- name: $1
	infini_vol:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		pool: ${3:# Pool that volume will reside on}
		name: ${4:# Volume Name}
		# size: ${5:# Volume size in MB, GB or TB units. See examples.}
		# state: ${6:#present|absent}
		# user: ${7:# Infinibox User username with sufficient priveledges ( see notes ).}
		# password: ${8:# Infinibox User password.}
$0
endsnippet

snippet na_cdot_aggregate "Manage NetApp cDOT aggregates." b
- name: $1
	na_cdot_aggregate:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		state: ${3:present|absent}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		name: ${5:# The name of the aggregate to manage.}
		password: ${6:# Password for the specified user.}
		# disk_count: ${7:# Number of disks to place into the aggregate, including parity disks.}
$0
endsnippet

snippet na_cdot_license "Manage NetApp cDOT protocol and feature licenses" b
- name: $1
	na_cdot_license:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		password: ${4:# Password for the specified user.}
		# licenses: ${5:# List of licenses to add or remove.}
		# remove_unused: ${6:true|false}
		# remove_expired: ${7:true|false}
		# serial_number: ${8:# Serial number of the node associated with the license.}
$0
endsnippet

snippet na_cdot_lun "Manage  NetApp cDOT luns" b
- name: $1
	na_cdot_lun:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		vserver: ${3:# The name of the vserver to use.}
		name: ${4:# The name of the lun to manage.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		# flexvol_name: ${8:# The name of the FlexVol the lun should exist on.}
		# size_unit: ${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# force_remove: ${10:no}
		# force_resize: ${11:no}
		# force_remove_fenced: ${12:no}
		# size: ${13:# The size of the lun in C(size_unit).}
$0
endsnippet

snippet na_cdot_qtree "Manage qtrees" b
- name: $1
	na_cdot_qtree:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		vserver: ${3:# The name of the vserver to use.}
		state: ${4:present|absent}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		name: ${6:# The name of the Qtree to manage.}
		password: ${7:# Password for the specified user.}
		# flexvol_name: ${8:# The name of the FlexVol the Qtree should exist on. Required when C(state=present).}
$0
endsnippet

snippet na_cdot_svm "Manage NetApp cDOT svm" b
- name: $1
	na_cdot_svm:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the SVM to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# root_volume_aggregate: ${7:# The aggregate on which the root volume will be created.}
		# root_volume_security_style: ${8:unix|ntfs|mixed|unified}
		# root_volume: ${9:# Root volume of the SVM. Required when C(state=present).}
$0
endsnippet

snippet na_cdot_user "useradmin configuration and management" b
- name: $1
	na_cdot_user:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the user to manage.}
		authentication_method: ${4:community|password|publickey|domain|nsswitch|usm}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		vserver: ${6:# The name of the vserver to use.}
		application: ${7:console|http|ontapi|rsh|snmp|sp|ssh|telnet}
		state: ${8:present|absent}
		password: ${9:# Password for the specified user.}
		# role_name: ${10:# The name of the role. Required when C(state=present)}
		# set_password: ${11:# Password for the user account.}
$0
endsnippet

snippet na_cdot_user_role "useradmin configuration and management" b
- name: $1
	na_cdot_user_role:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the role to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		command_directory_name: ${8:# The command or command directory to which the role has an access.}
		# access_level: ${9:none|readonly|#all}
$0
endsnippet

snippet na_cdot_volume "Manage NetApp cDOT volumes" b
- name: $1
	na_cdot_volume:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the volume to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# Name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		# aggregate_name: ${8:# The name of the aggregate the flexvol should exist on. Required when C(state=present).}
		# size_unit: ${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# online: ${10:#True|False}
		# infinite: ${11:True|#False}
		# size: ${12:# The size of the volume in (size_unit). Required when C(state=present).}
$0
endsnippet

snippet netapp_e_amg "Create, Remove, and Update Asynchronous Mirror Groups" b
- name: $1
	netapp_e_amg:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		secondaryArrayId: ${3:# The ID of the secondary array to be used in mirroing process}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		name: ${5:# The name of the async array you wish to target, or create.}
		state: ${6:# A C(state) of present will either create or update the async mirror group.}
		api_username: ${7:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${8:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# syncIntervalMinutes: ${9:10}
		# recoveryWarnThresholdMinutes: ${10:20}
		# repoUtilizationWarnThreshold: ${11:80}
		# interfaceType: ${12:iscsi|fibre}
		# manualSync: ${13:no}
		# syncWarnThresholdMinutes: ${14:10}
		# validate_certs: ${15:yes}
$0
endsnippet

snippet netapp_e_amg_role "Update the role of a storage array within an Asynchronous Mirror Group (AMG)." b
- name: $1
	netapp_e_amg_role:
		ssid: ${2:# The ID of the primary storage array for the async mirror action}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		role: ${4:primary|secondary}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# force: ${7:no}
		# validate_certs: ${8:yes}
		# noSync: ${9:True|#False}
$0
endsnippet

snippet netapp_e_amg_sync "Conduct synchronization actions on asynchronous mirror groups." b
- name: $1
	netapp_e_amg_sync:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${3:running|suspended}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${6:# The name of the async mirror group you wish to target}
		# ssid: ${7:# The ID of the storage array containing the AMG you wish to target}
		# delete_recovery_point: ${8:True|#False}
		# validate_certs: ${9:yes}
$0
endsnippet

snippet netapp_e_auth "Sets or updates the password for a storage array." b
- name: $1
	netapp_e_auth:
		new_password: ${2:# The password you would like to set. Cannot be more than 30 characters.}
		# ssid: ${3:# the identifier of the storage array in the Web Services Proxy.}
		# name: ${4:# The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.}
		# api_password: ${5:# The password used to authenticate against the API}
		# current_password: ${6:# The current admin password. This is not required if the password hasn't been set before.}
		# api_username: ${7:# The username used to authenticate against the API}
		# validate_certs: ${8:yes}
		# set_admin: ${9:no}
		# api_url: ${10:# The full API url.}
$0
endsnippet

snippet netapp_e_facts "Get facts about NetApp E-Series arrays" b
- name: $1
	netapp_e_facts:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${3:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# validate_certs: ${6:yes}
$0
endsnippet

snippet netapp_e_flashcache "Manage NetApp SSD caches" b
- name: $1
	netapp_e_flashcache:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:#present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${7:# The name of the SSD cache to manage}
		# cache_size_min: ${8:# The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.}
		# io_type: ${9:#filesystem|database|media}
		# disk_count: ${10:# The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place}
		# size_unit: ${11:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet netapp_e_host "manage eseries hosts" b
- name: $1
	netapp_e_host:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		name: ${4:# If the host doesn't yet exist, the label to assign at creation time.}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		host_type_index: ${6:# The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.}
		api_url: ${7:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# group: ${8:# the group you want the host to be a member of}
		# validate_certs: ${9:yes}
		# ports: ${10:# a list of of dictionaries of host ports you wish to associate with the newly created host}
$0
endsnippet

snippet netapp_e_hostgroup "Manage NetApp Storage Array Host Groups" b
- name: $1
	netapp_e_hostgroup:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# new_name: ${7:# specify this when you need to update the name of a host group}
		# hosts:: ${8:# a list of host names/labels to add to the group}
		# validate_certs: ${9:yes}
		# id: ${10:# The id number of the host group to manage. Either this or C(name) must be supplied.}
		# name: ${11:# The name of the host group to manage. Either this or C(id_num) must be supplied.}
$0
endsnippet

snippet netapp_e_lun_mapping "Create or Remove LUN Mappings" b
- name: $1
	netapp_e_lun_mapping:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		volume_name: ${3:# The name of the volume you wish to include in the mapping.}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${7:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# target_type: ${8:host|group}
		# target: ${9:# The name of host or hostgroup you wish to assign to the mapping}
		# validate_certs: ${10:yes}
		# lun: ${11:0}
$0
endsnippet

snippet netapp_e_snapshot_group "Manage snapshot groups" b
- name: $1
	netapp_e_snapshot_group:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		name: ${3:# The name to give the snapshot group}
		state: ${4:present|absent}
		storage_pool_name: ${5:# The name of the storage pool on which to allocate the repository volume.}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		base_volume_name: ${7:# The name of the base volume or thin volume to use as the base for the new snapshot group.}
		api_url: ${8:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# repo_pct: ${9:20}
		# warning_threshold: ${10:80}
		# rollback_priority: ${11:highest|high|#medium|low|lowest|__UNDEFINED}
		# delete_limit: ${12:30}
		# full_policy: ${13:#purgepit|unknown|failbasewrites|__UNDEFINED}
		# validate_certs: ${14:yes}
$0
endsnippet

snippet netapp_e_snapshot_images "Create and delete snapshot images" b
- name: $1
	netapp_e_snapshot_images:
		state: ${2:create|remove}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		snapshot_group: ${4:# The name of the snapshot group in which you want to create a snapshot image.}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${6:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		# validate_certs: ${7:yes}
$0
endsnippet

snippet netapp_e_snapshot_volume "Manage E/EF-Series snapshot volumes." b
- name: $1
	netapp_e_snapshot_volume:
		snapshot_image_id: ${2:# The identifier of the snapshot image used to create the new snapshot volume.}
		ssid: ${3:# storage array ID}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		view_mode: ${5:modeUnknown|readWrite|readOnly|__UNDEFINED}
		state: ${6:absent|present}
		storage_pool_name: ${7:# Name of the storage pool on which to allocate the repository volume.}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${9:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${10:# The name you wish to give the snapshot volume}
		# repo_percentage: ${11:20}
		# full_threshold: ${12:85}
		# validate_certs: ${13:yes}
$0
endsnippet

snippet netapp_e_storage_system "Add/remove arrays from the Web Services Proxy" b
- name: $1
	netapp_e_storage_system:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		controller_addresses: ${7:# The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.}
		# meta_tags: ${8:# Optional meta tags to associate to this storage system}
		# array_wwn: ${9:# The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.}
		# array_password: ${10:# The management password of the array to manage, if set.}
		# enable_trace: ${11:no}
		# validate_certs: ${12:yes}
$0
endsnippet

snippet netapp_e_storagepool "Manage disk groups and disk pools" b
- name: $1
	netapp_e_storagepool:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		raid_level: ${5:raidAll|raid0|raid1|raid3|raid5|raid6|raidDiskPool}
		name: ${6:# The name of the storage pool to manage}
		state: ${7:present|absent}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		# criteria_min_usable_capacity: ${9:# The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.}
		# criteria_drive_min_size: ${10:# The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.}
		# remove_volumes: ${11:no}
		# criteria_drive_type: ${12:hdd|ssd}
		# reserve_drive_count: ${13:# Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.}
		# criteria_size_unit: ${14:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# criteria_drive_require_fde: ${15:# Whether full disk encryption ability is required for drives to be added to the storage pool}
		# criteria_drive_interface_type: ${16:sas|sas4k|fibre|fibre520b|scsi|sata|pata}
		# secure_pool: ${17:true|false}
		# criteria_drive_count: ${18:# The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place}
		# validate_certs: ${19:yes}
		# erase_secured_drives: ${20:true|false}
$0
endsnippet

snippet netapp_e_volume "Manage storage volumes (standard and thin)" b
- name: $1
	netapp_e_volume:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		name: ${5:# The name of the volume to manage}
		state: ${6:present|absent}
		storage_pool_name: ${7:# Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		thin_volume_repo_size: ${9:# Initial size of the thin volume repository volume (in size_unit)}
		size: ${10:# Required only when state = 'present'.  The size of the volume in (size_unit).}
		# segment_size_kb: ${11:512}
		# thin_provision: ${12:yes|no|true|false}
		# ssd_cache_enabled: ${13:yes|no|true|false}
		# data_assurance_enabled: ${14:no}
		# size_unit: ${15:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# thin_volume_max_repo_size: ${16:same as size (in size_unit)}
		# validate_certs: ${17:yes}
$0
endsnippet

snippet netapp_e_volume_copy "Create volume copy pairs" b
- name: $1
	netapp_e_volume_copy:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		state: ${5:present|absent}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		# source_volume_id: ${7:# The id of the volume copy source.}
		# destination_volume_id: ${8:# The id of the volume copy destination.}
		# start_stop_copy: ${9:# starts a re-copy or stops a copy in progress}
		# create_copy_pair_if_does_not_exist: ${10:#True|False}
		# search_volume_id: ${11:# Searches for all valid potential target and source volumes that could be used in a copy_pair}
		# volume_copy_pair_id: ${12:# The id of a given volume copy pair}
		# validate_certs: ${13:yes}
$0
endsnippet

snippet sf_account_manager "Manage SolidFire accounts" b
- name: $1
	sf_account_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# Unique username for this account. (May be 1 to 64 characters in length).}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# new_name: ${7:# New name for the user account.}
		# target_secret: ${8:# CHAP secret to use for the target (mutual CHAP authentication).}
		# initiator_secret: ${9:# CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.}
		# status: ${10:# Status of the account.}
		# attributes: ${11:# L}
		# account_id: ${12:# The ID of the account to manage or update.}
$0
endsnippet

snippet sf_check_connections "Check connectivity to MVIP and SVIP." b
- name: $1
	sf_check_connections:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		password: ${4:# Password for the specified user.}
		# svip: ${5:# Optionally, use to test connection of a different SVIP.}
		# skip: ${6:svip|mvip}
		# mvip: ${7:# Optionally, use to test connection of a different MVIP.}
$0
endsnippet

snippet sf_snapshot_schedule_manager "Manage SolidFire snapshot schedules" b
- name: $1
	sf_snapshot_schedule_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# Name for the snapshot schedule.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# time_interval_days: ${7:1}
		# time_interval_minutes: ${8:0}
		# schedule_id: ${9:# The schedule ID for the schedule that you want to update or delete.}
		# time_interval_hours: ${10:0}
		# paused: ${11:# Pause / Resume a schedule.}
		# snapshot_name: ${12:# Name for the created snapshots.}
		# volumes: ${13:# Volume IDs that you want to set the snapshot schedule for.}
		# starting_date: ${14:# Starting date for the schedule.}
		# recurring: ${15:# Should the schedule recur?}
		# retention: ${16:# Retention period for the snapshot.}
$0
endsnippet

snippet sf_volume_access_group_manager "Manage SolidFire Volume Access Groups" b
- name: $1
	sf_volume_access_group_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# Name of the volume access group. It is not required to be unique, but recommended.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# volume_access_group_id: ${7:# The ID of the volume access group to modify or delete.}
		# virtual_network_id: ${8:# The ID of the SolidFire Virtual Network ID to associate the volume access group with.}
		# volumes: ${9:# List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.}
		# initiators: ${10:# List of initiators to include in the volume access group. If unspecified, the access group will start out without configured initiators.}
		# attributes: ${11:# L}
		# virtual_network_tags: ${12:# The ID of the VLAN Virtual Network Tag to associate the volume access group with.}
$0
endsnippet

snippet sf_volume_manager "Manage SolidFire volumes" b
- name: $1
	sf_volume_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# The name of the volume to manage.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		account_id: ${7:# Account ID for the owner of this volume.}
		# qos: ${8:# I}
		# size_unit: ${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		# access: ${10:readOnly|readWrite|locked|replicationTarget}
		# size: ${11:# The size of the volume in (size_unit).}
		# volume_id: ${12:# The ID of the volume to manage or update.}
		# 512emulation: ${13:# Should the volume provide 512-byte sector emulation?}
		# attributes: ${14:# A}
$0
endsnippet

snippet purefa_hg "Manage hostgroups on Pure Storage FlashArrays" b
- name: $1
	purefa_hg:
		api_token: ${2:# FlashArray API token for admin privilaged user.}
		hostgroup: ${3:# The name of the hostgroup.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# volume: ${5:# List of existing volumes to add to hostgroup.}
		# state: ${6:absent|#present}
		# host: ${7:# List of existing hosts to add to hostgroup.}
$0
endsnippet

snippet purefa_host "Manage hosts on Pure Storage FlashArrays" b
- name: $1
	purefa_host:
		host: ${2:# The name of the host.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# protocol: ${5:fc|#iscsi}
		# volume: ${6:# Volume name to map to the host.}
		# state: ${7:absent|#present}
		# iqn: ${8:# List of IQNs of the host if protocol is iscsi.}
		# wwns: ${9:# List of wwns of the host if protocol is fc.}
$0
endsnippet

snippet purefa_pg "Manage protection groups on Pure Storage FlashArrays" b
- name: $1
	purefa_pg:
		pgroup: ${2:# The name of the protection group.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# enabled: ${5:yes}
		# state: ${6:absent|#present}
		# hostgroup: ${7:# List of existing hostgroups to add to protection group.}
		# volume: ${8:# List of existing volumes to add to protection group.}
		# host: ${9:# List of existing hosts to add to protection group.}
		# eradicate: ${10:no}
$0
endsnippet

snippet purefa_snap "Manage volume snapshots on Pure Storage FlashArrays" b
- name: $1
	purefa_snap:
		name: ${2:# The name of the source volume.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# suffix: ${5:# Suffix of snapshot name.}
		# state: ${6:absent|copy|#present}
		# eradicate: ${7:no}
		# target: ${8:# Name of target volume if creating from snapshot.}
		# overwrite: ${9:no}
$0
endsnippet

snippet purefa_volume "Manage volumes on Pure Storage FlashArrays" b
- name: $1
	purefa_volume:
		name: ${2:# The name of the volume.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# eradicate: ${5:no}
		# state: ${6:absent|#present}
		# size: ${7:# Volume size in M, G, T or P units.}
		# target: ${8:# The name of the target volume, if copying.}
		# overwrite: ${9:no}
$0
endsnippet

snippet zfs "Manage zfs" b
- name: $1
	zfs:
		state: ${2:present|absent}
		name: ${3:# File system, snapshot or volume name e.g. C(rpool/myfs)}
		# origin: ${4:# Snapshot from which to create a clone}
		# key_value: ${5:# The C(zfs) module takes key=value pairs for zfs properties to be set. See the zfs(8) man page for more information.}
$0
endsnippet

snippet zfs_facts "Gather facts about ZFS datasets." b
- name: $1
	zfs_facts:
		name: ${2:# ZFS dataset name.}
		# parsable: ${3:no}
		# depth: ${4:# Specifiies recurion depth.}
		# type: ${5:#all|filesystem|volume|snapshot|bookmark}
		# recurse: ${6:no}
		# properties: ${7:all}
$0
endsnippet

snippet zpool_facts "Gather facts about ZFS pools." b
- name: $1
	zpool_facts:
		# parsable: ${2:no}
		# name: ${3:# ZFS pool name.}
		# properties: ${4:all}
$0
endsnippet

snippet aix_inittab "Manages the inittab on AIX." b
- name: $1
	aix_inittab:
		action: ${2:respawn|wait|once|boot|bootwait|powerfail|powerwait|off|hold|ondemand|initdefault|sysinit}
		command: ${3:# What command has to run.}
		name: ${4:# Name of the inittab entry.}
		runlevel: ${5:# Runlevel of the entry.}
		# state: ${6:#present|absent}
		# insertafter: ${7:# After which inittabline should the new entry inserted.}
$0
endsnippet

snippet aix_lvol "Configure AIX LVM logical volumes" b
- name: $1
	aix_lvol:
		vg: ${2:# The volume group this logical volume is part of.}
		lv: ${3:# The name of the logical volume.}
		# pvs: ${4:# Comma separated list of physical volumes e.g. C(hdisk1,hdisk2).}
		# lv_type: ${5:jfs2}
		# copies: ${6:1}
		# state: ${7:absent|#present}
		# policy: ${8:#maximum|minimum}
		# opts: ${9:# Free-form options to be passed to the mklv command.}
		# size: ${10:# The size of the logical volume with one of the [MGT] units.}
$0
endsnippet

snippet alternatives "Manages alternative programs for common commands" b
- name: $1
	alternatives:
		path: ${2:# The path to the real executable that the link should point to.}
		name: ${3:# The generic name of the link.}
		# priority: ${4:50}
		# link: ${5:# The path to the symbolic link that should point to the real executable.}
$0
endsnippet

snippet at "Schedule the execution of a command or script file via the at command." b
- name: $1
	at:
		count: ${2:# The count of units in the future to execute the command or script file.}
		units: ${3:minutes|hours|days|weeks}
		# state: ${4:#present|absent}
		# command: ${5:# A command to be executed in the future.}
		# unique: ${6:no}
		# script_file: ${7:# An existing script file to be executed in the future.}
$0
endsnippet

snippet authorized_key "Adds or removes an SSH authorized key" b
- name: $1
	authorized_key:
		user: ${2:# The username on the remote host whose authorized_keys file will be modified}
		key: ${3:# The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)}
		# comment: ${4:# Change the comment on the public key. Rewriting the comment is useful in cases such as fetching it from GitHub or GitLab.}
		# exclusive: ${5:yes|#no}
		# key_options: ${6:# A string of ssh key options to be prepended to the key in the authorized_keys file}
		# state: ${7:#present|absent}
		# path: ${8:(homedir)+/.ssh/authorized_keys}
		# validate_certs: ${9:#yes|no}
		# manage_dir: ${10:#yes|no}
$0
endsnippet

snippet awall "Manage awall policies" b
- name: $1
	awall:
		# state: ${2:#enabled|disabled}
		# activate: ${3:no}
		# name: ${4:# A policy name, like C(foo), or multiple policies, like C(foo, bar).}
$0
endsnippet

snippet beadm "Manage ZFS boot environments on FreeBSD/Solaris/illumos systems." b
- name: $1
	beadm:
		name: ${2:# ZFS boot environment name.}
		# state: ${3:#present|absent|activated|mounted|unmounted}
		# force: ${4:true|false}
		# mountpoint: ${5:no}
		# snapshot: ${6:no}
		# options: ${7:no}
		# description: ${8:no}
$0
endsnippet

snippet capabilities "Manage Linux capabilities" b
- name: $1
	capabilities:
		capability: ${2:# Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))}
		path: ${3:# Specifies the path to the file to be managed.}
		# state: ${4:#present|absent}
$0
endsnippet

snippet cron "Manage cron.d and crontab entries." b
- name: $1
	cron:
		# cron_file: ${2:# If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens. To use the C(cron_file) parameter you must specify the C(user) as well.}
		# month: ${3:*}
		# disabled: ${4:no}
		# job: ${5:# The command to execute or, if env is set, the value of environment variable. The command should not contain line breaks. Required if state=present.}
		# special_time: ${6:reboot|yearly|annually|monthly|weekly|daily|hourly}
		# user: ${7:root}
		# insertafter: ${8:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable.}
		# insertbefore: ${9:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable.}
		# day: ${10:*}
		# minute: ${11:*}
		# name: ${12:# Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.}
		# hour: ${13:*}
		# reboot: ${14:yes|#no}
		# state: ${15:#present|absent}
		# weekday: ${16:*}
		# env: ${17:yes|#no}
		# backup: ${18:yes|no}
$0
endsnippet

snippet cronvar "Manage variables in crontabs" b
- name: $1
	cronvar:
		name: ${2:# Name of the crontab variable.}
		# insertbefore: ${3:# Used with C(state=present). If specified, the variable will be inserted just before the variable specified.}
		# cron_file: ${4:# If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.}
		# value: ${5:# The value to set this variable to.  Required if state=present.}
		# state: ${6:#present|absent}
		# user: ${7:root}
		# insertafter: ${8:# Used with C(state=present). If specified, the variable will be inserted after the variable specified.}
		# backup: ${9:no}
$0
endsnippet

snippet crypttab "Encrypted Linux block devices" b
- name: $1
	crypttab:
		state: ${2:present|absent|opts_present|opts_absent}
		name: ${3:# Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).}
		# backing_device: ${4:# Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=)}
		# path: ${5:/etc/crypttab}
		# password: ${6:none}
		# opts: ${7:# A comma-delimited list of options. See C(crypttab(5) ) for details.}
$0
endsnippet

snippet dconf "Modify and read dconf database" b
- name: $1
	dconf:
		key: ${2:# A dconf key to modify or read from the dconf database.}
		# state: ${3:read|#present|absent}
		# value: ${4:# Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present).}
$0
endsnippet

snippet debconf "Configure a .deb package" b
- name: $1
	debconf:
		name: ${2:# Name of package to configure.}
		# value: ${3:# Value to set the configuration to}
		# vtype: ${4:string|password|boolean|select|multiselect|note|error|title|text|seen}
		# question: ${5:# A debconf configuration setting}
		# unseen: ${6:no}
$0
endsnippet

snippet facter "Runs the discovery program I(facter) on the remote system" b
- name: $1
	facter:
$0
endsnippet

snippet filesystem "Makes file system on block device" b
- name: $1
	filesystem:
		dev: ${2:# Target block device.}
		fstype: ${3:# File System type to be created.}
		# resizefs: ${4:yes|#no}
		# force: ${5:yes|#no}
		# opts: ${6:# List of options to be passed to mkfs command.}
$0
endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld" b
- name: $1
	firewalld:
		state: ${2:enabled|disabled}
		# zone: ${3:work|drop|internal|external|trusted|home|dmz|public|block}
		# service: ${4:# Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.}
		# masquerade: ${5:# The masquerade setting you would like to enable/disable to/from zones within firewalld}
		# immediate: ${6:no}
		# source: ${7:# The source/network you would like to add/remove to/from firewalld}
		# permanent: ${8:# Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9). (NOTE: If this is false, immediate is assumed true.)
}
		# timeout: ${9:0}
		# interface: ${10:# The interface you would like to add/remove to/from a zone in firewalld}
		# port: ${11:# Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.}
		# rich_rule: ${12:# Rich rule to add/remove to/from firewalld.}
$0
endsnippet

snippet gconftool2 "Edit GNOME Configurations" b
- name: $1
	gconftool2:
		state: ${2:get|present|absent}
		key: ${3:# A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)}
		# value_type: ${4:int|bool|float|string}
		# direct: ${5:yes|no}
		# value: ${6:# Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)}
		# config_source: ${7:# Specify a configuration source to use rather than the default path. See man gconftool-2(1)}
$0
endsnippet

snippet getent "a wrapper to the unix getent utility" b
- name: $1
	getent:
		database: ${2:# the name of a getent database supported by the target system (passwd, group, hosts, etc).}
		# fail_key: ${3:yes}
		# split: ${4:# character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database}
		# key: ${5:}
$0
endsnippet

snippet gluster_volume "Manage GlusterFS volumes" b
- name: $1
	gluster_volume:
		name: ${2:# The volume name}
		state: ${3:present|absent|started|stopped}
		# force: ${4:# If brick is being created in the root partition, module will fail. Set force to true to override this behaviour.}
		# replicas: ${5:# Replica count for volume}
		# bricks: ${6:# Brick paths on servers. Multiple brick paths can be separated by commas.}
		# quota: ${7:# Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list)}
		# stripes: ${8:# Stripe count for volume}
		# cluster: ${9:# List of hosts to use for probing and brick setup}
		# host: ${10:# Override local hostname (for peer probing purposes)}
		# arbiter: ${11:# Arbiter count for volume}
		# redundancies: ${12:# Redundancy count for volume}
		# transport: ${13:#tcp|rdma|tcp,rdma}
		# disperses: ${14:# Disperse count for volume}
		# directory: ${15:# Directory for limit-usage}
		# start_on_create: ${16:yes}
		# rebalance: ${17:no}
		# options: ${18:# A dictionary/hash with options/settings for the volume}
$0
endsnippet

snippet group "Add or remove groups" b
- name: $1
	group:
		name: ${2:# Name of the group to manage.}
		# state: ${3:#present|absent}
		# gid: ${4:# Optional I(GID) to set for the group.}
		# system: ${5:yes|#no}
$0
endsnippet

snippet hostname "Manage hostname" b
- name: $1
	hostname:
		name: ${2:# Name of the host}
$0
endsnippet

snippet interfaces_file "Tweak settings in /etc/network/interfaces files" b
- name: $1
	interfaces_file:
		# iface: ${2:# Name of the interface, required for value changes or option remove}
		# group: ${3:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		# option: ${4:# Name of the option, required for value changes or option remove}
		# state: ${5:#present|absent}
		# unsafe_writes: ${6:no}
		# selevel: ${7:s0}
		# seuser: ${8:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		# serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		# value: ${10:# If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported}
		# dest: ${11:/etc/network/interfaces}
		# setype: ${12:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		# mode: ${13:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		# owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		# attributes: ${15:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		# backup: ${16:yes|#no}
$0
endsnippet

snippet iptables "Modify the systems iptables" b
- name: $1
	iptables:
		# tcp_flags: ${2:{}}
		# comment: ${3:# This specifies a comment that will be added to the rule.}
		# log_prefix: ${4:# Specifies a log text for the rule. Only make sense with a LOG jump.}
		# protocol: ${5:# The protocol of the rule or of the packet to check.}
		# chain: ${6:# Chain to operate on.}
		# out_interface: ${7:# Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
		# limit_burst: ${8:# Specifies the maximum burst before the above limit kicks in.}
		# ctstate: ${9:[DNAT, ESTABLISHED, INVALID, NEW, RELATED, SNAT, UNTRACKED}
		# jump: ${10:# This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.}
		# to_ports: ${11:# This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.}
		# flush: ${12:# Flushes the specified table and chain of all rules.}
		# table: ${13:#filter|nat|mangle|raw|security}
		# icmp_type: ${14:# This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'}
		# to_destination: ${15:# This specifies a destination address to use with DNAT.}
		# uid_owner: ${16:# Specifies the UID or username to use in match by owner rule.}
		# set_dscp_mark_class: ${17:# This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.}
		# destination: ${18:# Destination specification.}
		# state: ${19:absent|#present}
		# source: ${20:# Source specification.}
		# set_dscp_mark: ${21:# This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.}
		# policy: ${22:ACCEPT|DROP|QUEUE|RETURN}
		# set_counters: ${23:# This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).}
		# match: ${24:[]}
		# goto: ${25:# This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.}
		# fragment: ${26:# This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.}
		# to_source: ${27:# This specifies a source address to use with SNAT.}
		# syn: ${28:#ignore|match|negate}
		# in_interface: ${29:# Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
		# source_port: ${30:# Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
		# destination_port: ${31:# Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
		# reject_with: ${32:# Specifies the error packet type to return while rejecting.}
		# limit: ${33:# Specifies the maximum average number of matches to allow per second.}
		# action: ${34:#append|insert}
		# ip_version: ${35:#ipv4|ipv6}
$0
endsnippet

snippet java_cert "Uses keytool to import/remove key from java keystore(cacerts)" b
- name: $1
	java_cert:
		keystore_pass: ${2:# Keystore password.}
		# keystore_create: ${3:# Create keystore if it doesn't exist}
		# cert_alias: ${4:# Imported certificate alias.}
		# executable: ${5:keytool}
		# pkcs12_password: ${6:}
		# cert_port: ${7:443}
		# pkcs12_alias: ${8:1}
		# state: ${9:#present|absent}
		# pkcs12_path: ${10:# Local path to load PKCS12 keystore from.}
		# cert_url: ${11:# Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate.}
		# cert_path: ${12:# Local path to load certificate from. One of cert_url or cert_path is required to load certificate.}
		# keystore_path: ${13:# Path to keystore.}
$0
endsnippet

snippet kernel_blacklist "Blacklist kernel modules" b
- name: $1
	kernel_blacklist:
		name: ${2:# Name of kernel module to black- or whitelist.}
		# blacklist_file: ${3:# If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).}
		# state: ${4:#present|absent}
$0
endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file" b
- name: $1
	known_hosts:
		name: ${2:# The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.}
		# path: ${3:(homedir)+/.ssh/known_hosts}
		# state: ${4:#present|absent}
		# hash_host: ${5:no}
		# key: ${6:# The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(8), section "SSH_KNOWN_HOSTS FILE FORMAT")}
$0
endsnippet

snippet locale_gen "Creates or removes locales." b
- name: $1
	locale_gen:
		name: ${2:# Name and encoding of the locale, such as "en_GB.UTF-8".}
		# state: ${3:#present|absent}
$0
endsnippet

snippet lvg "Configure LVM volume groups" b
- name: $1
	lvg:
		vg: ${2:# The name of the volume group.}
		# vg_options: ${3:# Additional options to pass to C(vgcreate) when creating the volume group.}
		# pvs: ${4:# List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.}
		# force: ${5:yes|#no}
		# pesize: ${6:4}
		# pv_options: ${7:# Additional options to pass to C(pvcreate) when creating the volume group.}
		# state: ${8:#present|absent}
$0
endsnippet

snippet lvol "Configure LVM logical volumes" b
- name: $1
	lvol:
		vg: ${2:# The volume group this logical volume is part of.}
		lv: ${3:# The name of the logical volume.}
		# pvs: ${4:# Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb}
		# force: ${5:yes|#no}
		# state: ${6:#present|absent}
		# snapshot: ${7:# The name of the snapshot volume}
		# active: ${8:#yes|no}
		# shrink: ${9:yes}
		# opts: ${10:# Free-form options to be passed to the lvcreate command}
		# size: ${11:# The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.}
$0
endsnippet

snippet make "Run targets in a Makefile" b
- name: $1
	make:
		chdir: ${2:# cd into this directory before running make}
		# params: ${3:none}
		# target: ${4:none}
$0
endsnippet

snippet modprobe "Add or remove kernel modules" b
- name: $1
	modprobe:
		name: ${2:# Name of kernel module to manage.}
		# state: ${3:#present|absent}
		# params: ${4:}
$0
endsnippet

snippet mount "Control active and configured mount points" b
- name: $1
	mount:
		state: ${2:present|absent|mounted|unmounted}
		path: ${3:# Path to the mount point (e.g. C(/mnt/files)).}
		# src: ${4:# Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted).}
		# dump: ${5:0}
		# passno: ${6:0}
		# fstab: ${7:/etc/fstab (/etc/vfstab on Solaris)}
		# boot: ${8:yes|no}
		# fstype: ${9:# Filesystem type. Required when I(state) is C(present) or C(mounted).}
		# opts: ${10:# Mount options (see fstab(5), or vfstab(4) on Solaris).}
$0
endsnippet

snippet ohai "Returns inventory data from I(Ohai)" b
- name: $1
	ohai:
$0
endsnippet

snippet open_iscsi "Manage iscsi targets with open-iscsi" b
- name: $1
	open_iscsi:
		# auto_node_startup: ${2:True|False}
		# target: ${3:# the iscsi target name}
		# show_nodes: ${4:True|False}
		# node_auth: ${5:CHAP}
		# node_pass: ${6:# discovery.sendtargets.auth.password}
		# discover: ${7:True|False}
		# portal: ${8:# the ip address of the iscsi target}
		# login: ${9:True|False}
		# node_user: ${10:# discovery.sendtargets.auth.username}
		# port: ${11:3260}
$0
endsnippet

snippet openwrt_init "Manage services on OpenWrt." b
- name: $1
	openwrt_init:
		name: ${2:# Name of the service.}
		# pattern: ${3:# If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.}
		# state: ${4:started|stopped|restarted|reloaded}
		# enabled: ${5:yes|no}
$0
endsnippet

snippet osx_defaults "osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible" b
- name: $1
	osx_defaults:
		key: ${2:# The key of the user preference}
		# domain: ${3:NSGlobalDomain}
		# array_add: ${4:true|false}
		# host: ${5:# The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.}
		# type: ${6:array|bool|boolean|date|float|int|integer|#string}
		# state: ${7:#present|absent}
		# value: ${8:# The value to write. Only required when state = present.}
$0
endsnippet

snippet pam_limits "Modify Linux PAM limits" b
- name: $1
	pam_limits:
		domain: ${2:# A username, @groupname, wildcard, uid/gid range.}
		value: ${3:# The value of the limit.}
		limit_item: ${4:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
		limit_type: ${5:hard|soft|-}
		# comment: ${6:}
		# use_max: ${7:yes|#no}
		# dest: ${8:/etc/security/limits.conf}
		# use_min: ${9:yes|#no}
		# backup: ${10:yes|#no}
$0
endsnippet

snippet pamd "Manage PAM Modules" b
- name: $1
	pamd:
		control: ${2:# The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.}
		name: ${3:# The name generally refers to the PAM service file to change, for example system-auth.}
		module_path: ${4:# The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		type: ${5:# The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		# new_module_path: ${6:# The new module path to be assigned to the new rule.}
		# new_type: ${7:# The new type to assign to the new rule.}
		# state: ${8:#updated|before|after|args_present|args_absent|absent}
		# new_control: ${9:# The new control to assign to the new rule.}
		# path: ${10:/etc/pam.d/}
		# module_arguments: ${11:# When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.}
$0
endsnippet

snippet parted "Configure block device partitions" b
- name: $1
	parted:
		device: ${2:# T}
		# part_start: ${3:0%}
		# part_end: ${4:100%}
		# name: ${5:# Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).}
		# align: ${6:none|cylinder|minimal|#optimal}
		# number: ${7:# The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.}
		# label: ${8:aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun}
		# state: ${9:present|absent|#info}
		# part_type: ${10:#primary|extended|logical}
		# flags: ${11:# A}
		# unit: ${12:s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact}
$0
endsnippet

snippet ping "Try to connect to host, verify a usable python and return C(pong) on success" b
- name: $1
	ping:
		# data: ${2:pong}
$0
endsnippet

snippet puppet "Runs puppet" b
- name: $1
	puppet:
		# logdest: ${2:#stdout|syslog}
		# execute: ${3:# Execute a specific piece of Puppet code. It has no effect with a puppetmaster.}
		# facter_basename: ${4:ansible}
		# tags: ${5:# A comma-separated list of puppet tags to be used.}
		# puppetmaster: ${6:# The hostname of the puppetmaster to contact.}
		# certname: ${7:# The name to use when handling certificates.}
		# manifest: ${8:# Path to the manifest file to run puppet apply on.}
		# environment: ${9:# Puppet environment to be used.}
		# timeout: ${10:30m}
		# facts: ${11:# A dict of values to pass in as persistent external facter facts}
		# modulepath: ${12:# Path to an alternate location for puppet modules}
$0
endsnippet

snippet runit "Manage runit services." b
- name: $1
	runit:
		name: ${2:# Name of the service to manage.}
		# state: ${3:started|stopped|restarted|killed|reloaded|once}
		# enabled: ${4:yes|no}
		# service_dir: ${5:/var/service}
		# service_src: ${6:/etc/sv}
$0
endsnippet

snippet seboolean "Toggles SELinux booleans." b
- name: $1
	seboolean:
		state: ${2:yes|no}
		name: ${3:# Name of the boolean to configure}
		# persistent: ${4:yes|no}
$0
endsnippet

snippet sefcontext "Manages SELinux file context mapping definitions" b
- name: $1
	sefcontext:
		setype: ${2:# SELinux type for the specified target.}
		target: ${3:# Target path (expression).}
		# reload: ${4:yes}
		# ftype: ${5:a}
		# selevel: ${6:# SELinux range for the specified target.}
		# seuser: ${7:# SELinux user for the specified target.}
		# state: ${8:absent|#present}
$0
endsnippet

snippet selinux "Change policy and state of SELinux" b
- name: $1
	selinux:
		state: ${2:enforcing|permissive|disabled}
		# policy: ${3:# name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)}
		# conf: ${4:/etc/selinux/config}
$0
endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy" b
- name: $1
	selinux_permissive:
		domain: ${2:# the domain that will be added or removed from the list of permissive domains}
		permissive: ${3:True|False}
		# no_reload: ${4:True|False}
		# store: ${5:# name of the SELinux policy store to use}
$0
endsnippet

snippet seport "Manages SELinux network port type definitions" b
- name: $1
	seport:
		setype: ${2:# SELinux type for the specified port.}
		proto: ${3:tcp|udp}
		state: ${4:#present|absent}
		ports: ${5:# Ports or port ranges, separated by a comma}
		# reload: ${6:yes}
$0
endsnippet

snippet service "Manage services." b
- name: $1
	service:
		name: ${2:# Name of the service.}
		# use: ${3:auto}
		# pattern: ${4:# If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.}
		# enabled: ${5:yes|no}
		# state: ${6:started|stopped|restarted|reloaded}
		# sleep: ${7:# If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.}
		# arguments: ${8:# Additional arguments provided on the command line}
		# runlevel: ${9:default}
$0
endsnippet

snippet setup "Gathers facts about remote hosts" b
- name: $1
	setup:
		# filter: ${2:*}
		# gather_subset: ${3:all}
		# fact_path: ${4:/etc/ansible/facts.d}
		# gather_timeout: ${5:10}
$0
endsnippet

snippet solaris_zone "Manage Solaris zones" b
- name: $1
	solaris_zone:
		name: ${2:# Zone name.}
		state: ${3:#present|installed|started|running|stopped|absent|configured|attached|detached}
		# install_options: ${4:empty string}
		# sparse: ${5:no}
		# create_options: ${6:empty string}
		# root_password: ${7:# The password hash for the root account. If not specified, the zone's root account will not have a password.}
		# timeout: ${8:600}
		# path: ${9:# The path where the zone will be created. This is required when the zone is created, but not used otherwise.}
		# config: ${10:empty string}
		# attach_options: ${11:empty string}
$0
endsnippet

snippet svc "Manage daemontools services." b
- name: $1
	svc:
		name: ${2:# Name of the service to manage.}
		# service_dir: ${3:/service}
		# downed: ${4:yes|no}
		# enabled: ${5:yes|no}
		# state: ${6:started|stopped|restarted|reloaded|once|killed}
		# service_src: ${7:# directory where services are defined, the source of symlinks to service_dir.}
$0
endsnippet

snippet sysctl "Manage entries in sysctl.conf." b
- name: $1
	sysctl:
		name: ${2:# The dot-separated path (aka I(key)) specifying the sysctl variable.}
		# reload: ${3:#yes|no}
		# state: ${4:#present|absent}
		# sysctl_set: ${5:yes|no}
		# ignoreerrors: ${6:yes|no}
		# sysctl_file: ${7:/etc/sysctl.conf}
		# value: ${8:# Desired value of the sysctl key.}
$0
endsnippet

snippet systemd "Manage services." b
- name: $1
	systemd:
		# masked: ${2:yes|no}
		# state: ${3:started|stopped|restarted|reloaded}
		# no_block: ${4:yes|no}
		# name: ${5:# Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service).}
		# enabled: ${6:yes|no}
		# daemon_reload: ${7:yes|no}
		# user: ${8:yes|no}
$0
endsnippet

snippet timezone "Configure timezone setting" b
- name: $1
	timezone:
		# hwclock: ${2:# Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS. B(At least one of name and hwclock are required.) I(Only used on Linux.)}
		# name: ${3:# Name of the timezone for the system clock. Default is to keep current setting. B(At least one of name and hwclock are required.)}
$0
endsnippet

snippet ufw "Manage firewall with UFW" b
- name: $1
	ufw:
		# comment: ${2:# Add a comment to the rule. Requires UFW version >=0.35.}
		# direction: ${3:in|out|incoming|outgoing|routed}
		# from_port: ${4:# Source port.}
		# to_ip: ${5:any}
		# to_port: ${6:# Destination port.}
		# from_ip: ${7:any}
		# interface: ${8:# Specify interface for rule.}
		# name: ${9:# Use profile located in C(/etc/ufw/applications.d)}
		# insert: ${10:# Insert the corresponding rule as rule number NUM}
		# logging: ${11:on|off|low|medium|high|full}
		# log: ${12:yes|no}
		# proto: ${13:any|tcp|udp|ipv6|esp|ah}
		# route: ${14:yes|no}
		# rule: ${15:allow|deny|reject|limit}
		# state: ${16:enabled|disabled|reloaded|reset}
		# policy: ${17:allow|deny|reject}
		# delete: ${18:yes|no}
$0
endsnippet

snippet user "Manage user accounts" b
- name: $1
	user:
		name: ${2:# Name of the user to create, remove or modify.}
		# comment: ${3:# Optionally sets the description (aka I(GECOS)) of user account.}
		# ssh_key_bits: ${4:default set by ssh-keygen}
		# update_password: ${5:#always|on_create}
		# non_unique: ${6:yes|#no}
		# force: ${7:yes|#no}
		# ssh_key_type: ${8:rsa}
		# expires: ${9:# An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux and FreeBSD.}
		# ssh_key_passphrase: ${10:# Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.}
		# groups: ${11:# Puts the user in  list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.}
		# home: ${12:# Optionally set the user's home directory.}
		# move_home: ${13:yes|#no}
		# password: ${14:# Optionally set the user's password to this crypted value.  See the user example in the github examples directory for what this looks like in a playbook. See U(http://docs.ansible.com/ansible/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module) for details on various ways to generate these password values. Note on Darwin system, this value has to be cleartext. Beware of security issues.}
		# skeleton: ${15:# Optionally set a home skeleton directory. Requires createhome option!}
		# generate_ssh_key: ${16:yes|#no}
		# append: ${17:yes|#no}
		# uid: ${18:# Optionally sets the I(UID) of the user.}
		# ssh_key_comment: ${19:ansible-generated on $HOSTNAME}
		# group: ${20:# Optionally sets the user's primary group (takes a group name).}
		# createhome: ${21:#yes|no}
		# system: ${22:yes|#no}
		# remove: ${23:yes|#no}
		# seuser: ${24:# Optionally sets the seuser type (user_u) on selinux enabled systems.}
		# state: ${25:#present|absent}
		# ssh_key_file: ${26:.ssh/id_rsa}
		# login_class: ${27:# Optionally sets the user's login class for FreeBSD, OpenBSD and NetBSD systems.}
		# shell: ${28:# Optionally set the user's shell.}
		# local: ${29:False}
$0
endsnippet

snippet meta "Execute Ansible 'actions'" b
- name: $1
	meta: $2
	args:
$0
endsnippet

snippet assert "Asserts given expressions are true" b
- name: $1
	assert:
		that: ${2:# A string expression of the same form that can be passed to the 'when' statement}
		# msg: ${3:# The customized message used for a failing assertion}
$0
endsnippet

snippet async_status "Obtain status of asynchronous task" b
- name: $1
	async_status:
		jid: ${2:# Job or task identifier}
		# mode: ${3:#status|cleanup}
$0
endsnippet

snippet debug "Print statements during execution" b
- name: $1
	debug:
		# msg: ${2:Hello world!}
		# var: ${3:# A variable name to debug.  Mutually exclusive with the 'msg' option.}
		# verbosity: ${4:0}
$0
endsnippet

snippet fail "Fail with custom message" b
- name: $1
	fail:
		# msg: ${2:'Failed as requested from task'}
$0
endsnippet

snippet import_plays "import a playbook." b
- name: $1
	import_plays:
		# free-form: ${2:# This action allows you to specify the name of the file directly w/o any other options.}
$0
endsnippet

snippet import_role "Import a role into a play" b
- name: $1
	import_role:
		name: ${2:# The name of the role to be executed.}
		# allow_duplicates: ${3:yes}
		# tasks_from: ${4:main}
		# vars_from: ${5:main}
		# defaults_from: ${6:main}
		# private: ${7:# If True the variables from defaults/ and vars/ in a role will not be made available to the rest of the play.}
$0
endsnippet

snippet import_tasks "import a task list." b
- name: $1
	import_tasks:
		# free-form: ${2:# This action allows you to specify the name of the file directly w/o any other options.}
$0
endsnippet

snippet include_role "Load and execute a role" b
- name: $1
	include_role:
		name: ${2:# The name of the role to be executed.}
		# allow_duplicates: ${3:yes}
		# tasks_from: ${4:main}
		# vars_from: ${5:main}
		# defaults_from: ${6:main}
		# private: ${7:# If True the variables from defaults/ and vars/ in a role will not be made available to the rest of the play.}
$0
endsnippet

snippet include_tasks "dynamically include a task list." b
- name: $1
	include_tasks:
		# free-form: ${2:# This action allows you to specify the name of the file directly w/o any other options.}
$0
endsnippet

snippet include_vars "Load variables from files, dynamically within a task." b
- name: $1
	include_vars:
		# ignore_files: ${2:# List of file names to ignore.}
		# free-form: ${3:# This module allows you to specify the 'file' option directly w/o any other options. There is no 'free-form' option, this is just an indicator, see example below.}
		# files_matching: ${4:# Limit the files that are loaded within any directory to this regular expression.}
		# depth: ${5:0}
		# extensions: ${6:[u'yaml', u'yml', u'json']}
		# file: ${7:# The file name from which variables should be loaded.}
		# dir: ${8:# The directory name from which the variables should be loaded.}
		# name: ${9:# The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars.}
$0
endsnippet

snippet pause "Pause playbook execution" b
- name: $1
	pause:
		# seconds: ${2:# A positive number of seconds to pause for.}
		# minutes: ${3:# A positive number of minutes to pause for.}
		# prompt: ${4:# Optional text to use for the prompt message.}
$0
endsnippet

snippet set_fact "Set host facts from a task" b
- name: $1
	set_fact:
		key_value: ${2:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}
		# cacheable: ${3:no}
$0
endsnippet

snippet set_stats "Set stats for the current ansible run" b
- name: $1
	set_stats:
		data: ${2:# A dictionary of which each key represents a stat (or variable) you want to keep track of}
		# aggregate: ${3:yes}
		# per_host: ${4:no}
$0
endsnippet

snippet wait_for "Waits for a condition before continuing" b
- name: $1
	wait_for:
		# active_connection_states: ${2:[u'ESTABLISHED', u'FIN_WAIT1', u'FIN_WAIT2', u'SYN_RECV', u'SYN_SENT', u'TIME_WAIT']}
		# host: ${3:127.0.0.1}
		# connect_timeout: ${4:5}
		# delay: ${5:0}
		# search_regex: ${6:# Can be used to match a string in either a file or a socket connection.}
		# state: ${7:absent|drained|present|#started|stopped}
		# sleep: ${8:1}
		# timeout: ${9:300}
		# exclude_hosts: ${10:# List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.}
		# msg: ${11:# This overrides the normal error message from a failure to meet the required conditions.}
		# path: ${12:# Path to a file on the filesystem that must exist before continuing.}
		# port: ${13:# Port number to poll.}
$0
endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable" b
- name: $1
	wait_for_connection:
		# delay: ${2:0}
		# sleep: ${3:1}
		# connect_timeout: ${4:5}
		# timeout: ${5:600}
$0
endsnippet

snippet apache2_mod_proxy "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool" b
- name: $1
	apache2_mod_proxy:
		balancer_vhost: ${2:# (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.}
		# tls: ${3:true|false}
		# member_host: ${4:# (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.}
		# validate_certs: ${5:true|false}
		# state: ${6:present|absent|enabled|disabled|drained|hot_standby|ignore_errors}
		# balancer_url_suffix: ${7:/balancer-manager/}
$0
endsnippet

snippet apache2_module "enables/disables a module of the Apache2 webserver" b
- name: $1
	apache2_module:
		name: ${2:# name of the module to enable/disable}
		# state: ${3:#present|absent}
		# force: ${4:True|False}
		# ignore_configcheck: ${5:True|False}
$0
endsnippet

snippet deploy_helper "Manages some of the steps common in deploying projects." b
- name: $1
	deploy_helper:
		path: ${2:# the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact.}
		# unfinished_filename: ${3:DEPLOY_UNFINISHED}
		# keep_releases: ${4:5}
		# current_path: ${5:current}
		# state: ${6:#present|finalize|absent|clean|query}
		# shared_path: ${7:shared}
		# releases_path: ${8:releases}
		# clean: ${9:yes}
		# release: ${10:# the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).}
$0
endsnippet

snippet django_manage "Manages a Django application." b
- name: $1
	django_manage:
		app_path: ${2:# The path to the root of the Django application where B(manage.py) lives.}
		command: ${3:cleanup|collectstatic|flush|loaddata|migrate|runfcgi|syncdb|test|validate}
		# virtualenv: ${4:# An optional path to a I(virtualenv) installation to use while running the manage application.}
		# settings: ${5:# The Python path to the application's settings module, such as 'myapp.settings'.}
		# pythonpath: ${6:# A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.}
		# database: ${7:# The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands.}
		# apps: ${8:# A list of space-delimited apps to target. Used by the 'test' command.}
		# cache_table: ${9:# The name of the table used for database-backed caching. Used by the 'createcachetable' command.}
		# merge: ${10:# Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command}
		# skip: ${11:# Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)}
		# link: ${12:# Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command}
		# fixtures: ${13:# A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command.}
		# failfast: ${14:yes|#no}
$0
endsnippet

snippet ejabberd_user "Manages users for ejabberd servers" b
- name: $1
	ejabberd_user:
		username: ${2:# the name of the user to manage}
		host: ${3:# the ejabberd host associated with this username}
		# password: ${4:# the password to assign to the username}
		# logging: ${5:true|false|yes|no}
		# state: ${6:#present|absent}
$0
endsnippet

snippet gunicorn "Run gunicorn with various settings." b
- name: $1
	gunicorn:
		app: ${2:# The app module. A name refers to a WSGI callable that should be found in the specified module.}
		# venv: ${3:# Path to the virtualenv directory.}
		# user: ${4:# Switch worker processes to run as this user.}
		# config: ${5:# Path to the gunicorn configuration file.}
		# worker: ${6:sync|eventlet|gevent|tornado |gthread|gaiohttp}
		# chdir: ${7:# Chdir to specified directory before apps loading.}
		# pid: ${8:# A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn.}
$0
endsnippet

snippet htpasswd "manage user files for basic authentication" b
- name: $1
	htpasswd:
		name: ${2:# User name to add or remove}
		path: ${3:# Path to the file that contains the usernames and passwords}
		# state: ${4:#present|absent}
		# create: ${5:#yes|no}
		# password: ${6:# Password associated with user.}
		# crypt_scheme: ${7:#apr_md5_crypt|des_crypt|ldap_sha1|plaintext}
$0
endsnippet

snippet jboss "deploy applications to JBoss" b
- name: $1
	jboss:
		deployment: ${2:# The name of the deployment}
		# src: ${3:# The remote path of the application ear or war to deploy}
		# deploy_path: ${4:/var/lib/jbossas/standalone/deployments}
		# state: ${5:#present|absent}
$0
endsnippet

snippet jenkins_job "Manage jenkins jobs" b
- name: $1
	jenkins_job:
		name: ${2:# Name of the Jenkins job.}
		# url: ${3:http://localhost:8080}
		# enabled: ${4:# Whether the job should be enabled or disabled.}
		# state: ${5:#present|absent}
		# token: ${6:# API token used to authenticate alternatively to password.}
		# user: ${7:# User to authenticate with the Jenkins server.}
		# password: ${8:# Password to authenticate with the Jenkins server.}
		# config: ${9:# config in XML format.}
$0
endsnippet

snippet jenkins_plugin "Add or remove Jenkins plugin" b
- name: $1
	jenkins_plugin:
		name: ${2:# Plugin name.}
		# jenkins_home: ${3:/var/lib/jenkins}
		# group: ${4:jenkins}
		# url: ${5:http://localhost:8080}
		# updates_url: ${6:https://updates.jenkins-ci.org}
		# with_dependencies: ${7:#yes|no}
		# state: ${8:absent|#present|pinned|unpinned|enabled|disabled|latest}
		# version: ${9:# Plugin version number.}
		# params: ${10:# Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).}
		# mode: ${11:0664}
		# timeout: ${12:30}
		# owner: ${13:jenkins}
		# updates_expiration: ${14:86400}
$0
endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance" b
- name: $1
	jenkins_script:
		script: ${2:# The groovy script to be executed. This gets passed as a string Template if args is defined.}
		# password: ${3:# The password to connect to the jenkins server with.}
		# user: ${4:# The username to connect to the jenkins server with.}
		# timeout: ${5:10}
		# url: ${6:http://localhost:8080}
		# args: ${7:# A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).}
		# validate_certs: ${8:yes}
$0
endsnippet

snippet jira "create and modify issues in a JIRA instance" b
- name: $1
	jira:
		username: ${2:# The username to log-in with.}
		operation: ${3:create|comment|edit|fetch|transition|link}
		password: ${4:# The password to log-in with.}
		uri: ${5:# Base URI for the JIRA instance.}
		# comment: ${6:# The comment text to add.}
		# description: ${7:# The issue description, where appropriate.}
		# assignee: ${8:# Sets the assignee on create or transition operations. Note not all transitions will allow this.}
		# inwardissue: ${9:# Set issue from which link will be created.}
		# linktype: ${10:# Set type of link, when action 'link' selected.}
		# fields: ${11:# This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.}
		# outwardissue: ${12:# Set issue to which link will be created.}
		# summary: ${13:# The issue summary, where appropriate.}
		# project: ${14:# The project for this operation. Required for issue creation.}
		# status: ${15:# The desired status; only relevant for the transition operation.}
		# timeout: ${16:10}
		# issuetype: ${17:# The issue type, for issue creation.}
		# issue: ${18:# An existing issue key to operate on.}
$0
endsnippet

snippet letsencrypt "Create SSL certificates with Let's Encrypt" b
- name: $1
	letsencrypt:
		dest: ${2:# T}
		account_key: ${3:# File containing the Let's Encrypt account RSA key.}
		csr: ${4:# File containing the CSR for the new certificate.}
		# acme_directory: ${5:https://acme-staging.api.letsencrypt.org/directory}
		# account_email: ${6:# The email address associated with this account.}
		# data: ${7:# The data to validate ongoing challenges.}
		# challenge: ${8:#http-01|dns-01|tls-sni-02}
		# agreement: ${9:https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf}
		# remaining_days: ${10:10}
$0
endsnippet

snippet nginx_status_facts "Retrieve nginx status facts." b
- name: $1
	nginx_status_facts:
		url: ${2:# URL of the nginx status.}
		# timeout: ${3:10}
$0
endsnippet

snippet rundeck_acl_policy "Manage Rundeck ACL policies." b
- name: $1
	rundeck_acl_policy:
		name: ${2:# Sets the project name.}
		url: ${3:# Sets the rundeck instance URL.}
		token: ${4:# Sets the token to authenticate against Rundeck API.}
		# project: ${5:# Sets the project which receive the ACL policy.}
		# policy: ${6:# Sets the ACL policy content.}
		# state: ${7:#present|absent}
		# api_version: ${8:14}
$0
endsnippet

snippet rundeck_project "Manage Rundeck projects." b
- name: $1
	rundeck_project:
		url: ${2:# Sets the rundeck instance URL.}
		token: ${3:# Sets the token to authenticate against Rundeck API.}
		name: ${4:# Sets the project name.}
		# state: ${5:#present|absent}
		# api_version: ${6:14}
$0
endsnippet

snippet supervisorctl "Manage the state of a program or group of programs running via supervisord" b
- name: $1
	supervisorctl:
		state: ${2:present|started|stopped|restarted|absent}
		name: ${3:# The name of the supervisord program or group to manage.}
		# username: ${4:# username to use for authentication}
		# supervisorctl_path: ${5:# path to supervisorctl executable}
		# password: ${6:# password to use for authentication}
		# config: ${7:# The supervisor configuration file path}
		# server_url: ${8:# URL on which supervisord server is listening}
$0
endsnippet

snippet taiga_issue "Creates/deletes an issue in a Taiga Project Management Platform" b
- name: $1
	taiga_issue:
		project: ${2:# Name of the project containing the issue. Must exist previously.}
		issue_type: ${3:# The issue type. Must exist previously.}
		subject: ${4:# The issue subject.}
		# status: ${5:New}
		# severity: ${6:Normal}
		# tags: ${7:[]}
		# priority: ${8:Normal}
		# taiga_host: ${9:https://api.taiga.io}
		# state: ${10:#present|absent}
		# attachment: ${11:# Path to a file to be attached to the issue.}
		# attachment_description: ${12:}
		# description: ${13:}
$0
endsnippet

snippet tower_credential "create, update, or destroy Ansible Tower credential." b
- name: $1
	tower_credential:
		kind: ${2:ssh|net|scm|aws|rax|vmware|satellite6|cloudforms|gce|azure|azure_rm|openstack}
		name: ${3:# The name to use for the credential.}
		# authorize: ${4:no}
		# username: ${5:# Username for this credential. access_key for AWS.}
		# domain: ${6:# Domain for openstack type.}
		# description: ${7:# The description to use for the credential.}
		# tower_host: ${8:# URL to your Tower instance.}
		# vault_password: ${9:# Valut password. Use ASK for prompting.}
		# team: ${10:# Team that should own this credential.}
		# tower_config_file: ${11:# Path to the Tower config file. See notes.}
		# host: ${12:# Host for this credential.}
		# user: ${13:# User that should own this credential.}
		# become_password: ${14:# Become password. Use ASK for prompting.}
		# tower_password: ${15:# Password for your Tower instance.}
		# tower_username: ${16:# Username for your Tower instance.}
		# become_username: ${17:# Become username. Use ASK for prompting.}
		# password: ${18:# Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX.}
		# tenant: ${19:# Tenant ID for azure_rm type.}
		# subscription: ${20:# Subscription ID for azure_rm type.}
		# become_method: ${21:#None|sudo|su|pbrun|pfexec|pmrun}
		# tower_verify_ssl: ${22:yes}
		# secret: ${23:# Secret token for azure_rm type.}
		# project: ${24:# Project that should for this credential.}
		# state: ${25:#present|absent}
		# client: ${26:# Client or application ID for azure_rm type.}
		# ssh_key_data: ${27:# Path to SSH private key.}
		# ssh_key_unlock: ${28:# Unlock password for ssh_key. Use ASK for prompting.}
		# organization: ${29:# Organization that should own the credential.}
		# authorize_password: ${30:# Password for net credentials that require authroize.}
$0
endsnippet

snippet tower_group "create, update, or destroy Ansible Tower group." b
- name: $1
	tower_group:
		name: ${2:# The name to use for the group.}
		inventory: ${3:# Inventory the group should be made a member of.}
		# credential: ${4:# Credential to use for the group.}
		# description: ${5:# The description to use for the group.}
		# overwrite_vars: ${6:# Override vars in child groups and hosts with those from external source.}
		# source_regions: ${7:# Regions for cloud provider.}
		# variables: ${8:# Variables to use for the group, use '@' for a file.}
		# tower_username: ${9:# Username for your Tower instance.}
		# tower_password: ${10:# Password for your Tower instance.}
		# tower_config_file: ${11:# Path to the Tower config file. See notes.}
		# overwrite: ${12:no}
		# source_vars: ${13:# Override variables from source with variables from this field.}
		# source_script: ${14:# Inventory script to be used when group type is "custom".}
		# update_on_launch: ${15:no}
		# tower_verify_ssl: ${16:yes}
		# instance_filters: ${17:# Comma-separated list of filter expressions for matching hosts.}
		# source: ${18:manual|file|ec2|rax|vmware|gce|azure|azure_rm|openstack|satellite6|cloudforms|custom}
		# state: ${19:#present|absent}
		# group_by: ${20:# Limit groups automatically created from inventory source.}
		# tower_host: ${21:# URL to your Tower instance.}
$0
endsnippet

snippet tower_host "create, update, or destroy Ansible Tower host." b
- name: $1
	tower_host:
		name: ${2:# The name to use for the host.}
		inventory: ${3:# Inventory the host should be made a member of.}
		# tower_host: ${4:# URL to your Tower instance.}
		# variables: ${5:# Variables to use for the host. Use '@' for a file.}
		# enabled: ${6:yes}
		# tower_username: ${7:# Username for your Tower instance.}
		# state: ${8:#present|absent}
		# tower_password: ${9:# Password for your Tower instance.}
		# tower_config_file: ${10:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${11:yes}
		# description: ${12:# The description to use for the host.}
$0
endsnippet

snippet tower_inventory "create, update, or destroy Ansible Tower inventory." b
- name: $1
	tower_inventory:
		name: ${2:# The name to use for the inventory.}
		organization: ${3:# Organization the inventory belongs to.}
		# tower_host: ${4:# URL to your Tower instance.}
		# variables: ${5:# Inventory variables. Use '@' to get from file.}
		# tower_username: ${6:# Username for your Tower instance.}
		# state: ${7:#present|absent}
		# tower_password: ${8:# Password for your Tower instance.}
		# tower_config_file: ${9:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${10:yes}
		# description: ${11:# The description to use for the inventory.}
$0
endsnippet

snippet tower_job_cancel "Cancel an Ansible Tower Job." b
- name: $1
	tower_job_cancel:
		job_id: ${2:# ID of the job to cancel}
		# tower_config_file: ${3:# Path to the Tower config file. See notes.}
		# tower_password: ${4:# Password for your Tower instance.}
		# tower_username: ${5:# Username for your Tower instance.}
		# tower_host: ${6:# URL to your Tower instance.}
		# tower_verify_ssl: ${7:yes}
		# fail_if_not_running: ${8:no}
$0
endsnippet

snippet tower_job_launch "Launch an Ansible Job." b
- name: $1
	tower_job_launch:
		job_template: ${2:# Name of the job_template to use.}
		# credential: ${3:# Credential to use for job, only used if prompt for credential is set.}
		# use_job_endpoint: ${4:no}
		# tags: ${5:# Specific tags to use for from playbook.}
		# extra_vars: ${6:# Extra_vars to use for the job_template. Prepend '@' if a file.}
		# tower_host: ${7:# URL to your Tower instance.}
		# job_type: ${8:run|check|scan}
		# tower_config_file: ${9:# Path to the Tower config file. See notes.}
		# limit: ${10:# Limit to use for the job_template.}
		# inventory: ${11:# Inventory to use for the job, only used if prompt for inventory is set.}
		# job_explanation: ${12:# Job explanation field.}
		# tower_password: ${13:# Password for your Tower instance.}
		# tower_username: ${14:# Username for your Tower instance.}
		# tower_verify_ssl: ${15:yes}
$0
endsnippet

snippet tower_job_list "List Ansible Tower jobs." b
- name: $1
	tower_job_list:
		# status: ${2:pending|waiting|running|error|failed|canceled|successful}
		# tower_host: ${3:# URL to your Tower instance.}
		# page: ${4:# Page number of the results to fetch.}
		# tower_config_file: ${5:# Path to the Tower config file. See notes.}
		# all_pages: ${6:no}
		# tower_password: ${7:# Password for your Tower instance.}
		# tower_username: ${8:# Username for your Tower instance.}
		# query: ${9:# Query used to further filter the list of jobs. {"foo":"bar"} will be passed at ?foo=bar}
		# tower_verify_ssl: ${10:yes}
$0
endsnippet

snippet tower_job_template "create, update, or destroy Ansible Tower job_template." b
- name: $1
	tower_job_template:
		job_type: ${2:run|check|scan}
		playbook: ${3:# Playbook to use for the job_template.}
		name: ${4:# Name to use for the job_template.}
		project: ${5:# Project to use for the job_template.}
		# network_credential: ${6:# The network_credential to use for the job_template.}
		# description: ${7:# Description to use for the job_template.}
		# tower_host: ${8:# URL to your Tower instance.}
		# ask_inventory: ${9:no}
		# ask_job_type: ${10:no}
		# tower_username: ${11:# Username for your Tower instance.}
		# skip_tags: ${12:# The skip_tags to use for the job_template.}
		# tower_password: ${13:# Password for your Tower instance.}
		# tower_config_file: ${14:# Path to the Tower config file. See notes.}
		# ask_tags: ${15:no}
		# host_config_key: ${16:# Allow provisioning callbacks using this host config key.}
		# machine_credential: ${17:# Machine_credential to use for the job_template.}
		# tower_verify_ssl: ${18:yes}
		# ask_credential: ${19:no}
		# job_tags: ${20:# The job_tags to use for the job_template.}
		# verbosity: ${21:verbose|debug}
		# state: ${22:#present|absent}
		# ask_extra_vars: ${23:no}
		# extra_vars_path: ${24:# Path to the extra_vars yaml file.}
		# inventory: ${25:# Inventory to use for the job_template.}
		# limit: ${26:# A host pattern to further constrain the list of hosts managed or affected by the playbook}
		# forks: ${27:# The number of parallel or simultaneous processes to use while executing the playbook.}
		# cloud_credential: ${28:# Cloud_credential to use for the job_template.}
		# become_enabled: ${29:no}
$0
endsnippet

snippet tower_job_wait "Wait for Ansible Tower job to finish." b
- name: $1
	tower_job_wait:
		job_id: ${2:# ID of the job to monitor.}
		# min_interval: ${3:1}
		# tower_host: ${4:# URL to your Tower instance.}
		# tower_config_file: ${5:# Path to the Tower config file. See notes.}
		# max_interval: ${6:30}
		# timeout: ${7:# Maximum time in seconds to wait for a job to finish.}
		# tower_password: ${8:# Password for your Tower instance.}
		# tower_username: ${9:# Username for your Tower instance.}
		# tower_verify_ssl: ${10:yes}
$0
endsnippet

snippet tower_label "create, update, or destroy Ansible Tower label." b
- name: $1
	tower_label:
		name: ${2:# Name to use for the label.}
		organization: ${3:# Organization the label should be applied to.}
		# tower_host: ${4:# URL to your Tower instance.}
		# tower_username: ${5:# Username for your Tower instance.}
		# state: ${6:#present|absent}
		# tower_password: ${7:# Password for your Tower instance.}
		# tower_config_file: ${8:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${9:yes}
$0
endsnippet

snippet tower_organization "create, update, or destroy Ansible Tower organizations" b
- name: $1
	tower_organization:
		name: ${2:# Name to use for the organization.}
		# tower_host: ${3:# URL to your Tower instance.}
		# tower_username: ${4:# Username for your Tower instance.}
		# state: ${5:#present|absent}
		# tower_password: ${6:# Password for your Tower instance.}
		# tower_config_file: ${7:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${8:yes}
		# description: ${9:# The description to use for the organization.}
$0
endsnippet

snippet tower_project "create, update, or destroy Ansible Tower projects" b
- name: $1
	tower_project:
		name: ${2:# Name to use for the project.}
		# scm_branch: ${3:# The branch to use for the scm resource.}
		# description: ${4:# Description to use for the project.}
		# tower_host: ${5:# URL to your Tower instance.}
		# scm_update_on_launch: ${6:no}
		# scm_clean: ${7:no}
		# scm_type: ${8:#manual|git|hg|svn}
		# scm_delete_on_update: ${9:no}
		# tower_username: ${10:# Username for your Tower instance.}
		# tower_password: ${11:# Password for your Tower instance.}
		# tower_config_file: ${12:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${13:yes}
		# scm_credential: ${14:# Name of the credential to use with this scm resource.}
		# scm_url: ${15:# URL of scm resource.}
		# state: ${16:#present|absent}
		# local_path: ${17:# The server playbook directory for manual projects.}
		# organization: ${18:# Primary key of organization for project.}
$0
endsnippet

snippet tower_role "create, update, or destroy Ansible Tower role." b
- name: $1
	tower_role:
		role: ${2:admin|read|member|execute|adhoc|update|use|auditor}
		# credential: ${3:# Credential the role acts on.}
		# job_template: ${4:# The job_template the role acts on.}
		# tower_host: ${5:# URL to your Tower instance.}
		# team: ${6:# Team that receives the permissions specified by the role.}
		# project: ${7:# Project the role acts on.}
		# tower_username: ${8:# Username for your Tower instance.}
		# state: ${9:#present|absent}
		# inventory: ${10:# Inventory the role acts on.}
		# tower_password: ${11:# Password for your Tower instance.}
		# tower_config_file: ${12:# Path to the Tower config file. See notes.}
		# organization: ${13:# Organiation the role acts on.}
		# target_team: ${14:# Team that the role acts on.}
		# tower_verify_ssl: ${15:yes}
		# user: ${16:# User that receives the permissions specified by the role.}
$0
endsnippet

snippet tower_team "create, update, or destroy Ansible Tower team." b
- name: $1
	tower_team:
		name: ${2:# Name to use for the team.}
		organization: ${3:# Organization the team should be made a member of.}
		# tower_host: ${4:# URL to your Tower instance.}
		# tower_username: ${5:# Username for your Tower instance.}
		# state: ${6:#present|absent}
		# tower_password: ${7:# Password for your Tower instance.}
		# tower_config_file: ${8:# Path to the Tower config file. See notes.}
		# tower_verify_ssl: ${9:yes}
$0
endsnippet

snippet tower_user "create, update, or destroy Ansible Tower user." b
- name: $1
	tower_user:
		username: ${2:# The username of the user.}
		email: ${3:# Email address of the user.}
		# superuser: ${4:no}
		# first_name: ${5:# First name of the user.}
		# last_name: ${6:# Last name of the user.}
		# tower_host: ${7:# URL to your Tower instance.}
		# tower_username: ${8:# Username for your Tower instance.}
		# state: ${9:#present|absent}
		# auditor: ${10:no}
		# tower_password: ${11:# Password for your Tower instance.}
		# tower_config_file: ${12:# Path to the Tower config file. See notes.}
		# password: ${13:# Password of the user.}
		# tower_verify_ssl: ${14:yes}
$0
endsnippet

snippet win_acl "Set file/directory/registry permissions for a system user or group" b
- name: $1
	win_acl:
		user: ${2:# User or Group to add specified rights to act on src file/folder or registry key.}
		rights: ${3:# The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).}
		path: ${4:# The path to the file or directory.}
		type: ${5:allow|deny}
		# propagation: ${6:InheritOnly|#None|NoPropagateInherit}
		# state: ${7:absent|#present}
		# inherit: ${8:ContainerInherit|None|ObjectInherit}
$0
endsnippet

snippet win_acl_inheritance "Change ACL inheritance" b
- name: $1
	win_acl_inheritance:
		path: ${2:# Path to be used for changing inheritance}
		# state: ${3:present|#absent}
		# reorganize: ${4:#False|True}
$0
endsnippet

snippet win_chocolatey "Manage packages using chocolatey" b
- name: $1
	win_chocolatey:
		name: ${2:# Name of the package to be installed.}
		# force: ${3:no}
		# proxy_password: ${4:# Proxy password used to install chocolatey and the package.}
		# install_args: ${5:# Arguments to pass to the native installer.}
		# ignore_dependencies: ${6:no}
		# upgrade: ${7:no}
		# skip_scripts: ${8:no}
		# ignore_checksums: ${9:no}
		# proxy_url: ${10:# Proxy url used to install chocolatey and the package.}
		# allow_empty_checksums: ${11:no}
		# source: ${12:# Specify source rather than using default chocolatey repository.}
		# state: ${13:absent|downgrade|latest|#present|reinstalled}
		# version: ${14:# Specific version of the package to be installed.}
		# params: ${15:# Parameters to pass to the package}
		# proxy_username: ${16:# Proxy username used to install chocolatey and the package.}
		# timeout: ${17:2700}
$0
endsnippet

snippet win_command "Executes a command on a remote Windows node" b
- name: $1
	win_command: $2
	args:
		# creates: ${3:# a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
		# chdir: ${4:# set the specified path as the current working directory before executing a command}
		# removes: ${5:# a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
$0
endsnippet

snippet win_copy "Copies files to remote locations on windows hosts" b
- name: $1
	win_copy:
		src: ${2:# Local path to a file to copy to the remote server; can be absolute or relative.}
		dest: ${3:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		# content: ${4:# When used instead of C(src), sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.}
		# force: ${5:yes}
		# remote_src: ${6:no}
		# local_follow: ${7:yes}
$0
endsnippet

snippet win_defrag "Consolidate fragmented files on local volumes." b
- name: $1
	win_defrag:
		# priority: ${2:#low|normal}
		# excluded_volumes: ${3:# A list of drive letters or mount point paths to exclude from defragmentation.}
		# included_volumes: ${4:# A list of drive letters or mount point paths of the volumes to be defragmented.}
		# freespace_consolidation: ${5:# Perform free space consolidation on the specified volumes.}
		# parallel: ${6:yes|#no}
$0
endsnippet

snippet win_disk_image "Manage ISO/VHD/VHDX mounts on Windows hosts" b
- name: $1
	win_disk_image:
		image_path: ${2:# path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)}
		# state: ${3:#present|absent}
$0
endsnippet

snippet win_dns_client "Configures DNS lookup on Windows hosts" b
- name: $1
	win_dns_client:
		adapter_names: ${2:# Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value). The adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection).}
		ipv4_addresses: ${3:# Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.}
$0
endsnippet

snippet win_domain "Ensures the existence of a Windows domain." b
- name: $1
	win_domain:
		dns_domain_name: ${2:# the DNS name of the domain which should exist and be reachable or reside on the target Windows host}
		safe_mode_password: ${3:# safe mode password for the domain controller}
$0
endsnippet

snippet win_domain_controller "Manage domain controller/member server state for a Windows host" b
- name: $1
	win_domain_controller:
		domain_admin_user: ${2:# username of a domain admin for the target domain (necessary to promote or demote a domain controller)}
		domain_admin_password: ${3:# password for the specified C(domain_admin_user)}
		# state: ${4:domain_controller|member_server}
		# local_admin_password: ${5:# password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server))}
		# dns_domain_name: ${6:# when C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC}
		# safe_mode_password: ${7:# safe mode password for the domain controller (required when C(state) is C(domain_controller))}
$0
endsnippet

snippet win_domain_group "creates, modifies or removes domain groups" b
- name: $1
	win_domain_group:
		name: ${2:# The name of the group to create, modify or remove.}
		# category: ${3:distribution|security}
		# protect: ${4:# Will set the C(ProtectedFromAccidentalDeletion) flag based on this value.}
		# display_name: ${5:# The value to assign to the LDAP C(displayName) attribute.}
		# description: ${6:# The value to be assigned to the LDAP C(description) attribute.}
		# domain_username: ${7:# The username to use when interacting with AD.}
		# ignore_protection: ${8:no}
		# state: ${9:absent|#present}
		# domain_password: ${10:# The password for C(username).}
		# organizational_unit: ${11:# The full LDAP path to create or move the group to.}
		# attributes: ${12:# A dict of custom LDAP attributes to set on the group.}
		# managed_by: ${13:# The value to be assigned to the LDAP C(managedBy) attribute.}
		# scope: ${14:domainlocal|global|universal}
$0
endsnippet

snippet win_domain_membership "Manage domain/workgroup membership for a Windows host" b
- name: $1
	win_domain_membership:
		domain_admin_user: ${2:# username of a domain admin for the target domain (required to join or leave the domain)}
		# workgroup_name: ${3:# when C(state) is C(workgroup), the name of the workgroup that the Windows host should be in}
		# domain_ou_path: ${4:# The desired OU path for adding the computer object.}
		# state: ${5:domain|workgroup}
		# dns_domain_name: ${6:# when C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined}
		# hostname: ${7:# the desired hostname for the Windows host}
		# domain_admin_password: ${8:# password for the specified C(domain_admin_user)}
$0
endsnippet

snippet win_domain_user "Manages Windows Active Directory user accounts" b
- name: $1
	win_domain_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# upn: ${3:# Configures the User Principal Name (UPN) for the account. This is not required, but is best practice to configure for modern versions of Active Directory. The format is "<username>@<domain>".}
		# update_password: ${4:#always|on_create}
		# surname: ${5:# Configures the user's last name (surname)}
		# description: ${6:# Description of the user}
		# firstname: ${7:# Configures the user's first name (given name)}
		# company: ${8:# Configures the user's company name}
		# groups_action: ${9:#replace|add|remove}
		# password_expired: ${10:# C(yes) will require the user to change their password at next login. C(no) will clear the expired password flag. This is mutually exclusive with I(password_never_expires).}
		# street: ${11:# Configures the user's street address}
		# postal_code: ${12:# Configures the user's postal code / zip code}
		# groups: ${13:# Adds or removes the user from this list of groups, depending on the value of I(groups_action). To remove all but the Principal Group, set C(groups=<principal group name>) and I(groups_action=replace). Note that users cannot be removed from their principal group (for example, "Domain Users").}
		# path: ${14:# Container or OU for the new user; if you do not specify this, the user will be placed in the default container for users in the domain. Setting the path is only available when a new user is created; if you specify a path on an existing user, the user's path will not be updated - you must delete (e.g., state=absent) the user and then re-add the user with the appropriate path.}
		# password_never_expires: ${15:# C(yes) will set the password to never expire.  C(no) will allow the password to expire. This is mutually exclusive with I(password_expired)}
		# account_locked: ${16:no}
		# state_province: ${17:# Configures the user's state or province}
		# city: ${18:# Configures the user's city}
		# password: ${19:# Optionally set the user's password to this (plain text) value. In order to enable an account - I(enabled) - a password must already be configured on the account, or you must provide a password here.}
		# country: ${20:# Configures the user's country code. Note that this is a two-character ISO 3166 code.}
		# enabled: ${21:yes}
		# state: ${22:#present|absent|query}
		# email: ${23:# Configures the user's email address. This is a record in AD and does not do anything to configure any email servers or systems.}
		# user_cannot_change_password: ${24:# C(yes) will prevent the user from changing their password.  C(no) will allow the user to change their password.}
$0
endsnippet

snippet win_dotnet_ngen "Runs ngen to recompile DLLs after .NET  updates" b
- name: $1
	win_dotnet_ngen:
$0
endsnippet

snippet win_dsc "Invokes a PowerShell DSC configuration" b
- name: $1
	win_dsc:
		resource_name: ${2:# The DSC Resource to use. Must be accessible to PowerShell using any of the default paths.}
		# module_version: ${3:latest}
$0
endsnippet

snippet win_environment "Modifies environment variables on windows hosts." b
- name: $1
	win_environment:
		name: ${2:no default}
		level: ${3:machine|process|user}
		# state: ${4:#present|absent}
		# value: ${5:no default}
$0
endsnippet

snippet win_eventlog "Manage Windows event logs" b
- name: $1
	win_eventlog:
		name: ${2:# Name of the event log to manage.}
		# parameter_file: ${3:# For one or more sources specified, the path to a custom parameter resource file.}
		# overflow_action: ${4:OverwriteOlder|OverwriteAsNeeded|DoNotOverwrite}
		# retention_days: ${5:# The minimum number of days event entries must remain in the log.}
		# sources: ${6:# A list of one or more sources to ensure are present/absent in the log.}
		# state: ${7:#present|clear|absent}
		# message_file: ${8:# For one or more sources specified, the path to a custom event message resource file.}
		# maximum_size: ${9:# The maximum size of the event log.}
		# category_file: ${10:# For one or more sources specified, the path to a custom category resource file.}
$0
endsnippet

snippet win_eventlog_entry "Write entries to Windows event logs" b
- name: $1
	win_eventlog_entry:
		source: ${2:# Name of the log source to indicate where the entry is from.}
		log: ${3:# Name of the event log to write an entry to.}
		event_id: ${4:# The numeric event identifier for the entry.}
		message: ${5:# The message for the given log entry.}
		# category: ${6:# A numeric task category associated with the category message file for the log source.}
		# raw_data: ${7:# Binary data associated with the log entry.}
		# entry_type: ${8:Error|FailureAudit|Information|SuccessAudit|Warning}
$0
endsnippet

snippet win_feature "Installs and uninstalls Windows Features on Windows Server" b
- name: $1
	win_feature:
		name: ${2:# Names of roles or features to install as a single feature or a comma-separated list of features}
		# source: ${3: {driveletter}:\sources\sxs| {IP}\Share\sources\sxs}
		# state: ${4:#present|absent}
		# include_management_tools: ${5:True|False}
		# include_sub_features: ${6:True|False}
		# restart: ${7:True|False}
$0
endsnippet

snippet win_file "Creates, touches or removes files or directories." b
- name: $1
	win_file:
		path: ${2:# path to the file being managed.  Aliases: I(dest), I(name)}
		# state: ${3:file|directory|touch|absent}
$0
endsnippet

snippet win_file_version "Get DLL or EXE file build version" b
- name: $1
	win_file_version:
		path: ${2:# File to get version(provide absolute path)}
$0
endsnippet

snippet win_find "return a list of files based on specific criteria" b
- name: $1
	win_find:
		paths: ${2:# List of paths of directories to search for files or folders in. This can be supplied as a single path or a list of paths.}
		# file_type: ${3:#file|directory}
		# checksum_algorithm: ${4:md5|#sha1|sha256|sha384|sha512}
		# age: ${5:# Select files or folders whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., "2s", "10d", 1w").}
		# recurse: ${6:true|false}
		# age_stamp: ${7:atime|#mtime|ctime}
		# patterns: ${8:# One or more (powershell or regex) patterns to compare filenames with. The type of pattern matching is controlled by C(use_regex) option. The patterns retrict the list of files or folders to be returned based on the filenames. For a file to be matched it only has to match with one pattern in a list provided.}
		# get_checksum: ${9:true|false}
		# use_regex: ${10:true|false}
		# follow: ${11:true|false}
		# hidden: ${12:true|false}
		# size: ${13:no}
$0
endsnippet

snippet win_firewall "Enable or disable the Windows Firewall" b
- name: $1
	win_firewall:
		# state: ${2:enabled|disabled}
		# profiles: ${3:[#Domain, #Private, #Public}
$0
endsnippet

snippet win_firewall_rule "Windows firewall automation" b
- name: $1
	win_firewall_rule:
		direction: ${2:in|out}
		name: ${3:# The rules name}
		action: ${4:allow|block|bypass}
		# remoteport: ${5:# The remote port this rule applies to.}
		# protocol: ${6:any}
		# service: ${7:# The service this rule applies to.}
		# description: ${8:# Description for the firewall rule.}
		# enabled: ${9:yes}
		# profiles: ${10:domain,private,public}
		# localip: ${11:any}
		# state: ${12:#present|absent}
		# program: ${13:# The program this rule applies to.}
		# remoteip: ${14:any}
		# localport: ${15:# The local port this rule applies to.}
$0
endsnippet

snippet win_get_url "Fetches a file from a given URL" b
- name: $1
	win_get_url:
		url: ${2:# The full URL of a file to download.}
		dest: ${3:# The location to save the file at the URL.}
		# url_password: ${4:# Basic authentication password.}
		# force: ${5:yes}
		# use_proxy: ${6:yes}
		# skip_certificate_validation: ${7:no}
		# proxy_url: ${8:# The full URL of the proxy server to download through.}
		# proxy_password: ${9:# Proxy authentication password.}
		# headers: ${10:# Add custom HTTP headers to a request (as a dictionary).}
		# proxy_username: ${11:# Proxy authentication username.}
		# timeout: ${12:10}
		# url_username: ${13:# Basic authentication username.}
		# validate_certs: ${14:yes}
$0
endsnippet

snippet win_group "Add and remove local groups" b
- name: $1
	win_group:
		name: ${2:# Name of the group}
		# state: ${3:#present|absent}
		# description: ${4:# Description of the group}
$0
endsnippet

snippet win_group_membership "Manage Windows local group membership" b
- name: $1
	win_group_membership:
		name: ${2:# Name of the local group to manage membership on.}
		members: ${3:# A list of members to ensure are present/absent from the group.}
		# state: ${4:#present|absent}
$0
endsnippet

snippet win_hotfix "install and uninstalls Windows hotfixes" b
- name: $1
	win_hotfix:
		# hotfix_identifier: ${2:# The name of the hotfix as shown in DISM, see examples for details.}
		# state: ${3:absent|#present}
		# hotfix_kb: ${4:# The name of the KB the hotfix relates to, see examples for details.}
		# source: ${5:# The path to the downloaded hotfix .msu file.}
$0
endsnippet

snippet win_iis_virtualdirectory "Configures a virtual directory in IIS." b
- name: $1
	win_iis_virtualdirectory:
		name: ${2:# The name of the virtual directory to create or remove}
		site: ${3:# The site name under which the virtual directory is created or exists.}
		# application: ${4:# The application under which the virtual directory is created or exists.}
		# state: ${5:absent|#present}
		# physical_path: ${6:# The physical path to the folder in which the new virtual directory is created. The specified folder must already exist.}
$0
endsnippet

snippet win_iis_webapplication "Configures IIS web applications" b
- name: $1
	win_iis_webapplication:
		name: ${2:# Name of the web application.}
		site: ${3:# Name of the site on which the application is created.}
		# state: ${4:absent|#present}
		# application_pool: ${5:# The application pool in which the new site executes.}
		# physical_path: ${6:# The physical path on the remote host to use for the new application.}
$0
endsnippet

snippet win_iis_webapppool "configures an IIS Web Application Pool" b
- name: $1
	win_iis_webapppool:
		name: ${2:# Name of the application pool.}
		# attributes: ${3:# As of Ansible 2.4, this field can take in dict entries to set the application pool attributes.}
		# state: ${4:#present|absent|stopped|started|restarted}
$0
endsnippet

snippet win_iis_webbinding "Configures a IIS Web site." b
- name: $1
	win_iis_webbinding:
		name: ${2:# Names of web site}
		# protocol: ${3:# The protocol to be used for the Web binding (usually HTTP, HTTPS, or FTP).}
		# certificate_hash: ${4:# Certificate hash for the SSL binding. The certificate hash is the unique identifier for the certificate.}
		# ip: ${5:# The IP address to bind to / use for the new site.}
		# host_header: ${6:# The host header to bind to / use for the new site.}
		# state: ${7:present|absent}
		# port: ${8:# The port to bind to / use for the new site.}
		# certificate_store_name: ${9:My}
$0
endsnippet

snippet win_iis_website "Configures a IIS Web site." b
- name: $1
	win_iis_website:
		name: ${2:# Names of web site}
		# application_pool: ${3:# The application pool in which the new site executes.}
		# parameters: ${4:# Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. "foo:1|bar:2"}
		# ip: ${5:# The IP address to bind to / use for the new site.}
		# physical_path: ${6:# The physical path on the remote host to use for the new site. The specified folder must already exist.}
		# hostname: ${7:# The host header to bind to / use for the new site.}
		# site_id: ${8:# Explicitly set the IIS numeric ID for a site. Note that this value cannot be changed after the website has been created.}
		# ssl: ${9:# Enables HTTPS binding on the site..}
		# state: ${10:started|restarted|stopped|absent}
		# port: ${11:# The port to bind to / use for the new site.}
$0
endsnippet

snippet win_lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression." b
- name: $1
	win_lineinfile:
		path: ${2:# The path of the file to modify.}
		# insertbefore: ${3:BOF|*regex*}
		# encoding: ${4:auto}
		# create: ${5:yes|#no}
		# newline: ${6:#windows|unix}
		# backrefs: ${7:yes|#no}
		# state: ${8:#present|absent}
		# insertafter: ${9:#EOF|*regex*}
		# regexp: ${10:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).
}
		# line: ${11:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
		# backup: ${12:yes|#no}
		# validate: ${13:# Validation to run before copying into place. Use %s in the command to indicate the current file to validate.}
$0
endsnippet

snippet win_mapped_drive "maps a network drive for a user" b
- name: $1
	win_mapped_drive:
		letter: ${2:# The letter of the network path to map to.}
		# username: ${3:# Credentials to map the drive with.}
		# path: ${4:# The UNC path to map the drive to.}
		# state: ${5:absent|#present}
		# password: ${6:# The password for C(username).}
$0
endsnippet

snippet win_msg "Sends a message to logged in users on Windows hosts." b
- name: $1
	win_msg:
		# msg: ${2:Hello world!}
		# to: ${3:*}
		# display_seconds: ${4:10}
		# wait: ${5:no}
$0
endsnippet

snippet win_nssm "NSSM - the Non-Sucking Service Manager" b
- name: $1
	win_nssm:
		name: ${2:# Name of the service to operate on}
		# start_mode: ${3:#auto|manual|disabled}
		# state: ${4:present|#started|stopped|restarted|absent}
		# app_parameters_free_form: ${5:# Single string of parameters to be passed to the service.}
		# application: ${6:# The application binary to run as a service}
		# stderr_file: ${7:# Path to receive error output}
		# dependencies: ${8:# Service dependencies that has to be started to trigger startup, separated by comma.}
		# user: ${9:# User to be used for service startup}
		# password: ${10:# Password to be used for service startup}
		# stdout_file: ${11:# Path to receive output}
		# app_parameters: ${12:# Parameters to be passed to the application when it starts.}
$0
endsnippet

snippet win_owner "Set owner" b
- name: $1
	win_owner:
		path: ${2:# Path to be used for changing owner}
		user: ${3:# Name to be used for changing owner}
		# recurse: ${4:no}
$0
endsnippet

snippet win_package "Installs/uninstalls an installable package" b
- name: $1
	win_package:
		# username: ${2:# Username of an account with access to the package if it is located on a file share.}
		# creates_path: ${3:# Will check the existance of the path specified and use the result to determine whether the package is already installed.}
		# name: ${4:# Name of the package, if name isn't specified the path will be used for log messages.}
		# creates_service: ${5:# Will check the existing of the service specified and use the result to determine whether the package is already installed.}
		# expected_return_code: ${6:[0, 3010]}
		# state: ${7:present}
		# arguments: ${8:# Any arguments the installer needs to either install or uninstall the package.}
		# creates_version: ${9:# Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.}
		# path: ${10:# Location of the package to be installed or uninstalled.}
		# password: ${11:# The password for C(user_name), must be set when C(user_name) is.}
		# validate_certs: ${12:yes}
		# product_id: ${13:# The product id of the installed packaged.}
$0
endsnippet

snippet win_pagefile "Query or change pagefile configuration" b
- name: $1
	win_pagefile:
		# test_path: ${2:yes}
		# initial_size: ${3:# The initial size of the pagefile in megabytes.}
		# drive: ${4:# The drive of the pagefile.}
		# state: ${5:present|absent|#query}
		# system_managed: ${6:no}
		# remove_all: ${7:no}
		# override: ${8:yes}
		# maximum_size: ${9:# The maximum size of the pagefile in megabytes.}
		# automatic: ${10:# Configures AutomaticManagedPagefile for the entire system.}
$0
endsnippet

snippet win_path "Manage Windows path environment variables" b
- name: $1
	win_path:
		elements: ${2:# A single path element, or a list of path elements (ie, directories) to add or remove.}
		# scope: ${3:#machine|user}
		# state: ${4:present|absent}
		# name: ${5:PATH}
$0
endsnippet

snippet win_ping "A windows version of the classic ping module" b
- name: $1
	win_ping:
		# data: ${2:pong}
$0
endsnippet

snippet win_power_plan "Changes the power plan of a Windows system" b
- name: $1
	win_power_plan:
		name: ${2:# String value that indicates the desired power plan. The power plan must already be present on the system. Commonly there will be options for C(balanced) and C(high performance).}
$0
endsnippet

snippet win_psexec "Runs commands (remotely) as another (privileged) user" b
- name: $1
	win_psexec:
		command: ${2:# The command line to run through PsExec (limited to 260 characters).}
		# username: ${3:# The (remote) user to run the command as.}
		# limited: ${4:no}
		# executable: ${5:psexec.exe}
		# chdir: ${6:# Run the command from this (remote) directory.}
		# interactive: ${7:no}
		# noprofile: ${8:no}
		# system: ${9:no}
		# elevated: ${10:no}
		# priority: ${11:background|low|belownormal|abovenormal|high|realtime}
		# password: ${12:# The password for the (remote) user to run the command as.}
		# hostnames: ${13:# The hostnames to run the command.}
		# timeout: ${14:# The connection timeout in seconds}
		# nobanner: ${15:no}
		# wait: ${16:yes}
$0
endsnippet

snippet win_psmodule "Adds or removes a Powershell Module." b
- name: $1
	win_psmodule:
		name: ${2:# Name of the powershell module that has to be installed.}
		# url: ${3:# Url of the custom repository.}
		# allow_clobber: ${4:#False|True}
		# repository: ${5:# Name of the custom repository to register.}
		# state: ${6:#present|absent}
$0
endsnippet

snippet win_rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	win_rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# state: ${3:#enabled|disabled}
		# new_only: ${4:no}
		# prefix: ${5:# Specify a custom install prefix to a Rabbit.}
$0
endsnippet

snippet win_reboot "Reboot a windows machine" b
- name: $1
	win_reboot:
		# pre_reboot_delay: ${2:2}
		# post_reboot_delay: ${3:0}
		# test_command: ${4:whoami}
		# shutdown_timeout: ${5:600}
		# reboot_timeout: ${6:600}
		# msg: ${7:Reboot initiated by Ansible}
		# connect_timeout: ${8:5}
$0
endsnippet

snippet win_reg_stat "returns information about a Windows registry key or property of a key" b
- name: $1
	win_reg_stat:
		path: ${2:# T}
		# name: ${3:# The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.}
$0
endsnippet

snippet win_regedit "Add, change, or remove registry keys and values" b
- name: $1
	win_regedit:
		path: ${2:# Name of the registry path.}
		# state: ${3:#present|absent}
		# delete_key: ${4:yes}
		# name: ${5:# Name of the registry entry in the above C(path) parameters.}
		# type: ${6:binary|dword|expandstring|multistring|#string|qword}
		# data: ${7:# Value of the registry entry C(name) in C(path).}
$0
endsnippet

snippet win_region "Set the region and format settings" b
- name: $1
	win_region:
		# unicode_language: ${2:# The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect.}
		# copy_settings: ${3:true|false}
		# location: ${4:# The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to. This needs to be set if C(format) or C(unicode_language) is not set.}
		# format: ${5:# The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(unicode_language) is not set.}
$0
endsnippet

snippet win_regmerge "Merges the contents of a registry file into the windows registry" b
- name: $1
	win_regmerge:
		path: ${2:no default}
		# compare_key: ${3:no default}
$0
endsnippet

snippet win_robocopy "Synchronizes the contents of two directories using Robocopy" b
- name: $1
	win_robocopy:
		dest: ${2:# Destination file/directory to sync (Will receive contents of src).}
		src: ${3:# Source file/directory to sync.}
		# recurse: ${4:no}
		# purge: ${5:no}
		# flags: ${6:# Directly supply Robocopy flags. If set, C(purge) and C(recurse) will be ignored.}
$0
endsnippet

snippet win_route "Add or remove a static route." b
- name: $1
	win_route:
		destination: ${2:# Destination IP address in CIDR format (ip address/prefix length)}
		# metric: ${3:1}
		# gateway: ${4:# The gateway used by the static route.}
		# state: ${5:present}
$0
endsnippet

snippet win_say "Text to speech module for Windows to speak messages and optionally play sounds" b
- name: $1
	win_say:
		# end_sound_path: ${2:# Full path to a C(.wav) file containing a sound to play after the text has been spoken.}
		# msg: ${3:# The text to be spoken.}
		# start_sound_path: ${4:# Full path to a C(.wav) file containing a sound to play before the text is spoken.}
		# voice: ${5:system default voice}
		# msg_file: ${6:# Full path to a windows format text file containing the text to be spokend.}
		# speech_speed: ${7:0}
$0
endsnippet

snippet win_scheduled_task "Manage scheduled tasks" b
- name: $1
	win_scheduled_task:
		name: ${2:# Name of the scheduled task}
		state: ${3:present|absent}
		# executable: ${4:# Command the scheduled task should execute}
		# description: ${5:# The description for the scheduled task}
		# runlevel: ${6:#limited|highest}
		# enabled: ${7:#True|False}
		# days_of_week: ${8:# Days of the week to run a weekly task, not idempotent}
		# store_password: ${9:yes}
		# frequency: ${10:once|daily|weekly}
		# arguments: ${11:# Arguments to provide scheduled task action}
		# time: ${12:# Time to execute scheduled task, not idempotent}
		# path: ${13:\}
		# password: ${14:# Password for the user account to run the scheduled task as.  This is required for running a task without the user being logged in, excluding Windows built-in service accounts.  This should be used for specifying credentials during initial task creation, and changing stored user credentials, as setting this value will cause the task to be recreated.}
		# user: ${15:DOMAIN\user}
$0
endsnippet

snippet win_security_policy "changes local security policy settings" b
- name: $1
	win_security_policy:
		section: ${2:# The ini section the key exists in.}
		key: ${3:# The ini key of the section or policy name to modify.}
		value: ${4:# The value for the ini key or policy name.}
$0
endsnippet

snippet win_service "Manages Windows services" b
- name: $1
	win_service:
		name: ${2:# Name of the service}
		# username: ${3:# The username to set the service to start as.}
		# display_name: ${4:# The display name to set for the service.}
		# desktop_interact: ${5:no}
		# force_dependent_services: ${6:no}
		# dependency_action: ${7:#set|add|remove}
		# description: ${8:# The description to set for the service.}
		# start_mode: ${9:auto|manual|disabled|delayed}
		# state: ${10:started|stopped|restarted|absent|paused}
		# dependencies: ${11:# A list of service dependencies to set for this particular service.}
		# path: ${12:# The path to the executable to set for the service.}
		# password: ${13:# The password to set the service to start as.}
$0
endsnippet

snippet win_share "Manage Windows shares" b
- name: $1
	win_share:
		name: ${2:# Share name.}
		path: ${3:# Share directory.}
		# deny: ${4:# Specify user list that should get no access, regardless of implied access on share, separated by comma.}
		# full: ${5:# Specify user list that should get full access on share, separated by comma.}
		# encrypt: ${6:no}
		# read: ${7:# Specify user list that should get read access on share, separated by comma.}
		# list: ${8:no}
		# state: ${9:#present|absent}
		# caching_mode: ${10:BranchCache|Documents|#Manual|None|Programs|Unknown}
		# change: ${11:# Specify user list that should get read and write access on share, separated by comma.}
		# description: ${12:# Share description}
$0
endsnippet

snippet win_shell "Execute shell commands on target hosts." b
- name: $1
	win_shell: $2
	args:
		# creates: ${3:# a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
		# chdir: ${4:# set the specified path as the current working directory before executing a command}
		# removes: ${5:# a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
		# executable: ${6:# change the shell used to execute the command (eg, C(cmd)). The target shell must accept a C(/c) parameter followed by the raw command line to be executed.}
$0
endsnippet

snippet win_shortcut "Manage shortcuts on Windows" b
- name: $1
	win_shortcut:
		dest: ${2:# Destination file for the shortcuting file.}
		# windowstyle: ${3:maximized|minimized|normal}
		# src: ${4:# Executable or URL the shortcut points to.}
		# description: ${5:# Description for the shortcut.}
		# args: ${6:# Additional arguments for the executable defined in C(src).}
		# directory: ${7:# Working directory for executable defined in C(src).}
		# state: ${8:absent|#present}
		# hotkey: ${9:# Key combination for the shortcut.}
		# icon: ${10:# Icon used for the shortcut.}
$0
endsnippet

snippet win_stat "returns information about a Windows file" b
- name: $1
	win_stat:
		path: ${2:# The full path of the file/object to get the facts of; both forward and back slashes are accepted.}
		# get_md5: ${3:yes}
		# get_checksum: ${4:yes}
		# checksum_algorithm: ${5:md5|#sha1|sha256|sha384|sha512}
$0
endsnippet

snippet win_tempfile "Creates temporary files and directories." b
- name: $1
	win_tempfile:
		# path: ${2:%TEMP%}
		# state: ${3:#file|directory}
		# prefix: ${4:ansible.}
		# suffix: ${5:}
$0
endsnippet

snippet win_template "Templates a file out to a remote server." b
- name: $1
	win_template:
		src: ${2:# Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		# force: ${4:#yes|no}
		# trim_blocks: ${5:no}
		# block_end_string: ${6:%}}
		# variable_start_string: ${7:{{}
		# newline_sequence: ${8:\n|\r|#\r\n}
		# variable_end_string: ${9:}}}
		# block_start_string: ${10:{%}
$0
endsnippet

snippet win_timezone "Sets Windows machine timezone" b
- name: $1
	win_timezone:
		timezone: ${2:# Timezone to set to. Example Central Standard Time}
$0
endsnippet

snippet win_toast "Sends Toast windows notification to logged in users on Windows 10 or later hosts" b
- name: $1
	win_toast:
		# popup: ${2:yes}
		# group: ${3:Powershell}
		# expire: ${4:45}
		# title: ${5:Notification HH:mm}
		# msg: ${6:Hello, World!}
		# tag: ${7:Ansible}
$0
endsnippet

snippet win_unzip "Unzips compressed files and archives on the Windows node" b
- name: $1
	win_unzip:
		dest: ${2:# Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.}
		src: ${3:# File to be unzipped (provide absolute path).}
		# delete_archive: ${4:no}
		# recurse: ${5:no}
		# creates: ${6:# If this file or directory exists the specified src will not be extracted.}
$0
endsnippet

snippet win_updates "Download and install Windows updates" b
- name: $1
	win_updates:
		# log_path: ${2:# If set, C(win_updates) will append update progress to the specified file. The directory must already exist.}
		# state: ${3:#installed|searched}
		# category_names: ${4:[Application, Connectors, #CriticalUpdates, DefinitionUpdates, DeveloperKits, FeaturePacks, Guidance, #SecurityUpdates, ServicePacks, Tools, #UpdateRollups, Updates}
$0
endsnippet

snippet win_uri "Interacts with webservices" b
- name: $1
	win_uri:
		url: ${2:# Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path.}
		# body: ${3:# The body of the HTTP request/response to the web service.}
		# dest: ${4:# Output the response body to a file.}
		# status_code: ${5:200}
		# removes: ${6:# A filename, when it does not exist, this step will be skipped.}
		# use_basic_parsing: ${7:yes}
		# content_type: ${8:# Sets the "Content-Type" header.}
		# password: ${9:# Password to use for authentication.}
		# maximum_redirection: ${10:5}
		# method: ${11:CONNECT|DELETE|#GET|HEAD|OPTIONS|PATCH|POST|PUT|REFRESH|TRACE}
		# creates: ${12:# A filename, when it already exists, this step will be skipped.}
		# headers: ${13:# Key Value pairs for headers. Example "Host: www.somesite.com"}
		# timeout: ${14:30}
		# follow_redirects: ${15:all|none|#safe}
		# return_content: ${16:no}
		# validate_certs: ${17:yes}
		# client_cert: ${18:# Specifies the client certificate(.pfx)  that is used for a secure web request.}
		# user: ${19:# Username to use for authentication.}
$0
endsnippet

snippet win_user "Manages local Windows user accounts" b
- name: $1
	win_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# update_password: ${3:#always|on_create}
		# password: ${4:# Optionally set the user's password to this (plain text) value.}
		# description: ${5:# Description of the user}
		# groups_action: ${6:#replace|add|remove}
		# password_expired: ${7:yes|no}
		# state: ${8:#present|absent|query}
		# groups: ${9:# Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.}
		# account_disabled: ${10:yes|no}
		# fullname: ${11:# Full name of the user}
		# password_never_expires: ${12:yes|no}
		# account_locked: ${13:no}
		# user_cannot_change_password: ${14:yes|no}
$0
endsnippet

snippet win_user_right "Manage Windows User Rights" b
- name: $1
	win_user_right:
		name: ${2:# The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).}
		users: ${3:# A list of users or groups to add/remove on the User Right.}
		# action: ${4:#set|add|remove}
$0
endsnippet

snippet win_wait_for "Waits for a condition before continuing" b
- name: $1
	win_wait_for:
		# host: ${2:127.0.0.1}
		# port: ${3:# The port number to poll on C(host).}
		# delay: ${4:# The number of seconds to wait before starting to poll.}
		# state: ${5:present|#started|stopped|absent|drained}
		# sleep: ${6:1}
		# timeout: ${7:300}
		# exclude_hosts: ${8:# The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained).}
		# search_regex: ${9:# Can be used to match a string in a file.}
		# path: ${10:# The path to a file on the filesystem to check.}
		# connect_timeout: ${11:5}
$0
endsnippet

snippet win_wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	win_wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: ${3:255.255.255.255}
		# port: ${4:7}
$0
endsnippet

snippet win_webpicmd "Installs packages using Web Platform Installer command-line" b
- name: $1
	win_webpicmd:
		name: ${2:# Name of the package to be installed}
$0
endsnippet

