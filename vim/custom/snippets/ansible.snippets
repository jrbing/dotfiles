priority 50

# THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DON'T MODIFY BY HAND

snippet play "Execute an ansible play"
- hosts: ${1:host_group}
	remote_user: ${2:remote_user}
	tasks:
	$0
endsnippet

snippet aws_kms "Perform various KMS management tasks."
- name: $1
	aws_kms:
		mode: ${2:#grant|deny}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		role_arn: ${6:# ARN of role to allow/deny access. One of C(role_name) or C(role_arn) are required.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		grant_types: ${9:# List of grants to give to user/role. Likely "role,role grant" or "role,role grant,admin". Required when C(mode=grant).}
		role_name: ${10:# Role to allow/deny access. One of C(role_name) or C(role_arn) are required.}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		key_arn: ${12:# Full ARN to the key. One of C(key_alias) or C(key_arn) are required.}
		clean_invalid_entries: ${13:yes}
		validate_certs: ${14:#yes|no}
		key_alias: ${15:# Alias label to the key. One of C(key_alias) or C(key_arn) are required.}
$0
endsnippet

snippet cloudformation "Create or delete an AWS CloudFormation stack"
- name: $1
	cloudformation:
		stack_name: ${2:# name of the cloudformation stack}
		state: ${3:# If state is "present", stack will be created.  If state is "present" and if stack exists and template has changed, it will be updated. If state is "absent", stack will be removed.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		disable_rollback: ${7:true|#false}
		role_arn: ${8:# The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)}
		notification_arns: ${9:# The Simple Notification Service (SNS) topic ARNs to publish stack related events.}
		security_token: ${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${11:# Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.}
		stack_policy: ${12:# the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. (for instance, [allow all updates](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)}
		region: ${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		template_format: ${14:#json|yaml}
		template_parameters: ${15:{}}
		template_url: ${16:# Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.}
		template: ${17:# The local path of the cloudformation template.}
		ec2_url: ${18:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${19:#yes|no}
$0
endsnippet

snippet cloudformation_facts "Obtain facts about an AWS CloudFormation stack"
- name: $1
	cloudformation_facts:
		stack_name: ${2:# The name or id of the CloudFormation stack}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		stack_template: ${7:no}
		all_facts: ${8:no}
		stack_policy: ${9:no}
		region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		stack_events: ${11:no}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		stack_resources: ${13:no}
		validate_certs: ${14:#yes|no}
$0
endsnippet

snippet cloudfront_facts "Obtain facts about an AWS CloudFront distribution"
- name: $1
	cloudfront_facts:
		profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		list_streaming_distributions: ${3:no}
		origin_access_identity_config: ${4:no}
		streaming_distribution_configuration: ${5:no}
		invalidation: ${6:no}
		domain_name_alias: ${7:# Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.}
		list_invalidations: ${8:no}
		origin_access_identity_id: ${9:# The id of the cloudfront origin access identity to get information about.}
		list_distributions_by_web_acl_id: ${10:no}
		origin_access_identity: ${11:no}
		all_lists: ${12:no}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		list_distributions: ${14:no}
		summary: ${15:no}
		aws_secret_key: ${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		web_acl_id: ${19:# Used with I(list_distributions_by_web_acl_id).}
		region: ${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		streaming_distribution: ${21:no}
		distribution_id: ${22:# The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).}
		distribution_config: ${23:no}
		invalidation_id: ${24:# The id of the invalidation to get information about. Used with I(invalidation).}
		distribution: ${25:no}
		validate_certs: ${26:#yes|no}
		list_origin_access_identities: ${27:no}
$0
endsnippet

snippet cloudtrail "manage CloudTrail creation and deletion"
- name: $1
	cloudtrail:
		state: ${2:enabled|disabled}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${6:# name for given CloudTrail configuration.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${8:#yes|no}
		region: ${9:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		include_global_events: ${10:true|false}
		s3_bucket_prefix: ${11:# bucket to place CloudTrail in.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		s3_key_prefix: ${13:# prefix to keys in bucket. A trailing slash is not necessary and will be removed.}
$0
endsnippet

snippet cloudwatchevent_rule "Manage CloudWatch Event rules and targets"
- name: $1
	cloudwatchevent_rule:
		name: ${2:# The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\.\-_A-Za-z0-9]+))}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		role_arn: ${6:# The Amazon Resource Name (ARN) of the IAM role associated with the rule}
		description: ${7:# A description of the rule}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		event_pattern: ${9:# A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered}
		schedule_expression: ${10:# A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))}
		state: ${11:#present|disabled|absent}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${13:#yes|no}
		targets: ${14:# A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], input: [valid JSON string], input_path: [valid JSONPath string] }). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form.}
$0
endsnippet

snippet dynamodb_table "Create, update or delete AWS Dynamo DB tables."
- name: $1
	dynamodb_table:
		name: ${2:# Name of the table.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		read_capacity: ${5:1}
		hash_key_name: ${6:# Name of the hash key.}
		range_key_type: ${7:#STRING|NUMBER|BINARY}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		write_capacity: ${10:1}
		indexes: ${11:[]}
		range_key_name: ${12:# Name of the range key.}
		state: ${13:#present|absent}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		validate_certs: ${16:#yes|no}
		hash_key_type: ${17:#STRING|NUMBER|BINARY}
$0
endsnippet

snippet ec2 "create, terminate, start or stop an instance in ec2"
- name: $1
	ec2:
		image: ${2:# I(ami) ID to use for the instance}
		instance_type: ${3:# instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)}
		kernel: ${4:# kernel I(eki) to use for the instance}
		monitoring: ${5:yes|no}
		user_data: ${6:# opaque blob of data which is made available to the ec2 instance}
		termination_protection: ${7:yes|no}
		private_ip: ${8:# the private ip address to assign the instance (from the vpc subnet)}
		spot_type: ${9:#one-time|persistent}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		id: ${11:# identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances. This identifier is valid for at least 24 hours after the termination of the instance, and should not be reused for another call later on. For details, see the description of client token at U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).}
		source_dest_check: ${12:yes|no}
		aws_secret_key: ${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		spot_wait_timeout: ${14:600}
		group: ${15:# security group (or list of groups) to use with the instance}
		zone: ${16:# AWS availability zone in which to launch the instance}
		exact_count: ${17:# An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.}
		ebs_optimized: ${18:false}
		state: ${19:#present|absent|running|restarted|stopped}
		placement_group: ${20:# placement group for the instance when using EC2 Clustered Compute}
		key_name: ${21:# key pair to use on the instance}
		ramdisk: ${22:# ramdisk I(eri) to use for the instance}
		count_tag: ${23:# Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running.  This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with "class=webserver". The specified tag must already exist or be passed in as the 'instance_tags' option.}
		spot_launch_group: ${24:# Launch group for spot request, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group)}
		vpc_subnet_id: ${25:# the subnet ID in which to launch the instance (VPC)}
		instance_ids: ${26:# list of instance ids, currently used for states: absent, running, stopped}
		tenancy: ${27:#default|dedicated}
		profile: ${28:# Uses a boto profile. Only works with boto >= 2.24.0.}
		assign_public_ip: ${29:yes|no}
		spot_price: ${30:# Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started.}
		wait: ${31:yes|#no}
		count: ${32:1}
		aws_access_key: ${33:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${34:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		instance_profile_name: ${35:# Name of the IAM instance profile to use. Boto library must be 2.5.0+}
		region: ${36:# The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		network_interfaces: ${37:# A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)}
		instance_initiated_shutdown_behavior: ${38:#stop|terminate}
		wait_timeout: ${39:300}
		volumes: ${40:# a list of hash/dictionaries of volumes to add to the new instance; '[{"key":"value", "key":"value"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), iops (int) - device_type is deprecated use volume_type, iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.}
		instance_tags: ${41:# a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		group_id: ${42:# security group id (or list of ids) to use with the instance}
		validate_certs: ${43:#yes|no}
$0
endsnippet

snippet ec2_ami "create or destroy an image in ec2"
- name: $1
	ec2_ami:
		profile: ${2:# Uses a boto profile. Only works with boto >= 2.24.0.}
		description: ${3:# Human-readable string describing the contents and purpose of the AMI.}
		tags: ${4:# A dictionary of tags to add to the new image; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		kernel_id: ${5:# The target kernel id of the image to register}
		launch_permissions: ${6:# Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, "all" is the only acceptable value currently.}
		image_id: ${7:# Image ID to be deregistered.}
		no_reboot: ${8:yes|no}
		wait_timeout: ${9:300}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		wait: ${11:yes|#no}
		aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${14:# The name of the new AMI.}
		security_token: ${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		delete_snapshot: ${16:yes|#no}
		region: ${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		architecture: ${18:# The target architecture of the image to register}
		instance_id: ${19:# Instance ID to create the AMI from.}
		state: ${20:absent|#present}
		root_device_name: ${21:# The root device name of the image to register}
		validate_certs: ${22:#yes|no}
		virtualization_type: ${23:# The virtualization type of the image to register}
		device_mapping: ${24:# List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters)}
$0
endsnippet

snippet ec2_ami_copy "copies AMI between AWS regions, return new image id"
- name: $1
	ec2_ami_copy:
		source_image_id: ${2:# The ID of the AMI in source region that should be copied.}
		source_region: ${3:# The source region the AMI should be copied from.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${7:default}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${9:# A hash/dictionary of tags to add to the new copied AMI; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		encrypted: ${10:# Whether or not the destination snapshots of the copied AMI should be encrypted.}
		description: ${11:# An optional human-readable string describing the contents and purpose of the new AMI.}
		kms_key_id: ${12:# KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.}
		wait_timeout: ${13:1200}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${15:#yes|no}
		region: ${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		wait: ${17:yes|#no}
$0
endsnippet

snippet ec2_ami_find "Searches for AMIs to obtain the AMI ID and other information"
- name: $1
	ec2_ami_find:
		region: ${2:# The AWS region to use.}
		sort: ${3:name|description|tag|architecture|block_device_mapping|creationDate|hypervisor|is_public|location|owner_id|platform|root_device_name|root_device_type|state|virtualization_type}
		no_result_action: ${4:#success|fail}
		sort_end: ${5:# Which result to end with (when sorting).}
		sort_order: ${6:#ascending|descending}
		owner: ${7:# Search AMIs owned by the specified owner}
		is_public: ${8:yes|no}
		product_code: ${9:# Marketplace product code to match.}
		ami_id: ${10:# An AMI ID to match.}
		name: ${11:# An AMI name to match.}
		ami_tags: ${12:# A hash/dictionary of tags to match for the AMI.}
		hypervisor: ${13:# A hypervisor type type to match (e.g. xen).}
		sort_tag: ${14:# Tag name with which to sort results.}
		platform: ${15:# Platform type to match.}
		state: ${16:available}
		sort_start: ${17:# Which result to start with (when sorting).}
		architecture: ${18:# An architecture type to match (e.g. x86_64).}
		virtualization_type: ${19:# Virtualization type to match (e.g. hvm).}
$0
endsnippet

snippet ec2_asg "Create or delete AWS Autoscaling Groups"
- name: $1
	ec2_asg:
		launch_config_name: ${2:# Name of the Launch configuration to use for the group. See the ec2_lc module for managing these.}
		name: ${3:# Unique name for group to be created or deleted}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		default_cooldown: ${6:300 seconds}
		tags: ${7:# A list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.}
		aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		min_size: ${9:# Minimum number of instances in group, if unspecified then the current group value will be used.}
		wait_timeout: ${10:300}
		health_check_period: ${11:500 seconds}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		load_balancers: ${13:# List of ELB names to use for the group}
		aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		lc_check: ${15:yes}
		availability_zones: ${16:# List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.}
		replace_batch_size: ${17:1}
		vpc_zone_identifier: ${18:# List of VPC subnets to use}
		replace_all_instances: ${19:no}
		validate_certs: ${20:#yes|no}
		region: ${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		suspend_processes: ${22:[Launch, Terminate, HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions, AddToLoadBalancer}
		termination_policies: ${23:OldestInstance|NewestInstance|OldestLaunchConfiguration|ClosestToNextInstanceHour|#Default}
		replace_instances: ${24:# List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.}
		desired_capacity: ${25:# Desired number of instances in group, if unspecified then the current group value will be used.}
		state: ${26:#present|absent}
		health_check_type: ${27:#EC2|ELB}
		max_size: ${28:# Maximum number of instances in group, if unspecified then the current group value will be used.}
		placement_group: ${29:# Physical location of your cluster placement group created in Amazon EC2.}
		notification_topic: ${30:# A SNS topic ARN to send auto scaling notifications to.}
		notification_types: ${31:[u'autoscaling:EC2_INSTANCE_LAUNCH', u'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', u'autoscaling:EC2_INSTANCE_TERMINATE', u'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']}
		wait_for_instances: ${32:yes}
$0
endsnippet

snippet ec2_asg_facts "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS"
- name: $1
	ec2_asg_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# The prefix or name of the auto scaling group(s) you are searching for.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_customer_gateway "Manage an AWS customer gateway"
- name: $1
	ec2_customer_gateway:
		name: ${2:# Name of the customer gateway.}
		ip_address: ${3:# Internet-routable IP address for customers gateway, must be a static address.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${8:#yes|no}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		state: ${11:#present|absent}
		bgp_asn: ${12:# Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.}
$0
endsnippet

snippet ec2_eip "manages EC2 elastic IP (EIP) addresses."
- name: $1
	ec2_eip:
		release_on_disassociation: ${2:no}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		reuse_existing_ip_allowed: ${6:no}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		public_ip: ${8:# The IP address of a previously allocated EIP.}
		state: ${9:#present|absent}
		in_vpc: ${10:no}
		profile: ${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		private_ip_address: ${13:# The primary or secondary private IP address to associate with the Elastic IP address.}
		validate_certs: ${14:#yes|no}
		device_id: ${15:# The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.}
$0
endsnippet

snippet ec2_elb "De-registers or registers instances from EC2 ELBs"
- name: $1
	ec2_elb:
		instance_id: ${2:# EC2 Instance ID}
		state: ${3:present|absent}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		wait_timeout: ${9:0}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		ec2_elbs: ${11:# List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.}
		validate_certs: ${12:#yes|no}
		enable_availability_zone: ${13:yes|no}
		wait: ${14:yes|no}
$0
endsnippet

snippet ec2_elb_facts "Gather facts about EC2 Elastic Load Balancers in AWS"
- name: $1
	ec2_elb_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		names: ${5:# List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_elb_lb "Creates or destroys Amazon ELB."
- name: $1
	ec2_elb_lb:
		name: ${2:# The name of the ELB}
		state: ${3:present|absent}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		subnets: ${5:# A list of VPC subnets to use when creating ELB. Zones should be empty if using this.}
		health_check: ${6:# An associative array of health check configuration settings (see example)}
		tags: ${7:# An associative array of tags. To delete all tags, supply an empty dict.}
		purge_subnets: ${8:no}
		aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		instance_ids: ${10:no}
		zones: ${11:# List of availability zones to enable on this ELB}
		idle_timeout: ${12:# ELB connections from clients and to servers are timed out after this amount of time}
		wait_timeout: ${13:60}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		cross_az_load_balancing: ${15:yes|#no}
		security_group_ids: ${16:# A list of security groups to apply to the elb}
		purge_zones: ${17:no}
		wait: ${18:yes|no}
		aws_secret_key: ${19:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		purge_instance_ids: ${20:no}
		connection_draining_timeout: ${21:# Wait a specified timeout allowing connections to drain before terminating an instance}
		security_token: ${22:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${23:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		listeners: ${24:# List of ports/protocols for this ELB to listen on (see example)}
		access_logs: ${25:# An associative array of access logs configuration settings (see example)}
		security_group_names: ${26:# A list of security group names to apply to the elb}
		purge_listeners: ${27:yes}
		scheme: ${28:internet-facing}
		validate_certs: ${29:#yes|no}
		stickiness: ${30:# An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )}
$0
endsnippet

snippet ec2_eni "Create and optionally attach an Elastic Network Interface (ENI) to an instance"
- name: $1
	ec2_eni:
		subnet_id: ${2:# ID of subnet in which to create the ENI. Only required when state=present.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		secondary_private_ip_addresses: ${4:# A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		description: ${6:# Optional description of the ENI.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${8:#yes|no}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		device_index: ${10:0}
		attached: ${11:yes}
		force_detach: ${12:no}
		instance_id: ${13:# Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or       detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.}
		state: ${14:#present|absent}
		profile: ${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
		security_groups: ${16:# List of security groups associated with the interface. Only used when state=present. Since version 2.2, you       can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.}
		ec2_url: ${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		private_ip_address: ${18:# Private IP address.}
		secondary_private_ip_address_count: ${19:# The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses}
		eni_id: ${20:# The ID of the ENI}
		delete_on_termination: ${21:# Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.}
		source_dest_check: ${22:# By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.}
$0
endsnippet

snippet ec2_eni_facts "Gather facts about ec2 ENI interfaces in AWS"
- name: $1
	ec2_eni_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_facts "Gathers facts about remote hosts within ec2 (aws)"
- name: $1
	ec2_facts:
		validate_certs: ${2:#yes|no}
$0
endsnippet

snippet ec2_group "maintain an ec2 VPC security group."
- name: $1
	ec2_group:
		name: ${2:# Name of the security group.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		rules_egress: ${4:# List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		purge_rules: ${6:true}
		rules: ${7:# List of firewall inbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to acccess itself).}
		description: ${8:# Description of the security group. Required when C(state) is C(present).}
		state: ${9:#present|absent}
		profile: ${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		vpc_id: ${12:# ID of the VPC to create the group in.}
		security_token: ${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${14:#yes|no}
		region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		purge_rules_egress: ${16:true}
$0
endsnippet

snippet ec2_group_facts "Gather facts about ec2 security groups in AWS."
- name: $1
	ec2_group_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:{}}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_key "maintain an ec2 key pair."
- name: $1
	ec2_key:
		name: ${2:# Name of the key pair.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		force: ${6:yes}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		key_material: ${9:# Public key material.}
		state: ${10:present}
		wait_timeout: ${11:300}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${13:#yes|no}
		wait: ${14:no}
$0
endsnippet

snippet ec2_lc "Create or delete AWS Autoscaling Launch Configurations"
- name: $1
	ec2_lc:
		name: ${2:# Unique name for configuration}
		instance_type: ${3:# instance type to use for the instance}
		state: ${4:present|absent}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		kernel_id: ${7:# Kernel id for the EC2 instance}
		key_name: ${8:# The SSH key name to be used for access to managed instances}
		ramdisk_id: ${9:# A RAM disk id for the instances.}
		user_data: ${10:# opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path).}
		image_id: ${11:# The AMI unique identifier to be used for the group}
		assign_public_ip: ${12:# Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.}
		instance_monitoring: ${13:no}
		classic_link_vpc_id: ${14:# Id of ClassicLink enabled VPC}
		security_groups: ${15:# A list of security groups to apply to the instances. For VPC instances, specify security group IDs. For EC2-Classic, specify either security group names or IDs.}
		classic_link_vpc_security_groups: ${16:# A list of security group id's with which to associate the ClassicLink VPC instances.}
		aws_secret_key: ${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		spot_price: ${19:# The spot price you are bidding. Only applies for an autoscaling group with spot instances.}
		instance_profile_name: ${20:# The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.}
		user_data_path: ${21:# Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data).}
		region: ${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ebs_optimized: ${23:no}
		ec2_url: ${24:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		volumes: ${25:# a list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.}
		validate_certs: ${26:#yes|no}
$0
endsnippet

snippet ec2_lc_facts "Gather facts about AWS Autoscaling Launch Configurations"
- name: $1
	ec2_lc_facts:
		sort: ${2:launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		sort_end: ${4:# Which result to end with (when sorting).}
		name: ${5:[]}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		sort_start: ${9:# Which result to start with (when sorting).}
		sort_order: ${10:#ascending|descending}
		profile: ${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet ec2_lc_find "Find AWS Autoscaling Launch Configurations"
- name: $1
	ec2_lc_find:
		region: ${2:# The AWS region to use.}
		name_regex: ${3:# A Launch Configuration to match}
		sort_order: ${4:#ascending|descending}
		limit: ${5:# How many results to show.}
$0
endsnippet

snippet ec2_metric_alarm "Create/update or delete AWS Cloudwatch 'metric alarms'"
- name: $1
	ec2_metric_alarm:
		name: ${2:# Unique name for the alarm}
		state: ${3:present|absent}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ok_actions: ${5:# A list of the names of action(s) to take when the alarm is in the 'ok' status}
		description: ${6:# A longer description of the alarm}
		evaluation_periods: ${7:# The number of times in which the metric is evaluated before final calculation}
		metric: ${8:# Name of the monitored metric (e.g. CPUUtilization)}
		statistic: ${9:SampleCount|Average|Sum|Minimum|Maximum}
		period: ${10:# The time (in seconds) between metric evaluations}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		threshold: ${12:# Sets the min/max bound for triggering the alarm}
		unit: ${13:Seconds|Microseconds|Milliseconds|Bytes|Kilobytes|Megabytes|Gigabytes|Terabytes|Bits|Kilobits|Megabits|Gigabits|Terabits|Percent|Count|Bytes/Second|Kilobytes/Second|Megabytes/Second|Gigabytes/Second|Terabytes/Second|Bits/Second|Kilobits/Second|Megabits/Second|Gigabits/Second|Terabits/Second|Count/Second|None}
		dimensions: ${14:# Describes to what the alarm is applied}
		aws_secret_key: ${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		comparison: ${16:<=|<|>|>=}
		alarm_actions: ${17:# A list of the names action(s) taken when the alarm is in the 'alarm' status}
		security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		namespace: ${20:# Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch}
		insufficient_data_actions: ${21:# A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status}
		aws_access_key: ${22:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		validate_certs: ${23:#yes|no}
$0
endsnippet

snippet ec2_remote_facts "Gather facts about ec2 instances in AWS"
- name: $1
	ec2_remote_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_scaling_policy "Create or delete AWS scaling policies for Autoscaling groups"
- name: $1
	ec2_scaling_policy:
		name: ${2:# Unique name for the scaling policy}
		asg_name: ${3:# Name of the associated autoscaling group}
		state: ${4:present|absent}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		adjustment_type: ${10:ChangeInCapacity|ExactCapacity|PercentChangeInCapacity}
		min_adjustment_step: ${11:# Minimum amount of adjustment when policy is triggered}
		scaling_adjustment: ${12:# The amount by which the autoscaling group is adjusted by the policy}
		cooldown: ${13:# The minimum period of time between which autoscaling actions can take place}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${15:#yes|no}
$0
endsnippet

snippet ec2_snapshot "creates a snapshot from an existing volume"
- name: $1
	ec2_snapshot:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		description: ${5:# description to be applied to the snapshot}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		snapshot_tags: ${7:# a hash/dictionary of tags to add to the snapshot}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		volume_id: ${9:# volume from which to take the snapshot}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		device_name: ${11:# device name of a mounted volume to be snapshotted}
		instance_id: ${12:# instance that has the required volume to snapshot mounted}
		state: ${13:absent|#present}
		wait_timeout: ${14:0}
		snapshot_id: ${15:# snapshot id to remove}
		last_snapshot_min_age: ${16:0}
		validate_certs: ${17:#yes|no}
		wait: ${18:yes|no}
$0
endsnippet

snippet ec2_snapshot_facts "Gather facts about ec2 volume snapshots in AWS"
- name: $1
	ec2_snapshot_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		snapshot_ids: ${7:[]}
		filters: ${8:{}}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		restorable_by_user_ids: ${10:[]}
		validate_certs: ${11:#yes|no}
		owner_ids: ${12:[]}
$0
endsnippet

snippet ec2_tag "create and remove tag(s) to ec2 resources."
- name: $1
	ec2_tag:
		resource: ${2:# The EC2 resource id.}
		tags: ${3:# a hash/dictionary of tags to add to the resource; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		state: ${9:#present|absent|list}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ec2_vol "create and attach a volume, return volume id and device map"
- name: $1
	ec2_vol:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# volume Name tag if you wish to attach an existing volume (requires instance)}
		zone: ${6:# zone in which to create the volume, if unset uses the zone the instance is in (if set)}
		instance: ${7:# instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.}
		encrypted: ${8:no}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		kms_key_id: ${10:# Specify the id of the KMS key to use.}
		volume_type: ${11:standard}
		device_name: ${12:# device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.}
		volume_size: ${13:# size of volume (in GB) to create.}
		state: ${14:absent|#present|list}
		iops: ${15:100}
		snapshot: ${16:# snapshot ID on which to base the volume}
		ec2_url: ${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		id: ${18:# volume id if you wish to attach an existing volume (requires instance) or remove an existing volume}
		security_token: ${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${20:#yes|no}
		delete_on_termination: ${21:yes|#no}
		tags: ${22:{}}
$0
endsnippet

snippet ec2_vol_facts "Gather facts about ec2 volumes in AWS"
- name: $1
	ec2_vol_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_dhcp_options "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested"
- name: $1
	ec2_vpc_dhcp_options:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		dns_servers: ${5:# A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)}
		ntp_servers: ${8:# List of hosts to advertise as NTP servers for the VPC.}
		domain_name: ${9:# The domain name to set in the DHCP option sets}
		delete_old: ${10:yes}
		state: ${11:absent|#present}
		netbios_node_type: ${12:# NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		vpc_id: ${14:# VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.}
		inherit_existing: ${15:no}
		validate_certs: ${16:#yes|no}
		dhcp_options_id: ${17:# The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)}
		netbios_name_servers: ${18:# List of hosts to advertise as NetBIOS servers.}
$0
endsnippet

snippet ec2_vpc_dhcp_options_facts "Gather facts about dhcp options sets in AWS"
- name: $1
	ec2_vpc_dhcp_options_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		DhcpOptionsIds: ${7:# Get details of specific DHCP Option ID}
		filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_igw "Manage an AWS VPC Internet gateway"
- name: $1
	ec2_vpc_igw:
		vpc_id: ${2:# The VPC ID for the VPC in which to manage the Internet Gateway.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		state: ${8:#present|absent}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_igw_facts "Gather facts about internet gateways in AWS"
- name: $1
	ec2_vpc_igw_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		internet_gateway_ids: ${6:# Get details of specific Internet Gateway ID. Provide this value as a list.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_nacl "create and delete Network ACLs."
- name: $1
	ec2_vpc_nacl:
		name: ${2:# Tagged name identifying a network ACL.}
		vpc_id: ${3:# VPC id of the requesting VPC.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		subnets: ${5:# The list of subnets that should be associated with the network ACL.}
		ingress: ${6:# List of rules for incoming traffic.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${8:# Dictionary of tags to look for and apply when creating a network ACL.}
		aws_access_key: ${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		state: ${10:#present|absent}
		egress: ${11:# A list of rules for outgoing traffic.}
		profile: ${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${14:#yes|no}
$0
endsnippet

snippet ec2_vpc_nacl_facts "Gather facts about Network ACLs in an AWS VPC"
- name: $1
	ec2_vpc_nacl_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		nacl_ids: ${7:[]}
		filters: ${8:{}}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_nat_gateway "Manage AWS VPC NAT Gateways."
- name: $1
	ec2_vpc_nat_gateway:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		release_eip: ${5:yes}
		nat_gateway_id: ${6:# The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		allocation_id: ${8:# The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.}
		subnet_id: ${9:# The id of the subnet to create the NAT Gateway in. This is required with the present option.}
		region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		if_exist_do_not_create: ${11:no}
		eip_address: ${12:# The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.}
		state: ${13:#present|absent}
		wait_timeout: ${14:300}
		ec2_url: ${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		client_token: ${16:# Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.}
		validate_certs: ${17:#yes|no}
		wait: ${18:no}
$0
endsnippet

snippet ec2_vpc_nat_gateway_facts "Retrieves AWS VPC Managed Nat Gateway details using AWS methods."
- name: $1
	ec2_vpc_nat_gateway_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		nat_gateway_ids: ${4:# Get details of specific nat gateway IDs}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${6:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_vpc_net "Configure AWS virtual private clouds"
- name: $1
	ec2_vpc_net:
		name: ${2:# The name to give your VPC. This is used in combination with the cidr_block parameter to determine if a VPC already exists.}
		cidr_block: ${3:# The CIDR of the VPC}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		dns_support: ${7:yes|no}
		tags: ${8:# The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		multi_ok: ${11:no}
		state: ${12:#present|absent}
		tenancy: ${13:#default|dedicated}
		dns_hostnames: ${14:yes|no}
		validate_certs: ${15:#yes|no}
		region: ${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		dhcp_opts_id: ${17:# the id of the DHCP options to use for this vpc}
$0
endsnippet

snippet ec2_vpc_net_facts "Gather facts about ec2 VPCs in AWS"
- name: $1
	ec2_vpc_net_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_peer "create, delete, accept, and reject VPC peering connections between two VPCs."
- name: $1
	ec2_vpc_peer:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		peering_id: ${6:# Peering connection id.}
		tags: ${7:# Dictionary of tags to look for and apply when creating a Peering Connection.}
		ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		peer_owner_id: ${9:# The AWS account number for cross account peering.}
		state: ${10:#present|absent|accept|reject}
		peer_vpc_id: ${11:# VPC id of the accepting VPC.}
		vpc_id: ${12:# VPC id of the requesting VPC.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet ec2_vpc_route_table "Manage route tables for AWS virtual private clouds"
- name: $1
	ec2_vpc_route_table:
		subnets: ${2:# An array of subnets to add to this route table. Subnets may be specified by either subnet ID, Name tag, or by a CIDR such as '10.0.0.0/24'.}
		vpc_id: ${3:# VPC ID of the VPC in which to create the route table.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }. Tags are used to uniquely identify route tables within a VPC when the route_table_id is not supplied.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		purge_subnets: ${9:true}
		purge_routes: ${10:true}
		route_table_id: ${11:# The ID of the route table to update or delete.}
		state: ${12:#present|absent}
		lookup: ${13:#tag|id}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		routes: ${15:# List of routes in the route table. Routes are specified as dicts containing the keys 'dest' and one of 'gateway_id', 'instance_id', 'interface_id', or 'vpc_peering_connection_id'. If 'gateway_id' is specified, you can refer to the VPC's IGW by using the value 'igw'. Routes are required for present states.}
		profile: ${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
		validate_certs: ${17:#yes|no}
		propagating_vgw_ids: ${18:# Enable route propagation from virtual gateways specified by ID.}
$0
endsnippet

snippet ec2_vpc_route_table_facts "Gather facts about ec2 VPC route tables in AWS"
- name: $1
	ec2_vpc_route_table_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_subnet "Manage subnets in AWS virtual private clouds"
- name: $1
	ec2_vpc_subnet:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${6:# A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		state: ${8:#present|absent}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		vpc_id: ${10:# VPC ID of the VPC in which to create the subnet.}
		cidr: ${11:# The CIDR block for the subnet. E.g. 192.0.2.0/24. Only required when state=present.}
		az: ${12:# The availability zone for the subnet. Only required when state=present.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet ec2_vpc_subnet_facts "Gather facts about ec2 VPC subnets in AWS"
- name: $1
	ec2_vpc_subnet_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		filters: ${6:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ec2_vpc_vgw "Create and delete AWS VPN Virtual Gateways."
- name: $1
	ec2_vpc_vgw:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# name of the vgw to be created or deleted}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# dictionary of resource tags}
		validate_certs: ${8:#yes|no}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		state: ${10:#present|absent}
		wait_timeout: ${11:320}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		vpc_id: ${13:# the vpc-id of a vpc to attach or detach}
		vpn_gateway_id: ${14:# vpn gateway id of an existing virtual gateway}
		type: ${15:ipsec.1}
$0
endsnippet

snippet ec2_vpc_vgw_facts "Gather facts about virtual gateways in AWS"
- name: $1
	ec2_vpc_vgw_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		vpn_gateway_ids: ${5:# Get details of a specific Virtual Gateway ID. This value should be provided as a list.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		filters: ${8:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet ec2_win_password "gets the default administrator password for ec2 windows instances"
- name: $1
	ec2_win_password:
		instance_id: ${2:# The instance id to get the password data from.}
		key_file: ${3:# Path to the file containing the key pair used on the instance.}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		key_passphrase: ${9:# The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) openssl rsa -in current_key -out new_key -des3.}
		wait_timeout: ${10:120}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${12:#yes|no}
		wait: ${13:yes|#no}
$0
endsnippet

snippet ecs_cluster "create or terminate ecs clusters"
- name: $1
	ecs_cluster:
		name: ${2:# The cluster name}
		state: ${3:present|absent|has_instances}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		repeat: ${7:# The number of times to wait for the cluster to have an instance}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		delay: ${10:# Number of seconds to wait}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${12:#yes|no}
$0
endsnippet

snippet ecs_ecr "Manage Elastic Container Registry repositories"
- name: $1
	ecs_ecr:
		name: ${2:# the name of the repository}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${7:#yes|no}
		delete_policy: ${8:no}
		force_set_policy: ${9:no}
		state: ${10:#present|absent}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		policy: ${12:# JSON or dict that represents the new policy}
		registry_id: ${13:# AWS account id associated with the registry.}
$0
endsnippet

snippet ecs_service "create, terminate, start or stop a service in ecs"
- name: $1
	ecs_service:
		name: ${2:# The name of the service}
		state: ${3:present|absent|deleting}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		repeat: ${7:10}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		desired_count: ${9:# The count of how many instances of the service. This parameter is required when state=present}
		region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		delay: ${11:10}
		cluster: ${12:# The name of the cluster in which the service exists}
		task_definition: ${13:# The task definition the service will run. This parameter is required when state=present}
		role: ${14:# The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service.}
		deployment_configuration: ${15:# Optional parameters that control the deployment_configuration; format is '{"maximum_percent":<integer>, "minimum_healthy_percent":<integer>}}
		ec2_url: ${16:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		load_balancers: ${17:# The list of ELBs defined for this service}
		client_token: ${18:# Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.}
		validate_certs: ${19:#yes|no}
$0
endsnippet

snippet ecs_service_facts "list or describe services in ecs"
- name: $1
	ecs_service_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		service: ${6:# The service to get details for (required if details is true)}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		cluster: ${8:default}
		details: ${9:true|#false}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet ecs_task "run, start or stop a task in ecs"
- name: $1
	ecs_task:
		operation: ${2:run|start|stop}
		count: ${3:# How many new instances to start}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		task: ${6:# The task to stop}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		overrides: ${8:# A dictionary of values to pass to the new instances}
		started_by: ${9:# A value showing who or what started the task (for informational purposes)}
		cluster: ${10:# The name of the cluster to run the task on}
		task_definition: ${11:# The task definition to start or run}
		container_instances: ${12:# The list of container instances on which to deploy the task}
		profile: ${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${15:#yes|no}
		region: ${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
$0
endsnippet

snippet ecs_taskdefinition "register a task definition in ecs"
- name: $1
	ecs_taskdefinition:
		state: ${2:present|absent}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		family: ${7:# A Name that would be given to the task definition}
		task_role_arn: ${8:# The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		network_mode: ${10:#bridge|host|none}
		containers: ${11:# A list of containers definitions}
		volumes: ${12:# A list of names of volumes to be attached}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${14:#yes|no}
		arn: ${15:# The arn of the task description to delete}
		revision: ${16:# A revision number for the task definition}
$0
endsnippet

snippet efs "create and maintain EFS file systems"
- name: $1
	efs:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# Creation Token of Amazon EFS file system. Required for create. Either name or ID required for delete.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.}
		validate_certs: ${8:#yes|no}
		targets: ${9:# List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in. - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet. - security_groups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.}
		state: ${10:#present|absent}
		wait_timeout: ${11:0}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		performance_mode: ${13:#general_purpose|max_io}
		id: ${14:# ID of Amazon EFS. Either name or ID required for delete.}
		wait: ${15:yes|#no}
$0
endsnippet

snippet efs_facts "Get information about Amazon EFS file systems"
- name: $1
	efs_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# Creation Token of Amazon EFS file system.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# List of tags of Amazon EFS. Should be defined as dictionary}
		targets: ${8:# List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - SubnetId - Mandatory. The ID of the subnet to add the mount target in. - IpAddress - Optional. A valid IPv4 address within the address range of the specified subnet. - SecurityGroups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
		id: ${11:# ID of Amazon EFS.}
$0
endsnippet

snippet elasticache "Manage cache clusters in Amazon Elasticache."
- name: $1
	elasticache:
		name: ${2:# The cache cluster identifier}
		state: ${3:present|absent|rebooted}
		engine: ${4:redis|#memcached}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		cache_port: ${6:# The port number on which each of the cache nodes will accept connections}
		cache_parameter_group: ${7:# The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.}
		cache_engine_version: ${8:# The version number of the cache engine}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		node_type: ${11:cache.m1.small}
		num_nodes: ${12:# The initial number of cache nodes that the cache cluster will have. Required when state=present.}
		profile: ${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
		zone: ${14:# The EC2 Availability Zone in which the cache cluster will be created}
		cache_security_groups: ${15:# A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc}
		cache_subnet_group: ${16:# The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc}
		hard_modify: ${17:yes|no}
		aws_access_key: ${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		security_group_ids: ${20:# A list of vpc security group names to associate with this cache cluster. Only use if inside a vpc}
		validate_certs: ${21:#yes|no}
		wait: ${22:yes|no}
$0
endsnippet

snippet elasticache_parameter_group "Manage cache security groups in Amazon Elasticache."
- name: $1
	elasticache_parameter_group:
		group_family: ${2:memcached1.4|redis2.6|redis2.8|redis3.2}
		state: ${3:present|absent|reset}
		name: ${4:# A user-specified name for the cache parameter group.}
		values: ${5:# A user-specified list of parameters to reset or modify for the cache parameter group.}
		description: ${6:# A user-specified description for the cache parameter group.}
$0
endsnippet

snippet elasticache_snapshot "Manage cache snapshots in Amazon Elasticache."
- name: $1
	elasticache_snapshot:
		name: ${2:# The name of the snapshot we want to create, copy, delete}
		state: ${3:present|absent|copy}
		replication_id: ${4:# The name of the existing replication group to make the snapshot.}
		cluster_id: ${5:# The name of an existing cache cluster in the replication group to make the snapshot.}
		bucket: ${6:# The s3 bucket to which the snapshot is exported}
		target: ${7:# The name of a snapshot copy}
$0
endsnippet

snippet elasticache_subnet_group "manage Elasticache subnet groups"
- name: $1
	elasticache_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		subnets: ${5:# List of subnet IDs that make up the Elasticache subnet group.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		profile: ${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${11:#yes|no}
		description: ${12:# Elasticache subnet group description. Only set when a new group is added.}
$0
endsnippet

snippet execute_lambda "Execute an AWS Lambda function"
- name: $1
	execute_lambda:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		name: ${5:# The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN.}
		dry_run: ${6:no}
		function_arn: ${7:# The name of the function to be invoked}
		tail_log: ${8:no}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		version_qualifier: ${10:LATEST}
		security_token: ${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${12:#yes|no}
		payload: ${13:{}}
		wait: ${14:yes}
$0
endsnippet

snippet iam "Manage IAM users, groups, roles and keys"
- name: $1
	iam:
		name: ${2:# Name of IAM resource to create or identify}
		iam_type: ${3:user|group|role}
		state: ${4:present|absent|update}
		new_name: ${5:# When state is update, will replace name with new_name on IAM resource}
		aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		update_password: ${7:#always|on_create}
		new_path: ${8:# When state is update, will replace the path with new_path on the IAM resource}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		access_key_state: ${10:create|remove|active|inactive}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		key_count: ${12:1}
		aws_access_key: ${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		validate_certs: ${14:#yes|no}
		access_key_ids: ${15:# A list of the keys that you want impacted by the access_key_state parameter.}
		profile: ${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
		groups: ${17:# A list of groups the user should belong to. When update, will gracefully remove groups not listed.}
		trust_policy: ${18:# The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath).}
		path: ${19:/}
		password: ${20:# When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.}
		trust_policy_filepath: ${21:# The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy).}
$0
endsnippet

snippet iam_cert "Manage server certificates for use on ELBs and CloudFront"
- name: $1
	iam_cert:
		name: ${2:# Name of certificate to add, update or remove.}
		state: ${3:present|absent}
		new_name: ${4:# When present, this will update the name of the cert with the value passed here.}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		dup_ok: ${6:no}
		new_path: ${7:# When present, this will update the path of the cert with the value passed here.}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		cert: ${10:# The path to the certificate body in PEM encoded format.}
		profile: ${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
		key: ${12:# The path to the private key of the certificate in PEM encoded format.}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		path: ${14:/}
		aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		validate_certs: ${16:#yes|no}
		cert_chain: ${17:# The path to the CA certificate chain in PEM encoded format.}
$0
endsnippet

snippet iam_mfa_device_facts "List the MFA (Multi-Factor Authentication) devices registered for a user"
- name: $1
	iam_mfa_device_facts:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		ec2_url: ${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${7:#yes|no}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		user_name: ${9:# The name of the user whose MFA devices will be listed}
$0
endsnippet

snippet iam_policy "Manage IAM policies for users, groups, and roles"
- name: $1
	iam_policy:
		iam_name: ${2:# Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.}
		iam_type: ${3:user|group|role}
		policy_name: ${4:# The name label for the policy to create or remove.}
		state: ${5:present|absent}
		aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		policy_document: ${7:# The path to the properly json formatted policy file (mutually exclusive with C(policy_json))}
		aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		policy_json: ${11:# A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)}
		skip_duplicates: ${12:/}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		profile: ${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
		validate_certs: ${15:#yes|no}
$0
endsnippet

snippet iam_role "Manage AWS IAM roles"
- name: $1
	iam_role:
		name: ${2:# The name of the role to create.}
		state: ${3:present|absent}
		managed_policy: ${4:# A list of managed policy ARNs (can't use friendly names due to AWS API limitation) to attach to the role. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		assume_role_policy_document: ${9:# The trust relationship policy document that grants an entity permission to assume the role.  This parameter is required when state: present.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		path: ${11:/}
		validate_certs: ${12:#yes|no}
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate"
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet kinesis_stream "Manage a Kinesis Stream."
- name: $1
	kinesis_stream:
		name: ${2:# The name of the Kinesis Stream you are managing.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${7:# A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		retention_period: ${9:# The default retention period is 24 hours and can not be less than 24 hours.}
		shards: ${10:# The number of shards you want to have with this stream. This can not be modified after being created.}
		state: ${11:#present|absent}
		wait_timeout: ${12:300}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${14:#yes|no}
		wait: ${15:yes}
$0
endsnippet

snippet lambda "Manage AWS Lambda functions"
- name: $1
	lambda:
		name: ${2:# The name you want to assign to the function you are uploading. Cannot be changed.}
		runtime: ${3:# The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		description: ${5:# A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.}
		s3_key: ${6:# The Amazon S3 object (the deployment package) key name you want to upload}
		zip_file: ${7:# A .zip file containing your deployment package}
		s3_object_version: ${8:# The Amazon S3 object (the deployment package) version you want to upload.}
		memory_size: ${9:128}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		dead_letter_arn: ${11:# The parent object that contains the target Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.}
		aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		s3_bucket: ${15:# Amazon S3 bucket name where the .zip file containing your deployment package is stored}
		state: ${16:#present|absent}
		handler: ${17:# The function within your code that Lambda calls to begin execution}
		role: ${18:# The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.}
		timeout: ${19:3}
		environment_variables: ${20:# A dictionary of environment variables the Lambda function is given.}
		validate_certs: ${21:#yes|no}
		region: ${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		vpc_subnet_ids: ${23:# List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.}
		vpc_security_group_ids: ${24:# List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.}
$0
endsnippet

snippet lambda_alias "Creates, updates or deletes AWS Lambda function aliases."
- name: $1
	lambda_alias:
		name: ${2:# Name of the function alias.}
		state: ${3:#present|absent}
		function_name: ${4:# The name of the function alias.}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		description: ${8:# A short, user-defined function alias description.}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		version: ${10:# Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${12:#yes|no}
$0
endsnippet

snippet lambda_event "Creates, updates or deletes AWS Lambda function event mappings."
- name: $1
	lambda_event:
		source_params: ${2:# Sub-parameters required for event source.}
		lambda_function_arn: ${3:# The name or ARN of the lambda function.}
		alias: ${4:# Name of the function alias. Mutually exclusive with C(version).}
		state: ${5:#present|absent}
		aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		event_source: ${8:#stream}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		version: ${10:# Version of the Lambda function. Mutually exclusive with C(alias).}
		profile: ${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet lambda_facts "Gathers AWS Lambda function details as Ansible facts"
- name: $1
	lambda_facts:
		query: ${2:aliases|#all|config|mappings|policy|versions}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		event_source_arn: ${7:# For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.}
		ec2_url: ${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${9:#yes|no}
		function_name: ${10:# The name of the lambda function for which facts are requested.}
$0
endsnippet

snippet rds "create, delete, or modify an Amazon rds instance"
- name: $1
	rds:
		command: ${2:create|replicate|delete|facts|modify|promote|snapshot|reboot|restore}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		db_engine: ${4:mariadb|MySQL|oracle-se1|oracle-se|oracle-ee|sqlserver-ee|sqlserver-se|sqlserver-ex|sqlserver-web|postgres|aurora}
		iops: ${5:# Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000.}
		backup_window: ${6:# Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		backup_retention: ${8:# Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.}
		port: ${9:3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.}
		security_groups: ${10:# Comma separated list of one or more security groups.  Used only when command=create or command=modify.}
		size: ${11:# Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.}
		aws_secret_key: ${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		subnet: ${13:# VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.}
		vpc_security_groups: ${14:# Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.}
		upgrade: ${15:yes|no}
		zone: ${16:# availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.}
		instance_type: ${17:# The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.}
		source_instance: ${18:# Name of the database to replicate. Used only when command=replicate.}
		parameter_group: ${19:# Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.}
		multi_zone: ${20:yes|no}
		new_instance_name: ${21:# Name to rename an instance to. Used only when command=modify.}
		username: ${22:# Master database username. Used only when command=create.}
		tags: ${23:# tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0}
		db_name: ${24:# Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.}
		license_model: ${25:license-included|bring-your-own-license|general-public-license|postgresql-license}
		password: ${26:# Password for the master database username. Used only when command=create or command=modify.}
		apply_immediately: ${27:yes|no}
		wait: ${28:yes|#no}
		aws_access_key: ${29:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${30:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		character_set_name: ${31:# Associate the DB instance with a specified character set. Used with command=create.}
		validate_certs: ${32:#yes|no}
		region: ${33:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		option_group: ${34:# The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.}
		engine_version: ${35:# Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used.}
		instance_name: ${36:# Database instance identifier. Required except when using command=facts or command=delete on just a snapshot}
		force_failover: ${37:yes|#no}
		wait_timeout: ${38:300}
		snapshot: ${39:# Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.}
		publicly_accessible: ${40:# explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0}
		maint_window: ${41:# Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.}
$0
endsnippet

snippet rds_param_group "manage RDS parameter groups"
- name: $1
	rds_param_group:
		name: ${2:# Database parameter group identifier.}
		state: ${3:#present|absent}
		engine: ${4:aurora5.6|mariadb10.0|mariadb10.1|mysql5.1|mysql5.5|mysql5.6|mysql5.7|oracle-ee-11.2|oracle-ee-12.1|oracle-se-11.2|oracle-se-12.1|oracle-se1-11.2|oracle-se1-12.1|postgres9.3|postgres9.4|postgres9.5|postgres9.6|sqlserver-ee-10.5'|sqlserver-ee-11.0|sqlserver-ex-10.5|sqlserver-ex-11.0|sqlserver-ex-12.0|sqlserver-se-10.5|sqlserver-se-11.0|sqlserver-se-12.0|sqlserver-web-10.5|sqlserver-web-11.0|sqlserver-web-12.0}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		immediate: ${9:# Whether to apply the changes immediately, or after the next reboot of any associated instances.}
		params: ${10:# Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		profile: ${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
		validate_certs: ${13:#yes|no}
		description: ${14:# Database parameter group description. Only set when a new group is added.}
$0
endsnippet

snippet rds_subnet_group "manage RDS database subnet groups"
- name: $1
	rds_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		subnets: ${5:# List of subnet IDs that make up the database subnet group.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		profile: ${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${11:#yes|no}
		description: ${12:# Database subnet group description. Only set when a new group is added.}
$0
endsnippet

snippet redshift "create, delete, or modify an Amazon Redshift instance"
- name: $1
	redshift:
		command: ${2:create|facts|delete|modify}
		identifier: ${3:# Redshift cluster identifier.}
		cluster_parameter_group_name: ${4:# name of the cluster parameter group}
		username: ${5:# Master database username. Used only when command=create.}
		new_cluster_identifier: ${6:# Only used when command=modify.}
		number_of_nodes: ${7:# Number of nodes. Only used when cluster_type=multi-node.}
		availability_zone: ${8:# availability zone in which to launch cluster}
		encrypted: ${9:no}
		node_type: ${10:ds1.xlarge|ds1.8xlarge|ds2.xlarge|ds2.8xlarge|dc1.large|dc1.8xlarge|dw1.xlarge|dw1.8xlarge|dw2.large|dw2.8xlarge}
		db_name: ${11:# Name of the database.}
		publicly_accessible: ${12:no}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		password: ${14:# Master database password. Used only when command=create.}
		port: ${15:# which port the cluster is listining}
		wait: ${16:yes|#no}
		aws_secret_key: ${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		allow_version_upgrade: ${20:yes}
		cluster_type: ${21:multi-node|#single-node}
		elastic_ip: ${22:# if the cluster has an elastic IP or not}
		cluster_subnet_group_name: ${23:# which subnet to place the cluster}
		profile: ${24:# Uses a boto profile. Only works with boto >= 2.24.0.}
		validate_certs: ${25:#yes|no}
		wait_timeout: ${26:300}
		cluster_security_groups: ${27:# in which security group the cluster belongs}
		automated_snapshot_retention_period: ${28:# period when the snapshot take place}
		cluster_version: ${29:1.0}
		preferred_maintenance_window: ${30:# maintenance window}
		vpc_security_group_ids: ${31:# VPC security group}
$0
endsnippet

snippet redshift_subnet_group "mange Redshift cluster subnet groups"
- name: $1
	redshift_subnet_group:
		group_name: ${2:# Cluster subnet group name.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		ec2_url: ${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		state: ${8:#present|absent}
		group_subnets: ${9:# List of subnet IDs that make up the cluster subnet group.}
		group_description: ${10:# Database subnet group description.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet route53 "add or delete entries in Amazons Route53 DNS service"
- name: $1
	route53:
		zone: ${2:# The DNS zone to modify}
		record: ${3:# The full DNS record to create or delete}
		command: ${4:get|create|delete}
		type: ${5:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|NS|SOA}
		profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		health_check: ${8:# Health check to associate with this record}
		weight: ${9:# Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		hosted_zone_id: ${11:# The Hosted Zone ID of the DNS zone to modify}
		wait_timeout: ${12:300}
		ttl: ${13:3600 (one hour)}
		overwrite: ${14:# Whether an existing record should be overwritten on create if values do not match}
		wait: ${15:no}
		aws_secret_key: ${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		alias_hosted_zone_id: ${18:# The hosted zone identifier.}
		validate_certs: ${19:#yes|no}
		region: ${20:# Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing}
		retry_interval: ${21:500}
		value: ${22:# The new value when creating a DNS record.  Multiple comma-spaced values are allowed for non-alias records.  When deleting a record all values for the record must be specified or Route53 will not delete it.}
		alias: ${23:True|False}
		private_zone: ${24:no}
		alias_evaluate_target_health: ${25:no}
		vpc_id: ${26:# When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.}
		identifier: ${27:# Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.}
		failover: ${28:# Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY}
$0
endsnippet

snippet route53_facts "Retrieves route53 details using AWS methods"
- name: $1
	route53_facts:
		query: ${2:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		start_record_name: ${6:# The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		resource_id: ${8:# The ID/s of the specified resource/s}
		hosted_zone_method: ${9:details|#list|list_by_name|count|tags}
		dns_name: ${10:# The first name in the lexicographic ordering of domain names that you want the list_command to start listing from}
		health_check_method: ${11:#list|details|status|failure_reason|count|tags}
		delegation_set_id: ${12:# The DNS Zone delegation set ID}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		max_items: ${14:# Maximum number of items to return for various get/list requests}
		hosted_zone_id: ${15:# The Hosted Zone ID of the DNS zone}
		validate_certs: ${16:#yes|no}
		health_check_id: ${17:# The ID of the health check}
		change_id: ${18:# The ID of the change batch request. The value that you specify here is the value that ChangeResourceRecordSets returned in the Id element when you submitted the request.}
		next_marker: ${19:# Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results}
		type: ${20:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|NS}
$0
endsnippet

snippet route53_health_check "add or delete health-checks in Amazons Route53 DNS service"
- name: $1
	route53_health_check:
		request_interval: ${2:10|#30}
		type: ${3:HTTP|HTTPS|HTTP_STR_MATCH|HTTPS_STR_MATCH|TCP}
		state: ${4:present|absent}
		failure_threshold: ${5:1|2|#3|4|5|6|7|8|9|10}
		aws_secret_key: ${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		fqdn: ${12:# Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.}
		port: ${13:# The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.}
		validate_certs: ${14:#yes|no}
		resource_path: ${15:# The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.}
		ip_address: ${16:# IP address of the end-point to check. Either this or `fqdn` has to be provided.}
		string_match: ${17:# If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.}
$0
endsnippet

snippet route53_zone "add or delete Route53 zones"
- name: $1
	route53_zone:
		zone: ${2:# The DNS zone record (eg: foo.com.)}
		comment: ${3:}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		vpc_region: ${6:# The VPC Region the zone should be a part of (if this is going to be a private zone)}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		state: ${8:present|absent}
		profile: ${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		vpc_id: ${11:# The VPC ID the zone should be a part of (if this is going to be a private zone)}
		security_token: ${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet s3 "manage objects in S3."
- name: $1
	s3:
		bucket: ${2:# Bucket name.}
		mode: ${3:get|put|delete|create|geturl|getstr|delobj|list}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		permission: ${5:private}
		dest: ${6:# The destination file path when downloading an object/key with a GET operation.}
		object: ${7:# Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.}
		prefix: ${8:# Limits the response to keys that begin with the specified prefix for list mode}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		marker: ${10:# Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.}
		ignore_nonexistent_bucket: ${11:no}
		overwrite: ${12:always}
		headers: ${13:# Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
		aws_secret_key: ${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		src: ${15:# The source file path when performing a PUT operation.}
		aws_access_key: ${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		encrypt: ${17:no}
		security_token: ${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		rgw: ${19:no}
		region: ${20:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.  Prior to ansible 1.8 this parameter could be specified but had no effect.}
		retries: ${21:0}
		max_keys: ${22:1000}
		version: ${23:# Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.}
		expiration: ${24:600}
		s3_url: ${25:# S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS}
		metadata: ${26:# Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
		validate_certs: ${27:#yes|no}
$0
endsnippet

snippet s3_bucket "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3"
- name: $1
	s3_bucket:
		name: ${2:# Name of the s3 bucket}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		force: ${6:yes|no}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		tags: ${8:# tags dict to apply to bucket}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		ceph: ${10:# Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.}
		state: ${11:#present|absent}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		policy: ${13:# The JSON policy as a string.}
		s3_url: ${14:# S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS}
		validate_certs: ${15:#yes|no}
		requester_pays: ${16:yes|no}
		versioning: ${17:yes|no}
$0
endsnippet

snippet s3_lifecycle "Manage s3 bucket lifecycle rules in AWS"
- name: $1
	s3_lifecycle:
		name: ${2:# Name of the s3 bucket}
		status: ${3:#enabled|disabled}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		transition_days: ${5:# Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		expiration_date: ${7:# Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		prefix: ${9:# Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket.}
		state: ${10:#present|absent}
		storage_class: ${11:#glacier|standard_ia}
		profile: ${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		expiration_days: ${14:# Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.}
		aws_access_key: ${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		validate_certs: ${16:#yes|no}
		rule_id: ${17:# Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.}
		transition_date: ${18:# Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required.}
$0
endsnippet

snippet s3_logging "Manage logging facility of an s3 bucket in AWS"
- name: $1
	s3_logging:
		name: ${2:# Name of the s3 bucket.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${7:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		target_prefix: ${8:}
		target_bucket: ${9:# The bucket to log to. Required when state=present.}
		state: ${10:#present|absent}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${12:#yes|no}
$0
endsnippet

snippet s3_sync "Efficiently upload multiple files to S3"
- name: $1
	s3_sync:
		file_root: ${2:# File/directory path for synchronization. This is a local path.}
		bucket: ${3:# Bucket name.}
		mode: ${4:#push}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${6:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		file_change_strategy: ${8:force|checksum|#date_size}
		security_token: ${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		permission: ${10:|private|public-read|public-read-write|authenticated-read|aws-exec-read|bucket-owner-read|bucket-owner-full-control}
		region: ${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		mime_map: ${12:# Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({".txt": "application/text", ".yml": "appication/text"})}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		exclude: ${14:.*}
		include: ${15:*}
		validate_certs: ${16:#yes|no}
		key_prefix: ${17:# In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary.}
$0
endsnippet

snippet s3_website "Configure an s3 bucket as a website"
- name: $1
	s3_website:
		name: ${2:# Name of the s3 bucket}
		redirect_all_requests: ${3:# Describes the redirect behavior for every request to this s3 bucket website endpoint}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		suffix: ${6:index.html}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		region: ${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		error_key: ${9:# The object key name to use when a 4XX class error occurs. To remove an error key, set to None.}
		state: ${10:#present|absent}
		profile: ${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${13:#yes|no}
$0
endsnippet

snippet sns_topic "Manages AWS SNS topics and subscriptions"
- name: $1
	sns_topic:
		name: ${2:# The name or ARN of the SNS topic to converge}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		display_name: ${6:# Display name of the topic}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		subscriptions: ${8:[]}
		delivery_policy: ${9:# Delivery policy to apply to the SNS topic}
		state: ${10:absent|#present}
		ec2_url: ${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		policy: ${12:# Policy to apply to the SNS topic}
		purge_subscriptions: ${13:yes}
		validate_certs: ${14:#yes|no}
$0
endsnippet

snippet sqs_queue "Creates or deletes AWS SQS queues."
- name: $1
	sqs_queue:
		name: ${2:# Name of the queue.}
		aws_secret_key: ${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${4:# Uses a boto profile. Only works with boto >= 2.24.0.}
		message_retention_period: ${5:# The message retention period in seconds.}
		delivery_delay: ${6:# The delivery delay in seconds.}
		default_visibility_timeout: ${7:# The default visibility timeout in seconds.}
		validate_certs: ${8:#yes|no}
		region: ${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
		aws_access_key: ${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		state: ${11:#present|absent}
		maximum_message_size: ${12:# The maximum message size in bytes.}
		ec2_url: ${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		policy: ${14:# The json dict policy to attach to queue}
		security_token: ${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		redrive_policy: ${16:# json dict with the redrive_policy (see example)}
		receive_message_wait_time: ${17:# The receive message wait time in seconds.}
$0
endsnippet

snippet sts_assume_role "Assume a role using AWS Security Token Service and obtain temporary credentials"
- name: $1
	sts_assume_role:
		role_arn: ${2:# The Amazon Resource Name (ARN) of the role that the caller is assuming (http://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs)}
		role_session_name: ${3:# Name of the role's session - will be used by CloudTrail}
		aws_secret_key: ${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${5:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		duration_seconds: ${8:# The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds.}
		validate_certs: ${9:#yes|no}
		mfa_serial_number: ${10:# he identification number of the MFA device that is associated with the user who is making the AssumeRole call.}
		mfa_token: ${11:# The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.}
		ec2_url: ${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		policy: ${13:# Supplemental policy to use in addition to assumed role's policies.}
		external_id: ${14:# A unique identifier that is used by third parties to assume a role in their customers' accounts.}
		region: ${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
$0
endsnippet

snippet sts_session_token "Obtain a session token from the AWS Security Token Service"
- name: $1
	sts_session_token:
		aws_secret_key: ${2:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
		profile: ${3:# Uses a boto profile. Only works with boto >= 2.24.0.}
		aws_access_key: ${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
		security_token: ${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
		duration_seconds: ${6:# The duration, in seconds, of the session token. See http://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters for acceptable and default values.}
		mfa_serial_number: ${7:# The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.}
		mfa_token: ${8:# The value provided by the MFA device, if the trust policy of the user requires MFA.}
		ec2_url: ${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
		validate_certs: ${10:#yes|no}
		region: ${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
$0
endsnippet

snippet atomic_host "Manage the atomic host platform"
- name: $1
	atomic_host:
		revision: ${2:latest}
$0
endsnippet

snippet atomic_image "Manage the container images on the atomic host platform"
- name: $1
	atomic_image:
		name: ${2:# Name of the container image}
		started: ${3:yes|no}
		state: ${4:present|absent|#latest}
$0
endsnippet

snippet azure "create or terminate a virtual machine in azure"
- name: $1
	azure:
		image: ${2:# system image for creating the virtual machine (e.g., b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu_DAILY_BUILD-precise-12_04_3-LTS-amd64-server-20131205-en-us-30GB)}
		storage_account: ${3:# the azure storage account in which to store the data disks.}
		name: ${4:# name of the virtual machine and associated cloud service.}
		location: ${5:# the azure location to use (e.g. 'East US')}
		role_size: ${6:Small}
		virtual_network_name: ${7:# Name of virtual network.}
		wait_timeout_redirects: ${8:300}
		wait_timeout: ${9:600}
		user: ${10:# the unix username for the new virtual machine.}
		auto_updates: ${11:yes|#no}
		password: ${12:# the unix password for the new virtual machine.}
		os_type: ${13:windows|#linux}
		wait: ${14:yes|#no}
		management_cert_path: ${15:# path to an azure management certificate associated with the subscription id. Overrides the AZURE_CERT_PATH environment variable.}
		hostname: ${16:# hostname to write /etc/hostname. Defaults to <name>.cloudapp.net.}
		ssh_cert_path: ${17:# path to an X509 certificate containing the public ssh key to install in the virtual machine. See http://www.windowsazure.com/en-us/manage/linux/tutorials/intro-to-linux/ for more details.}
		state: ${18:present}
		subscription_id: ${19:# azure subscription id. Overrides the AZURE_SUBSCRIPTION_ID environment variable.}
		endpoints: ${20:22}
		enable_winrm: ${21:#yes|no}
$0
endsnippet

snippet azure_rm_deployment "Create or destroy Azure Resource Manager template deployments"
- name: $1
	azure_rm_deployment:
		resource_group_name: ${2:# The resource group name to use or create to host the deployed template}
		profile: ${3:# Security profile found in ~/.azure/credentials file.}
		parameters: ${4:# A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'parameters_link'. Either one of them is required if "state" parameter is "present".}
		deployment_name: ${5:ansible-arm}
		wait_for_deployment_polling_period: ${6:10}
		ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		wait_for_deployment_completion: ${8:yes|no}
		template_link: ${9:# Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if "state" parameter is "present".}
		secret: ${10:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${11:#present|absent}
		client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		location: ${13:westus}
		template: ${14:# A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if "state" parameter is "present".}
		parameters_link: ${15:# Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if "state" parameter is "present".}
		subscription_id: ${16:# Your Azure subscription Id.}
		password: ${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		deployment_mode: ${18:complete|#incremental}
		tenant: ${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_networkinterface "Manage Azure network interfaces."
- name: $1
	azure_rm_networkinterface:
		resource_group: ${2:# Name of a resource group where the network interface exists or will be created.}
		name: ${3:# Name of the network interface.}
		profile: ${4:# Security profile found in ~/.azure/credentials file.}
		open_ports: ${5:# When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.}
		virtual_network_name: ${6:# Name of an existing virtual network with which the network interface will be associated. Required when creating a network interface.}
		public_ip_allocation_method: ${7:#Dynamic|Static}
		security_group_name: ${8:# Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created.}
		public_ip: ${9:yes}
		private_ip_allocation_method: ${10:#Dynamic|Static}
		client_id: ${11:# Azure client ID. Use when authenticating with a Service Principal.}
		password: ${12:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		subscription_id: ${13:# Your Azure subscription Id.}
		tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
		public_ip_address_name: ${15:# Name of an existing public IP address object to associate with the security group.}
		append_tags: ${16:yes}
		ad_user: ${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		state: ${18:absent|#present}
		secret: ${19:# Azure client secret. Use when authenticating with a Service Principal.}
		tags: ${20:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		subnet_name: ${21:# Name of an existing subnet within the specified virtual network. Required when creating a network interface}
		location: ${22:resource_group location}
		private_ip_address: ${23:# Valid IPv4 address that falls within the specified subnet.}
		os_type: ${24:Windows|#Linux}
$0
endsnippet

snippet azure_rm_networkinterface_facts "Get network interface facts."
- name: $1
	azure_rm_networkinterface_facts:
		profile: ${2:# Security profile found in ~/.azure/credentials file.}
		name: ${3:# Only show results for a specific network interface.}
		resource_group: ${4:# Name of the resource group containing the network interface(s). Required when searching by name.}
		tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${9:# Your Azure subscription Id.}
		password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_publicipaddress "Manage Azure Public IP Addresses."
- name: $1
	azure_rm_publicipaddress:
		name: ${2:# Name of the Public IP.}
		resource_group: ${3:# Name of resource group with which the Public IP is associated.}
		profile: ${4:# Security profile found in ~/.azure/credentials file.}
		tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		append_tags: ${6:yes}
		ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${9:absent|#present}
		domain_name_label: ${10:# The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP.}
		location: ${11:resource_group location}
		client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		allocation_method: ${13:#Dynamic|Static}
		subscription_id: ${14:# Your Azure subscription Id.}
		password: ${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_publicipaddress_facts "Get public IP facts."
- name: $1
	azure_rm_publicipaddress_facts:
		profile: ${2:# Security profile found in ~/.azure/credentials file.}
		name: ${3:# Only show results for a specific Public IP.}
		resource_group: ${4:# Limit results by resource group. Required when using name parameter.}
		tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${9:# Your Azure subscription Id.}
		password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_resourcegroup "Manage Azure resource groups."
- name: $1
	azure_rm_resourcegroup:
		name: ${2:# Name of the resource group.}
		profile: ${3:# Security profile found in ~/.azure/credentials file.}
		force: ${4:no}
		tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		append_tags: ${6:yes}
		ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${9:absent|#present}
		location: ${10:# Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.}
		client_id: ${11:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${12:# Your Azure subscription Id.}
		password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_resourcegroup_facts "Get resource group facts."
- name: $1
	azure_rm_resourcegroup_facts:
		profile: ${2:# Security profile found in ~/.azure/credentials file.}
		name: ${3:# Limit results to a specific resource group.}
		tags: ${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${6:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${7:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${8:# Your Azure subscription Id.}
		password: ${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_securitygroup "Manage Azure network security groups."
- name: $1
	azure_rm_securitygroup:
		resource_group: ${2:# Name of the resource group the security group belongs to.}
		profile: ${3:# Security profile found in ~/.azure/credentials file.}
		purge_rules: ${4:no}
		tags: ${5:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		rules: ${6:# Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.}
		append_tags: ${7:yes}
		ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		default_rules: ${10:# The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.}
		purge_default_rules: ${11:no}
		state: ${12:absent|#present}
		location: ${13:resource_group location}
		client_id: ${14:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${15:# Your Azure subscription Id.}
		password: ${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
		name: ${18:# Name of the security group to operate on.}
$0
endsnippet

snippet azure_rm_securitygroup_facts "Get security group facts."
- name: $1
	azure_rm_securitygroup_facts:
		resource_group: ${2:# Name of the resource group to use.}
		profile: ${3:# Security profile found in ~/.azure/credentials file.}
		name: ${4:# Only show results for a specific security group.}
		tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${9:# Your Azure subscription Id.}
		password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_storageaccount "Manage Azure storage accounts."
- name: $1
	azure_rm_storageaccount:
		resource_group: ${2:# Name of the resource group to use.}
		profile: ${3:# Security profile found in ~/.azure/credentials file.}
		kind: ${4:#Storage|StorageBlob}
		account_type: ${5:Premium_LRS|Standard_GRS|Standard_LRS|Standard_RAGRS|Standard_ZRS}
		custom_domain: ${6:# User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.}
		tags: ${7:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		append_tags: ${8:yes}
		ad_user: ${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${10:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${11:absent|#present}
		location: ${12:resource_group location}
		client_id: ${13:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${14:# Your Azure subscription Id.}
		password: ${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
		name: ${17:# Name of the storage account to update or create.}
$0
endsnippet

snippet azure_rm_storageaccount_facts "Get storage account facts."
- name: $1
	azure_rm_storageaccount_facts:
		profile: ${2:# Security profile found in ~/.azure/credentials file.}
		name: ${3:# Only show results for a specific account.}
		resource_group: ${4:# Limit results to a resource group. Required when filtering by name.}
		tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${9:# Your Azure subscription Id.}
		password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_storageblob "Manage blob containers and blob objects."
- name: $1
	azure_rm_storageblob:
		resource_group: ${2:# Name of the resource group to use.}
		container: ${3:# Name of a blob container within the storage account.}
		storage_account_name: ${4:# Name of the storage account to use.}
		profile: ${5:# Security profile found in ~/.azure/credentials file.}
		force: ${6:no}
		client_id: ${7:# Azure client ID. Use when authenticating with a Service Principal.}
		tags: ${8:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		dest: ${9:# Destination file path. Use with state 'present' to download a blob.}
		content_language: ${10:# Set the blob content-language header.}
		content_type: ${11:# Set the blob content-type header. For example, 'image/png'.}
		public_access: ${12:container|blob}
		password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
		src: ${15:# Source file path. Use with state 'present' to upload a blob.}
		append_tags: ${16:yes}
		ad_user: ${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${18:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${19:absent|#present}
		blob: ${20:# Name of a blob object within the container.}
		content_md5: ${21:# Set the blob md5 hash value.}
		subscription_id: ${22:# Your Azure subscription Id.}
		content_disposition: ${23:# Set the blob content-disposition header.}
		cache_control: ${24:# Set the blob cache-control header.}
		content_encoding: ${25:# Set the blob encoding header.}
$0
endsnippet

snippet azure_rm_subnet "Manage Azure subnets."
- name: $1
	azure_rm_subnet:
		name: ${2:# Name of the subnet.}
		resource_group: ${3:# Name of resource group.}
		virtual_network_name: ${4:# Name of an existing virtual network with which the subnet is or will be associated.}
		state: ${5:absent|#present}
		address_prefix_cidr: ${6:# CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.}
		profile: ${7:# Security profile found in ~/.azure/credentials file.}
		ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		security_group_name: ${10:# Name of an existing security group with which to associate the subnet.}
		client_id: ${11:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${12:# Your Azure subscription Id.}
		password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_virtualmachine "Manage Azure virtual machines."
- name: $1
	azure_rm_virtualmachine:
		resource_group: ${2:# Name of the resource group containing the virtual machine.}
		image: ${3:# A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image.}
		name: ${4:# Name of the virtual machine.}
		profile: ${5:# Security profile found in ~/.azure/credentials file.}
		tags: ${6:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		virtual_network_name: ${7:# When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead.}
		public_ip_allocation_method: ${8:[Dynamic, #Static}
		open_ports: ${9:# If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.}
		ssh_public_keys: ${10:# For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.}
		storage_container_name: ${11:vhds}
		client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		allocated: ${13:yes}
		password: ${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		ssh_password_enabled: ${15:yes}
		vm_size: ${16:Standard_D1}
		tenant: ${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
		remove_on_absent: ${18:[u'all']}
		restarted: ${19:no}
		append_tags: ${20:yes}
		ad_user: ${21:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${22:# Azure client secret. Use when authenticating with a Service Principal.}
		admin_username: ${23:# Admin username used to access the host after it is created. Required when creating a VM.}
		subscription_id: ${24:# Your Azure subscription Id.}
		short_hostname: ${25:# Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.}
		started: ${26:yes}
		state: ${27:absent|#present}
		subnet_name: ${28:# When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead.}
		location: ${29:# Valid Azure location. Defaults to location of the resource group.}
		os_disk_caching: ${30:#ReadOnly|ReadWrite}
		network_interface_names: ${31:# List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist.}
		os_type: ${32:[Windows, #Linux}
		storage_account_name: ${33:# Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.}
		storage_blob_name: ${34:# Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'}
		admin_password: ${35:# Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.}
$0
endsnippet

snippet azure_rm_virtualmachineimage_facts "Get virtual machine image facts."
- name: $1
	azure_rm_virtualmachineimage_facts:
		location: ${2:# Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.}
		sku: ${3:# Image offering SKU. Combine with offer to see a list of available versions.}
		publisher: ${4:# Name of an image publisher. List image offerings associated with a particular publisher.}
		name: ${5:# Only show results for a specific security group.}
		offer: ${6:# Name of an image offering. Combine with sku to see a list of available image versions.}
		ad_user: ${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${8:# Azure client secret. Use when authenticating with a Service Principal.}
		version: ${9:# Specific version number of an image.}
		profile: ${10:# Security profile found in ~/.azure/credentials file.}
		client_id: ${11:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${12:# Your Azure subscription Id.}
		password: ${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet azure_rm_virtualnetwork "Manage Azure virtual networks."
- name: $1
	azure_rm_virtualnetwork:
		name: ${2:# name of the virtual network.}
		resource_group: ${3:# name of resource group.}
		profile: ${4:# Security profile found in ~/.azure/credentials file.}
		dns_servers: ${5:# Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.}
		tags: ${6:# Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.
}
		append_tags: ${7:yes}
		ad_user: ${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${9:# Azure client secret. Use when authenticating with a Service Principal.}
		state: ${10:absent|#present}
		address_prefixes_cidr: ${11:# List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.}
		client_id: ${12:# Azure client ID. Use when authenticating with a Service Principal.}
		purge_address_prefixes: ${13:no}
		purge_dns_servers: ${14:no}
		subscription_id: ${15:# Your Azure subscription Id.}
		password: ${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
		location: ${18:resource_group location}
$0
endsnippet

snippet azure_rm_virtualnetwork_facts "Get virtual network facts."
- name: $1
	azure_rm_virtualnetwork_facts:
		profile: ${2:# Security profile found in ~/.azure/credentials file.}
		name: ${3:# Only show results for a specific security group.}
		resource_group: ${4:# Limit results by resource group. Required when filtering by name.}
		tags: ${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
		ad_user: ${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
		secret: ${7:# Azure client secret. Use when authenticating with a Service Principal.}
		client_id: ${8:# Azure client ID. Use when authenticating with a Service Principal.}
		subscription_id: ${9:# Your Azure subscription Id.}
		password: ${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
		tenant: ${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
$0
endsnippet

snippet clc_aa_policy "Create or Delete Anti Affinity Policies at CenturyLink Cloud."
- name: $1
	clc_aa_policy:
		location: ${2:# Datacenter in which the policy lives/should live.}
		name: ${3:# The name of the Anti Affinity Policy.}
		state: ${4:#present|absent}
		wait: ${5:#True|False}
$0
endsnippet

snippet clc_alert_policy "Create or Delete Alert Policies at CenturyLink Cloud."
- name: $1
	clc_alert_policy:
		alias: ${2:# The alias of your CLC Account}
		name: ${3:# The name of the alert policy. This is mutually exclusive with id}
		metric: ${4:cpu|memory|disk}
		alert_recipients: ${5:# A list of recipient email ids to notify the alert. This is required for state 'present'}
		state: ${6:#present|absent}
		threshold: ${7:# The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0}
		id: ${8:# The alert policy id. This is mutually exclusive with name}
		duration: ${9:# The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'}
$0
endsnippet

snippet clc_blueprint_package "deploys a blue print package on a set of servers in CenturyLink Cloud."
- name: $1
	clc_blueprint_package:
		server_ids: ${2:# A list of server Ids to deploy the blue print package.}
		package_id: ${3:# The package id of the blue print.}
		package_params: ${4:{}}
		state: ${5:#present}
		wait: ${6:#True|False}
$0
endsnippet

snippet clc_firewall_policy "Create/delete/update firewall policies"
- name: $1
	clc_firewall_policy:
		location: ${2:# Target datacenter for the firewall policy}
		source_account_alias: ${3:# CLC alias for the source account}
		destination_account_alias: ${4:# CLC alias for the destination account}
		destination: ${5:# The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'}
		enabled: ${6:#True|False}
		source: ${7:# The list  of source addresses for traffic on the originating firewall. This is required when state is 'present"}
		state: ${8:#present|absent}
		firewall_policy_id: ${9:# Id of the firewall policy. This is required to update or delete an existing firewall policy}
		ports: ${10:any|icmp|TCP/123|UDP/123|TCP/123-456|UDP/123-456}
		wait: ${11:#True|False}
$0
endsnippet

snippet clc_group "Create/delete Server Groups at Centurylink Cloud"
- name: $1
	clc_group:
		name: ${2:# The name of the Server Group}
		state: ${3:#present|absent}
		parent: ${4:# The parent group of the server group. If parent is not provided, it creates the group at top level.}
		wait: ${5:#True|False}
		location: ${6:# Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account}
		description: ${7:# A description of the Server Group}
$0
endsnippet

snippet clc_loadbalancer "Create, Delete shared loadbalancers in CenturyLink Cloud."
- name: $1
	clc_loadbalancer:
		name: ${2:# The name of the loadbalancer}
		alias: ${3:# The alias of your CLC Account}
		location: ${4:# The location of the datacenter where the load balancer resides in}
		status: ${5:#enabled|disabled}
		method: ${6:leastConnection|roundRobin}
		state: ${7:#present|absent|port_absent|nodes_present|nodes_absent}
		nodes: ${8:[]}
		port: ${9:80|443}
		persistence: ${10:standard|sticky}
		description: ${11:# A description for the loadbalancer}
$0
endsnippet

snippet clc_modify_server "modify servers in CenturyLink Cloud."
- name: $1
	clc_modify_server:
		server_ids: ${2:# A list of server Ids to modify.}
		alert_policy_id: ${3:# The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'}
		anti_affinity_policy_name: ${4:# The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'}
		state: ${5:#present|absent}
		anti_affinity_policy_id: ${6:# The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'}
		alert_policy_name: ${7:# The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'}
		memory: ${8:# Memory (in GB) to set to the server.}
		cpu: ${9:# How many CPUs to update on the server}
		wait: ${10:#True|False}
$0
endsnippet

snippet clc_publicip "Add and Delete public ips on servers in CenturyLink Cloud."
- name: $1
	clc_publicip:
		server_ids: ${2:# A list of servers to create public ips on.}
		state: ${3:#present|absent}
		protocol: ${4:#TCP|UDP|ICMP}
		ports: ${5:# A list of ports to expose. This is required when state is 'present'}
		wait: ${6:#True|False}
$0
endsnippet

snippet clc_server "Create, Delete, Start and Stop servers in CenturyLink Cloud."
- name: $1
	clc_server:
		cpu_autoscale_policy_id: ${2:# The autoscale policy to assign to the server.}
		anti_affinity_policy_name: ${3:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.}
		storage_type: ${4:#standard|hyperscale}
		anti_affinity_policy_id: ${5:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.}
		ttl: ${6:# The time to live for the server in seconds.  The server will be deleted when this time expires.}
		count_group: ${7:# Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.}
		secondary_dns: ${8:# Secondary DNS used by the server.}
		custom_fields: ${9:[]}
		packages: ${10:[]}
		group: ${11:Default Group}
		exact_count: ${12:# Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.}
		state: ${13:#present|absent|started|stopped}
		location: ${14:# The Datacenter to create servers in.}
		template: ${15:# The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'}
		memory: ${16:1}
		server_ids: ${17:[]}
		type: ${18:#standard|hyperscale|bareMetal}
		managed_os: ${19:True|#False}
		additional_disks: ${20:[]}
		description: ${21:# The description to set for the server.}
		add_public_ip: ${22:#False|True}
		alert_policy_id: ${23:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.}
		alert_policy_name: ${24:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.}
		password: ${25:# Password for the administrator / root user}
		ip_address: ${26:# The IP Address for the server. One is assigned if not provided.}
		public_ip_protocol: ${27:#TCP|UDP|ICMP}
		wait: ${28:#True|False}
		count: ${29:1}
		name: ${30:# A 1 to 6 character identifier to use for the server. This is required when state is 'present'}
		network_id: ${31:# The network UUID on which to create servers.}
		primary_dns: ${32:# Primary DNS used by the server.}
		alias: ${33:# The account alias to provision the servers under.}
		public_ip_ports: ${34:[]}
		source_server_password: ${35:# The password for the source server if a clone is specified.}
		os_type: ${36:redHat6_64Bit|centOS6_64Bit|windows2012R2Standard_64Bit|ubuntu14_64Bit}
		configuration_id: ${37:# Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.}
		cpu: ${38:1}
$0
endsnippet

snippet clc_server_snapshot "Create, Delete and Restore server snapshots in CenturyLink Cloud."
- name: $1
	clc_server_snapshot:
		server_ids: ${2:# The list of CLC server Ids.}
		expiration_days: ${3:7}
		state: ${4:#present|absent|restore}
		wait: ${5:#True|False}
$0
endsnippet

snippet cloudscale_server "Manages servers on the cloudscale.ch IaaS service"
- name: $1
	cloudscale_server:
		volume_size_gb: ${2:10}
		uuid: ${3:# UUID of the server}
		name: ${4:# Name of the Server}
		use_public_network: ${5:yes}
		state: ${6:#running|stopped|absent}
		image: ${7:# Image used to create the server}
		use_ipv6: ${8:yes}
		user_data: ${9:# Cloud-init configuration (cloud-config) data to use for the server.}
		anti_affinity_with: ${10:# UUID of another server to create an anti-affinity group with}
		use_private_network: ${11:no}
		bulk_volume_size_gb: ${12:null (no bulk storage volume)}
		api_token: ${13:# cloudscale.ch API token.}
		flavor: ${14:# Flavor of the server}
		ssh_keys: ${15:# List of SSH public keys}
$0
endsnippet

snippet cs_account "Manages accounts on Apache CloudStack based clouds."
- name: $1
	cs_account:
		name: ${2:# Name of account.}
		username: ${3:# Username of the user to be created if account did not exist.}
		first_name: ${4:# First name of the user to be created if account did not exist.}
		last_name: ${5:# Last name of the user to be created if account did not exist.}
		account_type: ${6:#user|root_admin|domain_admin}
		api_http_method: ${7:#get|post}
		password: ${8:# Password of the user to be created if account did not exist.}
		api_timeout: ${9:10}
		domain: ${10:ROOT}
		api_region: ${11:cloudstack}
		api_key: ${12:# API key of the CloudStack API.}
		state: ${13:#present|absent|enabled|disabled|locked|unlocked}
		api_secret: ${14:# Secret key of the CloudStack API.}
		timezone: ${15:# Timezone of the user to be created if account did not exist.}
		poll_async: ${16:yes}
		network_domain: ${17:# Network domain of the account.}
		email: ${18:# Email of the user to be created if account did not exist.}
		api_url: ${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_affinitygroup "Manages affinity groups on Apache CloudStack based clouds."
- name: $1
	cs_affinitygroup:
		name: ${2:# Name of the affinity group.}
		account: ${3:# Account the affinity group is related to.}
		poll_async: ${4:yes}
		api_http_method: ${5:#get|post}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		affinty_type: ${8:# Type of the affinity group. If not specified, first found affinity type is used.}
		domain: ${9:# Domain the affinity group is related to.}
		api_region: ${10:cloudstack}
		project: ${11:# Name of the project the affinity group is related to.}
		state: ${12:#present|absent}
		api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_key: ${14:# API key of the CloudStack API.}
		description: ${15:# Description of the affinity group.}
$0
endsnippet

snippet cs_cluster "Manages host clusters on Apache CloudStack based clouds."
- name: $1
	cs_cluster:
		name: ${2:# name of the cluster.}
		username: ${3:# Username for the cluster.}
		guest_vswitch_type: ${4:vmwaresvs|vmwaredvs}
		ovm3_cluster: ${5:# Ovm3 native OCFS2 clustering enabled for cluster.}
		ovm3_pool: ${6:# Ovm3 native pooling enabled for cluster.}
		api_http_method: ${7:#get|post}
		api_secret: ${8:# Secret key of the CloudStack API.}
		api_timeout: ${9:10}
		api_region: ${10:cloudstack}
		api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		pod: ${12:# Name of the pod in which the cluster belongs to.}
		hypervisor: ${13:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		guest_vswitch_name: ${14:# Name of virtual switch used for guest traffic in the cluster.}
		vms_username: ${15:# Username for the VSM associated with this cluster.}
		password: ${16:# Password for the cluster.}
		public_vswitch_type: ${17:vmwaresvs|vmwaredvs}
		zone: ${18:# Name of the zone in which the cluster belongs to.}
		url: ${19:# URL for the cluster}
		cluster_type: ${20:CloudManaged|ExternalManaged}
		ovm3_vip: ${21:# Ovm3 vip to use for pool (and cluster).}
		vms_ip_address: ${22:# IP address of the VSM associated with this cluster.}
		state: ${23:#present|absent|disabled|enabled}
		public_vswitch_name: ${24:# Name of virtual switch used for public traffic in the cluster.}
		api_key: ${25:# API key of the CloudStack API.}
		vms_password: ${26:# Password for the VSM associated with this cluster.}
$0
endsnippet

snippet cs_configuration "Manages configuration on Apache CloudStack based clouds."
- name: $1
	cs_configuration:
		name: ${2:# Name of the configuration.}
		value: ${3:# Value of the configuration.}
		domain: ${4:ROOT}
		zone: ${5:# Ensure the value for corresponding zone.}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		storage: ${8:# Ensure the value for corresponding storage pool.}
		account: ${9:# Ensure the value for corresponding account.}
		api_region: ${10:cloudstack}
		cluster: ${11:# Ensure the value for corresponding cluster.}
		api_http_method: ${12:#get|post}
		api_key: ${13:# API key of the CloudStack API.}
		api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_domain "Manages domains on Apache CloudStack based clouds."
- name: $1
	cs_domain:
		path: ${2:# Path of the domain.}
		api_key: ${3:# API key of the CloudStack API.}
		poll_async: ${4:yes}
		api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_http_method: ${6:#get|post}
		api_secret: ${7:# Secret key of the CloudStack API.}
		api_timeout: ${8:10}
		clean_up: ${9:no}
		api_region: ${10:cloudstack}
		state: ${11:#present|absent}
		network_domain: ${12:# Network domain for networks in the domain.}
$0
endsnippet

snippet cs_facts "Gather facts on instances of Apache CloudStack based clouds."
- name: $1
	cs_facts:
		filter: ${2:cloudstack_service_offering|cloudstack_availability_zone|cloudstack_public_hostname|cloudstack_public_ipv4|cloudstack_local_hostname|cloudstack_local_ipv4|cloudstack_instance_id|cloudstack_user_data}
$0
endsnippet

snippet cs_firewall "Manages firewall rules on Apache CloudStack based clouds."
- name: $1
	cs_firewall:
		icmp_code: ${2:# Error code for this icmp message. Considered if C(protocol=icmp).}
		domain: ${3:# Domain the firewall rule is related to.}
		api_key: ${4:# API key of the CloudStack API.}
		protocol: ${5:#tcp|udp|icmp|all}
		network: ${6:# Network the egress rule is related to.}
		zone: ${7:# Name of the zone in which the virtual machine is in.}
		type: ${8:#ingress|egress}
		end_port: ${9:# End port for this rule. Considered if C(protocol=tcp) or C(protocol=udp). If not specified, equal C(start_port).}
		account: ${10:# Account the firewall rule is related to.}
		api_region: ${11:cloudstack}
		project: ${12:# Name of the project the firewall rule is related to.}
		state: ${13:#present|absent}
		api_timeout: ${14:10}
		api_http_method: ${15:#get|post}
		api_secret: ${16:# Secret key of the CloudStack API.}
		start_port: ${17:# Start port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).}
		poll_async: ${18:yes}
		cidr: ${19:0.0.0.0/0}
		icmp_type: ${20:# Type of the icmp message being sent. Considered if C(protocol=icmp).}
		ip_address: ${21:# Public IP address the ingress rule is assigned to.}
		api_url: ${22:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_host "Manages hosts on Apache CloudStack based clouds."
- name: $1
	cs_host:
		name: ${2:# Name of the host.}
		username: ${3:# Username for the host.}
		api_key: ${4:# API key of the CloudStack API.}
		zone: ${5:# Name of the zone in which the host should be deployed.}
		host_tags: ${6:# Tags of the host.}
		hypervisor: ${7:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator}
		api_timeout: ${8:10}
		api_region: ${9:cloudstack}
		cluster: ${10:# Name of the cluster.}
		state: ${11:#present|absent}
		api_http_method: ${12:#get|post}
		api_secret: ${13:# Secret key of the CloudStack API.}
		pod: ${14:# Name of the pod.}
		password: ${15:# Password for the host.}
		allocation_state: ${16:enabled|disabled}
		api_url: ${17:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_instance "Manages instances and virtual machines on Apache CloudStack based clouds."
- name: $1
	cs_instance:
		domain: ${2:# Domain the instance is related to.}
		api_timeout: ${3:10}
		force: ${4:no}
		disk_offering: ${5:# Name of the disk offering to be used.}
		api_http_method: ${6:#get|post}
		tags: ${7:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		api_secret: ${8:# Secret key of the CloudStack API.}
		keyboard: ${9:de|de-ch|es|fi|fr|fr-be|fr-ch|is|it|jp|nl-be|no|pt|uk|us}
		user_data: ${10:# Optional data (ASCII) that can be sent to the instance upon a successful deployment.}
		root_disk_size: ${11:# Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)}
		ssh_key: ${12:# Name of the SSH key to be deployed on the new instance.}
		cpu_speed: ${13:# The clock speed/shares allocated to the instance, used with custom service offerings}
		ip6_address: ${14:# IPv6 address for default instance's network.}
		service_offering: ${15:# Name or id of the service offering of the new instance.}
		ip_address: ${16:# IPv4 address for default instance's network during creation.}
		networks: ${17:[]}
		security_groups: ${18:# List of security groups the instance to be applied to.}
		display_name: ${19:# Custom display name of the instances.}
		account: ${20:# Account the instance is related to.}
		api_key: ${21:# API key of the CloudStack API.}
		group: ${22:# Group in where the new instance should be in.}
		name: ${23:# Host name of the instance. C(name) can only contain ASCII letters.}
		zone: ${24:# Name of the zone in which the instance should be deployed.}
		hypervisor: ${25:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		ip_to_networks: ${26:# List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4}}
		disk_size: ${27:# Disk size in GByte required if deploying instance from ISO.}
		project: ${28:# Name of the project the instance to be deployed in.}
		api_url: ${29:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		state: ${30:deployed|started|stopped|restarted|restored|destroyed|expunged|#present|absent}
		api_region: ${31:cloudstack}
		affinity_groups: ${32:[]}
		template: ${33:# Name or id of the template to be used for creating the new instance.}
		memory: ${34:# The memory allocated to the instance, used with custom service offerings}
		iso: ${35:# Name or id of the ISO to be used for creating the new instance.}
		poll_async: ${36:yes}
		template_filter: ${37:featured|self|selfexecutable|sharedexecutable|#executable|community}
		cpu: ${38:# The number of CPUs to allocate to the instance, used with custom service offerings}
$0
endsnippet

snippet cs_instance_facts "Gathering facts from the API of instances from Apache CloudStack based clouds."
- name: $1
	cs_instance_facts:
		name: ${2:# Name or display name of the instance.}
		account: ${3:# Account the instance is related to.}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		domain: ${7:# Domain the instance is related to.}
		api_region: ${8:cloudstack}
		project: ${9:# Project the instance is related to.}
		api_key: ${10:# API key of the CloudStack API.}
		api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_instancegroup "Manages instance groups on Apache CloudStack based clouds."
- name: $1
	cs_instancegroup:
		name: ${2:# Name of the instance group.}
		account: ${3:# Account the instance group is related to.}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		domain: ${7:# Domain the instance group is related to.}
		api_region: ${8:cloudstack}
		project: ${9:# Project the instance group is related to.}
		state: ${10:#present|absent}
		api_key: ${11:# API key of the CloudStack API.}
		api_url: ${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_ip_address "Manages public IP address associations on Apache CloudStack based clouds."
- name: $1
	cs_ip_address:
		account: ${2:# Account the IP address is related to.}
		api_timeout: ${3:10}
		poll_async: ${4:yes}
		network: ${5:# Network the IP address is related to.}
		zone: ${6:# Name of the zone in which the IP address is in.}
		api_secret: ${7:# Secret key of the CloudStack API.}
		api_http_method: ${8:#get|post}
		domain: ${9:# Domain the IP address is related to.}
		api_region: ${10:cloudstack}
		project: ${11:# Name of the project the IP address is related to.}
		vpc: ${12:# VPC the IP address is related to.}
		api_key: ${13:# API key of the CloudStack API.}
		ip_address: ${14:# Public IP address.}
		api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_iso "Manages ISO images on Apache CloudStack based clouds."
- name: $1
	cs_iso:
		name: ${2:# Name of the ISO.}
		is_featured: ${3:no}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		iso_filter: ${7:featured|#self|selfexecutable|sharedexecutable|executable|community}
		api_region: ${8:cloudstack}
		domain: ${9:# Domain the ISO is related to.}
		is_public: ${10:no}
		api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		account: ${12:# Account the ISO is related to.}
		poll_async: ${13:yes}
		zone: ${14:# Name of the zone you wish the ISO to be registered or deleted from. If not specified, first zone found will be used.}
		url: ${15:# URL where the ISO can be downloaded from. Required if C(state) is present.}
		checksum: ${16:no}
		is_dynamically_scalable: ${17:no}
		project: ${18:# Name of the project the ISO to be registered in.}
		bootable: ${19:yes}
		state: ${20:#present|absent}
		is_ready: ${21:no}
		os_type: ${22:# Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present.}
		api_key: ${23:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_loadbalancer_rule "Manages load balancer rules on Apache CloudStack based clouds."
- name: $1
	cs_loadbalancer_rule:
		name: ${2:# The name of the load balancer rule.}
		public_port: ${3:# The public port from where the network traffic will be load balanced from.}
		state: ${4:#present|absent}
		ip_address: ${5:# Public IP address from where the network traffic will be load balanced from.}
		domain: ${6:# Domain the rule is related to.}
		api_key: ${7:# API key of the CloudStack API.}
		protocol: ${8:# The protocol to be used on the load balancer}
		algorithm: ${9:#source|roundrobin|leastconn}
		open_firewall: ${10:no}
		api_timeout: ${11:10}
		account: ${12:# Account the rule is related to.}
		api_region: ${13:cloudstack}
		project: ${14:# Name of the project the load balancer IP address is related to.}
		private_port: ${15:# The private port of the private ip address/virtual machine where the network traffic will be load balanced to.}
		api_http_method: ${16:#get|post}
		api_secret: ${17:# Secret key of the CloudStack API.}
		api_url: ${18:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		cidr: ${19:# CIDR (full notation) to be used for firewall rule if required.}
		zone: ${20:# Name of the zone in which the rule should be created.}
		description: ${21:# The description of the load balancer rule.}
$0
endsnippet

snippet cs_loadbalancer_rule_member "Manages load balancer rule members on Apache CloudStack based clouds."
- name: $1
	cs_loadbalancer_rule_member:
		name: ${2:# The name of the load balancer rule.}
		vms: ${3:# List of VMs to assign to or remove from the rule.}
		domain: ${4:# Domain the rule is related to.}
		zone: ${5:# Name of the zone in which the rule should be located.}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		account: ${8:# Account the rule is related to.}
		api_region: ${9:cloudstack}
		project: ${10:# Name of the project the firewall rule is related to.}
		state: ${11:#present|absent}
		api_http_method: ${12:#get|post}
		api_key: ${13:# API key of the CloudStack API.}
		ip_address: ${14:# Public IP address from where the network traffic will be load balanced from.}
		api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_network "Manages networks on Apache CloudStack based clouds."
- name: $1
	cs_network:
		name: ${2:# Name (case sensitive) of the network.}
		domain: ${3:# Domain the network is related to.}
		api_timeout: ${4:10}
		end_ipv6: ${5:# The ending IPv6 address of the network belongs to.}
		api_http_method: ${6:#get|post}
		api_secret: ${7:# Secret key of the CloudStack API.}
		vlan: ${8:# The ID or VID of the network.}
		clean_up: ${9:no}
		netmask: ${10:# The netmask of the network.}
		network_offering: ${11:# Name of the offering for the network.}
		vpc: ${12:# Name of the VPC of the network.}
		start_ip: ${13:# The beginning IPv4 address of the network belongs to.}
		gateway: ${14:# The gateway of the network.}
		gateway_ipv6: ${15:# The gateway of the IPv6 network.}
		api_url: ${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		display_text: ${17:# Display text of the network.}
		isolated_pvlan: ${18:# The isolated private VLAN for this network.}
		account: ${19:# Account the network is related to.}
		acl_type: ${20:#account|domain}
		poll_async: ${21:yes}
		zone: ${22:# Name of the zone in which the network should be deployed.}
		api_region: ${23:cloudstack}
		start_ipv6: ${24:# The beginning IPv6 address of the network belongs to.}
		cidr_ipv6: ${25:# CIDR of IPv6 network, must be at least /64.}
		project: ${26:# Name of the project the network to be deployed in.}
		api_key: ${27:# API key of the CloudStack API.}
		state: ${28:#present|absent|restarted}
		end_ip: ${29:# The ending IPv4 address of the network belongs to.}
		network_domain: ${30:# The network domain.}
$0
endsnippet

snippet cs_nic "Manages NICs and secondary IPs of an instance on Apache CloudStack based clouds."
- name: $1
	cs_nic:
		vm: ${2:# Name of instance.}
		vm_guest_ip: ${3:# Secondary IP address to be added to the instance nic.}
		account: ${4:# Account the instance is related to.}
		api_timeout: ${5:10}
		poll_async: ${6:yes}
		network: ${7:# Name of the network.}
		zone: ${8:# Name of the zone in which the instance is deployed in.}
		api_secret: ${9:# Secret key of the CloudStack API.}
		api_http_method: ${10:#get|post}
		domain: ${11:# Domain the instance is related to.}
		project: ${12:# Name of the project the instance is deployed in.}
		state: ${13:#present|absent}
		api_region: ${14:cloudstack}
		vpc: ${15:# Name of the VPC the C(vm) is related to.}
		api_key: ${16:# API key of the CloudStack API.}
		api_url: ${17:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_pod "Manages pods on Apache CloudStack based clouds."
- name: $1
	cs_pod:
		name: ${2:# Name of the pod.}
		zone: ${3:# Name of the zone in which the pod belongs to.}
		api_secret: ${4:# Secret key of the CloudStack API.}
		api_timeout: ${5:10}
		netmask: ${6:# Netmask for the Pod.}
		api_region: ${7:cloudstack}
		gateway: ${8:# Gateway for the Pod.}
		state: ${9:#present|enabled|disabled|absent}
		end_ip: ${10:# Ending IP address for the Pod.}
		api_http_method: ${11:#get|post}
		start_ip: ${12:# Starting IP address for the Pod.}
		api_key: ${13:# API key of the CloudStack API.}
		id: ${14:# uuid of the exising pod.}
		api_url: ${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_portforward "Manages port forwarding rules on Apache CloudStack based clouds."
- name: $1
	cs_portforward:
		private_port: ${2:# Start private port for this rule.}
		ip_address: ${3:# Public IP address the rule is assigned to.}
		public_port: ${4:# Start public port for this rule.}
		vm_guest_ip: ${5:no}
		domain: ${6:# Domain the C(vm) is related to.}
		protocol: ${7:#tcp|udp}
		api_http_method: ${8:#get|post}
		api_secret: ${9:# Secret key of the CloudStack API.}
		api_timeout: ${10:10}
		vm: ${11:# Name of virtual machine which we make the port forwarding rule for.}
		vpc: ${12:# Name of the VPC.}
		private_end_port: ${13:# End private port for this rule.}
		api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		account: ${15:# Account the C(vm) is related to.}
		api_key: ${16:# API key of the CloudStack API.}
		poll_async: ${17:yes}
		network: ${18:# Name of the network.}
		open_firewall: ${19:no}
		api_region: ${20:cloudstack}
		public_end_port: ${21:# End public port for this rule.}
		project: ${22:# Name of the project the C(vm) is located in.}
		state: ${23:#present|absent}
		zone: ${24:# Name of the zone in which the virtual machine is in.}
$0
endsnippet

snippet cs_project "Manages projects on Apache CloudStack based clouds."
- name: $1
	cs_project:
		name: ${2:# Name of the project.}
		display_text: ${3:# Display text of the project.}
		account: ${4:# Account the project is related to.}
		poll_async: ${5:yes}
		api_http_method: ${6:#get|post}
		tags: ${7:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		api_secret: ${8:# Secret key of the CloudStack API.}
		api_timeout: ${9:10}
		domain: ${10:# Domain the project is related to.}
		api_region: ${11:cloudstack}
		state: ${12:#present|absent|active|suspended}
		api_key: ${13:# API key of the CloudStack API.}
		api_url: ${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_region "Manages regions on Apache CloudStack based clouds."
- name: $1
	cs_region:
		id: ${2:# ID of the region.}
		endpoint: ${3:# Endpoint URL of the region.}
		name: ${4:# Name of the region.}
		api_http_method: ${5:#get|post}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		api_region: ${8:cloudstack}
		state: ${9:#present|absent}
		api_key: ${10:# API key of the CloudStack API.}
		api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_resourcelimit "Manages resource limits on Apache CloudStack based clouds."
- name: $1
	cs_resourcelimit:
		resource_type: ${2:instance|ip_address|volume|snapshot|template|network|vpc|cpu|memory|primary_storage|secondary_storage}
		domain: ${3:# Domain the resource is related to.}
		api_url: ${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_http_method: ${5:#get|post}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		account: ${8:# Account the resource is related to.}
		api_region: ${9:cloudstack}
		project: ${10:# Name of the project the resource is related to.}
		limit: ${11:-1}
		api_key: ${12:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_role "Manages user roles on Apache CloudStack based clouds."
- name: $1
	cs_role:
		name: ${2:# Name of the role.}
		description: ${3:# Description of the role.}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		api_region: ${7:cloudstack}
		state: ${8:#present|absent}
		api_url: ${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_key: ${10:# API key of the CloudStack API.}
		id: ${11:# ID of the role.}
		role_type: ${12:#User|DomainAdmin|ResourceAdmin|Admin}
$0
endsnippet

snippet cs_router "Manages routers on Apache CloudStack based clouds."
- name: $1
	cs_router:
		name: ${2:# Name of the router.}
		account: ${3:# Account the router is related to.}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		domain: ${7:# Domain the router is related to.}
		api_region: ${8:cloudstack}
		project: ${9:# Name of the project the router is related to.}
		state: ${10:#present|absent|started|stopped|restarted}
		service_offering: ${11:# Name or id of the service offering of the router.}
		api_key: ${12:# API key of the CloudStack API.}
		api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_securitygroup "Manages security groups on Apache CloudStack based clouds."
- name: $1
	cs_securitygroup:
		name: ${2:# Name of the security group.}
		account: ${3:# Account the security group is related to.}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_timeout: ${6:10}
		domain: ${7:# Domain the security group is related to.}
		api_region: ${8:cloudstack}
		project: ${9:# Name of the project the security group to be created in.}
		state: ${10:#present|absent}
		api_url: ${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_key: ${12:# API key of the CloudStack API.}
		description: ${13:# Description of the security group.}
$0
endsnippet

snippet cs_securitygroup_rule "Manages security group rules on Apache CloudStack based clouds."
- name: $1
	cs_securitygroup_rule:
		security_group: ${2:# Name of the security group the rule is related to. The security group must be existing.}
		icmp_code: ${3:# Error code for this icmp message. Required if C(protocol=icmp).}
		api_key: ${4:# API key of the CloudStack API.}
		protocol: ${5:#tcp|udp|icmp|ah|esp|gre}
		api_url: ${6:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_http_method: ${7:#get|post}
		start_port: ${8:# Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).}
		user_security_group: ${9:# Security group this rule is based of.}
		end_port: ${10:# End port for this rule. Required if C(protocol=tcp) or C(protocol=udp), but C(start_port) will be used if not set.}
		api_region: ${11:cloudstack}
		project: ${12:# Name of the project the security group to be created in.}
		state: ${13:#present|absent}
		api_timeout: ${14:10}
		api_secret: ${15:# Secret key of the CloudStack API.}
		poll_async: ${16:yes}
		cidr: ${17:0.0.0.0/0}
		icmp_type: ${18:# Type of the icmp message being sent. Required if C(protocol=icmp).}
		type: ${19:#ingress|egress}
$0
endsnippet

snippet cs_snapshot_policy "Manages volume snapshot policies on Apache CloudStack based clouds."
- name: $1
	cs_snapshot_policy:
		volume: ${2:# Name of the volume.}
		domain: ${3:# Domain the volume is related to.}
		api_timeout: ${4:10}
		api_url: ${5:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_http_method: ${6:#get|post}
		schedule: ${7:# Time the snapshot is scheduled. Required if C(state=present).}
		api_secret: ${8:# Secret key of the CloudStack API.}
		interval_type: ${9:hourly|#daily|weekly|monthly}
		vm: ${10:# Name of the instance to select the volume from.}
		volume_type: ${11:DATADISK|ROOT}
		time_zone: ${12:UTC}
		project: ${13:# Name of the project the volume is related to.}
		state: ${14:#present|absent}
		api_region: ${15:cloudstack}
		vpc: ${16:# Name of the vpc the instance is deployed in.}
		account: ${17:# Account the volume is related to.}
		max_snaps: ${18:8}
		api_key: ${19:# API key of the CloudStack API.}
		device_id: ${20:# ID of the device on a VM the volume is attached to.}
$0
endsnippet

snippet cs_sshkeypair "Manages SSH keys on Apache CloudStack based clouds."
- name: $1
	cs_sshkeypair:
		name: ${2:# Name of public key.}
		public_key: ${3:# String of the public key.}
		account: ${4:# Account the public key is related to.}
		api_http_method: ${5:#get|post}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		domain: ${8:# Domain the public key is related to.}
		api_region: ${9:cloudstack}
		project: ${10:# Name of the project the public key to be registered in.}
		state: ${11:#present|absent}
		api_key: ${12:# API key of the CloudStack API.}
		api_url: ${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_staticnat "Manages static NATs on Apache CloudStack based clouds."
- name: $1
	cs_staticnat:
		ip_address: ${2:# Public IP address the static NAT is assigned to.}
		vm_guest_ip: ${3:no}
		domain: ${4:# Domain the static NAT is related to.}
		api_timeout: ${5:10}
		poll_async: ${6:yes}
		network: ${7:# Network the IP address is related to.}
		zone: ${8:# Name of the zone in which the virtual machine is in.}
		api_secret: ${9:# Secret key of the CloudStack API.}
		api_http_method: ${10:#get|post}
		vm: ${11:# Name of virtual machine which we make the static NAT for.}
		api_region: ${12:cloudstack}
		project: ${13:# Name of the project the static NAT is related to.}
		state: ${14:#present|absent}
		vpc: ${15:# VPC the network related to.}
		account: ${16:# Account the static NAT is related to.}
		api_key: ${17:# API key of the CloudStack API.}
		api_url: ${18:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_template "Manages templates on Apache CloudStack based clouds."
- name: $1
	cs_template:
		name: ${2:# Name of the template.}
		is_featured: ${3:no}
		api_http_method: ${4:#get|post}
		format: ${5:QCOW2|RAW|VHD|OVA}
		api_secret: ${6:# Secret key of the CloudStack API.}
		api_timeout: ${7:10}
		vm: ${8:# VM name the template will be created from its volume or alternatively from a snapshot.}
		api_region: ${9:cloudstack}
		domain: ${10:# Domain the template, snapshot or VM is related to.}
		is_extractable: ${11:no}
		is_public: ${12:no}
		checksum: ${13:no}
		requires_hvm: ${14:no}
		display_text: ${15:# Display text of the template.}
		account: ${16:# Account the template, snapshot or VM is related to.}
		api_key: ${17:# API key of the CloudStack API.}
		poll_async: ${18:yes}
		password_enabled: ${19:no}
		zone: ${20:# Name of the zone you wish the template to be registered or deleted from.}
		url: ${21:# URL of where the template is hosted on C(state=present).}
		bits: ${22:64}
		sshkey_enabled: ${23:no}
		is_dynamically_scalable: ${24:no}
		cross_zones: ${25:no}
		project: ${26:# Name of the project the template to be registered in.}
		api_url: ${27:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		state: ${28:#present|absent|extacted}
		is_ready: ${29:no}
		details: ${30:# Template details in key/value pairs.}
		hypervisor: ${31:KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM}
		is_routing: ${32:no}
		os_type: ${33:# OS type that best represents the OS of this template.}
		template_tag: ${34:# the tag for this template.}
		template_filter: ${35:featured|#self|selfexecutable|sharedexecutable|executable|community}
		snapshot: ${36:# Name of the snapshot, created from the VM ROOT volume, the template will be created from.}
		mode: ${37:#http_download|ftp_upload}
$0
endsnippet

snippet cs_user "Manages users on Apache CloudStack based clouds."
- name: $1
	cs_user:
		username: ${2:# Username of the user.}
		account: ${3:# Account the user will be created under.}
		last_name: ${4:# Last name of the user.}
		poll_async: ${5:yes}
		api_url: ${6:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_http_method: ${7:#get|post}
		api_secret: ${8:# Secret key of the CloudStack API.}
		api_timeout: ${9:10}
		first_name: ${10:# First name of the user.}
		api_region: ${11:cloudstack}
		api_key: ${12:# API key of the CloudStack API.}
		state: ${13:#present|absent|enabled|disabled|locked|unlocked}
		domain: ${14:ROOT}
		timezone: ${15:# Timezone of the user.}
		password: ${16:# Password of the user to be created.}
		email: ${17:# Email of the user.}
$0
endsnippet

snippet cs_vmsnapshot "Manages VM snapshots on Apache CloudStack based clouds."
- name: $1
	cs_vmsnapshot:
		vm: ${2:# Name of the virtual machine.}
		name: ${3:# Unique Name of the snapshot. In CloudStack terms display name.}
		snapshot_memory: ${4:no}
		domain: ${5:# Domain the VM snapshot is related to.}
		poll_async: ${6:yes}
		description: ${7:# Description of the snapshot.}
		zone: ${8:# Name of the zone in which the VM is in. If not set, default zone is used.}
		api_secret: ${9:# Secret key of the CloudStack API.}
		api_timeout: ${10:10}
		api_region: ${11:cloudstack}
		project: ${12:# Name of the project the VM is assigned to.}
		state: ${13:#present|absent|revert}
		api_http_method: ${14:#get|post}
		account: ${15:# Account the VM snapshot is related to.}
		api_url: ${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		api_key: ${17:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_volume "Manages volumes on Apache CloudStack based clouds."
- name: $1
	cs_volume:
		name: ${2:# Name of the volume.}
		domain: ${3:# Name of the domain the volume to be deployed in.}
		force: ${4:no}
		disk_offering: ${5:# Name of the disk offering to be used.}
		api_http_method: ${6:#get|post}
		api_secret: ${7:# Secret key of the CloudStack API.}
		api_timeout: ${8:10}
		account: ${9:# Account the volume is related to.}
		shrink_ok: ${10:no}
		display_volume: ${11:yes}
		api_url: ${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		min_iops: ${13:# Min iops}
		size: ${14:# Size of disk in GB}
		custom_id: ${15:# Custom id to the resource.}
		poll_async: ${16:yes}
		zone: ${17:# Name of the zone in which the volume should be deployed.}
		max_iops: ${18:# Max iops}
		project: ${19:# Name of the project the volume to be deployed in.}
		state: ${20:#present|absent|attached|detached}
		api_region: ${21:cloudstack}
		snapshot: ${22:# The snapshot name for the disk volume.}
		vm: ${23:# Name of the virtual machine to attach the volume to.}
		api_key: ${24:# API key of the CloudStack API.}
$0
endsnippet

snippet cs_vpc "Manages VPCs on Apache CloudStack based clouds."
- name: $1
	cs_vpc:
		name: ${2:# Name of the VPC.}
		display_text: ${3:# Display text of the VPC.}
		vpc_offering: ${4:# Name of the VPC offering.}
		api_key: ${5:# API key of the CloudStack API.}
		poll_async: ${6:yes}
		zone: ${7:# Name of the zone.}
		tags: ${8:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
		api_secret: ${9:# Secret key of the CloudStack API.}
		api_timeout: ${10:10}
		domain: ${11:# Domain the VPC is related to.}
		api_region: ${12:cloudstack}
		project: ${13:# Name of the project the VPC is related to.}
		state: ${14:#present|absent|restarted}
		api_http_method: ${15:#get|post}
		account: ${16:# Account the VPC is related to.}
		cidr: ${17:# CIDR of the VPC, e.g. 10.1.0.0/16}
		network_domain: ${18:# Network domain for the VPC.}
		api_url: ${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet cs_zone "Manages zones on Apache CloudStack based clouds."
- name: $1
	cs_zone:
		name: ${2:# Name of the zone.}
		internal_dns1: ${3:# First internal DNS for the zone.}
		domain: ${4:# Domain the zone is related to.}
		api_key: ${5:# API key of the CloudStack API.}
		api_http_method: ${6:#get|post}
		state: ${7:#present|enabled|disabled|absent}
		dns2: ${8:# Second DNS for the zone.}
		dns1: ${9:# First DNS for the zone.}
		api_timeout: ${10:10}
		internal_dns2: ${11:# Second internal DNS for the zone.}
		network_type: ${12:#basic|advanced}
		guest_cidr_address: ${13:# Guest CIDR address for the zone.}
		api_region: ${14:cloudstack}
		api_secret: ${15:# Secret key of the CloudStack API.}
		api_url: ${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
		dhcp_provider: ${17:# DHCP provider for the Zone.}
		network_domain: ${18:# Network domain for the zone.}
		dns2_ipv6: ${19:# Second DNS for IPv6 for the zone.}
		id: ${20:# uuid of the exising zone.}
		dns1_ipv6: ${21:# First DNS for IPv6 for the zone.}
$0
endsnippet

snippet cs_zone_facts "Gathering facts of zones from Apache CloudStack based clouds."
- name: $1
	cs_zone_facts:
		name: ${2:# Name of the zone.}
		api_timeout: ${3:10}
		api_http_method: ${4:#get|post}
		api_secret: ${5:# Secret key of the CloudStack API.}
		api_key: ${6:# API key of the CloudStack API.}
		api_region: ${7:cloudstack}
		api_url: ${8:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
$0
endsnippet

snippet digital_ocean "Create/delete a droplet/SSH_key in DigitalOcean"
- name: $1
	digital_ocean:
		unique_name: ${2:yes|#no}
		virtio: ${3:#yes|no}
		region_id: ${4:# This is the slug of the region you would like your server to be created in.}
		backups_enabled: ${5:yes|#no}
		user_data: ${6:# opaque blob of data which is made available to the droplet}
		image_id: ${7:# This is the slug of the image you would like the droplet created with.}
		wait_timeout: ${8:300}
		api_token: ${9:# DigitalOcean api token.}
		ssh_pub_key: ${10:# The public SSH key you want to add to your account.}
		wait: ${11:#yes|no}
		name: ${12:# String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.}
		size_id: ${13:# This is the slug of the size you would like the droplet created with.}
		id: ${14:# Numeric, the droplet id you want to operate on.}
		state: ${15:#present|active|absent|deleted}
		command: ${16:#droplet|ssh}
		ssh_key_ids: ${17:# Optional, array of SSH key (numeric) ID that you would like to be added to the server.}
		ipv6: ${18:yes|#no}
		private_networking: ${19:yes|#no}
$0
endsnippet

snippet digital_ocean_block_storage "Create/destroy or attach/detach Block Storage volumes in DigitalOcean"
- name: $1
	digital_ocean_block_storage:
		region: ${2:# The slug of the region where your Block Storage volume should be located in.}
		volume_name: ${3:# The name of the Block Storage volume.}
		state: ${4:present|absent}
		command: ${5:create|attach}
		api_token: ${6:# DigitalOcean api token.}
		droplet_id: ${7:# The droplet id you want to operate on. Required when command=attach.}
		description: ${8:# Description of the Block Storage volume.}
		timeout: ${9:10}
		block_size: ${10:# The size of the Block Storage volume in gigabytes. Required when command=create and state=present.}
$0
endsnippet

snippet digital_ocean_domain "Create/delete a DNS record in DigitalOcean"
- name: $1
	digital_ocean_domain:
		ip: ${2:# The IP address to point a domain at.}
		state: ${3:#present|absent}
		api_token: ${4:# DigitalOcean api token.}
		id: ${5:# Numeric, the droplet id you want to operate on.}
		name: ${6:# String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.}
$0
endsnippet

snippet digital_ocean_sshkey "Create/delete an SSH key in DigitalOcean"
- name: $1
	digital_ocean_sshkey:
		state: ${2:#present|absent}
		name: ${3:# String, this is the name of an SSH key to create or destroy.}
		client_id: ${4:# DigitalOcean manager id.}
		api_key: ${5:# DigitalOcean api key.}
		id: ${6:# Numeric, the SSH key id you want to operate on.}
		ssh_pub_key: ${7:# The public SSH key you want to add to your account.}
$0
endsnippet

snippet digital_ocean_tag "Create and remove tag(s) to DigitalOcean resource."
- name: $1
	digital_ocean_tag:
		name: ${2:# The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.}
		state: ${3:#present|absent}
		resource_id: ${4:# The ID of the resource to operate on.}
		resource_type: ${5:#droplet}
		api_token: ${6:# DigitalOcean api token.}
$0
endsnippet

snippet dimensiondata_network "Create, update, and delete MCP 1.0 & 2.0 networks"
- name: $1
	dimensiondata_network:
		name: ${2:# The name of the network domain to create.}
		location: ${3:# The target datacenter.}
		service_plan: ${4:#ESSENTIALS|ADVANCED}
		mcp_user: ${5:# The username used to authenticate to the CloudControl API.}
		mcp_password: ${6:# The password used to authenticate to the CloudControl API.}
		region: ${7:Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.}
		wait_time: ${8:600}
		state: ${9:#present|absent}
		wait_poll_interval: ${10:2}
		wait: ${11:no}
		validate_certs: ${12:yes}
		description: ${13:# Additional description of the network domain.}
$0
endsnippet

snippet docker_container "manage docker containers"
- name: $1
	docker_container:
		name: ${2:# Assign a name to a new container or match an existing container.}
		tty: ${3:no}
		dns_servers: ${4:# List of custom DNS servers.}
		image: ${5:# Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.}
		labels: ${6:# Dictionary of key value pairs.}
		docker_host: ${7:unix://var/run/docker.sock}
		cpuset_cpus: ${8:# CPUs in which to allow execution C(1,3) or C(1-3).}
		force_kill: ${9:no}
		pid_mode: ${10:# Set the PID namespace mode for the container. Currently only supports 'host'.}
		networks: ${11:# List of networks the container belongs to.}
		cpu_period: ${12:0}
		capabilities: ${13:# List of capabilities to add to the container.}
		memory_swap: ${14:0}
		mac_address: ${15:# Container MAC address (e.g. 92:d0:c6:0a:29:33)}
		volumes_from: ${16:# List of container names or Ids to get volumes from.}
		log_options: ${17:# Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details.}
		recreate: ${18:no}
		memory: ${19:0}
		memory_swappiness: ${20:0}
		network_mode: ${21:bridge|container:<name|id>|host|none}
		detach: ${22:yes}
		published_ports: ${23:# List of ports to publish from the container to the host.}
		restart: ${24:no}
		pull: ${25:no}
		stop_signal: ${26:# Override default signal used to stop the container.}
		devices: ${27:# List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>}
		uts: ${28:# Set the UTS namespace mode for the container.}
		blkio_weight: ${29:# Block IO (relative weight), between 10 and 1000.}
		timeout: ${30:60}
		stop_timeout: ${31:# Number of seconds to wait for the container to stop before sending SIGKILL.}
		ulimits: ${32:# List of ulimit options. A ulimit is specified as C(nofile:262144:262144)}
		interactive: ${33:no}
		links: ${34:# List of name aliases for linked containers in the format C(container_name:alias)}
		oom_score_adj: ${35:0}
		ssl_version: ${36:1.0}
		command: ${37:# Command to execute when the container starts.}
		paused: ${38:no}
		tls_verify: ${39:no}
		dns_search_domains: ${40:# List of custom DNS search domains.}
		security_opts: ${41:# List of security options in the form of C("label:user:User")}
		env_file: ${42:# Path to a file containing environment variables I(FOO=BAR).}
		cpu_quota: ${43:0}
		read_only: ${44:no}
		cpuset_mems: ${45:# Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)}
		hostname: ${46:# Container hostname.}
		state: ${47:absent|present|stopped|#started}
		cleanup: ${48:no}
		entrypoint: ${49:# Command that overwrites the default ENTRYPOINT of the image.}
		key_path: ${50:# Path to the client's TLS key file.}
		env: ${51:# Dictionary of key,value pairs.}
		keep_volumes: ${52:yes}
		ipc_mode: ${53:# Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.}
		privileged: ${54:no}
		api_version: ${55:default provided by docker-py}
		exposed_ports: ${56:# List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.}
		trust_image_content: ${57:no}
		cacert_path: ${58:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		log_driver: ${59:none|json-file|syslog|journald|gelf|fluentd|awslogs|splunk}
		oom_killer: ${60:no}
		shm_size: ${61:# Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes).}
		kill_signal: ${62:# Override default signal used to kill a running container.}
		tls_hostname: ${63:localhost}
		volume_driver: ${64:none}
		user: ${65:# Sets the username or UID used and optionally the groupname or GID for the specified command.}
		groups: ${66:# List of additional group names and/or IDs that the container process will run as.}
		cert_path: ${67:# Path to the client's TLS certificate file.}
		purge_networks: ${68:no}
		tls: ${69:no}
		ignore_image: ${70:no}
		restart_policy: ${71:always|False|#on-failure|unless-stopped}
		kernel_memory: ${72:0}
		etc_hosts: ${73:# Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.}
		memory_reservation: ${74:0}
		volumes: ${75:# List of volumes to mount within the container.}
		cpu_shares: ${76:# CPU shares (relative weight).}
		restart_retries: ${77:0}
$0
endsnippet

snippet docker_image "Manage docker images."
- name: $1
	docker_image:
		name: ${2:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}
		archive_path: ${3:# Use with state C(present) to archive an image to a .tar file.}
		cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		force: ${5:no}
		timeout: ${6:60}
		repository: ${7:# Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).}
		tls_hostname: ${8:localhost}
		docker_host: ${9:unix://var/run/docker.sock}
		tag: ${10:latest}
		cert_path: ${11:# Path to the client's TLS certificate file.}
		path: ${12:# Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.}
		tls: ${13:no}
		pull: ${14:yes}
		nocache: ${15:no}
		container_limits: ${16:# A dictionary of limits applied to each container created by the build process.}
		http_timeout: ${17:# Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.}
		ssl_version: ${18:1.0}
		load_path: ${19:# Use with state C(present) to load an image from a .tar file.}
		use_tls: ${20:#False|encrypt|verify}
		state: ${21:absent|#present|build}
		tls_verify: ${22:no}
		key_path: ${23:# Path to the client's TLS key file.}
		buildargs: ${24:# Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.}
		push: ${25:no}
		rm: ${26:yes}
		dockerfile: ${27:Dockerfile}
		api_version: ${28:default provided by docker-py}
$0
endsnippet

snippet docker_image_facts "Inspect docker images"
- name: $1
	docker_image_facts:
		name: ${2:# An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.}
		tls: ${3:no}
		cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		ssl_version: ${5:1.0}
		tls_hostname: ${6:localhost}
		docker_host: ${7:unix://var/run/docker.sock}
		tls_verify: ${8:no}
		key_path: ${9:# Path to the client's TLS key file.}
		timeout: ${10:60}
		cert_path: ${11:# Path to the client's TLS certificate file.}
		api_version: ${12:default provided by docker-py}
$0
endsnippet

snippet docker_login "Log into a Docker registry."
- name: $1
	docker_login:
		username: ${2:# The username for the registry account}
		password: ${3:# The plaintext password for the registry account}
		cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		tls_hostname: ${5:localhost}
		docker_host: ${6:unix://var/run/docker.sock}
		tls_verify: ${7:no}
		cert_path: ${8:# Path to the client's TLS certificate file.}
		tls: ${9:no}
		config_path: ${10:~/.docker/config.json}
		ssl_version: ${11:1.0}
		state: ${12:#present|absent}
		key_path: ${13:# Path to the client's TLS key file.}
		timeout: ${14:60}
		registry_url: ${15:https://index.docker.io/v1/}
		email: ${16:# The email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it.}
		api_version: ${17:default provided by docker-py}
		reauthorize: ${18:yes|no}
$0
endsnippet

snippet docker_network "Manage Docker networks"
- name: $1
	docker_network:
		name: ${2:# Name of the network to operate on.}
		tls: ${3:no}
		cacert_path: ${4:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		force: ${5:no}
		tls_verify: ${6:no}
		ssl_version: ${7:1.0}
		driver: ${8:bridge}
		docker_host: ${9:unix://var/run/docker.sock}
		ipam_options: ${10:# Dictionary of IPAM options.}
		tls_hostname: ${11:localhost}
		state: ${12:absent|#present}
		driver_options: ${13:# Dictionary of network settings. Consult docker docs for valid options and values.}
		connected: ${14:# List of container names or container IDs to connect to a network.}
		key_path: ${15:# Path to the client's TLS key file.}
		timeout: ${16:60}
		cert_path: ${17:# Path to the client's TLS certificate file.}
		ipam_driver: ${18:# Specify an IPAM driver.}
		appends: ${19:no}
		api_version: ${20:default provided by docker-py}
$0
endsnippet

snippet docker_service "Manage docker services and containers."
- name: $1
	docker_service:
		files: ${2:# List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.}
		project_name: ${3:# Provide a project name. If not provided, the project name is taken from the basename of C(project_src).}
		project_src: ${4:# Path to a directory containing a docker-compose.yml or docker-compose.yaml file.}
		hostname_check: ${5:no}
		recreate: ${6:always|never|#smart}
		tls_hostname: ${7:localhost}
		docker_host: ${8:unix://var/run/docker.sock}
		dependencies: ${9:yes}
		remove_images: ${10:# Use with state I(absent) to remove the all images or only local images.}
		services: ${11:# When C(state) is I(present) run I(docker-compose up) on a subset of services.}
		cert_path: ${12:# Path to the client's TLS certificate file.}
		pull: ${13:no}
		tls: ${14:no}
		definition: ${15:# Provide docker-compose yaml describing one or more services, networks and volumes.}
		scale: ${16:# When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.}
		nocache: ${17:no}
		restarted: ${18:no}
		ssl_version: ${19:1.0}
		state: ${20:absent|#present}
		api_version: ${21:default provided by docker-py}
		remove_volumes: ${22:no}
		tls_verify: ${23:no}
		stopped: ${24:no}
		build: ${25:no}
		timeout: ${26:60}
		debug: ${27:no}
		cacert_path: ${28:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
		key_path: ${29:# Path to the client's TLS key file.}
$0
endsnippet

snippet gc_storage "This module manages objects/buckets in Google Cloud Storage."
- name: $1
	gc_storage:
		gs_access_key: ${2:# GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.}
		bucket: ${3:# Bucket name.}
		mode: ${4:get|put|get_url|get_str|delete|create}
		gs_secret_key: ${5:# GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used.}
		src: ${6:# The source file path when performing a PUT operation.}
		force: ${7:yes}
		permission: ${8:private}
		dest: ${9:# The destination file path when downloading an object/key with a GET operation.}
		object: ${10:# Keyname of the object inside the bucket. Can be also be used to create "virtual directories" (see examples).}
		expiration: ${11:# Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.}
		headers: ${12:{}}
$0
endsnippet

snippet gcdns_record "Creates or removes resource records in Google Cloud DNS"
- name: $1
	gcdns_record:
		record: ${2:# The fully-qualified domain name of the resource record.}
		type: ${3:A|AAAA|CNAME|SRV|TXT|SOA|NS|MX|SPF|PTR}
		zone_id: ${4:# The Google Cloud ID of the zone (e.g., example-com).}
		zone: ${5:# The DNS domain name of the zone (e.g., example.com).}
		service_account_email: ${6:# The e-mail address for a service account with access to Google Cloud DNS.}
		ttl: ${7:300}
		pem_file: ${8:# The path to the PEM file associated with the service account email.}
		record_data: ${9:# The record_data to use for the resource record.}
		state: ${10:#present|absent}
		credentials_file: ${11:# The path to the JSON file associated with the service account email.}
		project_id: ${12:# The Google Cloud Platform project ID to use.}
		overwrite: ${13:True|#False}
$0
endsnippet

snippet gcdns_zone "Creates or removes zones in Google Cloud DNS"
- name: $1
	gcdns_zone:
		zone: ${2:# The DNS domain name of the zone.}
		state: ${3:#present|absent}
		description: ${4:}
		credentials_file: ${5:# The path to the JSON file associated with the service account email.}
		service_account_email: ${6:# The e-mail address for a service account with access to Google Cloud DNS.}
		project_id: ${7:# The Google Cloud Platform project ID to use.}
		pem_file: ${8:# The path to the PEM file associated with the service account email.}
$0
endsnippet

snippet gce "create or terminate GCE instances"
- name: $1
	gce:
		zone: ${2:us-central1-a}
		disks: ${3:# a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).}
		num_instances: ${4:# can be used with 'name', specifies the number of nodes to provision using 'name' as a base name}
		ip_forward: ${5:false}
		image: ${6:debian-8}
		service_account_permissions: ${7:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
		pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		instance_names: ${9:# a comma-separated list of instance names to create or destroy}
		machine_type: ${10:n1-standard-1}
		name: ${11:# either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes}
		disk_size: ${12:10}
		network: ${13:default}
		external_ip: ${14:ephemeral}
		service_account_email: ${15:# service account email}
		tags: ${16:# a comma-separated list of tags to associate with the instance}
		persistent_boot_disk: ${17:false}
		disk_auto_delete: ${18:true}
		state: ${19:active|#present|absent|deleted|started|stopped|terminated}
		credentials_file: ${20:# path to the JSON file associated with the service account email}
		subnetwork: ${21:# name of the subnetwork in which the instance should be created}
		project_id: ${22:# your GCE project ID}
		preemptible: ${23:false}
		metadata: ${24:# a hash/dictionary of custom data for the instance; '{"key":"value", ...}'}
$0
endsnippet

snippet gce_eip "Create or Destroy Global or Regional External IP addresses."
- name: $1
	gce_eip:
		region: ${2:# Region to create the address in. Set to 'global' to create a global address.}
		name: ${3:# Name of Address.}
		state: ${4:#present|absent}
$0
endsnippet

snippet gce_img "utilize GCE image resources"
- name: $1
	gce_img:
		name: ${2:# the name of the image to create or delete}
		project_id: ${3:# your GCE project ID}
		family: ${4:# an optional family name}
		service_account_email: ${5:# service account email}
		pem_file: ${6:# path to the pem file associated with the service account email}
		source: ${7:# the source disk or the Google Cloud Storage URI to create the image from}
		state: ${8:#present|absent}
		timeout: ${9:180}
		zone: ${10:us-central1-a}
		description: ${11:# an optional description}
$0
endsnippet

snippet gce_instance_template "create or destroy intance templates of Compute Engine of GCP."
- name: $1
	gce_instance_template:
		name: ${2:# The name of the GCE instance template.}
		description: ${3:# description of instance template}
		tags: ${4:# a comma-separated list of tags to associate with the instance}
		automatic_restart: ${5:# Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.}
		image: ${6:# The image to use to create the instance. Cannot specify both both I(image) and I(source).}
		service_account_permissions: ${7:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
		pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		can_ip_forward: ${9:no}
		disk_type: ${10:pd-standard}
		size: ${11:f1-micro}
		network: ${12:default}
		external_ip: ${13:ephemeral}
		service_account_email: ${14:# service account email}
		disks: ${15:# a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).}
		nic_gce_struct: ${16:# Support passing in the GCE-specific formatted networkInterfaces[] structure.}
		disk_auto_delete: ${17:yes}
		source: ${18:# A source disk to attach to the instance. Cannot specify both I(image) and I(source).}
		state: ${19:#present|absent}
		credentials_file: ${20:# path to the JSON file associated with the service account email}
		image_family: ${21:# The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source).}
		subnetwork: ${22:# The Subnetwork resource name for this instance.}
		project_id: ${23:# your GCE project ID}
		preemptible: ${24:# Defines whether the instance is preemptible.}
		metadata: ${25:# a hash/dictionary of custom data for the instance; '{"key":"value", ...}'}
$0
endsnippet

snippet gce_lb "create/destroy GCE load-balancer resources"
- name: $1
	gce_lb:
		httphealthcheck_host: ${2:# host header to pass through on HTTP check requests}
		protocol: ${3:#tcp|udp}
		pem_file: ${4:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		members: ${5:# a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]}
		httphealthcheck_port: ${6:80}
		httphealthcheck_name: ${7:# the name identifier for the HTTP health check}
		name: ${8:# name of the load-balancer resource}
		external_ip: ${9:# the external static IPv4 (or auto-assigned) address for the LB}
		service_account_email: ${10:# service account email}
		region: ${11:# the GCE region where the load-balancer is defined}
		httphealthcheck_unhealthy_count: ${12:2}
		httphealthcheck_healthy_count: ${13:2}
		httphealthcheck_path: ${14:/}
		port_range: ${15:# the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports}
		state: ${16:active|#present|absent|deleted}
		httphealthcheck_timeout: ${17:5}
		credentials_file: ${18:# path to the JSON file associated with the service account email}
		project_id: ${19:# your GCE project ID}
		httphealthcheck_interval: ${20:5}
$0
endsnippet

snippet gce_mig "Create, Update or Destroy a Managed Instance Group (MIG)."
- name: $1
	gce_mig:
		name: ${2:# Name of the Managed Instance Group.}
		zone: ${3:# The GCE zone to use for this Managed Instance Group.}
		service_account_email: ${4:# service account email}
		autoscaling: ${5:# A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.}
		named_ports: ${6:# Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.}
		state: ${7:absent|#present}
		template: ${8:# Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.}
		credentials_file: ${9:# Path to the JSON file associated with the service account email}
		project_id: ${10:# GCE project ID}
		size: ${11:# Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.}
$0
endsnippet

snippet gce_net "create/destroy GCE networks and firewall rules"
- name: $1
	gce_net:
		src_tags: ${2:# the source instance tags for creating a firewall rule}
		subnet_region: ${3:# region of subnet to create}
		ipv4_range: ${4:# the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory}
		pem_file: ${5:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		target_tags: ${6:# the target instance tags for creating a firewall rule}
		allowed: ${7:# the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or 'tcp:80-800;udp:1-25') this parameter is mandatory when creating or updating a firewall rule}
		fwname: ${8:# name of the firewall rule}
		name: ${9:# name of the network}
		src_range: ${10:# the source IPv4 address range in CIDR notation}
		state: ${11:active|#present|absent|deleted}
		subnet_name: ${12:# name of subnet to create}
		mode: ${13:#legacy|auto|custom}
		credentials_file: ${14:# path to the JSON file associated with the service account email}
		service_account_email: ${15:# service account email}
		project_id: ${16:# your GCE project ID}
		subnet_desc: ${17:# description of subnet to create}
$0
endsnippet

snippet gce_pd "utilize GCE persistent disk resources"
- name: $1
	gce_pd:
		name: ${2:# name of the disk}
		size_gb: ${3:10}
		project_id: ${4:# your GCE project ID}
		zone: ${5:us-central1-b}
		service_account_email: ${6:# service account email}
		image: ${7:# the source image to use for the disk}
		pem_file: ${8:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
		instance_name: ${9:# instance name if you wish to attach or detach the disk}
		state: ${10:active|#present|absent|deleted}
		snapshot: ${11:# the source snapshot to use for the disk}
		detach_only: ${12:yes|#no}
		credentials_file: ${13:# path to the JSON file associated with the service account email}
		disk_type: ${14:#pd-standard|pd-ssd}
		delete_on_termination: ${15:yes|no}
		mode: ${16:READ_WRITE|#READ_ONLY}
$0
endsnippet

snippet gce_snapshot "Create or destroy snapshots for GCE storage volumes"
- name: $1
	gce_snapshot:
		instance_name: ${2:# The GCE instance to snapshot}
		project_id: ${3:# The GCP project ID to use}
		credentials_file: ${4:# The path to the credentials file associated with the service account}
		service_account_email: ${5:# GCP service account email for the project where the instance resides}
		state: ${6:#present|absent}
		snapshot_name: ${7:# The name of the snapshot to manage}
		disks: ${8:all}
$0
endsnippet

snippet gce_tag "add or remove tag(s) to/from GCE instances"
- name: $1
	gce_tag:
		tags: ${2:# comma-separated list of tags to add or remove}
		zone: ${3:us-central1-a}
		service_account_email: ${4:# service account email}
		pem_file: ${5:# path to the pem file associated with the service account email}
		instance_name: ${6:# The name of the GCE instance to add/remove tags.  Required if instance_pattern is not specified.}
		state: ${7:#present|absent}
		instance_pattern: ${8:# The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details. If instance_name is not specified, this field is required.}
		project_id: ${9:# your GCE project ID}
$0
endsnippet

snippet gcpubsub "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub."
- name: $1
	gcpubsub:
		topic: ${2:# GCP pubsub topic name.  Only the name, not the full path, is required.}
		pull: ${3:# S}
		ack_deadline: ${4:# S}
		name: ${5:# S}
		publish: ${6:# L}
		state: ${7:present}
		push_endpoint: ${8:# S}
		subscription: ${9:# Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields.  See subfields name, push_endpoint and ack_deadline for more information.}
$0
endsnippet

snippet gcpubsub_facts "List Topics/Subscriptions and Messages from Google PubSub."
- name: $1
	gcpubsub_facts:
		view: ${2:# Choices are 'topics' or 'subscriptions'}
		topic: ${3:# GCP pubsub topic name.  Only the name, not the full path, is required.}
		state: ${4:# list is the only valid option.}
$0
endsnippet

snippet gcspanner "Create and Delete Instances/Databases on Spanner."
- name: $1
	gcspanner:
		instance_id: ${2:# GCP spanner instance name.}
		configuration: ${3:# Configuration the instance should use. Examples are us-central1, asia-east1 and europe-west1.}
		state: ${4:present}
		instance_display_name: ${5:# Name of Instance to display.  If not specified, instance_id will be used instead.}
		database_name: ${6:# Name of database contained on the instance.}
		force_instance_delete: ${7:no}
		node_count: ${8:# Number of nodes in the instance.  If not specified while creating an instance, node_count will be set to 1.}
$0
endsnippet

snippet linode "create / delete / stop / restart an instance in Linode Public Cloud"
- name: $1
	linode:
		alert_diskio_enabled: ${2:#True|False}
		additional_disks: ${3:# L}
		alert_bwin_enabled: ${4:#True|False}
		payment_term: ${5:#1|12|24}
		alert_bwout_threshold: ${6:# Set threshold in MB of bandwidth out alerts.}
		alert_bwin_threshold: ${7:# Set threshold in MB of bandwidth in alerts.}
		alert_cpu_enabled: ${8:#True|False}
		alert_bwquota_enabled: ${9:#True|False}
		linode_id: ${10:# Unique ID of a linode server}
		alert_diskio_threshold: ${11:# Set threshold for average IO ops/sec over 2 hour period.}
		wait_timeout: ${12:300}
		private_ip: ${13:yes|#no}
		watchdog: ${14:#True|False}
		password: ${15:# root password to apply to a new server (auto generated if missing)}
		ssh_pub_key: ${16:# SSH public key applied to root user}
		wait: ${17:yes|#no}
		datacenter: ${18:# datacenter to create an instance in (Linode Datacenter)}
		alert_bwquota_threshold: ${19:# Set threshold in MB of bandwidth quota alerts.}
		backupweeklyday: ${20:# Integer value for what day of the week to store weekly backups.}
		name: ${21:# Name to give the instance (alphanumeric, dashes, underscore)}
		displaygroup: ${22:# Add the instance to a Display Group in Linode Manager}
		alert_cpu_threshold: ${23:# Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.}
		alert_bwout_enabled: ${24:#True|False}
		state: ${25:#present|active|started|absent|deleted|stopped|restarted}
		swap: ${26:512}
		distribution: ${27:# distribution to use for the instance (Linode Distribution)}
		api_key: ${28:# Linode API key}
		plan: ${29:# plan to use for the instance (Linode plan)}
$0
endsnippet

snippet lxc_container "Manage LXC Containers"
- name: $1
	lxc_container:
		name: ${2:# Name of a container.}
		archive_path: ${3:# Path the save the archived container. If the path does not exist the archive method will attempt to create it.}
		zfs_root: ${4:# Create zfs under given zfsroot.}
		container_log_level: ${5:#INFO|ERROR|DEBUG}
		template_options: ${6:# Template options when building the container.}
		container_command: ${7:# Run a command within a container.}
		clone_name: ${8:no}
		lxc_path: ${9:# Place container under PATH}
		container_config: ${10:# list of 'key=value' options to use when configuring a container.}
		fs_type: ${11:ext4}
		archive: ${12:True|#False}
		vg_name: ${13:lxc}
		clone_snapshot: ${14:True|#False}
		container_log: ${15:True|#False}
		lv_name: ${16:$CONTAINER_NAME}
		fs_size: ${17:5G}
		archive_compression: ${18:#gzip|bzip2|none}
		backing_store: ${19:#dir|lvm|loop|btrfs|overlayfs|zfs}
		state: ${20:#started|stopped|restarted|absent|frozen}
		thinpool: ${21:# Use LVM thin pool called TP.}
		template: ${22:ubuntu}
		directory: ${23:# Place rootfs directory under DIR.}
		config: ${24:# Path to the LXC configuration file.}
$0
endsnippet

snippet lxd_container "Manage LXD Containers"
- name: $1
	lxd_container:
		name: ${2:# Name of a container.}
		source: ${3:# The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		url: ${4:unix:/var/lib/lxd/unix.socket}
		config: ${5:# The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		cert_file: ${6:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
		ephemeral: ${7:# Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		devices: ${8:# The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		wait_for_ipv4_addresses: ${9:no}
		state: ${10:#started|stopped|restarted|absent|frozen}
		architecture: ${11:# The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
		timeout: ${12:30}
		key_file: ${13:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
		trust_password: ${14:# The client trusted password.}
		force_stop: ${15:no}
$0
endsnippet

snippet lxd_profile "Manage LXD profiles"
- name: $1
	lxd_profile:
		name: ${2:# Name of a profile.}
		new_name: ${3:# A new name of a profile.}
		url: ${4:unix:/var/lib/lxd/unix.socket}
		config: ${5:# The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
		cert_file: ${6:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
		devices: ${7:# The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
		state: ${8:#present|absent}
		key_file: ${9:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
		trust_password: ${10:# The client trusted password.}
$0
endsnippet

snippet ovirt "oVirt/RHEV platform management"
- name: $1
	ovirt:
		user: ${2:# the user to authenticate with}
		password: ${3:# password of the user to authenticate with}
		url: ${4:# the url of the oVirt instance}
		instance_name: ${5:# the name of the instance to use}
		instance_mem: ${6:# the instance's amount of memory in MB}
		instance_cores: ${7:1}
		instance_cpus: ${8:1}
		image: ${9:# template to use for the instance}
		instance_hostname: ${10:# define the instance's Hostname}
		instance_disksize: ${11:# size of the instance's disk in GB}
		instance_nic: ${12:# name of the network interface in oVirt/RHEV}
		instance_network: ${13:rhevm}
		instance_type: ${14:#server|desktop}
		sdomain: ${15:# the Storage Domain where you want to create the instance's disk on.}
		instance_os: ${16:# type of Operating System}
		instance_ip: ${17:# define the instance's IP}
		zone: ${18:# deploy the image to this oVirt cluster}
		disk_alloc: ${19:#thin|preallocated}
		region: ${20:# the oVirt/RHEV datacenter where you want to deploy to}
		instance_dns: ${21:# define the instance's Primary DNS server}
		instance_netmask: ${22:# define the instance's Netmask}
		state: ${23:#present|absent|shutdown|started|restarted}
		instance_key: ${24:# define the instance's Authorized key}
		instance_domain: ${25:# define the instance's Domain}
		instance_rootpw: ${26:# define the instance's Root password}
		resource_type: ${27:new|template}
		disk_int: ${28:#virtio|ide}
$0
endsnippet

snippet proxmox "management of instances in Proxmox VE cluster"
- name: $1
	proxmox:
		api_host: ${2:# the host of the Proxmox VE cluster}
		api_user: ${3:# the user to authenticate with}
		node: ${4:# Proxmox VE node, when new VM will be created}
		force: ${5:no}
		cpuunits: ${6:1000}
		vmid: ${7:# the instance id}
		api_password: ${8:# the password to authenticate with}
		cpus: ${9:1}
		ostemplate: ${10:# the template for VM creating}
		unprivileged: ${11:no}
		disk: ${12:3}
		ip_address: ${13:# specifies the address the container will be assigned}
		pool: ${14:# Proxmox VE resource pool}
		password: ${15:# the instance root password}
		searchdomain: ${16:# sets DNS search domain for a container}
		netif: ${17:# specifies network interfaces for the container. As a hash/dictionary defining interfaces.}
		validate_certs: ${18:no}
		hostname: ${19:# the instance hostname}
		storage: ${20:local}
		state: ${21:#present|started|absent|stopped|restarted}
		swap: ${22:0}
		timeout: ${23:30}
		memory: ${24:512}
		mounts: ${25:# specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points}
		nameserver: ${26:# sets DNS server IP address for a container}
		pubkey: ${27:# Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions}
		onboot: ${28:no}
$0
endsnippet

snippet proxmox_kvm "Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster."
- name: $1
	proxmox_kvm:
		api_host: ${2:# Specify the target host of the Proxmox VE cluster.}
		api_user: ${3:# Specify the user to authenticate with.}
		revert: ${4:# Revert a pending change.}
		boot: ${5:cnd}
		migrate_speed: ${6:# Sets maximum speed (in MB/s) for migrations.}
		vga: ${7:#std|cirrus|vmware|qxl|serial0|serial1|serial2|serial3|qxl2|qxl3|qxl4}
		keyboard: ${8:# Sets the keyboard layout for VNC server.}
		watchdog: ${9:# Creates a virtual hardware watchdog device.}
		sockets: ${10:1}
		digest: ${11:# Specify if to prevent changes if current configuration file has different SHA1 digest.}
		tablet: ${12:yes|#no}
		bios: ${13:seabios|ovmf}
		hostpci: ${14:# Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').}
		autostart: ${15:yes|#no}
		memory: ${16:512}
		migrate_downtime: ${17:# Sets maximum tolerated downtime (in seconds) for migrations.}
		localtime: ${18:yes|no}
		virtio: ${19:# A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').}
		format: ${20:cloop|cow|qcow|#qcow2|qed|raw|vmdk}
		snapname: ${21:# The name of the snapshot. Used only with clone.}
		hotplug: ${22:# Selectively enable hotplug features.}
		name: ${23:# Specifies the VM name. Only used on the configuration web interface.}
		target: ${24:# Target node. Only allowed if the original VM is on shared storage.}
		vmid: ${25:# Specifies the VM ID. Instead use I(name) parameter.}
		bootdisk: ${26:# Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)}
		vcpus: ${27:# Sets number of hotplugged vcpus.}
		newid: ${28:# VMID for the clone. Used only with clone.}
		timeout: ${29:30}
		skiplock: ${30:# Ignore locks}
		validate_certs: ${31:yes|#no}
		onboot: ${32:#yes|no}
		delete: ${33:# Specify a list of settings you want to delete.}
		force: ${34:yes|no}
		lock: ${35:migrate|backup|snapshot|rollback}
		startup: ${36:# Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).}
		agent: ${37:yes|no}
		freeze: ${38:yes|no}
		serial: ${39:# A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').}
		startdate: ${40:# Sets the initial date of the real time clock.}
		balloon: ${41:0}
		cpuunits: ${42:1000}
		storage: ${43:# Target storage for full clone.}
		reboot: ${44:yes|no}
		shares: ${45:# Rets amount of memory shares for auto-ballooning. (0 - 50000).}
		machine: ${46:# Specifies the Qemu machine type.}
		sata: ${47:# A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').}
		state: ${48:#present|started|absent|stopped|restarted|current}
		template: ${49:yes|#no}
		net: ${50:# A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').}
		acpi: ${51:#yes|no}
		node: ${52:# Proxmox VE node, where the new VM will be created.}
		full: ${53:yes|no}
		description: ${54:# Specify the description for the VM. Only used on the configuration web interface.}
		scsihw: ${55:lsi|lsi53c810|virtio-scsi-pci|virtio-scsi-single|megasas|pvscsi}
		clone: ${56:# Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone.}
		args: ${57:-serial unix:/var/run/qemu-server/VMID.serial,server,nowait}
		api_password: ${58:# Specify the password to authenticate with.}
		tdf: ${59:yes|no}
		update: ${60:yes|#no}
		kvm: ${61:#yes|no}
		ostype: ${62:other|wxp|w2k|w2k3|w2k8|wvista|win7|win8|l24|#l26|solaris}
		protection: ${63:yes|no}
		numa: ${64:# A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').}
		parallel: ${65:# A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').}
		pool: ${66:# Add the new VM to the specified pool.}
		cpulimit: ${67:# Specify if CPU usage will be limited. Value 0 indicates no CPU limit.}
		hugepages: ${68:any|2|1024}
		smbios: ${69:# Specifies SMBIOS type 1 fields.}
		cores: ${70:1}
		scsi: ${71:# A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').}
		ide: ${72:# A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').}
		cpu: ${73:kvm64}
$0
endsnippet

snippet proxmox_template "management of OS templates in Proxmox VE cluster"
- name: $1
	proxmox_template:
		node: ${2:# Proxmox VE node, when you will operate with template}
		api_host: ${3:# the host of the Proxmox VE cluster}
		api_user: ${4:# the user to authenticate with}
		src: ${5:# path to uploaded file}
		force: ${6:no}
		api_password: ${7:# the password to authenticate with}
		storage: ${8:local}
		state: ${9:#present|absent}
		content_type: ${10:#vztmpl|iso}
		timeout: ${11:30}
		validate_certs: ${12:no}
		template: ${13:# the template name}
$0
endsnippet

snippet rhevm "RHEV/oVirt automation"
- name: $1
	rhevm:
		vmhost: ${2:# The host you wish your VM to run on.}
		vmmem: ${3:1}
		cd_drive: ${4:# The CD you wish to have mounted on the VM when I(state = 'CD').}
		image: ${5:# The template to use for the VM.}
		cpu_share: ${6:0}
		insecure_api: ${7:no}
		cluster: ${8:# The rhev/ovirt cluster in which you want you VM to start.}
		user: ${9:admin@internal}
		port: ${10:443}
		vm_ha: ${11:yes}
		disks: ${12:# This option uses complex arguments and is a list of disks with the options name, size and domain.}
		datacenter: ${13:Default}
		name: ${14:# The name of the VM.}
		ifaces: ${15:# This option uses complex arguments and is a list of interfaces with the options name and vlan.}
		server: ${16:127.0.0.1}
		state: ${17:ping|#present|absent|up|down|restarted|cd|info}
		osver: ${18:rhel_6x64}
		mempol: ${19:1}
		timeout: ${20:# The timeout you wish to define for power actions.}
		del_prot: ${21:yes}
		boot_order: ${22:[u'network', u'hd']}
		type: ${23:#server|desktop|host}
		vmcpu: ${24:2}
$0
endsnippet

snippet serverless "Manages a Serverless Framework project"
- name: $1
	serverless:
		service_path: ${2:# The path to the root of the Serverless Service to be operated on.}
		region: ${3:us-east-1}
		functions: ${4:[]}
		state: ${5:#present|absent}
		deploy: ${6:yes}
$0
endsnippet

snippet virt "Manages virtual machines supported by libvirt"
- name: $1
	virt:
		name: ${2:# name of the guest VM being managed. Note that VM must be previously defined with xml.}
		xml: ${3:# XML document used with the define command}
		state: ${4:running|shutdown|destroyed|paused}
		command: ${5:create|status|start|stop|pause|unpause|shutdown|undefine|destroy|get_xml|freemem|list_vms|info|nodeinfo|virttype|define}
		autostart: ${6:True|False}
		uri: ${7:qemu:///system}
$0
endsnippet

snippet virt_net "Manage libvirt network configuration"
- name: $1
	virt_net:
		name: ${2:# name of the network being managed. Note that network must be previously defined with xml.}
		xml: ${3:# XML document used with the define command.}
		state: ${4:active|inactive|present|absent}
		command: ${5:define|create|start|stop|destroy|undefine|get_xml|list_nets|facts|info|status|modify}
		autostart: ${6:yes|no}
		uri: ${7:qemu:///system}
$0
endsnippet

snippet virt_pool "Manage libvirt storage pools"
- name: $1
	virt_pool:
		xml: ${2:# XML document used with the define command.}
		state: ${3:active|inactive|present|absent|undefined|deleted}
		command: ${4:define|build|create|start|stop|destroy|delete|undefine|get_xml|list_pools|facts|info|status}
		name: ${5:# name of the storage pool being managed. Note that pool must be previously defined with xml.}
		autostart: ${6:yes|no}
		uri: ${7:qemu:///system}
		mode: ${8:new|repair|resize|no_overwrite|overwrite|normal|zeroed}
$0
endsnippet

snippet xenserver_facts "get facts reported on xenserver"
- name: $1
	xenserver_facts:
$0
endsnippet

snippet os_auth "Retrieve an auth token"
- name: $1
	os_auth:
		auth_type: ${2:password}
		region_name: ${3:# Name of the region.}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${7:# A path to a client key to use as part of the SSL transaction.}
		cert: ${8:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${9:#public|internal|admin}
		timeout: ${10:180}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		validate_certs: ${12:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${14:#yes|no}
$0
endsnippet

snippet os_client_config "Get OpenStack Client config"
- name: $1
	os_client_config:
		clouds: ${2:[]}
$0
endsnippet

snippet os_flavor_facts "Retrieve facts about one or more flavors"
- name: $1
	os_flavor_facts:
		auth_type: ${2:password}
		api_timeout: ${3:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		ram: ${6:no}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${12:#yes|no}
		name: ${13:# A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).}
		ephemeral: ${14:no}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		vcpus: ${16:no}
		limit: ${17:# Limits the number of flavors returned. All matching flavors are returned by default.}
		timeout: ${18:180}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_floating_ip "Add/Remove floating IP from an instance"
- name: $1
	os_floating_ip:
		server: ${2:# The name or ID of the instance to which the IP address should be assigned.}
		auth_type: ${3:password}
		reuse: ${4:no}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		floating_ip_address: ${9:# A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${13:#yes|no}
		fixed_address: ${14:# To which fixed IP of server the floating IP address should be attached to.}
		network: ${15:# The name or ID of a neutron external network or a nova pool name.}
		region_name: ${16:# Name of the region.}
		cert: ${17:# A path to a client certificate to use as part of the SSL transaction.}
		nat_destination: ${18:# The name or id of a neutron private network that the fixed IP to attach floating IP is on}
		purge: ${19:no}
		state: ${20:#present|absent}
		timeout: ${21:180}
		validate_certs: ${22:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_group "Manage OpenStack Identity Groups"
- name: $1
	os_group:
		name: ${2:# Group name}
		auth_type: ${3:password}
		description: ${4:# Group description}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		domain_id: ${11:# Domain id to create the group in if the cloud supports domains.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${13:# Name of the region.}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${15:#present|absent}
		timeout: ${16:180}
		wait: ${17:#yes|no}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_image "Add/Delete images from OpenStack Cloud"
- name: $1
	os_image:
		name: ${2:# Name that has to be given to the image}
		ramdisk: ${3:# The name of an existing ramdisk image that will be associated with this image}
		kernel: ${4:# The name of an existing kernel image that will be associated with this image}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		container_format: ${7:bare}
		min_ram: ${8:# The minimum ram (in MB) required to boot this image}
		api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		min_disk: ${11:# The minimum disk space (in GB) required to boot this image}
		endpoint_type: ${12:#public|internal|admin}
		key: ${13:# A path to a client key to use as part of the SSL transaction.}
		owner: ${14:# The owner of the image}
		is_public: ${15:yes}
		properties: ${16:{}}
		cloud: ${17:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${18:#yes|no}
		cacert: ${19:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		disk_format: ${20:qcow2}
		cert: ${21:# A path to a client certificate to use as part of the SSL transaction.}
		auth_type: ${22:password}
		filename: ${23:# The path to the file which has to be uploaded}
		state: ${24:#present|absent}
		timeout: ${25:180}
		validate_certs: ${26:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_image_facts "Retrieve facts about an image within OpenStack."
- name: $1
	os_image_facts:
		image: ${2:# Name or ID of the image}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${8:# A path to a client key to use as part of the SSL transaction.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		timeout: ${11:180}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		validate_certs: ${13:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${15:#yes|no}
$0
endsnippet

snippet os_ironic "Create/Delete Bare Metal Resources from OpenStack"
- name: $1
	os_ironic:
		driver: ${2:# The name of the Ironic Driver to use with this node.}
		nics: ${3:# A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"}
		auth_type: ${4:password}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		properties: ${12:# Definition of the physical characteristics of this server, used for scheduling purposes}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		name: ${14:# unique name identifier to be given to the resource.}
		timeout: ${15:180}
		cert: ${16:# A path to a client certificate to use as part of the SSL transaction.}
		uuid: ${17:# globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.}
		driver_info: ${18:# Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.}
		ironic_url: ${19:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
		validate_certs: ${20:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		state: ${21:#present|absent}
		chassis_uuid: ${22:# Associate the node with a pre-defined chassis.}
		wait: ${23:#yes|no}
		skip_update_of_driver_password: ${24:no}
$0
endsnippet

snippet os_ironic_inspect "Explicitly triggers baremetal node introspection in ironic."
- name: $1
	os_ironic_inspect:
		auth_type: ${2:password}
		region_name: ${3:# Name of the region.}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		mac: ${7:# unique mac address that is used to attempt to identify the host.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		name: ${12:# unique name identifier to identify the host in Ironic.}
		uuid: ${13:# globally unique identifier (UUID) to identify the host.}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		ironic_url: ${15:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.}
		timeout: ${16:180}
		wait: ${17:#yes|no}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_ironic_node "Activate/Deactivate Bare Metal Resources from OpenStack"
- name: $1
	os_ironic_node:
		auth_type: ${2:password}
		timeout: ${3:180}
		power: ${4:#present|absent}
		deploy: ${5:true|false}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		maintenance_reason: ${7:# A string expression regarding the reason a node is in a maintenance mode.}
		endpoint_type: ${8:#public|internal|admin}
		auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${13:#yes|no}
		uuid: ${14:# globally unique identifier (UUID) to be given to the resource.}
		region_name: ${15:# Name of the region.}
		cert: ${16:# A path to a client certificate to use as part of the SSL transaction.}
		availability_zone: ${17:# Ignored. Present for backwards compatability}
		ironic_url: ${18:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
		state: ${19:#present|absent}
		maintenance: ${20:no}
		validate_certs: ${21:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		instance_info: ${22:# Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.}
		config_drive: ${23:# A configdrive file or HTTP(S) URL that will be passed along to the node.}
$0
endsnippet

snippet os_keypair "Add/Delete a keypair from OpenStack"
- name: $1
	os_keypair:
		name: ${2:# Name that has to be given to the key pair}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		public_key_file: ${11:# Path to local file containing ssh public key. Mutually exclusive with public_key.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${13:#yes|no}
		public_key: ${14:# The public key that would be uploaded to nova and injected into VMs upon creation.}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${16:#present|absent}
		timeout: ${17:180}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_keystone_domain "Manage OpenStack Identity Domains"
- name: $1
	os_keystone_domain:
		name: ${2:# Name that has to be given to the instance}
		auth_type: ${3:password}
		description: ${4:# Description of the domain}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${12:# Name of the region.}
		enabled: ${13:yes}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${15:#present|absent}
		timeout: ${16:180}
		wait: ${17:#yes|no}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_keystone_domain_facts "Retrieve facts about one or more OpenStack domains"
- name: $1
	os_keystone_domain_facts:
		name: ${2:# Name or ID of the domain}
		auth_type: ${3:password}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		timeout: ${6:180}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${8:# A path to a client key to use as part of the SSL transaction.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		filters: ${11:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${13:#yes|no}
		validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${16:# Name of the region.}
$0
endsnippet

snippet os_keystone_role "Manage OpenStack Identity Roles"
- name: $1
	os_keystone_role:
		name: ${2:# Role Name}
		auth_type: ${3:password}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cert: ${6:# A path to a client certificate to use as part of the SSL transaction.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${8:# A path to a client key to use as part of the SSL transaction.}
		state: ${9:#present|absent}
		endpoint_type: ${10:#public|internal|admin}
		timeout: ${11:180}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${13:#yes|no}
		validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${16:# Name of the region.}
$0
endsnippet

snippet os_keystone_service "Manage OpenStack Identity services"
- name: $1
	os_keystone_service:
		name: ${2:# Name of the service}
		service_type: ${3:# The type of service}
		auth_type: ${4:password}
		description: ${5:# Description of the service}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${13:# Name of the region.}
		enabled: ${14:yes}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${16:#present|absent}
		timeout: ${17:180}
		wait: ${18:#yes|no}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_network "Creates/removes networks from OpenStack"
- name: $1
	os_network:
		name: ${2:# Name to be assigned to the network.}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		provider_network_type: ${5:# The type of physical network that maps to this network resource.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		provider_physical_network: ${9:# The physical network where this network object is implemented.}
		endpoint_type: ${10:#public|internal|admin}
		external: ${11:no}
		key: ${12:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${15:#yes|no}
		admin_state_up: ${16:yes}
		cert: ${17:# A path to a client certificate to use as part of the SSL transaction.}
		project: ${18:# Project name or ID containing the network (name admin-only)}
		state: ${19:#present|absent}
		provider_segmentation_id: ${20:# An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.}
		timeout: ${21:180}
		shared: ${22:no}
		validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_networks_facts "Retrieve facts about one or more OpenStack networks."
- name: $1
	os_networks_facts:
		auth_type: ${2:password}
		name: ${3:# Name or ID of the Network}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		timeout: ${6:180}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${8:# A path to a client key to use as part of the SSL transaction.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		filters: ${11:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${13:#yes|no}
		validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${16:# Name of the region.}
$0
endsnippet

snippet os_nova_flavor "Manage OpenStack compute flavors"
- name: $1
	os_nova_flavor:
		name: ${2:# Flavor name.}
		auth_type: ${3:password}
		api_timeout: ${4:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		ram: ${7:# Amount of memory, in MB.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		extra_specs: ${10:# Metadata dictionary}
		key: ${11:# A path to a client key to use as part of the SSL transaction.}
		rxtx_factor: ${12:1.0}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		is_public: ${14:yes}
		disk: ${15:# Size of local disk, in GB.}
		cloud: ${16:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${17:#yes|no}
		flavorid: ${18:auto}
		cert: ${19:# A path to a client certificate to use as part of the SSL transaction.}
		ephemeral: ${20:0}
		vcpus: ${21:# Number of virtual CPUs.}
		state: ${22:#present|absent}
		swap: ${23:0}
		timeout: ${24:180}
		validate_certs: ${25:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_nova_host_aggregate "Manage OpenStack host aggregates"
- name: $1
	os_nova_host_aggregate:
		name: ${2:# N}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# A}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${12:#yes|no}
		cert: ${13:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${14:#present|absent}
		hosts: ${15:# L}
		timeout: ${16:180}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		metadata: ${18:# M}
$0
endsnippet

snippet os_object "Create or Delete objects and containers from OpenStack"
- name: $1
	os_object:
		container: ${2:# The name of the container in which to create the object}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${12:#yes|no}
		name: ${13:# Name to be give to the object. If omitted, operations will be on the entire container}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		filename: ${15:# Path to local file to be uploaded.}
		state: ${16:#present|absent}
		timeout: ${17:180}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		container_access: ${19:#private|public}
$0
endsnippet

snippet os_port "Add/Update/Delete ports from an OpenStack cloud."
- name: $1
	os_port:
		network: ${2:# Network ID or name this port belongs to.}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		allowed_address_pairs: ${5:# Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		extra_dhcp_opts: ${7:# Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		device_owner: ${10:# The ID of the entity that uses this port.}
		endpoint_type: ${11:#public|internal|admin}
		key: ${12:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		fixed_ips: ${14:# Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.}
		security_groups: ${15:# Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)}
		name: ${16:# Name that has to be given to the port.}
		admin_state_up: ${17:# Sets admin state.}
		cert: ${18:# A path to a client certificate to use as part of the SSL transaction.}
		wait: ${19:#yes|no}
		state: ${20:#present|absent}
		no_security_groups: ${21:no}
		cloud: ${22:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		timeout: ${23:180}
		mac_address: ${24:# MAC address of this port.}
		device_id: ${25:# Device ID of device using this port.}
		validate_certs: ${26:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_port_facts "Retrieve facts about ports within OpenStack."
- name: $1
	os_port_facts:
		auth_type: ${2:password}
		region_name: ${3:# Name of the region.}
		availability_zone: ${4:# Ignored. Present for backwards compatability}
		api_timeout: ${5:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		timeout: ${6:180}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${8:# A path to a client key to use as part of the SSL transaction.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		filters: ${11:# A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		validate_certs: ${13:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		port: ${14:# Unique name or ID of a port.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${16:#yes|no}
$0
endsnippet

snippet os_project "Manage OpenStack Projects"
- name: $1
	os_project:
		name: ${2:# Name for the project}
		auth_type: ${3:password}
		description: ${4:# Description for the project}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		domain_id: ${11:# Domain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${13:# Name of the region.}
		enabled: ${14:yes}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${16:#present|absent}
		timeout: ${17:180}
		wait: ${18:#yes|no}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_project_facts "Retrieve facts about one or more OpenStack projects"
- name: $1
	os_project_facts:
		name: ${2:# Name or ID of the project}
		auth_type: ${3:password}
		domain: ${4:# Name or ID of the domain containing the project if the cloud supports domains}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		filters: ${11:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${14:#yes|no}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		timeout: ${16:180}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_quota "Manage OpenStack Quotas"
- name: $1
	os_quota:
		name: ${2:# Name of the OpenStack Project to manage.}
		snapshots_lvm: ${3:# N}
		server_groups: ${4:# N}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		ram: ${6:# M}
		snapshots: ${7:# N}
		instances: ${8:# M}
		backups: ${9:# M}
		fixed_ips: ${10:# N}
		port: ${11:# N}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		subnet: ${13:# N}
		per_volume_gigabytes: ${14:# M}
		network: ${15:# N}
		floatingip: ${16:# N}
		volumes_lvm: ${17:# N}
		floating_ips: ${18:# N}
		auth_type: ${19:password}
		security_group_rule: ${20:# N}
		state: ${21:present}
		injected_files: ${22:# N}
		rbac_policy: ${23:# N}
		wait: ${24:#yes|no}
		api_timeout: ${25:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		injected_path_size: ${26:# M}
		region_name: ${27:# Name of the region.}
		gigabytes: ${28:# M}
		backup_gigabytes: ${29:# M}
		subnetpool: ${30:# N}
		key_pairs: ${31:# N}
		endpoint_type: ${32:#public|internal|admin}
		injected_file_size: ${33:# M}
		key: ${34:# A path to a client key to use as part of the SSL transaction.}
		router: ${35:# N}
		cacert: ${36:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		properties: ${37:# N}
		server_group_members: ${38:# N}
		validate_certs: ${39:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		timeout: ${40:180}
		cert: ${41:# A path to a client certificate to use as part of the SSL transaction.}
		volumes: ${42:# N}
		gigabytes_lvm: ${43:# M}
		security_group: ${44:# N}
		cores: ${45:# M}
		auth: ${46:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
$0
endsnippet

snippet os_recordset "Manage OpenStack DNS recordsets"
- name: $1
	os_recordset:
		name: ${2:# Name of the recordset}
		zone: ${3:# Zone managing the recordset}
		records: ${4:# List of recordset definitions}
		recordset_type: ${5:# Recordset type}
		auth_type: ${6:password}
		availability_zone: ${7:# Ignored. Present for backwards compatability}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${11:# A path to a client key to use as part of the SSL transaction.}
		state: ${12:#present|absent}
		endpoint_type: ${13:#public|internal|admin}
		region_name: ${14:# Name of the region.}
		timeout: ${15:180}
		ttl: ${16:# TTL (Time To Live) value in seconds}
		cacert: ${17:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${18:#yes|no}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${20:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		description: ${21:# Description of the recordset}
$0
endsnippet

snippet os_router "Create or delete routers from OpenStack"
- name: $1
	os_router:
		name: ${2:# Name to be give to the router}
		auth_type: ${3:password}
		key: ${4:# A path to a client key to use as part of the SSL transaction.}
		enable_snat: ${5:yes}
		network: ${6:# Unique name or ID of the external gateway network.}
		region_name: ${7:# Name of the region.}
		admin_state_up: ${8:yes}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		interfaces: ${10:# List of subnets to attach to the router internal interface.}
		availability_zone: ${11:# Ignored. Present for backwards compatability}
		timeout: ${12:180}
		auth: ${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		project: ${14:# Unique name or ID of the project.}
		state: ${15:#present|absent}
		endpoint_type: ${16:#public|internal|admin}
		api_timeout: ${17:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cacert: ${18:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${19:#yes|no}
		validate_certs: ${20:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${21:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		external_fixed_ips: ${22:# The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.}
$0
endsnippet

snippet os_security_group "Add/Delete security groups from an OpenStack cloud."
- name: $1
	os_security_group:
		name: ${2:# Name that has to be given to the security group. This module requires that security group names be unique.}
		auth_type: ${3:password}
		description: ${4:# Long description of the purpose of the security group}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${12:# Name of the region.}
		cert: ${13:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${14:#present|absent}
		timeout: ${15:180}
		wait: ${16:#yes|no}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_security_group_rule "Add/Delete rule from an existing security group"
- name: $1
	os_security_group_rule:
		security_group: ${2:# Name or ID of the security group}
		auth_type: ${3:password}
		direction: ${4:egress|#ingress}
		protocol: ${5:tcp|udp|icmp|112|#None}
		region_name: ${6:# Name of the region.}
		availability_zone: ${7:# Ignored. Present for backwards compatability}
		port_range_max: ${8:# Ending port}
		api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${11:#public|internal|admin}
		key: ${12:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${14:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${15:#yes|no}
		remote_ip_prefix: ${16:# Source IP address(es) in CIDR notation (exclusive with remote_group)}
		remote_group: ${17:# Name or ID of the Security group to link (exclusive with remote_ip_prefix)}
		cert: ${18:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${19:#present|absent}
		port_range_min: ${20:# Starting port}
		timeout: ${21:180}
		ethertype: ${22:#IPv4|IPv6}
		validate_certs: ${23:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_server "Create/Delete Compute Instances from OpenStack"
- name: $1
	os_server:
		name: ${2:# Name that has to be given to the instance}
		image: ${3:# The name or id of the base image to boot.}
		auth_type: ${4:password}
		volumes: ${5:[]}
		availability_zone: ${6:# Availability zone in which to create the server.}
		key_name: ${7:# The key pair name to be used when creating a instance}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		image_exclude: ${9:# Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"}
		boot_volume: ${10:# Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.}
		flavor_include: ${11:# Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		meta: ${13:# A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"}
		auth: ${14:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${15:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		terminate_volume: ${17:no}
		flavor: ${18:1}
		delete_fip: ${19:no}
		security_groups: ${20:# Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.}
		scheduler_hints: ${21:# Arbitrary key/value pairs to the scheduler for custom use}
		boot_from_volume: ${22:no}
		userdata: ${23:# Opaque blob of data which is made available to the instance}
		cert: ${24:# A path to a client certificate to use as part of the SSL transaction.}
		network: ${25:# Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.}
		region_name: ${26:# Name of the region.}
		nics: ${27:# A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.}
		floating_ips: ${28:# list of valid floating IPs that pre-exist to assign to this node}
		flavor_ram: ${29:1}
		volume_size: ${30:# The size of the volume to create in GB if booting from volume based on an image.}
		state: ${31:#present|absent}
		endpoint_type: ${32:#public|internal|admin}
		auto_ip: ${33:yes}
		config_drive: ${34:no}
		timeout: ${35:180}
		wait: ${36:#yes|no}
		validate_certs: ${37:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		reuse_ips: ${38:yes}
		floating_ip_pools: ${39:# Name of floating IP pool from which to choose a floating IP}
$0
endsnippet

snippet os_server_actions "Perform actions on Compute Instances from OpenStack"
- name: $1
	os_server_actions:
		server: ${2:# Name or ID of the instance}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		image: ${6:# Image the server should be rebuilt with}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${13:#yes|no}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		timeout: ${15:180}
		action: ${16:stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_server_facts "Retrieve facts about one or more compute instances"
- name: $1
	os_server_facts:
		detailed: ${2:no}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		server: ${8:# restrict results to servers with names or UUID matching this glob expression (e.g., C<web*>).}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${11:#public|internal|admin}
		timeout: ${12:180}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${16:#yes|no}
$0
endsnippet

snippet os_server_group "Manage OpenStack server groups"
- name: $1
	os_server_group:
		name: ${2:# Server group name.}
		auth_type: ${3:password}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${8:#public|internal|admin}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${11:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${12:#yes|no}
		cert: ${13:# A path to a client certificate to use as part of the SSL transaction.}
		timeout: ${14:180}
		state: ${15:#present|absent}
		policies: ${16:# A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_server_volume "Attach/Detach Volumes from OpenStack VM's"
- name: $1
	os_server_volume:
		volume: ${2:# Name or id of volume you want to attach to a server}
		server: ${3:# Name or ID of server you want to attach a volume to}
		auth_type: ${4:password}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		cacert: ${9:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		endpoint_type: ${10:#public|internal|admin}
		key: ${11:# A path to a client key to use as part of the SSL transaction.}
		device: ${12:# Device you want to attach. Defaults to auto finding a device name.}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${14:#yes|no}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${16:#present|absent}
		timeout: ${17:180}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_stack "Add/Remove Heat Stack"
- name: $1
	os_stack:
		name: ${2:# Name of the stack that should be created, name could be char and digit, no space}
		auth_type: ${3:password}
		key: ${4:# A path to a client key to use as part of the SSL transaction.}
		rollback: ${5:no}
		parameters: ${6:# Dictionary of parameters for the stack creation}
		availability_zone: ${7:# Ignored. Present for backwards compatability}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		environment: ${11:# List of environment files that should be used for the stack creation}
		state: ${12:#present|absent}
		endpoint_type: ${13:#public|internal|admin}
		region_name: ${14:# Name of the region.}
		timeout: ${15:180}
		cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${17:#yes|no}
		validate_certs: ${18:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${19:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		template: ${20:# Path of the template file to use for the stack creation}
$0
endsnippet

snippet os_subnet "Add/Remove subnet to an OpenStack network"
- name: $1
	os_subnet:
		name: ${2:# The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.}
		auth_type: ${3:password}
		no_gateway_ip: ${4:no}
		use_default_subnetpool: ${5:no}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		ipv6_ra_mode: ${9:dhcpv6-stateful|dhcpv6-stateless|slaac}
		endpoint_type: ${10:#public|internal|admin}
		host_routes: ${11:# A list of host route dictionaries for the subnet.}
		key: ${12:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		ipv6_address_mode: ${14:dhcpv6-stateful|dhcpv6-stateless|slaac}
		cidr: ${15:# The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.}
		network_name: ${16:# Name of the network to which the subnet should be attached}
		allocation_pool_end: ${17:# From the subnet pool the last IP that should be assigned to the virtual machines.}
		region_name: ${18:# Name of the region.}
		enable_dhcp: ${19:yes}
		dns_nameservers: ${20:# List of DNS nameservers for this subnet.}
		cert: ${21:# A path to a client certificate to use as part of the SSL transaction.}
		project: ${22:# Project name or ID containing the subnet (name admin-only)}
		state: ${23:#present|absent}
		allocation_pool_start: ${24:# From the subnet pool the starting address from which the IP should be allocated.}
		gateway_ip: ${25:# The ip that would be assigned to the gateway for this subnet}
		cloud: ${26:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		timeout: ${27:180}
		ip_version: ${28:4}
		wait: ${29:#yes|no}
		validate_certs: ${30:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_subnets_facts "Retrieve facts about one or more OpenStack subnets."
- name: $1
	os_subnets_facts:
		auth_type: ${2:password}
		subnet: ${3:# Name or ID of the subnet}
		region_name: ${4:# Name of the region.}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		api_timeout: ${6:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		timeout: ${7:180}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		endpoint_type: ${11:#public|internal|admin}
		filters: ${12:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		cacert: ${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		validate_certs: ${14:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		cloud: ${15:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${16:#yes|no}
$0
endsnippet

snippet os_user "Manage OpenStack Identity Users"
- name: $1
	os_user:
		name: ${2:# Username for the user}
		auth_type: ${3:password}
		domain: ${4:# Domain to create the user in if the cloud supports domains}
		availability_zone: ${5:# Ignored. Present for backwards compatability}
		cert: ${6:# A path to a client certificate to use as part of the SSL transaction.}
		update_password: ${7:#always|on_create}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		enabled: ${9:yes}
		default_project: ${10:# Project name or ID that the user should be associated with by default}
		auth: ${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${12:# A path to a client key to use as part of the SSL transaction.}
		state: ${13:#present|absent}
		endpoint_type: ${14:#public|internal|admin}
		timeout: ${15:180}
		cacert: ${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${17:#yes|no}
		password: ${18:# Password for the user}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		email: ${20:# Email address for the user}
		cloud: ${21:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		region_name: ${22:# Name of the region.}
$0
endsnippet

snippet os_user_facts "Retrieve facts about one or more OpenStack users"
- name: $1
	os_user_facts:
		name: ${2:# Name or ID of the user}
		auth_type: ${3:password}
		domain: ${4:# Name or ID of the domain containing the user if the cloud supports domains}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${9:# A path to a client key to use as part of the SSL transaction.}
		endpoint_type: ${10:#public|internal|admin}
		filters: ${11:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${14:#yes|no}
		cert: ${15:# A path to a client certificate to use as part of the SSL transaction.}
		timeout: ${16:180}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_user_group "Associate OpenStack Identity users and groups"
- name: $1
	os_user_group:
		user: ${2:# Name or id for the user}
		group: ${3:# Name or id for the group.}
		auth_type: ${4:password}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		key: ${10:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${11:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${12:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${13:#yes|no}
		cert: ${14:# A path to a client certificate to use as part of the SSL transaction.}
		state: ${15:#present|absent}
		timeout: ${16:180}
		validate_certs: ${17:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_user_role "Associate OpenStack Identity users and roles"
- name: $1
	os_user_role:
		role: ${2:# Name or ID for the role.}
		auth_type: ${3:password}
		domain: ${4:# ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		api_timeout: ${7:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		auth: ${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		endpoint_type: ${9:#public|internal|admin}
		user: ${10:# Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.}
		key: ${11:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		cloud: ${13:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		wait: ${14:#yes|no}
		group: ${15:# Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.}
		cert: ${16:# A path to a client certificate to use as part of the SSL transaction.}
		project: ${17:# Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.}
		state: ${18:#present|absent}
		timeout: ${19:180}
		validate_certs: ${20:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
$0
endsnippet

snippet os_volume "Create/Delete Cinder Volumes"
- name: $1
	os_volume:
		display_name: ${2:# Name of volume}
		auth_type: ${3:password}
		key: ${4:# A path to a client key to use as part of the SSL transaction.}
		region_name: ${5:# Name of the region.}
		availability_zone: ${6:# Ignored. Present for backwards compatability}
		validate_certs: ${7:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		image: ${8:# Image name or id for boot from volume}
		api_timeout: ${9:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cert: ${10:# A path to a client certificate to use as part of the SSL transaction.}
		volume_type: ${11:# Volume type for volume}
		volume: ${12:# Volume name or id to create from}
		state: ${13:#present|absent}
		endpoint_type: ${14:#public|internal|admin}
		display_description: ${15:# String describing the volume}
		timeout: ${16:180}
		snapshot_id: ${17:# Volume snapshot id to create from}
		cacert: ${18:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		wait: ${19:#yes|no}
		auth: ${20:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		cloud: ${21:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
		size: ${22:# Size of volume in GB. This parameter is required when the I(state) parameter is 'present'.}
$0
endsnippet

snippet os_zone "Manage OpenStack DNS zones"
- name: $1
	os_zone:
		name: ${2:# Zone name}
		auth_type: ${3:password}
		masters: ${4:# Master nameservers (only applies if zone_type is secondary)}
		description: ${5:# Zone description}
		region_name: ${6:# Name of the region.}
		availability_zone: ${7:# Ignored. Present for backwards compatability}
		api_timeout: ${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
		cert: ${9:# A path to a client certificate to use as part of the SSL transaction.}
		auth: ${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
		key: ${11:# A path to a client key to use as part of the SSL transaction.}
		cacert: ${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
		state: ${13:#present|absent}
		endpoint_type: ${14:#public|internal|admin}
		timeout: ${15:180}
		ttl: ${16:# TTL (Time To Live) value in seconds}
		zone_type: ${17:primary|secondary}
		wait: ${18:#yes|no}
		validate_certs: ${19:# Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.}
		email: ${20:# Email of the zone owner (only applies if zone_type is primary)}
		cloud: ${21:# Named cloud to operate against. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present.}
$0
endsnippet

snippet ovh_ip_loadbalancing_backend "Manage OVH IP LoadBalancing backends"
- name: $1
	ovh_ip_loadbalancing_backend:
		endpoint: ${2:# The endpoint to use ( for instance ovh-eu)}
		name: ${3:# Name of the LoadBalancing internal name (ip-X.X.X.X)}
		application_key: ${4:# The applicationKey to use}
		application_secret: ${5:# The application secret to use}
		consumer_key: ${6:# The consumer key to use}
		backend: ${7:# The IP address of the backend to update / modify / delete}
		weight: ${8:8}
		probe: ${9:#none|http|icmp|oco}
		state: ${10:#present|absent}
		timeout: ${11:120}
$0
endsnippet

snippet ovirt_affinity_groups "Module to manage affinity groups in oVirt"
- name: $1
	ovirt_affinity_groups:
		name: ${2:# Name of the the affinity group to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm_enforcing: ${4:# If I(true) VM cannot start if it does not satisfy the C(vm_rule).}
		host_rule: ${5:positive|negative}
		poll_interval: ${6:3}
		fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		cluster: ${9:# Name of the cluster of the affinity group.}
		state: ${10:#present|absent}
		hosts: ${11:# List of the hosts names, which should have assigned this affinity group.}
		timeout: ${12:180}
		vm_rule: ${13:positive|negative|disabled}
		host_enforcing: ${14:# If I(true) VM cannot start on host if it does not satisfy the C(host_rule).}
		wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
		vms: ${16:# List of the VMs names, which should have assigned this affinity group.}
		description: ${17:# Description of the affinity group.}
$0
endsnippet

snippet ovirt_affinity_labels "Module to manage affinity labels in oVirt"
- name: $1
	ovirt_affinity_labels:
		name: ${2:# Name of the the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		poll_interval: ${4:3}
		fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
		cluster: ${7:# Name of the cluster where vms and hosts resides.}
		state: ${8:#present|absent}
		hosts: ${9:# List of the hosts names, which should have assigned this affinity label.}
		timeout: ${10:180}
		vms: ${11:# List of the VMs names, which should have assigned this affinity label.}
		wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_affinity_labels_facts "Retrieve facts about one or more oVirt affinity labels"
- name: $1
	ovirt_affinity_labels_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		fetch_nested: ${3:# If I(True) the module will fetch additional data from the API.}
		host: ${4:# Name of the host, which affinity labels should be listed.}
		name: ${5:# Name of the affinity labels which should be listed.}
		vm: ${6:# Name of the VM, which affinity labels should be listed.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_auth "Module to manage authentication to oVirt"
- name: $1
	ovirt_auth:
		username: ${2:# The name of the user. For example: I(admin@internal).}
		url: ${3:# A string containing the base URL of the server. For example: I(https://server.example.com/ovirt-engine/api).}
		password: ${4:# The password of the user.}
		ca_file: ${5:# A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used.}
		insecure: ${6:# A boolean flag that indicates if the server TLS certificate and host name should be checked.}
		kerberos: ${7:# A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.}
		compress: ${8:# A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).}
		state: ${9:#present|absent}
		timeout: ${10:# The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.}
$0
endsnippet

snippet ovirt_clusters "Module to manage clusters in oVirt"
- name: $1
	ovirt_clusters:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the the cluster to manage.}
		comment: ${4:# Comment of the cluster.}
		ha_reservation: ${5:# If I(True) enable the oVirt to monitor cluster capacity for highly available virtual machines.}
		fence_skip_if_connectivity_broken: ${6:# If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.}
		virt: ${7:# If I(True), hosts in this cluster will be used to run virtual machines.}
		threads_as_cores: ${8:# If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.}
		gluster: ${9:# If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.}
		vm_reason: ${10:# If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		migration_bandwidth_limit: ${12:# Set the I(custom) migration bandwidth limit.}
		switch_type: ${13:legacy|ovs}
		data_center: ${14:# Datacenter name where cluster reside.}
		ksm_numa: ${15:# If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.}
		description: ${16:# Description of the cluster.}
		cpu_arch: ${17:x86_64|ppc64|undefined}
		rng_sources: ${18:# List that specify the random number generator devices that all hosts in the cluster will use.}
		network: ${19:# Management network of cluster to access cluster hosts.}
		state: ${20:#present|absent}
		ksm: ${21:# I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.}
		migration_compressed: ${22:true|false|inherit}
		ballooning: ${23:# If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.}
		migration_auto_converge: ${24:true|false|inherit}
		fence_enabled: ${25:# If I(True) enables fencing on the cluster.}
		migration_policy: ${26:legacy|minimal_downtime|suspend_workload}
		nested_attributes: ${27:# Specifies list of the attributes which should be fetched from the API.}
		resilience_policy: ${28:do_not_migrate|migrate|migrate_highly_available}
		fence_connectivity_threshold: ${29:# The threshold used by C(fence_skip_if_connectivity_broken).}
		spice_proxy: ${30:# The proxy by which the SPICE client will connect to virtual machines.}
		memory_policy: ${31:disabled|server|desktop}
		migration_bandwidth: ${32:auto|hypervisor_default|custom}
		fence_skip_if_sd_active: ${33:# If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.}
		scheduling_policy: ${34:# Name of the scheduling policy to be used for cluster.}
		wait: ${35:# I(True) if the module should wait for the entity to get into desired state.}
		compatibility_version: ${36:# The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.}
		serial_policy_value: ${37:# Allows you to specify a custom serial number.}
		host_reason: ${38:# If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.}
		poll_interval: ${39:3}
		cpu_type: ${40:# CPU codename. For example I(Intel SandyBridge Family).}
		timeout: ${41:180}
		serial_policy: ${42:# Specify a serial number policy for the virtual machines in the cluster.}
		trusted_service: ${43:# If (True) enable integration with an OpenAttestation server.}
$0
endsnippet

snippet ovirt_clusters_facts "Retrieve facts about one or more oVirt clusters"
- name: $1
	ovirt_clusters_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_datacenters "Module to manage data centers in oVirt"
- name: $1
	ovirt_datacenters:
		name: ${2:# Name of the the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		comment: ${4:# Comment of the data center.}
		compatibility_version: ${5:# Compatibility version of the data center.}
		mac_pool: ${6:# MAC pool to be used by this datacenter.}
		local: ${7:# I(True) if the data center should be local, I(False) if should be shared.}
		poll_interval: ${8:3}
		fetch_nested: ${9:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${10:# Specifies list of the attributes which should be fetched from the API.}
		state: ${11:#present|absent}
		timeout: ${12:180}
		wait: ${13:# I(True) if the module should wait for the entity to get into desired state.}
		quota_mode: ${14:disabled|audit|enabled}
		description: ${15:# Description of the data center.}
$0
endsnippet

snippet ovirt_datacenters_facts "Retrieve facts about one or more oVirt datacenters"
- name: $1
	ovirt_datacenters_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_disks "Module to manage Virtual Machine and floating disks in oVirt"
- name: $1
	ovirt_disks:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm_name: ${3:# Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		profile: ${4:# Disk profile name to be attached to disk. By default profile is chosen by oVirt engine.}
		storage_domains: ${5:# Storage domain names where disk should be copied.}
		force: ${6:# Please take a look at C(image_path) documentation to see the correct usage of this parameter.}
		format: ${7:raw|cow}
		poll_interval: ${8:3}
		logical_unit: ${9:# Dictionary which describes LUN to be directly attached to VM:}
		nested_attributes: ${10:# Specifies list of the attributes which should be fetched from the API.}
		fetch_nested: ${11:# If I(True) the module will fetch additional data from the API.}
		download_image_path: ${12:# Path on a file system where disk should be downloaded.}
		interface: ${13:#virtio|ide|virtio_scsi}
		vm_id: ${14:# ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
		id: ${15:# ID of the disk to manage. Either C(id) or C(name) is required.}
		size: ${16:# Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.}
		storage_domain: ${17:# Storage domain name where disk should be created. By default storage is chosen by oVirt engine.}
		name: ${18:# Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.}
		bootable: ${19:# I(True) if the disk should be bootable. By default when disk is created it isn't bootable.}
		upload_image_path: ${20:# Path to disk image, which should be uploaded.}
		state: ${21:#present|absent|attached|detached}
		shareable: ${22:# I(True) if the disk should be shareable. By default when disk is created it isn't shareable.}
		timeout: ${23:180}
		wait: ${24:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_external_providers "Module to manage external providers in oVirt"
- name: $1
	ovirt_external_providers:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		username: ${3:# Username to be used for login to external provider.}
		read_only: ${4:# Specify if the network should be read only.}
		name: ${5:# Name of the the external provider to manage.}
		url: ${6:# URL where external provider is hosted.}
		tenant_name: ${7:# Name of the tenant.}
		poll_interval: ${8:3}
		fetch_nested: ${9:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${10:# Specifies list of the attributes which should be fetched from the API.}
		state: ${11:#present|absent}
		authentication_url: ${12:# Keystone authentication URL of the openstack provider.}
		timeout: ${13:180}
		data_center: ${14:# Name of the data center where provider should be attached.}
		wait: ${15:# I(True) if the module should wait for the entity to get into desired state.}
		password: ${16:# Password of the user specified in C(username) parameter.}
		type: ${17:os_image|network|os_volume|foreman}
		network_type: ${18:[#external, neutron}
		description: ${19:# Description of the external provider.}
$0
endsnippet

snippet ovirt_external_providers_facts "Retrieve facts about one or more oVirt external providers"
- name: $1
	ovirt_external_providers_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		type: ${3:os_image|os_network|os_volume|foreman}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		name: ${5:# Name of the external provider, can be used as glob expression.}
		nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_groups "Module to manage groups in oVirt"
- name: $1
	ovirt_groups:
		name: ${2:# Name of the the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		namespace: ${5:# Namespace of the authorization provider, where group resides.}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		poll_interval: ${8:3}
		state: ${9:#present|absent}
		timeout: ${10:180}
		wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_groups_facts "Retrieve facts about one or more oVirt groups"
- name: $1
	ovirt_groups_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_host_networks "Module to manage host networks in oVirt"
- name: $1
	ovirt_host_networks:
		name: ${2:# Name of the the host to manage networks for.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		labels: ${4:# List of names of the network label to be assigned to bond or interface.}
		poll_interval: ${5:3}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		networks: ${8:# List of dictionary describing networks to be attached to interface or bond:}
		state: ${9:#present|absent}
		timeout: ${10:180}
		interface: ${11:# Name of the network interface where logical network should be attached.}
		wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
		save: ${13:# If I(true) network configuration will be persistent, by default they are temporary.}
		check: ${14:# If I(true) verify connectivity between host and engine.}
		bond: ${15:# Dictionary describing network bond:}
$0
endsnippet

snippet ovirt_host_pm "Module to manage power management of hosts in oVirt"
- name: $1
	ovirt_host_pm:
		name: ${2:# Name of the the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		username: ${4:# Username to be used to connect to power management interface.}
		slot: ${5:# Power management slot.}
		password: ${6:# Password of the user specified in C(username) parameter.}
		poll_interval: ${7:3}
		fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${9:# Specifies list of the attributes which should be fetched from the API.}
		order: ${10:# Integer value specifying, by default it's added at the end.}
		port: ${11:# Power management interface port.}
		state: ${12:#present|absent}
		timeout: ${13:180}
		address: ${14:# Address of the power management interface.}
		encrypt_options: ${15:# If (true) options will be encrypted when send to agent.}
		type: ${16:# Type of the power management. oVirt predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type.}
		options: ${17:# Dictionary of additional fence agent options.}
		wait: ${18:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_hosts "Module to manage hosts in oVirt"
- name: $1
	ovirt_hosts:
		name: ${2:# Name of the the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		comment: ${4:# Description of the host.}
		public_key: ${5:no}
		password: ${6:# Password of the root. It's required in case C(public_key) is set to I(False).}
		force: ${7:no}
		cluster: ${8:# Name of the cluster, where host should be created.}
		spm_priority: ${9:# SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.}
		address: ${10:# Host address. It can be either FQDN (preferred) or IP address.}
		poll_interval: ${11:3}
		fetch_nested: ${12:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${13:# Specifies list of the attributes which should be fetched from the API.}
		kernel_params: ${14:# List of kernel boot parameters.}
		state: ${15:#present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled}
		timeout: ${16:180}
		hosted_engine: ${17:# If I(deploy) it means this host should deploy also hosted engine components.}
		wait: ${18:# I(True) if the module should wait for the entity to get into desired state.}
		override_iptables: ${19:# If True host iptables will be overridden by host deploy script.}
		kdump_integration: ${20:#enabled|disabled}
		override_display: ${21:# Override the display address of all VMs on this host with specified address.}
$0
endsnippet

snippet ovirt_hosts_facts "Retrieve facts about one or more oVirt hosts"
- name: $1
	ovirt_hosts_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_mac_pools "Module to manage MAC pools in oVirt"
- name: $1
	ovirt_mac_pools:
		name: ${2:# Name of the the MAC pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		ranges: ${4:# List of MAC ranges. The from and to should be splitted by comma.}
		poll_interval: ${5:3}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		allow_duplicates: ${8:# If (true) allow a MAC address to be used multiple times in a pool.}
		state: ${9:#present|absent}
		timeout: ${10:180}
		wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
		description: ${12:# Description of the MAC pool.}
$0
endsnippet

snippet ovirt_networks "Module to manage logical networks in oVirt"
- name: $1
	ovirt_networks:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the the network to manage.}
		comment: ${4:# Comment of the network.}
		timeout: ${5:180}
		description: ${6:# Description of the network.}
		poll_interval: ${7:3}
		fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${9:# Specifies list of the attributes which should be fetched from the API.}
		mtu: ${10:# Maximum transmission unit (MTU) of the network.}
		state: ${11:#present|absent}
		vm_network: ${12:# If I(True) network will be marked as network for VM.}
		data_center: ${13:# Datacenter name where network reside.}
		clusters: ${14:# List of dictionaries describing how the network is managed in specific cluster.}
		vlan_tag: ${15:# Specify VLAN tag.}
		wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_networks_facts "Retrieve facts about one or more oVirt networks"
- name: $1
	ovirt_networks_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_nics "Module to manage network interfaces of Virtual Machines in oVirt"
- name: $1
	ovirt_nics:
		vm: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${4:# Name of the network interface to manage.}
		profile: ${5:# Virtual network interface profile to be attached to VM network interface.}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		network: ${7:# Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.}
		poll_interval: ${8:3}
		nested_attributes: ${9:# Specifies list of the attributes which should be fetched from the API.}
		state: ${10:#present|absent|plugged|unplugged}
		timeout: ${11:180}
		mac_address: ${12:# Custom MAC address of the network interface, by default it's obtained from MAC pool.}
		interface: ${13:#virtio|e1000|rtl8139|pci_passthrough|rtl8139_virtio|spapr_vlan}
		wait: ${14:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_nics_facts "Retrieve facts about one or more oVirt virtual machine network interfaces"
- name: $1
	ovirt_nics_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm: ${3:# Name of the VM where NIC is attached.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
		name: ${6:# Name of the NIC, can be used as glob expression.}
$0
endsnippet

snippet ovirt_permissions "Module to manage permissions of users/groups in oVirt"
- name: $1
	ovirt_permissions:
		authz_name: ${2:# Authorization provider of the user/group. In previous versions of oVirt known as domain.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		poll_interval: ${4:3}
		fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		object_type: ${6:data_center|cluster|host|storage_domain|network|disk|#vm|vm_pool|template|cpu_profile|disk_profile|vnic_profile|system}
		namespace: ${7:# Namespace of the authorization provider, where user/group resides.}
		state: ${8:#present|absent}
		object_id: ${9:# ID of the object where the permissions should be managed.}
		group_name: ${10:# Name of the the group to manage.}
		object_name: ${11:# Name of the object where the permissions should be managed.}
		role: ${12:UserRole}
		nested_attributes: ${13:# Specifies list of the attributes which should be fetched from the API.}
		timeout: ${14:180}
		user_name: ${15:# Username of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		wait: ${16:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_permissions_facts "Retrieve facts about one or more oVirt permissions"
- name: $1
	ovirt_permissions_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		authz_name: ${3:# Authorization provider of the user/group. In previous versions of oVirt known as domain.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		user_name: ${5:# Username of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		namespace: ${6:# Namespace of the authorization provider, where user/group resides.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		group_name: ${8:# Name of the the group to manage.}
$0
endsnippet

snippet ovirt_quotas "Module to manage datacenter quotas in oVirt"
- name: $1
	ovirt_quotas:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		data_center: ${3:# Name of the datacenter where quota should be managed.}
		name: ${4:# Name of the the quota to manage.}
		timeout: ${5:180}
		description: ${6:# Description of the the quota to manage.}
		cluster_grace: ${7:# Cluster grace(hard limit) defined in percentage (1-100).}
		cluster_threshold: ${8:# Cluster threshold(soft limit) defined in percentage (0-100).}
		poll_interval: ${9:3}
		fetch_nested: ${10:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${11:# Specifies list of the attributes which should be fetched from the API.}
		state: ${12:#present|absent}
		storage_grace: ${13:# Storage grace(hard limit) defined in percentage (1-100).}
		storage_threshold: ${14:# Storage threshold(soft limit) defined in percentage (0-100).}
		clusters: ${15:# List of dictionary of cluster limits, which is valid to specific cluster.}
		storages: ${16:# List of dictionary of storage limits, which is valid to specific storage.}
		wait: ${17:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_quotas_facts "Retrieve facts about one or more oVirt quotas"
- name: $1
	ovirt_quotas_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		data_center: ${3:# Name of the datacenter where quota resides.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		name: ${5:# Name of the quota, can be used as glob expression.}
		nested_attributes: ${6:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_snapshots "Module to manage Virtual Machine Snapshots in oVirt"
- name: $1
	ovirt_snapshots:
		vm_name: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		description: ${4:# Description of the snapshot.}
		use_memory: ${5:# If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.}
		poll_interval: ${6:3}
		fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		state: ${9:restore|#present|absent}
		timeout: ${10:180}
		snapshot_id: ${11:# ID of the snapshot to manage.}
		wait: ${12:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_snapshots_facts "Retrieve facts about one or more oVirt virtual machine snapshots"
- name: $1
	ovirt_snapshots_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm: ${3:# Name of the VM with snapshot.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		description: ${5:# Description of the snapshot, can be used as glob expression.}
		snapshot_id: ${6:# Id of the snaphost we want to retrieve facts about.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_storage_domains "Module to manage storage domains in oVirt"
- name: $1
	ovirt_storage_domains:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		comment: ${3:# Comment of the storage domain.}
		domain_function: ${4:#data|iso|export}
		fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		fcp: ${6:# Dictionary with values for fibre channel storage type:}
		name: ${7:# Name of the the storage domain to manage.}
		format: ${8:# If I(True) storage domain will be formatted after removing it from oVirt.}
		iscsi: ${9:# Dictionary with values for iSCSI storage type:}
		posixfs: ${10:# Dictionary with values for PosixFS storage type:}
		poll_interval: ${11:3}
		host: ${12:# Host to be used to mount storage.}
		nested_attributes: ${13:# Specifies list of the attributes which should be fetched from the API.}
		glusterfs: ${14:# Dictionary with values for GlusterFS storage type:}
		state: ${15:#present|absent|maintenance|unattached}
		nfs: ${16:# Dictionary with values for NFS storage type:}
		timeout: ${17:180}
		data_center: ${18:# Data center name where storage domain should be attached.}
		destroy: ${19:# Logical remove of the storage domain. If I(true) retains the storage domain's data for import.}
		wait: ${20:# I(True) if the module should wait for the entity to get into desired state.}
		description: ${21:# Description of the storage domain.}
$0
endsnippet

snippet ovirt_storage_domains_facts "Retrieve facts about one or more oVirt storage domains"
- name: $1
	ovirt_storage_domains_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_tags "Module to manage tags in oVirt"
- name: $1
	ovirt_tags:
		name: ${2:# Name of the the tag to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		parent: ${4:# Name of the parent tag.}
		poll_interval: ${5:3}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		state: ${8:#present|absent}
		hosts: ${9:# List of the hosts names, which should have assigned this tag.}
		timeout: ${10:180}
		wait: ${11:# I(True) if the module should wait for the entity to get into desired state.}
		vms: ${12:# List of the VMs names, which should have assigned this tag.}
		description: ${13:# Description of the the tag to manage.}
$0
endsnippet

snippet ovirt_tags_facts "Retrieve facts about one or more oVirt tags"
- name: $1
	ovirt_tags_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		fetch_nested: ${3:# If I(True) the module will fetch additional data from the API.}
		name: ${4:# Name of the tag which should be listed.}
		poll_interval: ${5:3}
		vm: ${6:# Name of the VM, which tags should be listed.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		host: ${8:# Name of the host, which tags should be listed.}
		timeout: ${9:180}
		wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_templates "Module to manage virtual machine templates in oVirt"
- name: $1
	ovirt_templates:
		name: ${2:# Name of the the template to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		exclusive: ${4:# When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.}
		fetch_nested: ${5:# If I(True) the module will fetch additional data from the API.}
		cpu_profile: ${6:# CPU profile to be set to template.}
		storage_domain: ${7:# When C(state) is I(imported) this parameter specifies the name of the destination data storage domain.}
		description: ${8:# Description of the template.}
		export_domain: ${9:# When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.}
		image_disk: ${10:# When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.}
		poll_interval: ${11:3}
		vm: ${12:# Name of the VM, which will be used to create template.}
		nested_attributes: ${13:# Specifies list of the attributes which should be fetched from the API.}
		cluster: ${14:# Name of the cluster, where template should be created/imported.}
		state: ${15:#present|absent|exported|imported}
		timeout: ${16:180}
		wait: ${17:# I(True) if the module should wait for the entity to get into desired state.}
		clone_permissions: ${18:no}
		image_provider: ${19:# When C(state) is I(imported) this parameter specifies the name of the image provider to be used.}
$0
endsnippet

snippet ovirt_templates_facts "Retrieve facts about one or more oVirt templates"
- name: $1
	ovirt_templates_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_users "Module to manage users in oVirt"
- name: $1
	ovirt_users:
		name: ${2:# Name of the the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		authz_name: ${3:# Authorization provider of the user. In previous versions of oVirt known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		poll_interval: ${5:3}
		fetch_nested: ${6:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		state: ${8:#present|absent}
		timeout: ${9:180}
		wait: ${10:# I(True) if the module should wait for the entity to get into desired state.}
$0
endsnippet

snippet ovirt_users_facts "Retrieve facts about one or more oVirt users"
- name: $1
	ovirt_users_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_vmpools "Module to manage VM pools in oVirt"
- name: $1
	ovirt_vmpools:
		name: ${2:# Name of the the VM pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		timeout: ${4:180}
		description: ${5:# Description of the VM pool.}
		poll_interval: ${6:3}
		fetch_nested: ${7:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${8:# Specifies list of the attributes which should be fetched from the API.}
		vm_per_user: ${9:# Maximum number of VMs a single user can attach to from this pool.}
		cluster: ${10:# Name of the cluster, where VM pool should be created.}
		state: ${11:#present|absent}
		prestarted: ${12:# Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.}
		template: ${13:# Name of the template, which will be used to create VM pool.}
		wait: ${14:# I(True) if the module should wait for the entity to get into desired state.}
		type: ${15:manual|automatic}
		vm_count: ${16:# Number of VMs in the pool.}
$0
endsnippet

snippet ovirt_vmpools_facts "Retrieve facts about one or more oVirt vmpools"
- name: $1
	ovirt_vmpools_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		pattern: ${3:# Search term which is accepted by oVirt search backend.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		nested_attributes: ${5:# Specifies list of the attributes which should be fetched from the API.}
$0
endsnippet

snippet ovirt_vms "Module to manage Virtual Machines in oVirt"
- name: $1
	ovirt_vms:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		comment: ${3:# Comment of the Virtual Machine.}
		disks: ${4:# List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary:}
		force: ${5:no}
		cloud_init_nics: ${6:# List of dictionaries representing network interafaces to be setup by cloud init.}
		cluster: ${7:# Name of the cluster, where Virtual Machine should be created. Required if creating VM.}
		fetch_nested: ${8:# If I(True) the module will fetch additional data from the API.}
		timezone: ${9:# Sets time zone offset of the guest hardware clock.}
		id: ${10:# ID of the the Virtual Machine to manage.}
		cpu_sockets: ${11:# Number of virtual CPUs sockets of the Virtual Machine. Default value is set by oVirt engine.}
		high_availability: ${12:# If I(True) Virtual Machine will be set as highly available.}
		kernel_params: ${13:# Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.}
		nics: ${14:# List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary:}
		sysprep: ${15:# Dictionary with values for Windows Virtual Machine initialization using sysprep:}
		cpu_cores: ${16:# Number of virtual CPUs cores of the Virtual Machine. Default value is set by oVirt engine.}
		state: ${17:running|stopped|#present|absent|suspended|next_run}
		memory_guaranteed: ${18:# Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
		delete_protected: ${19:# If I(True) Virtual Machine will be set as delete protected.}
		memory: ${20:# Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
		cd_iso: ${21:# ISO file from ISO storage domain which should be attached to Virtual Machine.}
		clone_permissions: ${22:no}
		type: ${23:server|desktop}
		initrd_path: ${24:# Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.}
		description: ${25:# Description of the Virtual Machine.}
		clone: ${26:no}
		boot_devices: ${27:# List of boot devices which should be used to boot. Choices I(network), I(hd) and I(cdrom).}
		template: ${28:# Name of the template, which should be used to create Virtual Machine. Required if creating VM.}
		host: ${29:# Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.}
		serial_policy: ${30:# Specify a serial number policy for the Virtual Machine.}
		nested_attributes: ${31:# Specifies list of the attributes which should be fetched from the API.}
		wait: ${32:# I(True) if the module should wait for the entity to get into desired state.}
		use_latest_template_version: ${33:# Specify if latest template version should be used, when running a stateless VM.}
		stateless: ${34:# If I(True) Virtual Machine will be set as stateless.}
		operating_system: ${35:rhel_6_ppc64|other|freebsd|windows_2003x64|windows_10|rhel_6x64|rhel_4x64|windows_2008x64|windows_2008R2x64|debian_7|windows_2012x64|ubuntu_14_04|ubuntu_12_04|ubuntu_13_10|windows_8x64|other_linux_ppc64|windows_2003|other_linux|windows_10x64|windows_2008|rhel_3|rhel_5|rhel_4|other_ppc64|sles_11|rhel_6|windows_xp|rhel_7x64|freebsdx64|rhel_7_ppc64|windows_7|rhel_5x64|ubuntu_14_04_ppc64|sles_11_ppc64|windows_8|windows_2012R2x64|windows_2008r2x64|ubuntu_13_04|ubuntu_12_10|windows_7x64}
		serial_policy_value: ${36:# Allows you to specify a custom serial number.}
		name: ${37:# Name of the the Virtual Machine to manage. If VM don't exists C(name) is required. Otherwise C(id) or C(name) can be used.}
		kernel_path: ${38:# Path to a kernel image used to boot the virtual machine.}
		cloud_init: ${39:# Dictionary with values for Unix-like Virtual Machine initialization using cloud init:}
		template_version: ${40:# Version number of the template to be used for VM.}
		poll_interval: ${41:3}
		instance_type: ${42:# Name of virtual machine's hardware configuration.}
		timeout: ${43:180}
		cpu_shares: ${44:# Set a CPU shares for this Virtual Machine. Default value is set by oVirt engine.}
$0
endsnippet

snippet ovirt_vms_facts "Retrieve facts about one or more oVirt virtual machines"
- name: $1
	ovirt_vms_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		all_content: ${3:# If I(true) all the attributes of the virtual machines should be included in the response.}
		fetch_nested: ${4:# If I(True) the module will fetch additional data from the API.}
		max: ${5:# The maximum number of results to return.}
		pattern: ${6:# Search term which is accepted by oVirt search backend.}
		nested_attributes: ${7:# Specifies list of the attributes which should be fetched from the API.}
		case_sensitive: ${8:# If I(true) performed search will take case into account.}
$0
endsnippet

snippet packet_device "create, destroy, start, stop, and reboot a Packet Host machine."
- name: $1
	packet_device:
		project_id: ${2:# ID of project of the device.}
		count: ${3:# The number of devices to create. Count number can be included in hostname via the %d string formatter.}
		operating_system: ${4:# OS slug for device creation. See Packet docs or API for current list.}
		features: ${5:# Dict with "features" for device creation. See Packet API docs for details.}
		facility: ${6:# Facility slug for device creation. As of 2016, it should be one of [ewr1, sjc1, ams1, nrt1].}
		lock: ${7:no}
		auth_token: ${8:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
		device_ids: ${9:# List of device IDs on which to operate.}
		count_offset: ${10:# From which number to start the count.}
		user_data: ${11:# Userdata blob made available to the machine}
		state: ${12:#present|absent|active|inactive|rebooted}
		hostnames: ${13:# A hostname of a device, or a list of hostnames.}
		plan: ${14:# Plan slug for device creation. See Packet docs or API for current list.}
		wait_timeout: ${15:60}
		wait: ${16:no}
$0
endsnippet

snippet packet_sshkey "Create/delete an SSH key in Packet host."
- name: $1
	packet_sshkey:
		state: ${2:#present|absent}
		key: ${3:# Public Key string ({type} {base64 encoded key} {description}).}
		fingerprint: ${4:# Fingerprint of the key which you want to remove.}
		id: ${5:# UUID of the key which you want to remove.}
		auth_token: ${6:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
		key_file: ${7:# File with the public key.}
		label: ${8:# Label for the key. If you keep it empty, it will be read from key string.}
$0
endsnippet

snippet profitbricks "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine."
- name: $1
	profitbricks:
		image: ${2:# The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.}
		name: ${3:# The name of the virtual machine.}
		lan: ${4:1}
		image_password: ${5:# Password set for the administrative user.}
		bus: ${6:IDE|#VIRTIO}
		ram: ${7:2048}
		instance_ids: ${8:# list of instance ids, currently only used when state='absent' to remove instances.}
		subscription_password: ${9:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		wait_timeout: ${10:600}
		assign_public_ip: ${11:no}
		wait: ${12:#yes|no}
		count: ${13:1}
		datacenter: ${14:# The datacenter to provision this virtual machine.}
		remove_boot_volume: ${15:#yes|no}
		ssh_keys: ${16:# Public SSH keys allowing access to the virtual machine.}
		subscription_user: ${17:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		cpu_family: ${18:#AMD_OPTERON|INTEL_XEON}
		volume_size: ${19:10}
		state: ${20:running|stopped|absent|#present}
		location: ${21:#us/las|de/fra|de/fkb}
		auto_increment: ${22:yes|no}
		cores: ${23:2}
$0
endsnippet

snippet profitbricks_datacenter "Create or destroy a ProfitBricks Virtual Datacenter."
- name: $1
	profitbricks_datacenter:
		name: ${2:# The name of the virtual datacenter.}
		subscription_user: ${3:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		subscription_password: ${4:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		state: ${5:#present|absent}
		wait_timeout: ${6:600}
		location: ${7:#us/las|de/fra|de/fkb}
		wait: ${8:#yes|no}
		description: ${9:# The description of the virtual datacenter.}
$0
endsnippet

snippet profitbricks_nic "Create or Remove a NIC."
- name: $1
	profitbricks_nic:
		datacenter: ${2:# The datacenter in which to operate.}
		lan: ${3:# The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.}
		name: ${4:# The name or ID of the NIC. This is only required on deletes, but not on create.}
		server: ${5:# The server name or ID.}
		subscription_user: ${6:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		subscription_password: ${7:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		state: ${8:#present|absent}
		wait_timeout: ${9:600}
		wait: ${10:#yes|no}
$0
endsnippet

snippet profitbricks_volume "Create or destroy a volume."
- name: $1
	profitbricks_volume:
		image: ${2:# The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.}
		datacenter: ${3:# The datacenter in which to create the volumes.}
		name: ${4:# The name of the volumes. You can enumerate the names using auto_increment.}
		image_password: ${5:# Password set for the administrative user.}
		licence_type: ${6:LINUX|WINDOWS|#UNKNOWN|OTHER}
		bus: ${7:IDE|#VIRTIO}
		instance_ids: ${8:# list of instance ids, currently only used when state='absent' to remove instances.}
		subscription_password: ${9:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		wait_timeout: ${10:600}
		disk_type: ${11:#HDD|SSD}
		wait: ${12:#yes|no}
		count: ${13:1}
		subscription_user: ${14:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		state: ${15:#present|absent}
		auto_increment: ${16:yes|no}
		size: ${17:10}
		ssh_keys: ${18:# Public SSH keys allowing access to the virtual machine.}
$0
endsnippet

snippet profitbricks_volume_attachments "Attach or detach a volume."
- name: $1
	profitbricks_volume_attachments:
		datacenter: ${2:# The datacenter in which to operate.}
		server: ${3:# The name of the server you wish to detach or attach the volume.}
		volume: ${4:# The volume name or ID.}
		subscription_user: ${5:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
		state: ${6:#present|absent}
		wait_timeout: ${7:600}
		subscription_password: ${8:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
		wait: ${9:#yes|no}
$0
endsnippet

snippet pubnub_blocks "PubNub blocks management module."
- name: $1
	pubnub_blocks:
		name: ${2:# Name of managed block which will be later visible on admin.pubnub.com.}
		keyset: ${3:# Name of application's keys set which is bound to managed blocks.}
		application: ${4:# Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.}
		changes: ${5:{}}
		cache: ${6:{}}
		state: ${7:#started|stopped|present|absent}
		password: ${8:# Password which match to account to which specified C(email) belong.}
		validate_certs: ${9:yes}
		email: ${10:# Email from account for which new session should be started.}
		event_handlers: ${11:[]}
		description: ${12:New block}
$0
endsnippet

snippet rax "create / delete an instance in Rackspace Public Cloud"
- name: $1
	rax:
		files: ${2:# Files to insert into the instance. remotefilename:localcontent}
		boot_volume_terminate: ${3:no}
		tenant_name: ${4:# The tenant name used for authentication.}
		auto_increment: ${5:yes|no}
		image: ${6:# image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image}
		user_data: ${7:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
		boot_volume: ${8:# Cloud Block Storage ID or Name to use as the boot volume of the instance}
		count_offset: ${9:1}
		verify_ssl: ${10:# Whether or not to require SSL validation of API endpoints.}
		meta: ${11:# A hash of metadata to associate with the instance}
		instance_ids: ${12:# list of instance ids, currently only used when state='absent' to remove instances}
		tenant_id: ${13:# The tenant ID used for authentication.}
		credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		region: ${15:DFW}
		flavor: ${16:# flavor to use for the instance}
		networks: ${17:[u'public', u'private']}
		wait: ${18:yes|#no}
		boot_from_volume: ${19:yes|#no}
		api_key: ${20:# Rackspace API key, overrides I(credentials).}
		group: ${21:# host group to assign to server, is also used for idempotent operations to ensure a specific number of instances}
		name: ${22:# Name to give the instance}
		identity_type: ${23:rackspace}
		extra_client_args: ${24:# A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.}
		exact_count: ${25:yes|no}
		disk_config: ${26:#auto|manual}
		auth_endpoint: ${27:https://identity.api.rackspacecloud.com/v2.0/}
		count: ${28:1}
		username: ${29:# Rackspace username, overrides I(credentials).}
		state: ${30:#present|absent}
		wait_timeout: ${31:300}
		env: ${32:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		key_name: ${33:# key pair to use on the instance}
		boot_volume_size: ${34:100}
		extra_create_args: ${35:# A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.}
		config_drive: ${36:yes|no}
$0
endsnippet

snippet rax_cbs "Manipulate Rackspace Cloud Block Storage Volumes"
- name: $1
	rax_cbs:
		size: ${2:100}
		volume_type: ${3:#SATA|SSD}
		state: ${4:#present|absent}
		name: ${5:# Name to give the volume being created}
		username: ${6:# Rackspace username, overrides I(credentials).}
		api_key: ${7:# Rackspace API key, overrides I(credentials).}
		tenant_name: ${8:# The tenant name used for authentication.}
		description: ${9:# Description to give the volume being created}
		identity_type: ${10:rackspace}
		tenant_id: ${11:# The tenant ID used for authentication.}
		image: ${12:# image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)}
		auth_endpoint: ${13:https://identity.api.rackspacecloud.com/v2.0/}
		verify_ssl: ${14:# Whether or not to require SSL validation of API endpoints.}
		meta: ${15:# A hash of metadata to associate with the volume}
		env: ${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		snapshot_id: ${17:# The id of the snapshot to create the volume from}
		credentials: ${18:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		wait: ${19:yes|#no}
		region: ${20:DFW}
		wait_timeout: ${21:300}
$0
endsnippet

snippet rax_cbs_attachments "Manipulate Rackspace Cloud Block Storage Volume Attachments"
- name: $1
	rax_cbs_attachments:
		volume: ${2:# Name or id of the volume to attach/detach}
		device: ${3:# The device path to attach the volume to, e.g. /dev/xvde}
		server: ${4:# Name or id of the server to attach/detach}
		state: ${5:#present|absent}
		username: ${6:# Rackspace username, overrides I(credentials).}
		tenant_name: ${7:# The tenant name used for authentication.}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		wait_timeout: ${9:300}
		credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		wait: ${11:yes|#no}
		identity_type: ${12:rackspace}
		tenant_id: ${13:# The tenant ID used for authentication.}
		region: ${14:DFW}
		auth_endpoint: ${15:https://identity.api.rackspacecloud.com/v2.0/}
		env: ${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		api_key: ${17:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet rax_cdb "create/delete or resize a Rackspace Cloud Databases instance"
- name: $1
	rax_cdb:
		cdb_type: ${2:MySQL}
		username: ${3:# Rackspace username, overrides I(credentials).}
		name: ${4:# Name of the databases server instance}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		cdb_version: ${7:5.1|5.6|10}
		volume: ${8:2}
		state: ${9:#present|absent}
		wait_timeout: ${10:300}
		env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		flavor: ${13:1}
		api_key: ${14:# Rackspace API key, overrides I(credentials).}
		wait: ${15:yes|#no}
$0
endsnippet

snippet rax_cdb_database "create / delete a database in the Cloud Databases"
- name: $1
	rax_cdb_database:
		username: ${2:# Rackspace username, overrides I(credentials).}
		name: ${3:# Name to give to the database}
		cdb_id: ${4:# The databases server UUID}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		state: ${7:#present|absent}
		collate: ${8:utf8_general_ci}
		env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${11:# Rackspace API key, overrides I(credentials).}
		character_set: ${12:utf8}
$0
endsnippet

snippet rax_cdb_user "create / delete a Rackspace Cloud Database"
- name: $1
	rax_cdb_user:
		username: ${2:# Rackspace username, overrides I(credentials).}
		verify_ssl: ${3:# Whether or not to require SSL validation of API endpoints.}
		env: ${4:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		db_password: ${5:# Database user password}
		region: ${6:DFW}
		databases: ${7:[]}
		host: ${8:%}
		state: ${9:#present|absent}
		db_username: ${10:# Name of the database user}
		cdb_id: ${11:# The databases server UUID}
		credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${13:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet rax_clb "create / delete a load balancer in Rackspace Public Cloud"
- name: $1
	rax_clb:
		username: ${2:# Rackspace username, overrides I(credentials).}
		protocol: ${3:DNS_TCP|DNS_UDP|FTP|#HTTP|HTTPS|IMAPS|IMAPv4|LDAP|LDAPS|MYSQL|POP3|POP3S|SMTP|TCP|TCP_CLIENT_FIRST|UDP|UDP_STREAM|SFTP}
		name: ${4:# Name to give the load balancer}
		algorithm: ${5:RANDOM|#LEAST_CONNECTIONS|ROUND_ROBIN|WEIGHTED_LEAST_CONNECTIONS|WEIGHTED_ROUND_ROBIN}
		env: ${6:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		region: ${7:DFW}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		vip_id: ${9:# Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol}
		state: ${10:#present|absent}
		wait_timeout: ${11:300}
		meta: ${12:# A hash of metadata to associate with the instance}
		timeout: ${13:30}
		credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${15:# Rackspace API key, overrides I(credentials).}
		type: ${16:#PUBLIC|SERVICENET}
		port: ${17:80}
		wait: ${18:yes|#no}
$0
endsnippet

snippet rax_clb_nodes "add, modify and remove nodes from a Rackspace Cloud Load Balancer"
- name: $1
	rax_clb_nodes:
		load_balancer_id: ${2:# Load balancer id}
		username: ${3:# Rackspace username, overrides I(credentials).}
		weight: ${4:# Weight of node}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		state: ${7:#present|absent}
		wait_timeout: ${8:30}
		condition: ${9:enabled|disabled|draining}
		env: ${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		address: ${11:# IP address or domain name of the node}
		credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${13:# Rackspace API key, overrides I(credentials).}
		type: ${14:primary|secondary}
		port: ${15:# Port number of the load balanced service on the node}
		node_id: ${16:# Node id}
		wait: ${17:yes|#no}
$0
endsnippet

snippet rax_clb_ssl "Manage SSL termination for a Rackspace Cloud Load Balancer."
- name: $1
	rax_clb_ssl:
		loadbalancer: ${2:# Name or ID of the load balancer on which to manage SSL termination.}
		username: ${3:# Rackspace username, overrides I(credentials).}
		private_key: ${4:# The private SSL key as a string in PEM format.}
		certificate: ${5:# The public SSL certificates as a string in PEM format.}
		enabled: ${6:yes}
		region: ${7:DFW}
		https_redirect: ${8:# If "true", the load balancer will redirect HTTP traffic to HTTPS.}
		verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		state: ${10:#present|absent}
		wait_timeout: ${11:300}
		intermediate_certificate: ${12:# One or more intermediate certificate authorities as a string in PEM}
		secure_traffic_only: ${13:no}
		env: ${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		credentials: ${15:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		secure_port: ${16:443}
		api_key: ${17:# Rackspace API key, overrides I(credentials).}
		wait: ${18:no}
$0
endsnippet

snippet rax_dns "Manage domains on Rackspace Cloud DNS"
- name: $1
	rax_dns:
		comment: ${2:# Brief description of the domain. Maximum length of 160 characters}
		username: ${3:# Rackspace username, overrides I(credentials).}
		name: ${4:# Domain name to create}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		state: ${7:#present|absent}
		env: ${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		ttl: ${9:3600}
		credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${11:# Rackspace API key, overrides I(credentials).}
		email: ${12:# Email address of the domain administrator}
$0
endsnippet

snippet rax_dns_record "Manage DNS records on Rackspace Cloud DNS"
- name: $1
	rax_dns_record:
		name: ${2:# FQDN record name to create}
		data: ${3:# IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT}
		type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		comment: ${5:# Brief description of the domain. Maximum length of 160 characters}
		username: ${6:# Rackspace username, overrides I(credentials).}
		domain: ${7:# Domain name to create the record in. This is an invalid option when type=PTR}
		region: ${8:DFW}
		verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		server: ${10:# Server ID to create a PTR record for. Only used with type=PTR}
		priority: ${11:# Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.}
		state: ${12:#present|absent}
		loadbalancer: ${13:# Load Balancer ID to create a PTR record for. Only used with type=PTR}
		env: ${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		ttl: ${15:3600}
		credentials: ${16:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${17:# Rackspace API key, overrides I(credentials).}
		overwrite: ${18:yes}
$0
endsnippet

snippet rax_facts "Gather facts for Rackspace Cloud Servers"
- name: $1
	rax_facts:
		username: ${2:# Rackspace username, overrides I(credentials).}
		tenant_name: ${3:# The tenant name used for authentication.}
		name: ${4:# Server name to retrieve facts for}
		identity_type: ${5:rackspace}
		tenant_id: ${6:# The tenant ID used for authentication.}
		region: ${7:DFW}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		address: ${10:# Server IP address to retrieve facts for, will match any IP assigned to the server}
		credentials: ${11:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${12:# Rackspace API key, overrides I(credentials).}
		id: ${13:# Server ID to retrieve facts for}
		auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_files "Manipulate Rackspace Cloud Files Containers"
- name: $1
	rax_files:
		container: ${2:# The container to use for container or metadata operations.}
		username: ${3:# Rackspace username, overrides I(credentials).}
		web_index: ${4:# Sets an object to be presented as the HTTP index page when accessed by the CDN URL}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		private: ${7:# Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires}
		state: ${8:#present|absent}
		clear_meta: ${9:yes|#no}
		meta: ${10:# A hash of items to set as metadata values on a container}
		env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		ttl: ${12:# In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public}
		web_error: ${13:# Sets an object to be presented as the HTTP error page when accessed by the CDN URL}
		credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${15:# Rackspace API key, overrides I(credentials).}
		type: ${16:#file|meta}
		public: ${17:# Used to set a container as public, available via the Cloud Files CDN}
$0
endsnippet

snippet rax_files_objects "Upload, download, and delete objects in Rackspace Cloud Files"
- name: $1
	rax_files_objects:
		container: ${2:# The container to use for file object operations.}
		username: ${3:# Rackspace username, overrides I(credentials).}
		src: ${4:# Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17".  src and dest are mutually exclusive on remote-only object operations}
		dest: ${5:# The destination of a "get" operation; i.e. a local directory, "/home/user/myfolder". Used to specify the destination of an operation on a remote object; i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17"}
		region: ${6:DFW}
		expires: ${7:# Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		state: ${9:#present|absent}
		clear_meta: ${10:yes|#no}
		meta: ${11:# A hash of items to set as metadata values on an uploaded file or folder}
		env: ${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		credentials: ${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${14:# Rackspace API key, overrides I(credentials).}
		type: ${15:#file|meta}
		method: ${16:#get|put|delete}
		structure: ${17:True|no}
$0
endsnippet

snippet rax_identity "Load Rackspace Cloud Identity"
- name: $1
	rax_identity:
		username: ${2:# Rackspace username, overrides I(credentials).}
		identity_type: ${3:rackspace}
		tenant_id: ${4:# The tenant ID used for authentication.}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		state: ${7:#present|absent}
		env: ${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${9:# The tenant name used for authentication.}
		credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${11:# Rackspace API key, overrides I(credentials).}
		auth_endpoint: ${12:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_keypair "Create a keypair for use with Rackspace Cloud Servers"
- name: $1
	rax_keypair:
		name: ${2:# Name of keypair}
		username: ${3:# Rackspace username, overrides I(credentials).}
		public_key: ${4:# Public Key string to upload. Can be a file path or string}
		identity_type: ${5:rackspace}
		tenant_id: ${6:# The tenant ID used for authentication.}
		region: ${7:DFW}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		state: ${9:#present|absent}
		env: ${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${11:# The tenant name used for authentication.}
		credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${13:# Rackspace API key, overrides I(credentials).}
		auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_meta "Manipulate metadata for Rackspace Cloud Servers"
- name: $1
	rax_meta:
		username: ${2:# Rackspace username, overrides I(credentials).}
		tenant_name: ${3:# The tenant name used for authentication.}
		name: ${4:# Server name to modify metadata for}
		identity_type: ${5:rackspace}
		tenant_id: ${6:# The tenant ID used for authentication.}
		region: ${7:DFW}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		meta: ${9:# A hash of metadata to associate with the instance}
		env: ${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		address: ${11:# Server IP address to modify metadata for, will match any IP assigned to the server}
		credentials: ${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${13:# Rackspace API key, overrides I(credentials).}
		id: ${14:# Server ID to modify metadata for}
		auth_endpoint: ${15:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_alarm "Create or delete a Rackspace Cloud Monitoring alarm."
- name: $1
	rax_mon_alarm:
		entity_id: ${2:# ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.}
		notification_plan_id: ${3:# ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.}
		check_id: ${4:# ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.}
		label: ${5:# Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.}
		username: ${6:# Rackspace username, overrides I(credentials).}
		tenant_name: ${7:# The tenant name used for authentication.}
		tenant_id: ${8:# The tenant ID used for authentication.}
		region: ${9:DFW}
		auth_endpoint: ${10:https://identity.api.rackspacecloud.com/v2.0/}
		verify_ssl: ${11:# Whether or not to require SSL validation of API endpoints.}
		disabled: ${12:yes|no}
		identity_type: ${13:rackspace}
		state: ${14:#present|absent}
		env: ${15:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		criteria: ${16:# Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.}
		credentials: ${17:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${18:# Rackspace API key, overrides I(credentials).}
		metadata: ${19:# Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.}
$0
endsnippet

snippet rax_mon_check "Create or delete a Rackspace Cloud Monitoring check for an existing entity."
- name: $1
	rax_mon_check:
		entity_id: ${2:# ID of the rax_mon_entity to target with this check.}
		check_type: ${3:remote.dns|remote.ftp-banner|remote.http|remote.imap-banner|remote.mssql-banner|remote.mysql-banner|remote.ping|remote.pop3-banner|remote.postgresql-banner|remote.smtp-banner|remote.smtp|remote.ssh|remote.tcp|remote.telnet-banner|agent.filesystem|agent.memory|agent.load_average|agent.cpu|agent.disk|agent.network|agent.plugin}
		label: ${4:# Defines a label for this check, between 1 and 64 characters long.}
		username: ${5:# Rackspace username, overrides I(credentials).}
		tenant_name: ${6:# The tenant name used for authentication.}
		period: ${7:# The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.}
		disabled: ${8:yes|no}
		target_hostname: ${9:# One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.}
		credentials: ${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		auth_endpoint: ${11:https://identity.api.rackspacecloud.com/v2.0/}
		target_alias: ${12:# One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.}
		env: ${13:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		identity_type: ${14:rackspace}
		tenant_id: ${15:# The tenant ID used for authentication.}
		region: ${16:DFW}
		verify_ssl: ${17:# Whether or not to require SSL validation of API endpoints.}
		state: ${18:present|absent}
		details: ${19:# Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.}
		timeout: ${20:# The number of seconds this check will wait when attempting to collect results. Must be less than the period.}
		monitoring_zones_poll: ${21:# Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.}
		api_key: ${22:# Rackspace API key, overrides I(credentials).}
		metadata: ${23:# Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.}
$0
endsnippet

snippet rax_mon_entity "Create or delete a Rackspace Cloud Monitoring entity"
- name: $1
	rax_mon_entity:
		label: ${2:# Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.}
		username: ${3:# Rackspace username, overrides I(credentials).}
		identity_type: ${4:rackspace}
		tenant_id: ${5:# The tenant ID used for authentication.}
		region: ${6:DFW}
		auth_endpoint: ${7:https://identity.api.rackspacecloud.com/v2.0/}
		verify_ssl: ${8:# Whether or not to require SSL validation of API endpoints.}
		state: ${9:present|absent}
		agent_id: ${10:# Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.}
		env: ${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${12:# The tenant name used for authentication.}
		credentials: ${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${14:# Rackspace API key, overrides I(credentials).}
		named_ip_addresses: ${15:# Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.}
		metadata: ${16:# Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.}
$0
endsnippet

snippet rax_mon_notification "Create or delete a Rackspace Cloud Monitoring notification."
- name: $1
	rax_mon_notification:
		label: ${2:# Defines a friendly name for this notification. String between 1 and 255 characters long.}
		details: ${3:# Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.}
		notification_type: ${4:webhook|email|pagerduty}
		username: ${5:# Rackspace username, overrides I(credentials).}
		credentials: ${6:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		identity_type: ${7:rackspace}
		tenant_id: ${8:# The tenant ID used for authentication.}
		region: ${9:DFW}
		verify_ssl: ${10:# Whether or not to require SSL validation of API endpoints.}
		state: ${11:present|absent}
		env: ${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${13:# The tenant name used for authentication.}
		api_key: ${14:# Rackspace API key, overrides I(credentials).}
		auth_endpoint: ${15:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_mon_notification_plan "Create or delete a Rackspace Cloud Monitoring notification plan."
- name: $1
	rax_mon_notification_plan:
		label: ${2:# Defines a friendly name for this notification plan. String between 1 and 255 characters long.}
		username: ${3:# Rackspace username, overrides I(credentials).}
		warning_state: ${4:# Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.}
		identity_type: ${5:rackspace}
		tenant_id: ${6:# The tenant ID used for authentication.}
		region: ${7:DFW}
		critical_state: ${8:# Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.}
		verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		ok_state: ${10:# Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.}
		state: ${11:present|absent}
		env: ${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${13:# The tenant name used for authentication.}
		credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${15:# Rackspace API key, overrides I(credentials).}
		auth_endpoint: ${16:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_network "create / delete an isolated network in Rackspace Public Cloud"
- name: $1
	rax_network:
		username: ${2:# Rackspace username, overrides I(credentials).}
		identity_type: ${3:rackspace}
		tenant_id: ${4:# The tenant ID used for authentication.}
		region: ${5:DFW}
		verify_ssl: ${6:# Whether or not to require SSL validation of API endpoints.}
		label: ${7:# Label (name) to give the network}
		state: ${8:#present|absent}
		env: ${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		tenant_name: ${10:# The tenant name used for authentication.}
		credentials: ${11:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		cidr: ${12:# cidr of the network being created}
		api_key: ${13:# Rackspace API key, overrides I(credentials).}
		auth_endpoint: ${14:https://identity.api.rackspacecloud.com/v2.0/}
$0
endsnippet

snippet rax_queue "create / delete a queue in Rackspace Public Cloud"
- name: $1
	rax_queue:
		username: ${2:# Rackspace username, overrides I(credentials).}
		name: ${3:# Name to give the queue}
		region: ${4:DFW}
		verify_ssl: ${5:# Whether or not to require SSL validation of API endpoints.}
		state: ${6:#present|absent}
		env: ${7:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		credentials: ${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${9:# Rackspace API key, overrides I(credentials).}
$0
endsnippet

snippet rax_scaling_group "Manipulate Rackspace Cloud Autoscale Groups"
- name: $1
	rax_scaling_group:
		image: ${2:# image to use for the instance. Can be an C(id), C(human_id) or C(name)}
		min_entities: ${3:# The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		flavor: ${4:# flavor to use for the instance}
		max_entities: ${5:# The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		name: ${6:# Name to give the scaling group}
		server_name: ${7:# The base name for servers created by Autoscale}
		files: ${8:# Files to insert into the instance. Hash of C(remotepath: localpath)}
		username: ${9:# Rackspace username, overrides I(credentials).}
		key_name: ${10:# key pair to use on the instance}
		user_data: ${11:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
		verify_ssl: ${12:# Whether or not to require SSL validation of API endpoints.}
		cooldown: ${13:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
		credentials: ${14:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		networks: ${15:[u'public', u'private']}
		wait: ${16:yes|#no}
		loadbalancers: ${17:# List of load balancer C(id) and C(port) hashes}
		wait_timeout: ${18:300}
		disk_config: ${19:#auto|manual}
		state: ${20:#present|absent}
		meta: ${21:# A hash of metadata to associate with the instance}
		env: ${22:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		api_key: ${23:# Rackspace API key, overrides I(credentials).}
		region: ${24:DFW}
		config_drive: ${25:yes|no}
$0
endsnippet

snippet rax_scaling_policy "Manipulate Rackspace Cloud Autoscale Scaling Policy"
- name: $1
	rax_scaling_policy:
		name: ${2:# Name to give the policy}
		scaling_group: ${3:# Name of the scaling group that this policy will be added to}
		policy_type: ${4:webhook|schedule}
		username: ${5:# Rackspace username, overrides I(credentials).}
		is_percent: ${6:no}
		env: ${7:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
		region: ${8:DFW}
		verify_ssl: ${9:# Whether or not to require SSL validation of API endpoints.}
		cron: ${10:# The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)}
		desired_capacity: ${11:# The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.}
		state: ${12:#present|absent}
		cooldown: ${13:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
		at: ${14:# The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)}
		credentials: ${15:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
		api_key: ${16:# Rackspace API key, overrides I(credentials).}
		change: ${17:# The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.}
$0
endsnippet

snippet imgadm "Manage SmartOS images"
- name: $1
	imgadm:
		state: ${2:present|absent|deleted|imported|updated|vacuumed}
		source: ${3:# URI for the image source.}
		force: ${4:True|False}
		uuid: ${5:# Image UUID. Can either be a full UUID or C(*) for all images.}
		type: ${6:#imgapi|docker|dsapi}
		pool: ${7:zones}
$0
endsnippet

snippet smartos_image_facts "Get SmartOS image details."
- name: $1
	smartos_image_facts:
		filters: ${2:# Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.}
$0
endsnippet

snippet vmadm "Manage SmartOS virtual machines and zones."
- name: $1
	vmadm:
		state: ${2:present|absent|stopped|restarted}
		brand: ${3:#joyent|joyent-minimal|kvm|lx}
		customer_metadata: ${4:# Metadata to be set and associated with this VM, this contain customer modifiable keys.}
		disk_driver: ${5:# Default value for a virtual disk model for KVM guests.}
		force: ${6:# Force a particular action (i.e. stop or delete a VM).}
		zfs_root_compression: ${7:# Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.}
		virtio_txtimer: ${8:# Timeout (in nanoseconds) for the TX timer of virtio NICs.}
		spice_password: ${9:# Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.}
		zfs_io_priority: ${10:# IO throttle priority value relative to other VMs.}
		ram: ${11:# Amount of virtual RAM for a KVM guest (in MiBs).}
		dns_domain: ${12:# Domain value for C(/etc/hosts).}
		max_physical_memory: ${13:# Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.}
		nic_driver: ${14:# Default value for a virtual NIC model for KVM guests.}
		zfs_data_compression: ${15:# Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.}
		image_uuid: ${16:# Image UUID.}
		fs_allowed: ${17:# Comma separated list of filesystem types this zone is allowed to mount.}
		indestructible_delegated: ${18:# Adds an C(@indestructible) snapshot to delegated datasets.}
		qemu_opts: ${19:# Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.}
		delegate_dataset: ${20:# Whether to delegate a ZFS dataset to an OS VM.}
		firewall_enabled: ${21:# Enables the firewall, allowing fwadm(1M) rules to be applied.}
		mdata_exec_timeout: ${22:# Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.}
		archive_on_delete: ${23:# When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.}
		nics: ${24:# A list of nics to add, valid properties are documented in vmadm(1M).}
		hostname: ${25:# Zone/VM hostname.}
		boot: ${26:# Set the boot order for KVM VMs.}
		vga: ${27:# Specify VGA emulation used by KVM VMs.}
		zfs_snapshot_limit: ${28:# Number of snapshots the VM can have.}
		limit_priv: ${29:# Set (comma separated) list of privileges the zone is allowed to use.}
		cpu_cap: ${30:# Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.}
		maintain_resolvers: ${31:# Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.}
		indestructible_zoneroot: ${32:# Adds an C(@indestructible) snapshot to zoneroot.}
		vnc_password: ${33:# Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.}
		vcpus: ${34:# Number of virtual CPUs for a KVM guest.}
		disks: ${35:# A list of disks to add, valid properties are documented in vmadm(1M).}
		max_swap: ${36:# Maximum amount of virtual memory (in MiBs) the VM is allowed to use.}
		zfs_root_recsize: ${37:# Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.}
		zfs_filesystem_limit: ${38:# Maximum number of filesystems the VM can have.}
		quota: ${39:# Quota on zone filesystems (in MiBs).}
		filesystems: ${40:# Mount additional filesystems into an OS VM.}
		autoboot: ${41:# Whether or not a VM is booted when the system is rebooted.}
		tmpfs: ${42:# Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.}
		qemu_extra_opts: ${43:# Additional qemu cmdline arguments for KVM guests.}
		resolvers: ${44:# List of resolvers to be put into C(/etc/resolv.conf).}
		max_lwps: ${45:# Maximum number of lightweight processes this VM is allowed to have running.}
		nowait: ${46:# Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.}
		name: ${47:# Name of the VM. vmadm(1M) uses this as an optional name.}
		kernel_version: ${48:# Kernel version to emulate for LX VMs.}
		max_locked_memory: ${49:# Total amount of memory (in MiBs) on the host that can be locked by this VM.}
		vnc_port: ${50:# TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.}
		uuid: ${51:# UUID of the VM. Can either be a full UUID or C(*) for all VMs.}
		internal_metadata_namespace: ${52:# List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata).}
		virtio_txburst: ${53:# Number of packets that can be sent in a single flush of the tx queue of virtio NICs.}
		spice_opts: ${54:# Addition options for SPICE-enabled KVM VMs.}
		zfs_data_recsize: ${55:# Suggested block size (power of 2) for files in the delegated dataset's filesystem.}
		internal_metadata: ${56:# Metadata to be set and associated with this VM, this contains operator generated keys.}
		cpu_type: ${57:#qemu64|host}
		routes: ${58:# Dictionary that maps destinations to gateways, these will be set as static routes in the VM.}
		zpool: ${59:# ZFS pool the VM's zone dataset will be created in.}
		cpu_shares: ${60:# Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.}
$0
endsnippet

snippet sl_vm "create or cancel a virtual instance in SoftLayer"
- name: $1
	sl_vm:
		disks: ${2:[25]}
		cpus: ${3:# Count of cpus to be assigned to new virtual instance}
		memory: ${4:# Amount of memory to be assigned to new virtual instance}
		domain: ${5:# Domain name to be provided to a virtual instance}
		tags: ${6:# Tag or list of tags to be provided to a virtual instance}
		dedicated: ${7:no}
		private: ${8:no}
		image_id: ${9:# Image Template to be used for new virtual instance}
		nic_speed: ${10:10}
		private_vlan: ${11:# VLAN by its Id to be assigned to the private NIC}
		datacenter: ${12:# Datacenter for the virtual instance to be deployed}
		public_vlan: ${13:# VLAN by its Id to be assigned to the public NIC}
		wait: ${14:yes}
		hourly: ${15:yes}
		ssh_keys: ${16:# List of ssh keys by their Id to be assigned to a virtual instance}
		hostname: ${17:# Hostname to be provided to a virtual instance}
		os_code: ${18:# OS Code to be used for new virtual instance}
		instance_id: ${19:# Instance Id of the virtual instance to perform action option}
		local_disk: ${20:yes}
		state: ${21:present}
		wait_timeout: ${22:600}
		post_uri: ${23:# URL of a post provisioning script to be loaded and executed on virtual instance}
$0
endsnippet

snippet udm_dns_record "Manage dns entries on a univention corporate server"
- name: $1
	udm_dns_record:
		type: ${2:host_record|alias|ptr_record|srv_record|txt_record}
		name: ${3:# Name of the record, this is also the DNS record. E.g. www for www.example.com.}
		zone: ${4:# Corresponding DNS zone for this record, e.g. example.com.}
		state: ${5:#present|absent}
		data: ${6:[]}
$0
endsnippet

snippet udm_dns_zone "Manage dns zones on a univention corporate server"
- name: $1
	udm_dns_zone:
		zone: ${2:# DNS zone name, e.g. C(example.com).}
		type: ${3:forward_zone|reverse_zone}
		retry: ${4:1800}
		interfaces: ${5:# List of interface IP addresses, on which the server should response this zone. Required if C(state=present).}
		refresh: ${6:3600}
		state: ${7:#present|absent}
		contact: ${8:}
		expire: ${9:604800}
		ttl: ${10:600}
		nameserver: ${11:# List of appropriate name servers. Required if C(state=present).}
		mx: ${12:[]}
$0
endsnippet

snippet udm_group "Manage of the posix group"
- name: $1
	udm_group:
		name: ${2:# Name of the posix group.}
		state: ${3:#present|absent}
		position: ${4:# define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).}
		ou: ${5:# LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).}
		subpath: ${6:# Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).}
		description: ${7:# Group description.}
$0
endsnippet

snippet udm_share "Manage samba shares on a univention corporate server"
- name: $1
	udm_share:
		name: ${2:# Name}
		ou: ${3:# Organisational unit, inside the LDAP Base DN.}
		samba_name: ${4:# Windows name. Required if C(state=present).}
		samba_hide_files: ${5:# Hide files.}
		samba_blocking_locks: ${6:0|#1}
		samba_directory_mode: ${7:0755}
		samba_dos_filemode: ${8:#0|1}
		samba_postexec: ${9:# Postexec script.}
		owner: ${10:0}
		samba_fake_oplocks: ${11:#0|1}
		samba_strict_locking: ${12:Auto}
		samba_public: ${13:#0|1}
		samba_force_directory_security_mode: ${14:#0|1}
		group: ${15:0}
		samba_writeable: ${16:0|#1}
		samba_nt_acl_support: ${17:0|#1}
		samba_write_list: ${18:# Restrict write access to these users/groups.}
		samba_preexec: ${19:# Preexec script.}
		samba_browseable: ${20:0|#1}
		samba_inherit_acls: ${21:0|#1}
		samba_msdfs_root: ${22:#0|1}
		state: ${23:#present|absent}
		samba_valid_users: ${24:# Valid users or groups.}
		samba_force_create_mode: ${25:#0|1}
		root_squash: ${26:0|#1}
		samba_directory_security_mode: ${27:0777}
		samba_force_group: ${28:# Force group.}
		samba_vfs_objects: ${29:# VFS objects.}
		samba_force_directory_mode: ${30:#0|1}
		writeable: ${31:0|#1}
		samba_locking: ${32:0|#1}
		samba_security_mode: ${33:0777}
		samba_inherit_owner: ${34:#0|1}
		samba_csc_policy: ${35:manual}
		sync: ${36:sync}
		nfs_hosts: ${37:[]}
		path: ${38:# Directory on the providing server, e.g. C(/home). Required if C(state=present).}
		nfs_custom_settings: ${39:[]}
		samba_force_user: ${40:# Force user.}
		samba_invalid_users: ${41:# Invalid users or groups.}
		samba_create_mode: ${42:0744}
		samba_force_security_mode: ${43:#0|1}
		samba_level_2_oplocks: ${44:0|#1}
		samba_custom_settings: ${45:[]}
		samba_hide_unreadable: ${46:#0|1}
		host: ${47:# Host FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present).}
		samba_block_size: ${48:# Blocking size.}
		samba_oplocks: ${49:0|#1}
		samba_hosts_allow: ${50:[]}
		samba_inherit_permissions: ${51:#0|1}
		subtree_checking: ${52:0|#1}
		directorymode: ${53:00755}
		samba_hosts_deny: ${54:[]}
$0
endsnippet

snippet udm_user "Manage posix users on a univention corporate server"
- name: $1
	udm_user:
		username: ${2:# User name}
		update_password: ${3:always}
		samba_user_workstations: ${4:[]}
		homedrive: ${5:# Windows home drive, e.g. C("H:").}
		room_number: ${6:# Room number of users business address.}
		primary_group: ${7:cn=Domain Users,cn=groups,$LDAP_BASE_DN}
		postcode: ${8:# Postal code of users business address.}
		scriptpath: ${9:# Windows logon script.}
		home_share: ${10:# Home NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com).}
		override_pw_history: ${11:no}
		city: ${12:# City of users business address.}
		display_name: ${13:# Display name (not gecos)}
		pager_telephonenumber: ${14:[]}
		employee_number: ${15:# Employee number}
		serviceprovider: ${16:[u'']}
		organisation: ${17:# Organisation}
		subpath: ${18:cn=users}
		state: ${19:#present|absent}
		home_share_path: ${20:# Path to home NFS share, inside the homeShare.}
		userexpiry: ${21:Today + 1 year}
		unixhome: ${22:/home/$USERNAME}
		mail_home_server: ${23:# FQDN of mail server}
		email: ${24:[u'']}
		sambahome: ${25:# Windows home path, e.g. C('\\$FQDN\$USERNAME').}
		home_telephone_number: ${26:[]}
		shell: ${27:/bin/bash}
		description: ${28:# Description (not gecos)}
		firstname: ${29:# First name. Required if C(state=present).}
		lastname: ${30:# Last name. Required if C(state=present).}
		mail_alternative_address: ${31:[]}
		phone: ${32:[]}
		birthday: ${33:# Birthday}
		groups: ${34:[]}
		profilepath: ${35:# Windows profile directory}
		employee_type: ${36:# Employee type}
		password: ${37:# Password. Required if C(state=present).}
		pwd_change_next_login: ${38:0|1}
		mail_primary_address: ${39:# Primary e-mail address}
		country: ${40:# Country of users business address.}
		title: ${41:# Title, e.g. C(Prof.).}
		override_pw_length: ${42:no}
		street: ${43:# Street of users business address.}
		gecos: ${44:# GECOS}
		mobile_telephone_number: ${45:[]}
		position: ${46:}
		ou: ${47:}
		department_number: ${48:# Department number of users business address.}
		samba_privileges: ${49:[]}
		secretary: ${50:[]}
$0
endsnippet

snippet vca_fw "add remove firewall rules in a gateway  in a vca"
- name: $1
	vca_fw:
		fw_rules: ${2:no}
		username: ${3:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
		gateway_name: ${4:gateway}
		state: ${5:#present|absent}
		instance_id: ${6:# The instance id in a vchs environment to be used for creating the vapp.}
		host: ${7:# The authentication host to be used when service type is vcd.}
		service_type: ${8:#vca|vchs|vcd}
		org: ${9:# The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).}
		password: ${10:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
		vdc_name: ${11:# The name of the vdc where the gateway is located.}
		api_version: ${12:5.7}
		verify_certs: ${13:yes}
$0
endsnippet

snippet vca_nat "add remove nat rules in a gateway  in a vca"
- name: $1
	vca_nat:
		nat_rules: ${2:no}
		username: ${3:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
		purge_rules: ${4:no}
		state: ${5:#present|absent}
		instance_id: ${6:# The instance id in a vchs environment to be used for creating the vapp.}
		host: ${7:# The authentication host to be used when service type is vcd.}
		org: ${8:# The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).}
		service_type: ${9:#vca|vchs|vcd}
		gateway_name: ${10:gateway}
		password: ${11:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
		vdc_name: ${12:# The name of the vdc where the gateway is located.}
		api_version: ${13:5.7}
		verify_certs: ${14:yes}
$0
endsnippet

snippet vca_vapp "Manages vCloud Air vApp instances."
- name: $1
	vca_vapp:
		vapp_name: ${2:# The name of the vCloud Air vApp instance}
		vm_name: ${3:# The name of the virtual machine instance in the vApp to manage.}
		username: ${4:# The vCloud Air username to use during authentication}
		vm_memory: ${5:# The amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp.}
		template_name: ${6:# The name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)}
		network_mode: ${7:#pool|dhcp|static}
		org: ${8:# The org to login to for creating vapp, mostly set when the service_type is vdc.}
		operation: ${9:#noop|poweron|poweroff|suspend|shutdown|reboot|reset}
		password: ${10:# The vCloud Air password to use during authentication}
		vm_cpus: ${11:# The number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.}
		vdc_name: ${12:# The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.}
		network_name: ${13:# The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided.}
		host: ${14:# The authentication host to be used when service type  is vcd.}
		instance_id: ${15:# The instance id in a vchs environment to be used for creating the vapp}
		state: ${16:#present|absent|deployed|undeployed}
		service_type: ${17:#vca|vchs|vcd}
		api_version: ${18:5.7}
$0
endsnippet

snippet vmware_cluster "Create VMware vSphere Cluster"
- name: $1
	vmware_cluster:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		cluster_name: ${5:# The name of the cluster that will be created}
		password: ${6:# The password of the vSphere vCenter.}
		enable_ha: ${7:no}
		enable_vsan: ${8:no}
		enable_drs: ${9:no}
		validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters"
- name: $1
	vmware_datacenter:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		state: ${6:#present|absent}
		validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration"
- name: $1
	vmware_dns_config:
		username: ${2:# The username of the vSphere vCenter.}
		dns_servers: ${3:# The DNS servers that the host should be configured to use.}
		domainname: ${4:# The domain the ESXi host should be apart of.}
		change_hostname_to: ${5:# The hostname that an ESXi host should be changed to.}
		password: ${6:# The password of the vSphere vCenter.}
		hostname: ${7:# The hostname or IP address of the vSphere vCenter.}
		validate_certs: ${8:#True|False}
$0
endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch"
- name: $1
	vmware_dvs_host:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		state: ${4:present|absent}
		esxi_hostname: ${5:# The ESXi hostname}
		password: ${6:# The password of the vSphere vCenter.}
		vmnics: ${7:# The ESXi hosts vmnics to use with the Distributed vSwitch}
		switch_name: ${8:# The name of the Distributed vSwitch}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup"
- name: $1
	vmware_dvs_portgroup:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# The name of the portgroup that is to be created or deleted}
		password: ${4:# The password of the vSphere vCenter.}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		num_ports: ${6:# The number of ports the portgroup should contain}
		portgroup_type: ${7:earlyBinding|lateBinding|ephemeral}
		switch_name: ${8:# The name of the distributed vSwitch the port group should be created on.}
		vlan_id: ${9:# The VLAN ID that should be configured with the portgroup}
		validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_dvswitch "Create or remove a distributed vSwitch"
- name: $1
	vmware_dvswitch:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		datacenter_name: ${4:# The name of the datacenter that will contain the dvSwitch}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		discovery_proto: ${6:cdp|lldp}
		mtu: ${7:# The switch maximum transmission unit}
		switch_name: ${8:# The name of the switch to create or remove}
		uplink_quantity: ${9:# Quantity of uplink per ESXi host added to the switch}
		state: ${10:#present|absent}
		discovery_operation: ${11:both|none|advertise|listen}
		validate_certs: ${12:#True|False}
$0
endsnippet

snippet vmware_guest "Manages virtual machines in vcenter"
- name: $1
	vmware_guest:
		username: ${2:# The username of the vSphere vCenter.}
		name: ${3:# Name of the VM to work with}
		password: ${4:# The password of the vSphere vCenter.}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		state: ${6:present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest}
		resource_pool: ${7:# Affect machine to the given resource pool}
		force: ${8:# Ignore warnings and complete the actions}
		template: ${9:# Template used to create VM.}
		guest_id: ${10:# Set the guest ID (Debian, RHEL, Windows...)}
		cluster: ${11:# The cluster name where the VM will run.}
		hardware: ${12:# Manage some VM hardware attributes.}
		name_match: ${13:#first|last}
		customization: ${14:# Parameters to customize template}
		disk: ${15:# A list of disks to add}
		networks: ${16:# Network to use should include C(name) or C(vlan) entry}
		wait_for_ip_address: ${17:no}
		datacenter: ${18:ha-datacenter}
		uuid: ${19:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		customvalues: ${20:# Define a list of customvalues to set on VM.}
		annotation: ${21:# A note or annotation to include in the VM}
		is_template: ${22:no}
		esxi_hostname: ${23:# The esxi hostname where the VM will run.}
		folder: ${24:# Destination folder, absolute path to find an existing guest or create the new guest}
		validate_certs: ${25:#True|False}
$0
endsnippet

snippet vmware_guest_facts "Gather facts about a single VM"
- name: $1
	vmware_guest_facts:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter: ${3:# Destination datacenter for the deploy operation}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		name: ${6:# Name of the VM to work with}
		uuid: ${7:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		name_match: ${8:#first|last}
		folder: ${9:# Destination folder, absolute path to find an existing guest.}
		validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vcenter"
- name: $1
	vmware_guest_snapshot:
		username: ${2:# The username of the vSphere vCenter.}
		datacenter: ${3:# Destination datacenter for the deploy operation}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		name: ${5:# Name of the VM to work with}
		state: ${6:present|absent|revert|remove_all}
		password: ${7:# The password of the vSphere vCenter.}
		uuid: ${8:# UUID of the instance to manage if known, this is VMware's unique identifier.}
		snapshot_name: ${9:# Sets the snapshot name to manage.}
		name_match: ${10:#first|last}
		folder: ${11:# Define instance folder location.}
		validate_certs: ${12:#True|False}
		description: ${13:# Define an arbitrary description to attach to snapshot.}
$0
endsnippet

snippet vmware_host "Add/remove ESXi host to/from vCenter"
- name: $1
	vmware_host:
		cluster_name: ${2:# Name of the cluster to add the host}
		username: ${3:# The username of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		datacenter_name: ${5:# Name of the datacenter to add the host}
		esxi_hostname: ${6:# ESXi hostname to manage}
		esxi_password: ${7:# ESXi password}
		password: ${8:# The password of the vSphere vCenter.}
		esxi_username: ${9:# ESXi username}
		state: ${10:#present|absent}
		validate_certs: ${11:#True|False}
$0
endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host"
- name: $1
	vmware_local_user_manager:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		password: ${4:# The password of the vSphere vCenter.}
		local_user_name: ${5:# The local user name to be changed}
		local_user_description: ${6:# Description for the user}
		local_user_password: ${7:# The password to be set}
		state: ${8:#present|absent}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode"
- name: $1
	vmware_maintenancemode:
		username: ${2:# The username of the vSphere vCenter.}
		hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
		esxi_hostname: ${4:# Name of the host as defined in vCenter}
		password: ${5:# The password of the vSphere vCenter.}
		timeout: ${6:0}
		evacuate: ${7:True|#False}
		vsan_mode: ${8:ensureObjectAccessibility|evacuateAllData|noAction}
		state: ${9:#present|absent}
		validate_certs: ${10:#True|False}
$0
endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS"
- name: $1
	vmware_migrate_vmk:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		current_switch_name: ${4:# Switch VMK interface is currently on}
		migrate_portgroup_name: ${5:# Portgroup name to migrate VMK interface to}
		esxi_hostname: ${6:# ESXi hostname to be managed}
		device: ${7:# VMK interface name}
		migrate_switch_name: ${8:# Switch name to migrate VMK interface to}
		current_portgroup_name: ${9:# Portgroup name VMK interface is currently on}
		hostname: ${10:# The hostname or IP address of the vSphere vCenter.}
		validate_certs: ${11:#True|False}
$0
endsnippet

snippet vmware_portgroup "Create a VMware portgroup"
- name: $1
	vmware_portgroup:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# Portgroup name to add}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		switch_name: ${6:# vSwitch to modify}
		vlan_id: ${7:# VLAN ID to assign to portgroup}
		network_policy: ${8:# Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits. Settings are promiscuous_mode, forged_transmits, mac_changes}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet vmware_target_canonical_facts "Return canonical (NAA) from an ESXi host"
- name: $1
	vmware_target_canonical_facts:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		target_id: ${4:# The target id based on order of scsi device}
		hostname: ${5:# The hostname or IP address of the vSphere vCenter.}
		validate_certs: ${6:#True|False}
$0
endsnippet

snippet vmware_vm_facts "Return basic facts pertaining to a vSphere virtual machine guest"
- name: $1
	vmware_vm_facts:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		validate_certs: ${5:#True|False}
$0
endsnippet

snippet vmware_vm_shell "Execute a process in VM"
- name: $1
	vmware_vm_shell:
		username: ${2:# The username of the vSphere vCenter.}
		vm_shell: ${3:# The absolute path to the program to start. On Linux this is executed via bash.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		vm_id: ${6:# The identification for the VM}
		datacenter: ${7:# The datacenter hosting the VM}
		vm_password: ${8:# The password used to login to the VM.}
		vm_shell_cwd: ${9:# The current working directory of the application from which it will be run}
		vm_shell_args: ${10:# The argument to the program.}
		vm_username: ${11:# The user to connect to the VM.}
		vm_shell_env: ${12:# Comma separated list of envirnoment variable, specified in the guest OS notation}
		cluster: ${13:# The cluster hosting the VM}
		vm_id_type: ${14:uuid|dns_name|inventory_path|#vm_name}
		validate_certs: ${15:#True|False}
$0
endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed"
- name: $1
	vmware_vm_vss_dvs_migrate:
		vm_name: ${2:# Name of the virtual machine to migrate to a dvSwitch}
		username: ${3:# The username of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		dvportgroup_name: ${5:# Name of the portgroup to migrate to the virtual machine to}
		password: ${6:# The password of the vSphere vCenter.}
		validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_vmkernel "Create a VMware VMkernel Interface"
- name: $1
	vmware_vmkernel:
		username: ${2:# The username of the vSphere vCenter.}
		portgroup_name: ${3:# The name of the portgroup for the VMK interface}
		vland_id: ${4:# The VLAN ID for the VMK interface}
		subnet_mask: ${5:# The Subnet Mask for the VMK interface}
		vswitch_name: ${6:# The name of the vswitch where to add the VMK interface}
		hostname: ${7:# The hostname or IP address of the vSphere vCenter.}
		password: ${8:# The password of the vSphere vCenter.}
		ip_address: ${9:# The IP Address for the VMK interface}
		enable_vmotion: ${10:# Enable the VMK interface for vMotion traffic}
		validate_certs: ${11:#True|False}
		mtu: ${12:# The MTU for the VMK interface}
		enable_mgmt: ${13:# Enable the VMK interface for Management traffic}
		enable_vsan: ${14:# Enable the VMK interface for VSAN traffic}
		enable_ft: ${15:# Enable the VMK interface for Fault Tolerance traffic}
$0
endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address"
- name: $1
	vmware_vmkernel_ip_config:
		username: ${2:# The username of the vSphere vCenter.}
		subnet_mask: ${3:# Subnet Mask to assign to VMkernel interface}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		vmk_name: ${5:# VMkernel interface name}
		password: ${6:# The password of the vSphere vCenter.}
		ip_address: ${7:# IP address to assign to VMkernel interface}
		validate_certs: ${8:#True|False}
$0
endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion"
- name: $1
	vmware_vmotion:
		vm_name: ${2:# Name of the VM to perform a vMotion on}
		username: ${3:# The username of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		password: ${5:# The password of the vSphere vCenter.}
		destination_host: ${6:# Name of the end host the VM should be running on}
		validate_certs: ${7:#True|False}
$0
endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host"
- name: $1
	vmware_vsan_cluster:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		cluster_uuid: ${5:# Desired cluster UUID}
		validate_certs: ${6:#True|False}
$0
endsnippet

snippet vmware_vswitch "Add a VMware Standard Switch to an ESXi host"
- name: $1
	vmware_vswitch:
		username: ${2:# The username of the vSphere vCenter.}
		password: ${3:# The password of the vSphere vCenter.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
		nic_name: ${5:# vmnic name to attach to vswitch}
		switch_name: ${6:# vSwitch name to add}
		mtu: ${7:# MTU to configure on vswitch}
		state: ${8:#present|absent}
		number_of_ports: ${9:128}
		validate_certs: ${10:#True|False}
$0
endsnippet

snippet vsphere_copy "Copy a file to a vCenter datastore"
- name: $1
	vsphere_copy:
		src: ${2:# The file to push to vCenter}
		datacenter: ${3:# The datacenter on the vCenter server that holds the datastore.}
		host: ${4:# The vCenter server on which the datastore is available.}
		path: ${5:# The file to push to the datastore on the vCenter server.}
		login: ${6:# The login name to authenticate on the vCenter server.}
		password: ${7:# The password to authenticate on the vCenter server.}
		datastore: ${8:# The datastore on the vCenter server to push files to.}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet vsphere_guest "Create/delete/manage a guest VM through VMware vSphere."
- name: $1
	vsphere_guest:
		username: ${2:# Username to connect to vcenter as.}
		vcenter_hostname: ${3:# The hostname of the vcenter server the module will connect to, to create the guest.}
		password: ${4:# Password of the user to connect to vcenter as.}
		guest: ${5:# The virtual server name you wish to manage.}
		resource_pool: ${6:# The name of the resource_pool to create the VM in.}
		force: ${7:yes|#no}
		vm_disk: ${8:# A key, value list of disks and their sizes and which datastore to keep it in.}
		vm_hw_version: ${9:# Desired hardware version identifier (for example, "vmx-08" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported.}
		cluster: ${10:# The name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on.}
		vmware_guest_facts: ${11:# Gather facts from vCenter on a particular VM}
		vm_extra_config: ${12:# A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM.}
		template_src: ${13:# Name of the source template to deploy from}
		power_on_after_clone: ${14:yes|no}
		vm_nic: ${15:# A key, value list of nics, their types and what network to put them on.}
		esxi: ${16:# Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha-datacenter should be used as the datacenter name}
		vm_hardware: ${17:# A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi'].}
		validate_certs: ${18:yes|no}
		state: ${19:#present|powered_off|absent|powered_on|restarted|reconfigured}
		from_template: ${20:yes|no}
		snapshot_to_clone: ${21:none}
$0
endsnippet

snippet webfaction_app "Add or remove applications on a Webfaction host"
- name: $1
	webfaction_app:
		name: ${2:# The name of the application}
		login_password: ${3:# The webfaction password to use}
		type: ${4:# The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list.}
		login_name: ${5:# The webfaction account to use}
		port_open: ${6:no}
		machine: ${7:# The machine name to use (optional for accounts with only one machine)}
		state: ${8:#present|absent}
		autostart: ${9:no}
		extra_info: ${10:# Any extra parameters required by the app}
$0
endsnippet

snippet webfaction_db "Add or remove a database on Webfaction"
- name: $1
	webfaction_db:
		name: ${2:# The name of the database}
		login_password: ${3:# The webfaction password to use}
		type: ${4:mysql|postgresql}
		login_name: ${5:# The webfaction account to use}
		machine: ${6:# The machine name to use (optional for accounts with only one machine)}
		state: ${7:#present|absent}
		password: ${8:# The password for the new database user.}
$0
endsnippet

snippet webfaction_domain "Add or remove domains and subdomains on Webfaction"
- name: $1
	webfaction_domain:
		login_name: ${2:# The webfaction account to use}
		name: ${3:# The name of the domain}
		login_password: ${4:# The webfaction password to use}
		state: ${5:#present|absent}
		subdomains: ${6:# Any subdomains to create.}
$0
endsnippet

snippet webfaction_mailbox "Add or remove mailboxes on Webfaction"
- name: $1
	webfaction_mailbox:
		mailbox_password: ${2:# The password for the mailbox}
		login_name: ${3:# The webfaction account to use}
		mailbox_name: ${4:# The name of the mailbox}
		login_password: ${5:# The webfaction password to use}
		state: ${6:#present|absent}
$0
endsnippet

snippet webfaction_site "Add or remove a website on a Webfaction host"
- name: $1
	webfaction_site:
		name: ${2:# The name of the website}
		host: ${3:# The webfaction host on which the site should be created.}
		login_password: ${4:# The webfaction password to use}
		login_name: ${5:# The webfaction account to use}
		subdomains: ${6:# A list of subdomains associated with this site.}
		state: ${7:#present|absent}
		https: ${8:True|False}
		site_apps: ${9:# A mapping of URLs to apps}
$0
endsnippet

snippet consul "Add, modify & delete services within a consul cluster."
- name: $1
	consul:
		state: ${2:present|absent}
		service_address: ${3:# the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.}
		http: ${4:# checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.}
		tags: ${5:# a list of tags that will be attached to the service registration.}
		check_name: ${6:# a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.}
		service_name: ${7:# Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check}
		host: ${8:localhost}
		ttl: ${9:# checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m}
		port: ${10:8500}
		script: ${11:# the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa}
		check_id: ${12:# an ID for the service check, defaults to the check name, ignored if part of a service definition.}
		service_port: ${13:# the port on which the service is listening required for registration of a service, i.e. if service_name or service_id is set}
		notes: ${14:# Notes to attach to check when registering it.}
		interval: ${15:# the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.}
		token: ${16:# the token key indentifying an ACL rule set. May be required to register services.}
		timeout: ${17:# A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.}
		service_id: ${18:service_name if supplied}
		scheme: ${19:http}
		validate_certs: ${20:yes}
$0
endsnippet

snippet consul_acl "manipulate consul acl keys and rules"
- name: $1
	consul_acl:
		name: ${2:# the name that should be associated with the acl key, this is opaque to Consul}
		rules: ${3:# an list of the rules that should be associated with a given token.}
		state: ${4:#present|absent}
		token_type: ${5:#client|management}
		token: ${6:# the token key indentifying an ACL rule set. If generated by consul this will be a UUID.}
		mgmt_token: ${7:# a management token is required to manipulate the acl lists}
		host: ${8:localhost}
		scheme: ${9:http}
		validate_certs: ${10:yes}
		port: ${11:8500}
$0
endsnippet

snippet consul_kv "Manipulate entries in the key/value store of a consul cluster."
- name: $1
	consul_kv:
		value: ${2:# the value should be associated with the given key, required if state is present}
		key: ${3:# the key at which the value should be stored.}
		cas: ${4:# used when acquiring a lock with a session. If the cas is 0, then Consul will only put the key if it does not already exist. If the cas value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.}
		recurse: ${5:no}
		token: ${6:# the token key indentifying an ACL rule set that controls access to the key value pair}
		state: ${7:#present|absent|acquire|release}
		session: ${8:# the session that should be used to acquire or release a lock associated with a key/value pair}
		flags: ${9:# opaque integer value that can be passed when setting a value.}
		host: ${10:localhost}
		scheme: ${11:http}
		validate_certs: ${12:yes}
		port: ${13:8500}
$0
endsnippet

snippet consul_session "manipulate consul sessions"
- name: $1
	consul_session:
		node: ${2:# the name of the node that with which the session will be associated. by default this is the name of the agent.}
		datacenter: ${3:# name of the datacenter in which the session exists or should be created.}
		name: ${4:# the name that should be associated with the session. This is opaque to Consul and not required.}
		state: ${5:#present|absent|info|node|list}
		checks: ${6:# a list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.}
		delay: ${7:15}
		host: ${8:localhost}
		behavior: ${9:release}
		scheme: ${10:http}
		validate_certs: ${11:yes}
		port: ${12:8500}
$0
endsnippet

snippet kubernetes "Manage Kubernetes resources."
- name: $1
	kubernetes:
		inline_data: ${2:# The Kubernetes YAML data to send to the API I(endpoint). This option is mutually exclusive with C('file_reference').}
		api_endpoint: ${3:# The IPv4 API endpoint of the Kubernetes cluster.}
		state: ${4:#present|absent|update|replace}
		url_password: ${5:# The HTTP Basic Auth password for the API I(endpoint). This should be set unless using the C('insecure') option.}
		certificate_authority_data: ${6:# Certificate Authority data for Kubernetes server. Should be in either standard PEM format or base64 encoded PEM data. Note that certificate verification is broken until ansible supports a version of 'match_hostname' that can match the IP address against the CA data.}
		insecure: ${7:# Reverts the connection to using HTTP instead of HTTPS. This option should only be used when execuing the M('kubernetes') module local to the Kubernetes cluster using the insecure local port (locahost:8080 by default).}
		file_reference: ${8:# Specify full path to a Kubernets YAML file to send to API I(endpoint). This option is mutually exclusive with C('inline_data').}
		url_username: ${9:admin}
		validate_certs: ${10:no}
$0
endsnippet

snippet pacemaker_cluster "Manage a pacemaker cluster"
- name: $1
	pacemaker_cluster:
		state: ${2:online|offline|restart|cleanup}
		node: ${3:# Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.}
		force: ${4:yes}
		timeout: ${5:300}
$0
endsnippet

snippet znode "Create, delete, retrieve, and update znodes using ZooKeeper"
- name: $1
	znode:
		hosts: ${2:# A list of ZooKeeper servers (format '[server]:[port]').}
		name: ${3:# The path of the znode.}
		state: ${4:# The state to enforce. Mutually exclusive with op.}
		timeout: ${5:300}
		op: ${6:# An operation to perform. Mutually exclusive with state.}
		value: ${7:# The value assigned to the znode.}
		recursive: ${8:no}
$0
endsnippet

snippet command "Executes a command on a remote node"
- name: $1
	command:
		${2:free_form=# the command module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!}
		warn: ${3:yes}
		creates: ${4:# a filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.}
		executable: ${5:# change the shell used to execute the command. Should be an absolute path to the executable.}
		chdir: ${6:# cd into this directory before running the command}
		removes: ${7:# a filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.}
$0
endsnippet

snippet expect "Executes a command and responds to prompts"
- name: $1
	expect:
		command: ${2:# the command module takes command to run.}
		responses: ${3:# Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.}
		creates: ${4:# a filename, when it already exists, this step will B(not) be run.}
		chdir: ${5:# cd into this directory before running the command}
		timeout: ${6:30}
		removes: ${7:# a filename, when it does not exist, this step will B(not) be run.}
		echo: ${8:no}
$0
endsnippet

snippet raw "Executes a low-down and dirty SSH command"
- name: $1
	raw:
		${2:free_form=# the raw module takes a free form command to run. There is no parameter actually named 'free form'; see the examples!}
		executable: ${3:# change the shell used to execute the command. Should be an absolute path to the executable.}
$0
endsnippet

snippet script "Runs a local script on a remote node after transferring it"
- name: $1
	script:
		${2:free_form=# path to the local script file followed by optional arguments. There is no parameter actually named 'free form'; see the examples!}
		creates: ${3:# a filename, when it already exists, this step will B(not) be run.}
		removes: ${4:# a filename, when it does not exist, this step will B(not) be run.}
$0
endsnippet

snippet shell "Execute commands in nodes."
- name: $1
	shell:
		${2:free_form=# The shell module takes a free form command to run, as a string.  There's not an actual option named "free form".  See the examples!}
		warn: ${3:yes}
		creates: ${4:# a filename, when it already exists, this step will B(not) be run.}
		executable: ${5:# change the shell used to execute the command. Should be an absolute path to the executable.}
		chdir: ${6:# cd into this directory before running the command}
		removes: ${7:# a filename, when it does not exist, this step will B(not) be run.}
$0
endsnippet

snippet openssl_privatekey "Generate OpenSSL private keys."
- name: $1
	openssl_privatekey:
		path: ${2:# Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.}
		state: ${3:#present|absent}
		size: ${4:4096}
		force: ${5:True|#False}
		type: ${6:#RSA|DSA}
$0
endsnippet

snippet openssl_publickey "Generate an OpenSSL public key from its private key."
- name: $1
	openssl_publickey:
		path: ${2:# Name of the file in which the generated TLS/SSL public key will be written.}
		privatekey_path: ${3:# Path to the TLS/SSL private key from which to genereate the public key.}
		state: ${4:#present|absent}
		force: ${5:True|#False}
$0
endsnippet

snippet influxdb_database "Manage InfluxDB databases"
- name: $1
	influxdb_database:
		database_name: ${2:# Name of the database that will be created/destroyed}
		hostname: ${3:# The hostname or IP address on which InfluxDB server is listening}
		username: ${4:root}
		state: ${5:#present|absent}
		password: ${6:root}
		port: ${7:8086}
$0
endsnippet

snippet influxdb_retention_policy "Manage InfluxDB retention policies"
- name: $1
	influxdb_retention_policy:
		default: ${2:# Sets the retention policy as default retention policy}
		database_name: ${3:# Name of the database where retention policy will be created}
		hostname: ${4:# The hostname or IP address on which InfluxDB server is listening}
		policy_name: ${5:# Name of the retention policy}
		replication: ${6:# Determines how many independent copies of each point are stored in the cluster}
		duration: ${7:# Determines how long InfluxDB should keep the data}
		username: ${8:root}
		password: ${9:root}
		port: ${10:8086}
$0
endsnippet

snippet elasticsearch_plugin "Manage Elasticsearch plugins"
- name: $1
	elasticsearch_plugin:
		name: ${2:# Name of the plugin to install. In ES 2.x, the name can be an url or file location}
		proxy_host: ${3:# Proxy host to use during plugin installation}
		url: ${4:# Set exact URL to download the plugin from (Only works for ES 1.x)}
		proxy_port: ${5:# Proxy port to use during plugin installation}
		state: ${6:#present|absent}
		version: ${7:# Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated}
		timeout: ${8:1m}
		plugin_dir: ${9:/usr/share/elasticsearch/plugins/}
		plugin_bin: ${10:/usr/share/elasticsearch/bin/plugin}
$0
endsnippet

snippet kibana_plugin "Manage Kibana plugins"
- name: $1
	kibana_plugin:
		name: ${2:# Name of the plugin to install}
		force: ${3:yes|no}
		url: ${4:# Set exact URL to download the plugin from. For local file, prefix its absolute path with file://}
		state: ${5:#present|absent}
		version: ${6:# Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes}
		timeout: ${7:1m}
		plugin_dir: ${8:/opt/kibana/installedPlugins/}
		plugin_bin: ${9:/opt/kibana/bin/kibana}
$0
endsnippet

snippet redis "Various redis commands, slave and flush"
- name: $1
	redis:
		command: ${2:slave|flush|config}
		login_port: ${3:6379}
		name: ${4:# A redis config key.}
		flush_mode: ${5:#all|db}
		master_host: ${6:# The host of the master instance [slave command]}
		login_host: ${7:localhost}
		master_port: ${8:# The port of the master instance [slave command]}
		db: ${9:# The database to flush (used in db mode) [flush command]}
		value: ${10:# A redis config value.}
		login_password: ${11:# The password used to authenticate with (usually not used)}
		slave_mode: ${12:master|#slave}
$0
endsnippet

snippet riak "This module handles some common Riak operations"
- name: $1
	riak:
		target_node: ${2:riak@127.0.0.1}
		config_dir: ${3:/etc/riak}
		wait_for_service: ${4:kv}
		http_conn: ${5:127.0.0.1:8098}
		wait_for_ring: ${6:# Number of seconds to wait for all nodes to agree on the ring.}
		wait_for_handoffs: ${7:# Number of seconds to wait for handoffs to complete.}
		command: ${8:ping|kv_test|join|plan|commit}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet mongodb_parameter "Change an administrative parameter on a MongoDB server."
- name: $1
	mongodb_parameter:
		database: ${2:# The name of the database to add/remove the user from}
		param: ${3:# MongoDB administrative parameter to modify}
		value: ${4:# MongoDB administrative parameter value to set}
		login_port: ${5:27017}
		login_user: ${6:# The username used to authenticate with}
		login_host: ${7:localhost}
		login_database: ${8:# The database where login credentials are stored}
		ssl: ${9:no}
		param_type: ${10:str}
		login_password: ${11:# The password used to authenticate with}
		replica_set: ${12:# Replica set to connect to (automatically connects to primary for writes)}
$0
endsnippet

snippet mongodb_user "Adds or removes a user from a MongoDB database."
- name: $1
	mongodb_user:
		name: ${2:# The name of the user to add or remove}
		database: ${3:# The name of the database to add/remove the user from}
		login_port: ${4:27017}
		update_password: ${5:#always|on_create}
		roles: ${6:readWrite}
		login_user: ${7:# The username used to authenticate with}
		login_host: ${8:localhost}
		login_database: ${9:# The database where login credentials are stored}
		ssl_cert_reqs: ${10:#CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE}
		ssl: ${11:no}
		state: ${12:#present|absent}
		login_password: ${13:# The password used to authenticate with}
		password: ${14:# The password to use for the user}
		replica_set: ${15:# Replica set to connect to (automatically connects to primary for writes)}
$0
endsnippet

snippet mssql_db "Add or remove MSSQL databases from a remote host."
- name: $1
	mssql_db:
		name: ${2:# name of the database to add or remove}
		autocommit: ${3:false|true}
		login_port: ${4:1433}
		login_user: ${5:# The username used to authenticate with}
		login_host: ${6:# Host running the database}
		state: ${7:#present|absent|import}
		login_password: ${8:# The password used to authenticate with}
		target: ${9:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.}
$0
endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host."
- name: $1
	mysql_db:
		name: ${2:# name of the database to add or remove}
		ssl_key: ${3:# The path to the client private key.}
		config_file: ${4:~/.my.cnf}
		encoding: ${5:# Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)}
		login_user: ${6:# The username used to authenticate with.}
		login_host: ${7:localhost}
		login_unix_socket: ${8:# The path to a Unix domain socket for local connections.}
		login_password: ${9:# The password used to authenticate with.}
		collation: ${10:# Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.}
		ssl_ca: ${11:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		single_transaction: ${12:no}
		login_port: ${13:3306}
		ssl_cert: ${14:# The path to a client public key certificate.}
		target: ${15:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.}
		state: ${16:#present|absent|dump|import}
		quick: ${17:yes}
		connect_timeout: ${18:30}
$0
endsnippet

snippet mysql_replication "Manage MySQL replication"
- name: $1
	mysql_replication:
		master_ssl_cert: ${2:# same as mysql variable}
		master_auto_position: ${3:# does the host uses GTID based replication or not}
		config_file: ${4:~/.my.cnf}
		master_password: ${5:# same as mysql variable}
		master_host: ${6:# same as mysql variable}
		login_host: ${7:localhost}
		login_password: ${8:# The password used to authenticate with.}
		master_ssl_capath: ${9:# same as mysql variable}
		master_ssl_ca: ${10:# same as mysql variable}
		login_unix_socket: ${11:# The path to a Unix domain socket for local connections.}
		master_connect_retry: ${12:# same as mysql variable}
		master_user: ${13:# same as mysql variable}
		master_port: ${14:# same as mysql variable}
		master_log_file: ${15:# same as mysql variable}
		master_ssl_cipher: ${16:# same as mysql variable}
		relay_log_file: ${17:# same as mysql variable}
		login_port: ${18:3306}
		ssl_cert: ${19:# The path to a client public key certificate.}
		master_ssl: ${20:0|1}
		ssl_key: ${21:# The path to the client private key.}
		ssl_ca: ${22:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		master_ssl_key: ${23:# same as mysql variable}
		mode: ${24:#getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall}
		login_user: ${25:# The username used to authenticate with.}
		master_log_pos: ${26:# same as mysql variable}
		connect_timeout: ${27:30}
		relay_log_pos: ${28:# same as mysql variable}
$0
endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database."
- name: $1
	mysql_user:
		name: ${2:# name of the user (role) to add or remove}
		login_port: ${3:3306}
		update_password: ${4:#always|on_create}
		ssl_cert: ${5:# The path to a client public key certificate.}
		config_file: ${6:~/.my.cnf}
		ssl_key: ${7:# The path to the client private key.}
		encrypted: ${8:yes|#no}
		login_host: ${9:localhost}
		append_privs: ${10:yes|#no}
		sql_log_bin: ${11:#yes|no}
		host_all: ${12:yes|#no}
		ssl_ca: ${13:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		login_password: ${14:# The password used to authenticate with.}
		login_unix_socket: ${15:# The path to a Unix domain socket for local connections.}
		state: ${16:#present|absent}
		login_user: ${17:# The username used to authenticate with.}
		host: ${18:localhost}
		check_implicit_admin: ${19:yes|#no}
		password: ${20:# set the user's password.}
		connect_timeout: ${21:30}
		priv: ${22:# MySQL privileges string in the format: C(db.table:priv1,priv2).}
$0
endsnippet

snippet mysql_variables "Manage MySQL global variables"
- name: $1
	mysql_variables:
		variable: ${2:# Variable name to operate}
		login_port: ${3:3306}
		ssl_cert: ${4:# The path to a client public key certificate.}
		config_file: ${5:~/.my.cnf}
		ssl_key: ${6:# The path to the client private key.}
		login_user: ${7:# The username used to authenticate with.}
		login_host: ${8:localhost}
		value: ${9:# If set, then sets variable value to this}
		ssl_ca: ${10:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
		login_unix_socket: ${11:# The path to a Unix domain socket for local connections.}
		login_password: ${12:# The password used to authenticate with.}
		connect_timeout: ${13:30}
$0
endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host."
- name: $1
	postgresql_db:
		name: ${2:# name of the database to add or remove}
		ssl_rootcert: ${3:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
		ssl_mode: ${4:disable|allow|#prefer|require|verify-ca|verify-full}
		encoding: ${5:# Encoding of the database}
		login_user: ${6:postgres}
		lc_collate: ${7:# Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.}
		lc_ctype: ${8:# Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.}
		port: ${9:5432}
		login_unix_socket: ${10:# Path to a Unix domain socket for local connections}
		state: ${11:#present|absent}
		template: ${12:# Template used to create the database}
		login_password: ${13:# The password used to authenticate with}
		owner: ${14:# Name of the role to set as owner of the database}
		login_host: ${15:# Host running the database}
$0
endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database."
- name: $1
	postgresql_ext:
		name: ${2:# name of the extension to add or remove}
		db: ${3:# name of the database to add or remove the extension to/from}
		state: ${4:#present|absent}
		login_password: ${5:# The password used to authenticate with}
		login_user: ${6:# The username used to authenticate with}
		login_host: ${7:localhost}
		port: ${8:5432}
$0
endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database."
- name: $1
	postgresql_lang:
		lang: ${2:# name of the procedural language to add, remove or change}
		force_trust: ${3:yes|no}
		login_user: ${4:postgres}
		login_host: ${5:localhost}
		db: ${6:# name of database where the language will be added, removed or changed}
		cascade: ${7:yes|no}
		state: ${8:#present|absent}
		login_password: ${9:# Password used to authenticate with PostgreSQL (must match C(login_user))}
		trust: ${10:yes|no}
		fail_on_drop: ${11:#yes|no}
		port: ${12:5432}
$0
endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects."
- name: $1
	postgresql_privs:
		roles: ${2:# Comma separated list of role (user/group) names to set permissions for.}
		database: ${3:# Name of database to connect to.}
		objs: ${4:# Comma separated list of database objects to set privileges on.}
		ssl_rootcert: ${5:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
		ssl_mode: ${6:disable|allow|#prefer|require|verify-ca|verify-full}
		privs: ${7:# Comma separated list of privileges to grant/revoke.}
		state: ${8:#present|absent}
		unix_socket: ${9:# Path to a Unix domain socket for local connections.}
		host: ${10:# Database host address. If unspecified, connect via Unix socket.}
		login: ${11:postgres}
		password: ${12:# The password to authenticate with.}
		type: ${13:#table|sequence|function|database|schema|language|tablespace|group}
		port: ${14:5432}
		grant_option: ${15:yes|no}
		schema: ${16:# Schema that contains the database objects specified via I(objs).}
$0
endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema from a remote host"
- name: $1
	postgresql_schema:
		name: ${2:# Name of the schema to add or remove.}
		database: ${3:postgres}
		login_user: ${4:# The username used to authenticate with.}
		login_host: ${5:localhost}
		login_unix_socket: ${6:# Path to a Unix domain socket for local connections.}
		state: ${7:#present|absent}
		login_password: ${8:# The password used to authenticate with.}
		owner: ${9:# Name of the role to set as owner of the schema.}
		port: ${10:5432}
$0
endsnippet

snippet postgresql_user "Adds or removes a users (roles) from a PostgreSQL database."
- name: $1
	postgresql_user:
		name: ${2:# name of the user (role) to add or remove}
		ssl_rootcert: ${3:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
		ssl_mode: ${4:disable|allow|#prefer|require|verify-ca|verify-full}
		login_user: ${5:postgres}
		login_host: ${6:localhost}
		expires: ${7:# sets the user's password expiration.}
		db: ${8:# name of database where permissions will be granted}
		login_unix_socket: ${9:# Path to a Unix domain socket for local connections}
		login_password: ${10:# Password used to authenticate with PostgreSQL}
		password: ${11:# set the user's password, before 1.4 this was required.}
		port: ${12:5432}
		fail_on_user: ${13:#yes|no}
		priv: ${14:# PostgreSQL privileges string in the format: C(table:priv1,priv2)}
		no_password_changes: ${15:yes|#no}
		state: ${16:#present|absent}
		encrypted: ${17:no}
		role_attr_flags: ${18:[NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEUSER|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION}
$0
endsnippet

snippet proxysql_backend_servers "Adds or removes mysql hosts from proxysql admin interface."
- name: $1
	proxysql_backend_servers:
		hostname: ${2:# The ip address at which the mysqld instance can be contacted.}
		status: ${3:ONLINE|OFFLINE_SOFT|OFFLINE_HARD}
		comment: ${4:}
		config_file: ${5:}
		weight: ${6:# The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.}
		login_user: ${7:# The username used to authenticate to ProxySQL admin interface.}
		login_host: ${8:127.0.0.1}
		save_to_disk: ${9:yes}
		load_to_runtime: ${10:yes}
		login_password: ${11:# The password used to authenticate to ProxySQL admin interface.}
		use_ssl: ${12:# If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
		port: ${13:3306}
		max_connections: ${14:# The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.}
		login_port: ${15:6032}
		compression: ${16:# If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.}
		hostgroup_id: ${17:0}
		state: ${18:#present|absent}
		max_latency_ms: ${19:# Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.}
		max_replication_lag: ${20:# If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.}
$0
endsnippet

snippet proxysql_global_variables "Gets or sets the proxysql global variables."
- name: $1
	proxysql_global_variables:
		variable: ${2:# Defines which variable should be returned, or if I(value) is specified which variable should be updated.}
		login_port: ${3:6032}
		config_file: ${4:}
		login_user: ${5:# The username used to authenticate to ProxySQL admin interface.}
		login_host: ${6:127.0.0.1}
		login_password: ${7:# The password used to authenticate to ProxySQL admin interface.}
		value: ${8:# Defines a value the variable specified using I(variable) should be set to.}
		load_to_runtime: ${9:yes}
		save_to_disk: ${10:yes}
$0
endsnippet

snippet proxysql_manage_config "Writes the proxysql configuration settings between layers."
- name: $1
	proxysql_manage_config:
		direction: ${2:FROM|TO}
		config_settings: ${3:MYSQL USERS|MYSQL SERVERS|MYSQL QUERY RULES|MYSQL VARIABLES|ADMIN VARIABLES|SCHEDULER}
		action: ${4:LOAD|SAVE}
		config_layer: ${5:MEMORY|DISK|RUNTIME|CONFIG}
		login_port: ${6:6032}
		config_file: ${7:}
		login_user: ${8:# The username used to authenticate to ProxySQL admin interface.}
		login_host: ${9:127.0.0.1}
		login_password: ${10:# The password used to authenticate to ProxySQL admin interface.}
$0
endsnippet

snippet proxysql_mysql_users "Adds or removes mysql users from proxysql admin interface."
- name: $1
	proxysql_mysql_users:
		username: ${2:# Name of the user connecting to the mysqld or ProxySQL instance.}
		default_hostgroup: ${3:# If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.}
		frontend: ${4:yes}
		default_schema: ${5:# The schema to which the connection should change to by default.}
		login_user: ${6:# The username used to authenticate to ProxySQL admin interface.}
		login_host: ${7:127.0.0.1}
		save_to_disk: ${8:yes}
		fast_forward: ${9:# If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).}
		load_to_runtime: ${10:yes}
		login_password: ${11:# The password used to authenticate to ProxySQL admin interface.}
		active: ${12:# A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).}
		config_file: ${13:}
		password: ${14:# Password of the user connecting to the mysqld or ProxySQL instance.}
		max_connections: ${15:# The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.}
		login_port: ${16:6032}
		transaction_persistent: ${17:# If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).}
		state: ${18:#present|absent}
		use_ssl: ${19:# If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
		backend: ${20:yes}
$0
endsnippet

snippet proxysql_query_rules "Modifies query rules using the proxysql admin interface."
- name: $1
	proxysql_query_rules:
		comment: ${2:# Free form text field, usable for a descriptive comment of the query rule.}
		flagOUT: ${3:# Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.}
		login_user: ${4:# The username used to authenticate to ProxySQL admin interface.}
		save_to_disk: ${5:yes}
		match_pattern: ${6:# Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
		mirror_flagOUT: ${7:# Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.}
		apply: ${8:# Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.}
		schemaname: ${9:# Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.}
		replace_pattern: ${10:# This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.}
		digest: ${11:# Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.}
		match_digest: ${12:# Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
		mirror_hostgroup: ${13:# Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.}
		log: ${14:# Query will be logged.}
		delay: ${15:# Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.}
		state: ${16:#present|absent}
		proxy_addr: ${17:# Match incoming traffic on a specific local IP.}
		username: ${18:# Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.}
		config_file: ${19:}
		retries: ${20:# The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.}
		login_host: ${21:127.0.0.1}
		destination_hostgroup: ${22:# Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).}
		proxy_port: ${23:# Match incoming traffic on a specific local port.}
		load_to_runtime: ${24:yes}
		login_password: ${25:# The password used to authenticate to ProxySQL admin interface.}
		active: ${26:# A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.}
		cache_ttl: ${27:# The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.}
		error_msg: ${28:# Query will be blocked, and the specified error_msg will be returned to the client.}
		login_port: ${29:6032}
		negate_match_pattern: ${30:# If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.}
		flagIN: ${31:# Used in combination with I(flagOUT) and I(apply) to create chains of rules.}
		client_addr: ${32:# Match traffic from a specific source.}
		timeout: ${33:# The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.}
		force_delete: ${34:no}
		rule_id: ${35:# The unique id of the rule. Rules are processed in rule_id order.}
$0
endsnippet

snippet proxysql_replication_hostgroups "Manages replication hostgroups using the proxysql admin interface."
- name: $1
	proxysql_replication_hostgroups:
		reader_hostgroup: ${2:# Id of the reader hostgroup.}
		writer_hostgroup: ${3:# Id of the writer hostgroup.}
		comment: ${4:# Text field that can be used for any purposed defined by the user.}
		login_port: ${5:6032}
		config_file: ${6:}
		login_user: ${7:# The username used to authenticate to ProxySQL admin interface.}
		login_host: ${8:127.0.0.1}
		save_to_disk: ${9:yes}
		state: ${10:#present|absent}
		load_to_runtime: ${11:yes}
		login_password: ${12:# The password used to authenticate to ProxySQL admin interface.}
$0
endsnippet

snippet proxysql_scheduler "Adds or removes schedules from proxysql admin interface."
- name: $1
	proxysql_scheduler:
		filename: ${2:# Full path of the executable to be executed.}
		comment: ${3:# Text field that can be used for any purposed defined by the user.}
		config_file: ${4:}
		login_user: ${5:# The username used to authenticate to ProxySQL admin interface.}
		arg2: ${6:# Argument that can be passed to the job.}
		arg3: ${7:# Argument that can be passed to the job.}
		arg4: ${8:# Argument that can be passed to the job.}
		arg5: ${9:# Argument that can be passed to the job.}
		interval_ms: ${10:10000}
		load_to_runtime: ${11:yes}
		login_password: ${12:# The password used to authenticate to ProxySQL admin interface.}
		active: ${13:yes}
		login_port: ${14:6032}
		force_delete: ${15:no}
		save_to_disk: ${16:yes}
		state: ${17:#present|absent}
		arg1: ${18:# Argument that can be passed to the job.}
		login_host: ${19:127.0.0.1}
$0
endsnippet

snippet vertica_configuration "Updates Vertica configuration parameters."
- name: $1
	vertica_configuration:
		name: ${2:# Name of the parameter to update.}
		value: ${3:# Value of the parameter to be set.}
		cluster: ${4:localhost}
		login_password: ${5:# The password used to authenticate with.}
		login_user: ${6:dbadmin}
		db: ${7:# Name of the Vertica database.}
		port: ${8:5433}
$0
endsnippet

snippet vertica_facts "Gathers Vertica database facts."
- name: $1
	vertica_facts:
		login_user: ${2:dbadmin}
		cluster: ${3:localhost}
		db: ${4:# Name of the database running the schema.}
		port: ${5:5433}
		login_password: ${6:# The password used to authenticate with.}
$0
endsnippet

snippet vertica_role "Adds or removes Vertica database roles and assigns roles to them."
- name: $1
	vertica_role:
		name: ${2:# Name of the role to add or remove.}
		assigned_roles: ${3:# Comma separated list of roles to assign to the role.}
		login_user: ${4:dbadmin}
		db: ${5:# Name of the Vertica database.}
		cluster: ${6:localhost}
		state: ${7:#present|absent}
		login_password: ${8:# The password used to authenticate with.}
		port: ${9:5433}
$0
endsnippet

snippet vertica_schema "Adds or removes Vertica database schema and roles."
- name: $1
	vertica_schema:
		name: ${2:# Name of the schema to add or remove.}
		create_roles: ${3:# Comma separated list of roles to create and grant usage and create access to the schema.}
		login_user: ${4:dbadmin}
		db: ${5:# Name of the Vertica database.}
		usage_roles: ${6:# Comma separated list of roles to create and grant usage access to the schema.}
		cluster: ${7:localhost}
		state: ${8:#present|absent}
		login_password: ${9:# The password used to authenticate with.}
		owner: ${10:# Name of the user to set as owner of the schema.}
		port: ${11:5433}
$0
endsnippet

snippet vertica_user "Adds or removes Vertica database users and assigns roles."
- name: $1
	vertica_user:
		name: ${2:# Name of the user to add or remove.}
		profile: ${3:# Sets the user's profile.}
		resource_pool: ${4:# Sets the user's resource pool.}
		roles: ${5:# Comma separated list of roles to assign to the user.}
		login_user: ${6:dbadmin}
		ldap: ${7:# Set to true if users are authenticated via LDAP.}
		db: ${8:# Name of the Vertica database.}
		cluster: ${9:localhost}
		state: ${10:#present|absent|locked}
		login_password: ${11:# The password used to authenticate with.}
		password: ${12:# The user's password encrypted by the MD5 algorithm.}
		expired: ${13:# Sets the user's password expiration.}
		port: ${14:5433}
$0
endsnippet

snippet acl "Sets and retrieves file ACL information."
- name: $1
	acl:
		path: ${2:# The full path of the file or object.}
		recursive: ${3:yes|no}
		default: ${4:yes|no}
		entity: ${5:# actual user or group that the ACL applies to when matching entity types user or group are selected.}
		state: ${6:#query|present|absent}
		follow: ${7:yes|no}
		etype: ${8:user|group|mask|other}
		entry: ${9:# DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '<etype>:<qualifier>:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields.}
		permissions: ${10:# Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)}
$0
endsnippet

snippet archive "Creates a compressed archive of one or more files or trees."
- name: $1
	archive:
		path: ${2:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}
		group: ${3:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		format: ${4:#gz|bz2|zip}
		dest: ${5:# The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.}
		selevel: ${6:s0}
		seuser: ${7:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		setype: ${8:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		remove: ${9:no}
		unsafe_writes: ${10:no}
		serole: ${11:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		attributes: ${13:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
$0
endsnippet

snippet assemble "Assembles a configuration file from fragments"
- name: $1
	assemble:
		src: ${2:# An already existing directory full of source files.}
		dest: ${3:# A file to create using the concatenation of all of the source files.}
		ignore_hidden: ${4:no}
		group: ${5:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		remote_src: ${6:#True|False}
		selevel: ${7:s0}
		seuser: ${8:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		unsafe_writes: ${10:no}
		delimiter: ${11:# A delimiter to separate the file contents.}
		mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		attributes: ${13:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		regexp: ${15:# Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		validate: ${16:# The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.}
		backup: ${17:yes|#no}
		setype: ${18:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines."
- name: $1
	blockinfile:
		path: ${2:# The file to modify.}
		group: ${3:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		insertbefore: ${4:BOF|*regex*}
		unsafe_writes: ${5:no}
		selevel: ${6:s0}
		create: ${7:yes|#no}
		seuser: ${8:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		owner: ${10:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		marker: ${11:# {mark} ANSIBLE MANAGED BLOCK}
		state: ${12:#present|absent}
		mode: ${13:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		insertafter: ${14:#EOF|*regex*}
		follow: ${15:yes|#no}
		validate: ${16:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		attributes: ${17:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		backup: ${18:yes|#no}
		block: ${19:}
		setype: ${20:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet copy "Copies files to remote locations."
- name: $1
	copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		src: ${3:# Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.}
		directory_mode: ${4:# When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.}
		force: ${5:#yes|no}
		remote_src: ${6:True|#False}
		selevel: ${7:s0}
		seuser: ${8:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		setype: ${9:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		group: ${10:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		content: ${11:# When used instead of 'src', sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.}
		unsafe_writes: ${12:no}
		serole: ${13:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${14:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		attributes: ${15:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		owner: ${16:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		follow: ${17:yes|#no}
		validate: ${18:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		backup: ${19:yes|#no}
$0
endsnippet

snippet fetch "Fetches a file from remote nodes"
- name: $1
	fetch:
		dest: ${2:# A directory to save the file into. For example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile)}
		src: ${3:# The file on the remote system to fetch. This I(must) be a file, not a directory. Recursive fetching may be supported in a later release.}
		validate_checksum: ${4:#yes|no}
		fail_on_missing: ${5:yes|#no}
		flat: ${6:# Allows you to override the default behavior of appending hostname/path/to/file to the destination.  If dest ends with '/', it will use the basename of the source file, similar to the copy module. Obviously this is only handy if the filenames are unique.}
$0
endsnippet

snippet file "Sets attributes of files"
- name: $1
	file:
		path: ${2:[]}
		src: ${3:# path of the file to link to (applies only to C(state=link)). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded.}
		force: ${4:yes|#no}
		unsafe_writes: ${5:no}
		selevel: ${6:s0}
		seuser: ${7:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		recurse: ${8:yes|#no}
		serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		group: ${10:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		state: ${11:#file|link|directory|hard|touch|absent}
		mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		follow: ${13:yes|#no}
		owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		attributes: ${15:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		setype: ${16:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet find "return a list of files based on specific criteria"
- name: $1
	find:
		paths: ${2:# List of paths of directories to search. All paths must be fully qualified.}
		file_type: ${3:#file|directory|link|any}
		age: ${4:# Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., "1w").}
		contains: ${5:# One or more regex patterns which should be matched against the file content}
		recurse: ${6:yes|#no}
		age_stamp: ${7:atime|#mtime|ctime}
		patterns: ${8:*}
		get_checksum: ${9:True|False}
		use_regex: ${10:True|False}
		follow: ${11:True|False}
		hidden: ${12:True|False}
		size: ${13:# Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.}
$0
endsnippet

snippet ini_file "Tweak settings in INI files"
- name: $1
	ini_file:
		section: ${2:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}
		path: ${3:# Path to the INI-style file; this file is created if required.}
		seuser: ${4:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		group: ${5:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		option: ${6:# If set (required for changing a I(value)), this is the name of the option.}
		unsafe_writes: ${7:no}
		selevel: ${8:s0}
		no_extra_spaces: ${9:no}
		serole: ${10:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		value: ${11:# The string value to be associated with an I(option). May be omitted when removing an I(option).}
		state: ${12:#present|absent}
		mode: ${13:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		others: ${14:# All arguments accepted by the M(file) module also work here}
		owner: ${15:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		attributes: ${16:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		backup: ${17:yes|#no}
		create: ${18:#yes|no}
		setype: ${19:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet iso_extract "Extract files from an ISO image."
- name: $1
	iso_extract:
		dest: ${2:# The destination directory to extract files to.}
		files: ${3:# A list of files to extract from the image.}
		image: ${4:# The ISO image to extract files from.}
$0
endsnippet

snippet lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression."
- name: $1
	lineinfile:
		path: ${2:# The file to modify.}
		validate: ${3:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		group: ${4:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		insertbefore: ${5:BOF|*regex*}
		unsafe_writes: ${6:no}
		selevel: ${7:s0}
		create: ${8:yes|#no}
		seuser: ${9:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		serole: ${10:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		backrefs: ${11:yes|#no}
		owner: ${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		state: ${13:#present|absent}
		mode: ${14:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		others: ${15:# All arguments accepted by the M(file) module also work here.}
		insertafter: ${16:#EOF|*regex*}
		regexp: ${17:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove.  Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		attributes: ${18:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		backup: ${19:yes|#no}
		line: ${20:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
		setype: ${21:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
$0
endsnippet

snippet patch "Apply patch files using the GNU patch tool."
- name: $1
	patch:
		src: ${2:# Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's "files" directory.}
		strip: ${3:0}
		remote_src: ${4:yes|#no}
		dest: ${5:# Path of the file on the remote machine to be patched.}
		binary: ${6:no}
		basedir: ${7:# Path of a base directory in which the patch file will be applied. May be omitted when C(dest) option is specified, otherwise required.}
		backup: ${8:yes|#no}
$0
endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression."
- name: $1
	replace:
		regexp: ${2:# The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses multiline mode, which means C(^) and C($) match the beginning and end respectively of I(each line) of the file.}
		path: ${3:# The file to modify.}
		group: ${4:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		unsafe_writes: ${5:no}
		selevel: ${6:s0}
		seuser: ${7:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		setype: ${8:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		replace: ${9:# The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.}
		serole: ${10:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${11:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		others: ${12:# All arguments accepted by the M(file) module also work here.}
		owner: ${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		follow: ${14:yes|#no}
		attributes: ${15:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		backup: ${16:yes|#no}
		validate: ${17:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
$0
endsnippet

snippet stat "retrieve file or file system status"
- name: $1
	stat:
		path: ${2:# The full path of the file/object to get the facts of}
		get_checksum: ${3:yes}
		follow: ${4:no}
		checksum_algorithm: ${5:#sha1|sha224|sha256|sha384|sha512}
		get_mime: ${6:#True|False}
		get_md5: ${7:yes}
		get_attributes: ${8:yes}
$0
endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy."
- name: $1
	synchronize:
		src: ${2:# Path on the source host that will be synchronized to the destination; The path can be absolute or relative.}
		dest: ${3:# Path on the destination host that will be synchronized from the source; The path can be absolute or relative.}
		dirs: ${4:yes|#no}
		partial: ${5:no}
		links: ${6:yes|no}
		copy_links: ${7:yes|#no}
		perms: ${8:yes|no}
		compress: ${9:#yes|no}
		rsync_timeout: ${10:0}
		rsync_opts: ${11:# Specify additional rsync options by passing in an array.}
		owner: ${12:yes|no}
		set_remote_user: ${13:yes}
		times: ${14:yes|no}
		rsync_path: ${15:# Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.}
		dest_port: ${16:Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set}
		group: ${17:yes|no}
		existing_only: ${18:yes|#no}
		recursive: ${19:yes|no}
		archive: ${20:#yes|no}
		mode: ${21:#push|pull}
		checksum: ${22:yes|#no}
		verify_host: ${23:no}
		use_ssh_args: ${24:yes|#no}
		delete: ${25:yes|#no}
$0
endsnippet

snippet tempfile "Creates temporary files and directories."
- name: $1
	tempfile:
		path: ${2:# Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.}
		state: ${3:#file|directory}
		prefix: ${4:ansible.}
		suffix: ${5:}
$0
endsnippet

snippet template "Templates a file out to a remote server."
- name: $1
	template:
		src: ${2:# Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		force: ${4:#yes|no}
		selevel: ${5:s0}
		seuser: ${6:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		setype: ${7:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		unsafe_writes: ${8:no}
		serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${10:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		attributes: ${11:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		owner: ${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		group: ${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		validate: ${14:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		backup: ${15:yes|#no}
$0
endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine."
- name: $1
	unarchive:
		src: ${2:# If remote_src=no (default), local path to archive file to copy to the target server; can be absolute or relative. If remote_src=yes, path on the target server to existing archive file to unpack.}
		dest: ${3:# Remote absolute path where the archive should be unpacked}
		seuser: ${4:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		group: ${5:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		remote_src: ${6:yes|#no}
		selevel: ${7:s0}
		list_files: ${8:yes|#no}
		keep_newer: ${9:no}
		setype: ${10:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		creates: ${11:# a filename, when it already exists, this step will B(not) be run.}
		unsafe_writes: ${12:no}
		serole: ${13:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${14:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		exclude: ${15:[]}
		owner: ${16:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		extra_opts: ${17:# Specify additional options by passing in an array.}
		copy: ${18:#yes|no}
		validate_certs: ${19:#yes|no}
		attributes: ${20:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
$0
endsnippet

snippet xattr "set/retrieve extended attributes"
- name: $1
	xattr:
		path: ${2:# The full path of the file/object to get the facts of.}
		state: ${3:read|present|all|keys|absent}
		key: ${4:# The name of a specific Extended attribute key to set/retrieve}
		value: ${5:# The value to set the named name/key to, it automatically sets the C(state) to 'set'}
		follow: ${6:yes|no}
$0
endsnippet

snippet ipa_group "Manage FreeIPA group"
- name: $1
	ipa_group:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		ipa_port: ${4:443}
		group: ${5:# List of group names assigned to this group.}
		external: ${6:# Allow adding external non-IPA members from trusted domains.}
		ipa_prot: ${7:http|#https}
		gidnumber: ${8:# GID (use this option to set it manually).}
		state: ${9:#present|absent}
		ipa_host: ${10:ipa.example.com}
		ipa_user: ${11:admin}
		validate_certs: ${12:yes}
		nonposix: ${13:# Create as a non-POSIX group.}
		user: ${14:# List of user names assigned to this group.}
$0
endsnippet

snippet ipa_hbacrule "Manage FreeIPA HBAC rule"
- name: $1
	ipa_hbacrule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		sourcehostcategory: ${4:all}
		ipa_port: ${5:443}
		hostcategory: ${6:all}
		ipa_host: ${7:ipa.example.com}
		usergroup: ${8:# List of user group names to assign.}
		description: ${9:# D}
		servicecategory: ${10:all}
		service: ${11:# List of service names to assign.}
		user: ${12:# List of user names to assign.}
		ipa_prot: ${13:http|#https}
		host: ${14:# List of host names to assign.}
		hostgroup: ${15:# List of hostgroup names to assign.}
		usercategory: ${16:all}
		state: ${17:#present|absent|enabled|disabled}
		ipa_user: ${18:admin}
		servicegroup: ${19:# List of service group names to assign.}
		validate_certs: ${20:yes}
		sourcehostgroup: ${21:# List of source host group names to assign.}
		sourcehost: ${22:# List of source host names to assign.}
$0
endsnippet

snippet ipa_host "Manage FreeIPA host"
- name: $1
	ipa_host:
		fqdn: ${2:# Full qualified domain name.}
		ipa_pass: ${3:# P}
		force: ${4:# Force host name even if not in DNS.}
		description: ${5:# A description of this host.}
		ns_os_version: ${6:# Host operating system and version (e.g. "Fedora 9")}
		ipa_host: ${7:ipa.example.com}
		ip_address: ${8:# Add the host to DNS with this IP address.}
		ns_hardware_platform: ${9:# Host hardware platform (e.g. "Lenovo T61")}
		ns_host_location: ${10:# Host location (e.g. "Lab 2")}
		ipa_port: ${11:443}
		user_certificate: ${12:# List of Base-64 encoded server certificates.}
		ipa_prot: ${13:http|#https}
		state: ${14:#present|absent|disabled}
		ipa_user: ${15:admin}
		mac_address: ${16:# List of Hardware MAC address(es) off this host.}
		validate_certs: ${17:yes}
$0
endsnippet

snippet ipa_hostgroup "Manage FreeIPA host-group"
- name: $1
	ipa_hostgroup:
		cn: ${2:# Name of host-group.}
		ipa_pass: ${3:# P}
		ipa_port: ${4:443}
		ipa_prot: ${5:http|#https}
		host: ${6:# List of hosts that belong to the host-group.}
		hostgroup: ${7:# List of host-groups than belong to that host-group.}
		state: ${8:#present|absent}
		ipa_host: ${9:ipa.example.com}
		ipa_user: ${10:admin}
		validate_certs: ${11:yes}
		description: ${12:# Description}
$0
endsnippet

snippet ipa_role "Manage FreeIPA role"
- name: $1
	ipa_role:
		cn: ${2:# Role name.}
		ipa_pass: ${3:# P}
		ipa_port: ${4:443}
		group: ${5:# List of group names assign to this role.}
		service: ${6:# List of service names to assign.}
		description: ${7:# A description of this role-group.}
		ipa_prot: ${8:http|#https}
		host: ${9:# List of host names to assign.}
		hostgroup: ${10:# List of host group names to assign.}
		state: ${11:#present|absent}
		ipa_host: ${12:ipa.example.com}
		ipa_user: ${13:admin}
		validate_certs: ${14:yes}
		user: ${15:# List of user names to assign.}
$0
endsnippet

snippet ipa_sudocmd "Manage FreeIPA sudo command"
- name: $1
	ipa_sudocmd:
		ipa_pass: ${2:# P}
		sudocmd: ${3:# Sudo Command.}
		ipa_port: ${4:443}
		description: ${5:# A description of this command.}
		ipa_prot: ${6:http|#https}
		state: ${7:#present|absent}
		ipa_host: ${8:ipa.example.com}
		ipa_user: ${9:admin}
		validate_certs: ${10:yes}
$0
endsnippet

snippet ipa_sudocmdgroup "Manage FreeIPA sudo command group"
- name: $1
	ipa_sudocmdgroup:
		cn: ${2:# Sudo Command Group.}
		ipa_pass: ${3:# P}
		ipa_port: ${4:443}
		ipa_prot: ${5:http|#https}
		state: ${6:#present|absent}
		ipa_host: ${7:ipa.example.com}
		ipa_user: ${8:admin}
		sudocmd: ${9:# List of sudo commands to assign to the group.}
		validate_certs: ${10:yes}
		description: ${11:# Group description.}
$0
endsnippet

snippet ipa_sudorule "Manage FreeIPA sudo rule"
- name: $1
	ipa_sudorule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# P}
		hostcategory: ${4:all}
		user: ${5:# List of users assigned to the rule.}
		usergroup: ${6:# List of user groups assigned to the rule.}
		cmdcategory: ${7:all}
		ipa_port: ${8:443}
		cmd: ${9:# List of commands assigned to the rule.}
		ipa_prot: ${10:http|#https}
		host: ${11:# List of hosts assigned to the rule.}
		hostgroup: ${12:# List of host groups assigned to the rule.}
		usercategory: ${13:all}
		state: ${14:#present|absent|enabled|disabled}
		ipa_user: ${15:admin}
		validate_certs: ${16:yes}
		ipa_host: ${17:ipa.example.com}
$0
endsnippet

snippet ipa_user "Manage FreeIPA users"
- name: $1
	ipa_user:
		uid: ${2:# u}
		ipa_pass: ${3:# P}
		telephonenumber: ${4:# List of telephone numbers assigned to the user.}
		sshpubkey: ${5:# List of public SSH key.}
		displayname: ${6:# D}
		ipa_host: ${7:ipa.example.com}
		givenname: ${8:# F}
		ipa_port: ${9:443}
		password: ${10:# Password}
		title: ${11:# T}
		loginshell: ${12:# L}
		ipa_prot: ${13:http|#https}
		state: ${14:#present|absent|enabled|disabled}
		sn: ${15:# S}
		ipa_user: ${16:admin}
		mail: ${17:# List of mail addresses assigned to the user.}
		validate_certs: ${18:yes}
$0
endsnippet

snippet opendj_backendprop "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command."
- name: $1
	opendj_backendprop:
		name: ${2:# The configuration setting to update.}
		hostname: ${3:# The hostname of the OpenDJ server.}
		value: ${4:# The value for the configuration item.}
		port: ${5:# The Admin port on which the OpenDJ instance is available.}
		backend: ${6:# The name of the backend on which the property needs to be updated.}
		username: ${7:cn=Directory Manager}
		state: ${8:present}
		passwordfile: ${9:# Location to the password file which holds the password for the cn=Directory Manager user.}
		password: ${10:# The password for the cn=Directory Manager user.}
		opendj_bindir: ${11:/opt/opendj/bin}
$0
endsnippet

snippet add_host "add a host (and alternatively a group) to the ansible-playbook in-memory inventory"
- name: $1
	add_host:
		name: ${2:# The hostname/ip of the host to add to the inventory, can include a colon and a port number.}
		groups: ${3:# The groups to add the hostname to, comma separated.}
$0
endsnippet

snippet group_by "Create Ansible groups based on facts"
- name: $1
	group_by:
		key: ${2:# The variables whose values will be used as groups}
$0
endsnippet

snippet rabbitmq_binding "This module manages rabbitMQ bindings"
- name: $1
	rabbitmq_binding:
		name: ${2:# source exchange to create binding on}
		destination: ${3:# destination exchange or queue for the binding}
		destination_type: ${4:queue|exchange}
		login_port: ${5:15672}
		login_user: ${6:guest}
		login_host: ${7:localhost}
		routing_key: ${8:#}
		vhost: ${9:/}
		state: ${10:#present|absent}
		arguments: ${11:{}}
		login_password: ${12:no}
$0
endsnippet

snippet rabbitmq_exchange "This module manages rabbitMQ exchanges"
- name: $1
	rabbitmq_exchange:
		name: ${2:# Name of the exchange to create}
		login_port: ${3:15672}
		login_user: ${4:guest}
		login_host: ${5:localhost}
		durable: ${6:yes|no}
		exchange_type: ${7:fanout|#direct|headers|topic}
		vhost: ${8:/}
		state: ${9:#present|absent}
		internal: ${10:yes|no}
		arguments: ${11:{}}
		login_password: ${12:no}
		auto_delete: ${13:yes|no}
$0
endsnippet

snippet rabbitmq_parameter "Adds or removes parameters to RabbitMQ"
- name: $1
	rabbitmq_parameter:
		name: ${2:# Name of the parameter being set}
		component: ${3:# Name of the component of which the parameter is being set}
		node: ${4:rabbit}
		vhost: ${5:/}
		state: ${6:#present|absent}
		value: ${7:# Value of the parameter, as a JSON term}
$0
endsnippet

snippet rabbitmq_plugin "Adds or removes plugins to RabbitMQ"
- name: $1
	rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names}
		state: ${3:#enabled|disabled}
		new_only: ${4:yes|#no}
		prefix: ${5:# Specify a custom install prefix to a Rabbit}
$0
endsnippet

snippet rabbitmq_policy "Manage the state of policies in RabbitMQ."
- name: $1
	rabbitmq_policy:
		name: ${2:# The name of the policy to manage.}
		tags: ${3:# A dict or string describing the policy.}
		pattern: ${4:# A regex of queues to apply the policy to.}
		node: ${5:rabbit}
		priority: ${6:0}
		vhost: ${7:/}
		state: ${8:#present|absent}
		apply_to: ${9:#all|exchanges|queues}
$0
endsnippet

snippet rabbitmq_queue "This module manages rabbitMQ queues"
- name: $1
	rabbitmq_queue:
		name: ${2:# Name of the queue to create}
		login_port: ${3:15672}
		dead_letter_exchange: ${4:# Optional name of an exchange to which messages will be republished if they}
		durable: ${5:yes|no}
		login_user: ${6:guest}
		login_host: ${7:localhost}
		login_password: ${8:no}
		vhost: ${9:/}
		state: ${10:#present|absent}
		max_length: ${11:no limit}
		arguments: ${12:{}}
		message_ttl: ${13:forever}
		auto_expires: ${14:forever}
		dead_letter_routing_key: ${15:# Optional replacement routing key to use when a message is dead-lettered.}
		auto_delete: ${16:yes|no}
$0
endsnippet

snippet rabbitmq_user "Adds or removes users to RabbitMQ"
- name: $1
	rabbitmq_user:
		user: ${2:# Name of user to add}
		node: ${3:rabbit}
		force: ${4:yes|#no}
		tags: ${5:# User tags specified as comma delimited}
		read_priv: ${6:^$}
		write_priv: ${7:^$}
		state: ${8:#present|absent}
		configure_priv: ${9:^$}
		vhost: ${10:/}
		password: ${11:# Password of user to add.}
		permissions: ${12:[]}
$0
endsnippet

snippet rabbitmq_vhost "Manage the state of a virtual host in RabbitMQ"
- name: $1
	rabbitmq_vhost:
		name: ${2:# The name of the vhost to manage}
		node: ${3:rabbit}
		tracing: ${4:yes|#no}
		state: ${5:#present|absent}
$0
endsnippet

snippet airbrake_deployment "Notify airbrake about app deployments"
- name: $1
	airbrake_deployment:
		environment: ${2:# The airbrake environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		repo: ${4:# URL of the project repository}
		user: ${5:# The username of the person doing the deployment}
		url: ${6:https://airbrake.io/deploys.txt}
		validate_certs: ${7:#yes|no}
		revision: ${8:# A hash, number, tag, or other identifier showing what revision was deployed}
$0
endsnippet

snippet bigpanda "Notify BigPanda about deployments"
- name: $1
	bigpanda:
		component: ${2:# The name of the component being deployed. Ex: billing}
		token: ${3:# API token.}
		state: ${4:started|finished|failed}
		version: ${5:# The deployment version.}
		description: ${6:# Free text description of the deployment.}
		url: ${7:https://api.bigpanda.io}
		hosts: ${8:machine's hostname}
		env: ${9:# The environment name, typically 'production', 'staging', etc.}
		owner: ${10:# The person responsible for the deployment.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet boundary_meter "Manage boundary meters"
- name: $1
	boundary_meter:
		apikey: ${2:# Organizations boundary API KEY}
		apiid: ${3:# Organizations boundary API ID}
		name: ${4:# meter name}
		state: ${5:present|absent}
		validate_certs: ${6:#yes|no}
$0
endsnippet

snippet circonus_annotation "create an annotation in circonus"
- name: $1
	circonus_annotation:
		category: ${2:# Annotation Category}
		description: ${3:# Description of annotation}
		title: ${4:# Title of annotation}
		api_key: ${5:# Circonus API key}
		start: ${6:# Unix timestamp of event start, defaults to now}
		duration: ${7:# Duration in seconds of annotation, defaults to 0}
		stop: ${8:# Unix timestamp of event end, defaults to now + duration}
$0
endsnippet

snippet datadog_event "Posts events to DataDog  service"
- name: $1
	datadog_event:
		title: ${2:# The event title.}
		text: ${3:# The body of the event.}
		app_key: ${4:# Your DataDog app key.}
		api_key: ${5:# Your DataDog API key.}
		date_happened: ${6:now}
		alert_type: ${7:error|warning|#info|success}
		tags: ${8:# Comma separated list of tags to apply to the event.}
		priority: ${9:#normal|low}
		aggregation_key: ${10:# An arbitrary string to use for aggregation.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet datadog_monitor "Manages Datadog monitors"
- name: $1
	datadog_monitor:
		app_key: ${2:# Your DataDog app key.}
		name: ${3:# The name of the alert.}
		state: ${4:present|absent|muted|unmuted}
		api_key: ${5:# Your DataDog API key.}
		notify_audit: ${6:no}
		timeout_h: ${7:# The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.}
		tags: ${8:# A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.}
		thresholds: ${9:{u'warning': 1, u'ok': 1, u'critical': 1}}
		query: ${10:# The monitor query to notify on with syntax varying depending on what type of monitor you are creating.}
		message: ${11:# A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.}
		id: ${12:# The id of the alert. If set, will be used instead of the name to locate the alert.}
		locked: ${13:no}
		no_data_timeframe: ${14:2x timeframe for metric, 2 minutes for service}
		silenced: ${15:}
		require_full_window: ${16:# A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.}
		notify_no_data: ${17:no}
		renotify_interval: ${18:# The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.}
		escalation_message: ${19:# A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None}
		type: ${20:metric alert|service check|event alert}
$0
endsnippet

snippet honeybadger_deployment "Notify Honeybadger.io about app deployments"
- name: $1
	honeybadger_deployment:
		environment: ${2:# The environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		repo: ${4:# URL of the project repository}
		user: ${5:# The username of the person doing the deployment}
		url: ${6:https://api.honeybadger.io/v1/deploys}
		validate_certs: ${7:#yes|no}
		revision: ${8:# A hash, number, tag, or other identifier showing what revision was deployed}
$0
endsnippet

snippet icinga2_feature "Manage Icinga2 feature"
- name: $1
	icinga2_feature:
		name: ${2:# This is the feature name to enable or disable.}
		state: ${3:#present|absent}
$0
endsnippet

snippet librato_annotation "create an annotation in librato"
- name: $1
	librato_annotation:
		links: ${2:# See examples}
		title: ${3:# The title of an annotation is a string and may contain spaces}
		api_key: ${4:# Librato account api key}
		user: ${5:# Librato account username}
		description: ${6:# The description contains extra meta-data about a particular annotation}
		start_time: ${7:# The unix timestamp indicating the the time at which the event referenced by this annotation started}
		name: ${8:# The annotation stream name}
		source: ${9:# A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population}
		end_time: ${10:# The unix timestamp indicating the the time at which the event referenced by this annotation ended}
$0
endsnippet

snippet logentries "Module for tracking logs via logentries.com"
- name: $1
	logentries:
		path: ${2:# path to a log file}
		state: ${3:#present|absent}
		name: ${4:# name of the log}
		logtype: ${5:# type of the log}
$0
endsnippet

snippet logicmonitor "Manage your LogicMonitor account through Ansible Playbooks"
- name: $1
	logicmonitor:
		company: ${2:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."}
		user: ${3:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${4:# The password of the specified LogicMonitor user}
		target: ${5:collector|host|datsource|hostgroup}
		action: ${6:add|remove|update|sdt}
		displayname: ${7:hostname -f}
		description: ${8:}
		groups: ${9:[]}
		duration: ${10:30}
		collector: ${11:# The fully qualified domain name of a collector in your LogicMonitor account.}
		id: ${12:# ID of the datasource to target.}
		alertenable: ${13:#True|False}
		hostname: ${14:hostname -f}
		properties: ${15:{}}
		starttime: ${16:Now}
		fullpath: ${17:# The fullpath of the host group object you would like to manage.}
$0
endsnippet

snippet logicmonitor_facts "Collect facts about LogicMonitor objects"
- name: $1
	logicmonitor_facts:
		target: ${2:host|hostgroup}
		company: ${3:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".}
		user: ${4:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${5:# The password for the chosen LogicMonitor User.}
		displayname: ${6:hostname -f}
		hostname: ${7:hostname -f}
		fullpath: ${8:# The fullpath of the hostgroup object you would like to manage.}
		collector: ${9:# The fully qualified domain name of a collector in your LogicMonitor account.}
$0
endsnippet

snippet logstash_plugin "Manage Logstash plugins"
- name: $1
	logstash_plugin:
		name: ${2:# Install plugin with that name.}
		proxy_port: ${3:# Proxy port to use during plugin installation.}
		state: ${4:#present|absent}
		version: ${5:# Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.}
		proxy_host: ${6:# Proxy host to use during plugin installation.}
		plugin_bin: ${7:/usr/share/logstash/bin/logstash-plugin}
$0
endsnippet

snippet monit "Manage the state of a program monitored via Monit"
- name: $1
	monit:
		state: ${2:present|started|stopped|restarted|monitored|unmonitored|reloaded}
		name: ${3:# The name of the I(monit) program/process to manage}
		timeout: ${4:300}
$0
endsnippet

snippet nagios "Perform common tasks in Nagios related to downtime and notifications."
- name: $1
	nagios:
		action: ${2:downtime|delete_downtime|enable_alerts|disable_alerts|silence|unsilence|silence_nagios|unsilence_nagios|command|servicegroup_service_downtime|servicegroup_host_downtime}
		command: ${3:# The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action.}
		services: ${4:# What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions.}
		comment: ${5:Scheduling downtime}
		servicegroup: ${6:# The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime).}
		author: ${7:Ansible}
		host: ${8:# Host to operate on in Nagios.}
		minutes: ${9:30}
		cmdfile: ${10:auto-detected}
$0
endsnippet

snippet newrelic_deployment "Notify newrelic about app deployments"
- name: $1
	newrelic_deployment:
		token: ${2:# API token, to place in the x-api-key header.}
		application_id: ${3:# (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM}
		description: ${4:# Text annotation for the deployment - notes for you}
		changelog: ${5:# A list of changes for this deployment}
		appname: ${6:# Name of the application}
		environment: ${7:# The environment for this deployment}
		user: ${8:# The name of the user/process that triggered this deployment}
		revision: ${9:# A revision number (e.g., git commit SHA)}
		validate_certs: ${10:#yes|no}
		app_name: ${11:# (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application}
$0
endsnippet

snippet pagerduty "Create PagerDuty maintenance windows"
- name: $1
	pagerduty:
		name: ${2:}
		passwd: ${3:}
		state: ${4:running|started|ongoing|absent}
		token: ${5:}
		user: ${6:}
		requester_id: ${7:}
		service: ${8:}
		minutes: ${9:}
		hours: ${10:}
		validate_certs: ${11:#yes|no}
		desc: ${12:}
$0
endsnippet

snippet pagerduty_alert "Trigger, acknowledge or resolve PagerDuty incidents"
- name: $1
	pagerduty_alert:
		name: ${2:# PagerDuty unique subdomain.}
		state: ${3:triggered|acknowledged|resolved}
		service_key: ${4:# The GUID of one of your "Generic API" services.}
		api_key: ${5:# The pagerduty API key (readonly access), generated on the pagerduty site.}
		client_url: ${6:# The URL of the monitoring client that is triggering this event.}
		incident_key: ${7:# Identifies the incident to which this I(state) should be applied.}
		client: ${8:# The name of the monitoring client that is triggering this event.}
		desc: ${9:Created via Ansible}
$0
endsnippet

snippet pingdom "Pause/unpause Pingdom alerts"
- name: $1
	pingdom:
		checkid: ${2:}
		passwd: ${3:}
		state: ${4:running|paused}
		uid: ${5:}
		key: ${6:}
$0
endsnippet

snippet rollbar_deployment "Notify Rollbar about app deployments"
- name: $1
	rollbar_deployment:
		environment: ${2:# Name of the environment being deployed, e.g. 'production'.}
		token: ${3:# Your project access token.}
		revision: ${4:# Revision number/sha being deployed.}
		comment: ${5:# Deploy comment (e.g. what is being deployed).}
		rollbar_user: ${6:# Rollbar username of the user who deployed.}
		url: ${7:https://api.rollbar.com/api/1/deploy/}
		user: ${8:# User who deployed.}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet sensu_check "Manage Sensu checks"
- name: $1
	sensu_check:
		name: ${2:# The name of the check}
		command: ${3:# Path to the sensu check to run (not required when I(state=absent))}
		interval: ${4:# Check interval in seconds}
		handle: ${5:yes|no}
		subscribers: ${6:[]}
		metric: ${7:yes|no}
		subdue_begin: ${8:# When to disable handling of check failures}
		dependencies: ${9:[]}
		occurrences: ${10:1}
		low_flap_threshold: ${11:# The low threshhold for flap detection}
		aggregate: ${12:yes|no}
		path: ${13:/etc/sensu/conf.d/checks.json}
		standalone: ${14:yes|no}
		backup: ${15:yes|no}
		handlers: ${16:[]}
		publish: ${17:yes|no}
		custom: ${18:{}}
		source: ${19:# The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).}
		state: ${20:#present|absent}
		high_flap_threshold: ${21:# The high threshhold for flap detection}
		timeout: ${22:10}
		subdue_end: ${23:# When to enable handling of check failures}
		refresh: ${24:# Number of seconds handlers should wait before taking second action}
$0
endsnippet

snippet sensu_subscription "Manage Sensu subscriptions"
- name: $1
	sensu_subscription:
		name: ${2:# The name of the channel}
		path: ${3:/etc/sensu/conf.d/subscriptions.json}
		state: ${4:#present|absent}
		backup: ${5:yes|no}
$0
endsnippet

snippet stackdriver "Send code deploy and annotation events to stackdriver"
- name: $1
	stackdriver:
		key: ${2:# API key.}
		repository: ${3:# The repository (or project) deployed}
		level: ${4:#INFO|WARN|ERROR}
		annotated_by: ${5:Ansible}
		deployed_to: ${6:# The environment code was deployed to. (ie: development, staging, production)}
		deployed_by: ${7:Ansible}
		instance_id: ${8:# id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown}
		msg: ${9:# The contents of the annotation message, in plain text.  Limited to 256 characters. Required for annotation.}
		event_epoch: ${10:# Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.}
		revision_id: ${11:# The revision of the code that was deployed. Required for deploy events}
		event: ${12:annotation|deploy}
$0
endsnippet

snippet statusio_maintenance "Create maintenance windows for your status.io dashboard"
- name: $1
	statusio_maintenance:
		api_id: ${2:# Your unique API ID from status.io}
		statuspage: ${3:# Your unique StatusPage ID from status.io}
		api_key: ${4:# Your unique API Key from status.io}
		maintenance_notify_72_hr: ${5:no}
		maintenance_notify_now: ${6:no}
		start_time: ${7:# Time maintenance is expected to start (Hour:Minutes) (UTC)}
		automation: ${8:no}
		maintenance_notify_24_hr: ${9:no}
		all_infrastructure_affected: ${10:no}
		maintenance_id: ${11:# The maintenance id number when deleting a maintenance window}
		desc: ${12:Created by Ansible}
		maintenance_notify_1_hr: ${13:no}
		title: ${14:A new maintenance window}
		url: ${15:https://api.status.io}
		state: ${16:#present|absent}
		components: ${17:# The given name of your component (server name)}
		minutes: ${18:10}
		start_date: ${19:# Date maintenance is expected to start (Month/Day/Year) (UTC)}
		containers: ${20:# The given name of your container (data center)}
$0
endsnippet

snippet uptimerobot "Pause and start Uptime Robot monitoring"
- name: $1
	uptimerobot:
		monitorid: ${2:}
		state: ${3:started|paused}
		apikey: ${4:}
$0
endsnippet

snippet zabbix_group "Zabbix host groups creates/deletes"
- name: $1
	zabbix_group:
		login_user: ${2:# Zabbix user name.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		host_groups: ${4:# List of host groups to create or delete.}
		login_password: ${5:# Zabbix user password.}
		http_login_password: ${6:# Basic Auth password}
		timeout: ${7:10}
		http_login_user: ${8:# Basic Auth login}
		state: ${9:#present|absent}
$0
endsnippet

snippet zabbix_host "Zabbix host creates/updates/deletes"
- name: $1
	zabbix_host:
		login_user: ${2:# Zabbix user name, used to authenticate against the server.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https).}
		login_password: ${4:# Zabbix user password.}
		host_name: ${5:# Name of the host in Zabbix.}
		status: ${6:#enabled|disabled}
		inventory_mode: ${7:automatic|manual|disabled}
		interfaces: ${8:[]}
		proxy: ${9:# The name of the Zabbix Proxy to be used}
		host_groups: ${10:# List of host groups the host is part of.}
		force: ${11:#yes|no}
		http_login_password: ${12:# Basic Auth password}
		http_login_user: ${13:# Basic Auth login}
		visible_name: ${14:# Visible name of the host in Zabbix.}
		state: ${15:#present|absent}
		timeout: ${16:10}
		link_templates: ${17:# List of templates linked to the host.}
$0
endsnippet

snippet zabbix_hostmacro "Zabbix host macro creates/updates/deletes"
- name: $1
	zabbix_hostmacro:
		macro_name: ${2:# Name of the host macro.}
		macro_value: ${3:# Value of the host macro.}
		login_user: ${4:# Zabbix user name.}
		server_url: ${5:# Url of Zabbix server, with protocol (http or https).}
		host_name: ${6:# Name of the host.}
		login_password: ${7:# Zabbix user password.}
		http_login_password: ${8:# Basic Auth password}
		http_login_user: ${9:# Basic Auth login}
		state: ${10:#present|absent}
		timeout: ${11:10}
$0
endsnippet

snippet zabbix_maintenance "Create Zabbix maintenance windows"
- name: $1
	zabbix_maintenance:
		name: ${2:# Unique name of maintenance window.}
		login_user: ${3:# Zabbix user name.}
		server_url: ${4:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_password: ${5:# Zabbix user password.}
		desc: ${6:Created by Ansible}
		http_login_password: ${7:# Basic Auth password}
		http_login_user: ${8:# Basic Auth login}
		host_names: ${9:# Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.}
		host_groups: ${10:# Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.}
		state: ${11:#present|absent}
		timeout: ${12:10}
		collect_data: ${13:true}
		minutes: ${14:10}
$0
endsnippet

snippet zabbix_screen "Zabbix screen creates/updates/deletes"
- name: $1
	zabbix_screen:
		screens: ${2:# List of screens to be created/updated/deleted(see example).}
		login_password: ${3:# Zabbix user password.}
		login_user: ${4:# Zabbix user name.}
		server_url: ${5:# Url of Zabbix server, with protocol (http or https).}
		http_login_password: ${6:# Basic Auth password}
		timeout: ${7:10}
		http_login_user: ${8:# Basic Auth login}
$0
endsnippet

snippet cloudflare_dns "manage Cloudflare DNS records"
- name: $1
	cloudflare_dns:
		account_email: ${2:# Account email.}
		account_api_token: ${3:# Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://www.cloudflare.com/a/account)}
		zone: ${4:# The name of the Zone to work with (e.g. "example.com"). The Zone must already exist.}
		solo: ${5:# Whether the record should be the only one for that record type and record name. Only use with C(state=present)}
		weight: ${6:1}
		proxied: ${7:no}
		ttl: ${8:1 (automatic)}
		port: ${9:# S}
		service: ${10:# R}
		proto: ${11:tcp|udp}
		value: ${12:# The record value. Required for C(state=present)}
		priority: ${13:1}
		record: ${14:@}
		state: ${15:#present|absent}
		timeout: ${16:30}
		type: ${17:A|AAAA|CNAME|TXT|SRV|MX|NS|SPF}
$0
endsnippet

snippet dnsimple "Interface with dnsimple.com (a DNS hosting service)."
- name: $1
	dnsimple:
		solo: ${2:# Whether the record should be the only one for that record type and record name. Only use with state=present on a record}
		domain: ${3:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned.}
		account_email: ${4:# Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_TOKEN will be looked for. If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started)}
		record_ids: ${5:# List of records to ensure they either exist or don't exist}
		value: ${6:# Record value}
		priority: ${7:# Record priority}
		record: ${8:# Record to add, if blank a record for the domain will be created, supports the wildcard (*)}
		state: ${9:present|absent}
		ttl: ${10:3600 (one hour)}
		type: ${11:A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
		account_api_token: ${12:# Account API token. See I(account_email) for info.}
$0
endsnippet

snippet dnsmadeeasy "Interface with dnsmadeeasy.com (a DNS hosting service)."
- name: $1
	dnsmadeeasy:
		domain: ${2:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution.}
		account_secret: ${3:# Account Secret Key.}
		account_key: ${4:# Account API Key.}
		state: ${5:present|absent}
		record_name: ${6:# Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.}
		record_ttl: ${7:1800}
		record_type: ${8:A|AAAA|CNAME|HTTPRED|MX|NS|PTR|SRV|TXT}
		record_value: ${9:# Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet haproxy "Enable, disable, and set weights for HAProxy backend servers using socket commands."
- name: $1
	haproxy:
		state: ${2:enabled|disabled}
		host: ${3:# Name of the backend host to change.}
		socket: ${4:/var/run/haproxy.sock}
		weight: ${5:# The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.}
		wait_interval: ${6:5}
		backend: ${7:auto-detected}
		wait_retries: ${8:25}
		fail_on_not_found: ${9:no}
		shutdown_sessions: ${10:no}
		wait: ${11:no}
$0
endsnippet

snippet ipify_facts "Retrieve the public IP of your internet gateway."
- name: $1
	ipify_facts:
		api_url: ${2:https://api.ipify.org}
		timeout: ${3:10}
$0
endsnippet

snippet ipinfoio_facts "Retrieve IP geolocation facts of a host's IP address"
- name: $1
	ipinfoio_facts:
		http_agent: ${2:ansible-ipinfoio-module/0.0.1}
		timeout: ${3:10}
$0
endsnippet

snippet ldap_attr "Add or remove LDAP attribute values."
- name: $1
	ldap_attr:
		dn: ${2:# The DN of the entry to modify.}
		name: ${3:# The name of the attribute to modify.}
		values: ${4:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}
		server_uri: ${5:ldapi:///}
		start_tls: ${6:yes|#no}
		bind_dn: ${7:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
		state: ${8:#present|absent|exact}
		bind_pw: ${9:# The password to use with I(bind_dn).}
$0
endsnippet

snippet ldap_entry "Add or remove LDAP entries."
- name: $1
	ldap_entry:
		dn: ${2:# The DN of the entry to add or remove.}
		objectClass: ${3:# If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.}
		start_tls: ${4:yes|#no}
		bind_dn: ${5:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
		server_uri: ${6:ldapi:///}
		state: ${7:#present|absent}
		params: ${8:# List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).}
		bind_pw: ${9:# The password to use with I(bind_dn).}
		attributes: ${10:# If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.}
$0
endsnippet

snippet lldp "get details reported by lldp"
- name: $1
	lldp:
$0
endsnippet

snippet nmcli "Manage Networking"
- name: $1
	nmcli:
		conn_name: ${2:# Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]}
		state: ${3:present|absent}
		ingress: ${4:# This is only used with VLAN - VLAN ingress priority mapping}
		slavepriority: ${5:32}
		path_cost: ${6:100}
		vlandev: ${7:# This is only used with VLAN - parent device this VLAN is on, can use ifname}
		forwarddelay: ${8:15}
		primary: ${9:# This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'}
		hairpin: ${10:yes}
		egress: ${11:# This is only used with VLAN - VLAN egress priority mapping}
		ageingtime: ${12:300}
		dns4: ${13:# A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: ["192.0.2.53", "198.51.100.53"]}
		arp_ip_target: ${14:# This is only used with bond - ARP IP target}
		maxage: ${15:20}
		vlanid: ${16:# This is only used with VLAN - VLAN ID in range <0-4095>}
		priority: ${17:128}
		gw4: ${18:# The IPv4 gateway for this interface using this format ie: "192.0.2.1"}
		gw6: ${19:# The IPv6 gateway for this interface using this format ie: "2001:db8::1"}
		master: ${20:# master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.}
		stp: ${21:# This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge}
		ifname: ${22:conn_name}
		type: ${23:ethernet|team|team-slave|bond|bond-slave|bridge|vlan}
		miimon: ${24:100}
		hellotime: ${25:2}
		downdelay: ${26:# This is only used with bond - downdelay}
		mac: ${27:# This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)}
		ip6: ${28:# The IPv6 address to this interface using this format ie: "abbe::cafe"}
		ip4: ${29:# The IPv4 address to this interface using this format ie: "192.0.2.24/24"}
		autoconnect: ${30:#yes|no}
		dns6: ${31:# A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: ["2001:4860:4860::8888 2001:4860:4860::8844"]}
		mtu: ${32:1500}
		arp_interval: ${33:# This is only used with bond - ARP interval}
		flags: ${34:# This is only used with VLAN - flags}
		mode: ${35:balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb}
		updelay: ${36:# This is only used with bond - updelay}
$0
endsnippet

snippet nsupdate "Manage DNS records."
- name: $1
	nsupdate:
		zone: ${2:# DNS record will be modified on this C(zone).}
		server: ${3:# Apply DNS modification on this server.}
		record: ${4:# Sets the DNS record to modify.}
		key_algorithm: ${5:HMAC-MD5.SIG-ALG.REG.INT|hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hamc-sha384|hmac-sha512}
		key_name: ${6:# Use TSIG key name to authenticate against DNS C(server)}
		value: ${7:# Sets the record value.}
		state: ${8:present|absent}
		ttl: ${9:3600}
		type: ${10:A}
		key_secret: ${11:7911}
$0
endsnippet

snippet omapi_host "Setup OMAPI hosts."
- name: $1
	omapi_host:
		macaddr: ${2:# Sets the lease host MAC address.}
		key_name: ${3:# Sets the TSIG key name for authenticating against OMAPI server.}
		state: ${4:present|absent}
		key: ${5:# Sets the TSIG key content for authenticating against OMAPI server.}
		statements: ${6:[]}
		name: ${7:# Sets the host lease hostname (mandatory if state=present).}
		host: ${8:localhost}
		ddns: ${9:no}
		ip: ${10:# Sets the lease host IP address.}
		port: ${11:7911}
$0
endsnippet

snippet snmp_facts "Retrieve facts for a device using SNMP."
- name: $1
	snmp_facts:
		host: ${2:# Set to target snmp server (normally {{inventory_hostname}})}
		version: ${3:v2|v2c|v3}
		username: ${4:# Username for SNMPv3, required if version is v3}
		level: ${5:authPriv|authNoPriv}
		privacy: ${6:des|aes}
		community: ${7:# The SNMP community string, required if version is v2/v2c}
		authkey: ${8:# Authentication key, required if version is v3}
		integrity: ${9:md5|sha}
		privkey: ${10:# Encryption key, required if version is authPriv}
$0
endsnippet

snippet a10_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' server object."
- name: $1
	a10_server:
		username: ${2:# An account with administrator privileges.}
		server_name: ${3:# The SLB (Server Load Balancer) server name.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		password: ${5:# Password for the C(username) account.}
		write_config: ${6:yes|#no}
		server_ports: ${7:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
		partition: ${8:# set active-partition}
		server_status: ${9:#enabled|disabled}
		state: ${10:#present|absent}
		server_ip: ${11:# The SLB server IPv4 address.}
		validate_certs: ${12:#yes|no}
$0
endsnippet

snippet a10_server_axapi3 "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices"
- name: $1
	a10_server_axapi3:
		username: ${2:# An account with administrator privileges.}
		server_name: ${3:# The SLB (Server Load Balancer) server name.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		server_ip: ${5:# The SLB (Server Load Balancer) server IPv4 address.}
		password: ${6:# Password for the C(username) account.}
		write_config: ${7:yes|#no}
		server_ports: ${8:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).}
		server_status: ${9:#enable|disable}
		operation: ${10:#create|update|remove}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet a10_service_group "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' service groups."
- name: $1
	a10_service_group:
		service_group: ${2:# The SLB (Server Load Balancing) service-group name}
		username: ${3:# An account with administrator privileges.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		password: ${5:# Password for the C(username) account.}
		partition: ${6:# set active-partition}
		servers: ${7:# A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.}
		service_group_protocol: ${8:#tcp|udp}
		write_config: ${9:yes|#no}
		service_group_method: ${10:#round-robin|weighted-rr|least-connection|weighted-least-connection|service-least-connection|service-weighted-least-connection|fastest-response|least-request|round-robin-strict|src-ip-only-hash|src-ip-hash}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet a10_virtual_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' virtual servers."
- name: $1
	a10_virtual_server:
		username: ${2:# An account with administrator privileges.}
		password: ${3:# Password for the C(username) account.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		virtual_server: ${5:# The SLB (Server Load Balancing) virtual server name.}
		partition: ${6:# set active-partition}
		virtual_server_ports: ${7:# A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
		virtual_server_status: ${8:enabled|disabled}
		write_config: ${9:yes|#no}
		virtual_server_ip: ${10:# The SLB virtual server IPv4 address.}
		validate_certs: ${11:#yes|no}
$0
endsnippet

snippet aos_asn_pool "Manage AOS ASN Pool"
- name: $1
	aos_asn_pool:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		ranges: ${3:# List of ASNs ranges to add to the ASN Pool. Each range must have 2 values.}
		content: ${4:# Datastructure of the ASN Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		state: ${5:#present|absent}
		name: ${6:# Name of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
		id: ${7:# AOS Id of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_blueprint "Manage AOS blueprint instance"
- name: $1
	aos_blueprint:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		state: ${3:#present|absent|build-ready}
		reference_arch: ${4:# When creating a blueprint, this value identifies a known AOS reference architecture value. I(Refer to AOS-server documentation for available values).}
		name: ${5:# Name of the Blueprint to manage. Only one of I(name) or I(id) can be set.}
		timeout: ${6:5}
		id: ${7:# AOS Id of the IP Pool to manage (can't be used to create a new IP Pool). Only one of I(name) or I(id) can be set.}
		template: ${8:# When creating a blueprint, this value identifies, by name, an existing engineering design template within the AOS-server.}
$0
endsnippet

snippet aos_blueprint_param "Manage AOS blueprint parameter values"
- name: $1
	aos_blueprint_param:
		blueprint: ${2:# Blueprint Name or Id as defined in AOS.}
		session: ${3:# An existing AOS session as obtained by M(aos_login) module.}
		state: ${4:#present|absent}
		name: ${5:# Name of blueprint parameter, as defined by AOS design template. You can use the option I(get_param_list) to get the complete list of supported parameters for your blueprint.}
		get_param_list: ${6:# Get the complete list of supported parameters for this blueprint and the description of those parameters.}
		value: ${7:# Blueprint parameter value.  This value may be transformed by using the I(param_map) field; used when the the blueprint parameter requires an AOS unique ID value.}
		param_map: ${8:# Defines the aos-pyez collection that will is used to map the user-defined item name into the AOS unique ID value.  For example, if the caller provides an IP address pool I(param_value) called "Server-IpAddrs", then the aos-pyez collection is 'IpPools'. Some I(param_map) are already defined by default like I(logical_device_maps).}
$0
endsnippet

snippet aos_blueprint_virtnet "Manage AOS blueprint parameter values"
- name: $1
	aos_blueprint_virtnet:
		blueprint: ${2:# Blueprint Name or Id as defined in AOS.}
		session: ${3:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${4:# Datastructure of the Virtual Network to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		state: ${5:#present|absent}
		name: ${6:# Name of Virtual Network as part of the Blueprint.}
$0
endsnippet

snippet aos_device "Manage Devices on AOS Server"
- name: $1
	aos_device:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		state: ${3:#normal}
		name: ${4:# The device serial-number; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.}
		approve: ${5:yes|#no}
		id: ${6:# The AOS internal id for a device; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.}
		location: ${7:# When approving a device using the I(approve) argument, it's possible define the location of the device.}
$0
endsnippet

snippet aos_external_router "Manage AOS External Router"
- name: $1
	aos_external_router:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the External Router to create. The format is defined by the I(content_format) parameter. It's the same datastructure that is returned on success in I(value).}
		state: ${4:#present|absent}
		name: ${5:# Name of the External Router to manage. Only one of I(name), I(id) or I(content) can be set.}
		loopback: ${6:# IP address of the Loopback interface of the external_router.}
		asn: ${7:# ASN id of the external_router.}
		id: ${8:# AOS Id of the External Router to manage (can't be used to create a new External Router), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_ip_pool "Manage AOS IP Pool"
- name: $1
	aos_ip_pool:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the IP Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		subnets: ${4:# List of subnet that needs to be part of the IP Pool.}
		state: ${5:#present|absent}
		name: ${6:# Name of the IP Pool to manage. Only one of I(name), I(id) or I(content) can be set.}
		id: ${7:# AOS Id of the IP Pool to manage (can't be used to create a new IP Pool), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_logical_device "Manage AOS Logical Device"
- name: $1
	aos_logical_device:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the Logical Device to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		state: ${4:#present|absent}
		name: ${5:# Name of the Logical Device to manage. Only one of I(name), I(id) or I(content) can be set.}
		id: ${6:# AOS Id of the Logical Device to manage (can't be used to create a new Logical Device), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_logical_device_map "Manage AOS Logical Device Map"
- name: $1
	aos_logical_device_map:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the Logical Device Map to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value). Only one of I(name), I(id) or I(content) can be set.}
		state: ${4:#present|absent}
		name: ${5:# Name of the Logical Device Map to manage. Only one of I(name), I(id) or I(content) can be set.}
		id: ${6:# AOS Id of the Logical Device Map to manage (can't be used to create a new Logical Device Map), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_login "Login to AOS server for session token"
- name: $1
	aos_login:
		server: ${2:# Address of the AOS Server on which you want to open a connection.}
		passwd: ${3:admin}
		user: ${4:admin}
		port: ${5:8888}
$0
endsnippet

snippet aos_rack_type "Manage AOS Rack Type"
- name: $1
	aos_rack_type:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the Rack Type to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		state: ${4:#present|absent}
		name: ${5:# Name of the Rack Type to manage. Only one of I(name), I(id) or I(content) can be set.}
		id: ${6:# AOS Id of the Rack Type to manage (can't be used to create a new Rack Type), Only one of I(name), I(id) or I(content) can be set.}
$0
endsnippet

snippet aos_template "Manage AOS Template"
- name: $1
	aos_template:
		session: ${2:# An existing AOS session as obtained by M(aos_login) module.}
		content: ${3:# Datastructure of the Template to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).}
		state: ${4:#present|absent}
		name: ${5:# Name of the Template to manage. Only one of I(name), I(id) or I(src) can be set.}
		id: ${6:# AOS Id of the Template to manage (can't be used to create a new Template), Only one of I(name), I(id) or I(src) can be set.}
$0
endsnippet

snippet asa_acl "Manage access-lists on a Cisco ASA"
- name: $1
	asa_acl:
		lines: ${2:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		authorize: ${3:yes|no}
		force: ${4:yes|no}
		context: ${5:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		provider: ${6:# A dict object containing connection details.}
		before: ${7:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
		config: ${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuruation to use as the base config for comparison.}
		after: ${9:# The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		match: ${10:#line|strict|exact}
		replace: ${11:#line|block}
$0
endsnippet

snippet asa_command "Run arbitrary commands on Cisco ASA devices."
- name: $1
	asa_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		authorize: ${3:yes|no}
		retries: ${4:10}
		interval: ${5:1}
		context: ${6:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		provider: ${7:# A dict object containing connection details.}
		wait_for: ${8:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		match: ${9:any|#all}
$0
endsnippet

snippet asa_config "Manage Cisco ASA configuration sections"
- name: $1
	asa_config:
		authorize: ${2:yes|no}
		src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		passwords: ${4:yes|no}
		context: ${5:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
		backup: ${6:yes|no}
		after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${8:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		update: ${9:#merge|check}
		replace: ${10:#line|block}
		parents: ${11:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${12:yes|no}
		provider: ${13:# A dict object containing connection details.}
		commit: ${14:#merge|check}
		save: ${15:yes|no}
		config: ${16:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		match: ${17:#line|strict|exact|none}
		before: ${18:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system}
$0
endsnippet

snippet avi_analyticsprofile "Module for setup of AnalyticsProfile Avi RESTful Object"
- name: $1
	avi_analyticsprofile:
		name: ${2:# The name of the analytics profile.}
		disable_se_analytics: ${3:# Disable node (service engine) level analytics forvs metrics.}
		apdex_server_rtt_tolerated_factor: ${4:# Tolerated client to avi round trip time(rtt) factor.}
		hs_security_tls12_score: ${5:# Score assigned when supporting tls1.2 encryption protocol.}
		exclude_no_dns_record_as_error: ${6:# Exclude queries to domains that did not have configured services/records from the list of errors.}
		conn_server_lossy_zero_win_size_event_threshold: ${7:# A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.}
		conn_lossy_total_rexmt_threshold: ${8:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.}
		hs_pscore_traffic_threshold_l4_client: ${9:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
		exclude_no_valid_gs_member_as_error: ${10:# Exclude queries to gslb services that have no available members from the list of errors.}
		hs_security_cipherscore_ge128b: ${11:# Score assigned when the minimum cipher strength is greater than equal to 128 bits.}
		uuid: ${12:# Uuid of the analytics profile.}
		exclude_invalid_dns_domain_as_error: ${13:# Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.}
		exclude_http_error_codes: ${14:# List of http status codes to be excluded from being classified as an error.}
		hs_max_anomaly_penalty: ${15:# Maximum penalty that may be deducted from health score for anomalies.}
		conn_server_lossy_ooo_threshold: ${16:# A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.}
		exclude_persistence_change_as_error: ${17:# Exclude persistence server changed while load balancing' from the list of errors.}
		hs_security_selfsignedcert_penalty: ${18:# Deprecated.}
		conn_server_lossy_total_rexmt_threshold: ${19:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.}
		username: ${20:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		hs_security_certscore_le30d: ${21:# Score assigned when the certificate expires in less than or equal to 30 days.}
		exclude_syn_retransmit_as_error: ${22:# Exclude 'server unanswered syns' from the list of errors.}
		controller: ${23:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		hs_security_hsts_penalty: ${24:# Penalty for not enabling hsts.}
		apdex_rum_threshold: ${25:# If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.}
		password: ${26:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		conn_lossy_zero_win_size_event_threshold: ${27:# A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.}
		hs_security_encalgo_score_rc4: ${28:# Score assigned when rc4 algorithm is used for encryption.}
		apdex_rtt_threshold: ${29:# Satisfactory client to avi round trip time(rtt).}
		tenant_ref: ${30:# It is a reference to an object of type tenant.}
		apdex_response_tolerated_factor: ${31:# Client tolerated response latency factor.}
		exclude_tcp_reset_as_error: ${32:# Exclude tcp resets by client from the list of potential errors.}
		hs_security_chain_invalidity_penalty: ${33:# Penalty for allowing certificates with invalid chain.}
		exclude_invalid_dns_query_as_error: ${34:# Exclude invalid dns queries from the list of errors.}
		conn_lossy_ooo_threshold: ${35:# A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.}
		hs_security_cipherscore_lt128b: ${36:# Score assigned when the minimum cipher strength is less than 128 bits.}
		hs_security_encalgo_score_none: ${37:# Score assigned when no algorithm is used for encryption.}
		hs_event_throttle_window: ${38:# Time window (in secs) within which only unique health change events should occur.}
		hs_security_nonpfs_penalty: ${39:# Penalty for allowing non-pfs handshakes.}
		hs_security_certscore_gt30d: ${40:# Score assigned when the certificate expires in more than 30 days.}
		exclude_server_tcp_reset_as_error: ${41:# Exclude server tcp reset from errors.}
		hs_min_dos_rate: ${42:# Dos connection rate below which the dos security assessment will not kick in.}
		hs_max_resources_penalty: ${43:# Maximum penalty that may be deducted from health score for high resource utilization.}
		apdex_server_response_threshold: ${44:# A server http response is considered satisfied if latency is less than the satisfactory latency threshold.}
		hs_performance_boost: ${45:# Adds free performance score credits to health score.}
		client_log_config: ${46:# Clientlogconfiguration settings for analyticsprofile.}
		hs_security_tls11_score: ${47:# Score assigned when supporting tls1.1 encryption protocol.}
		exclude_gs_down_as_error: ${48:# Exclude queries to gslb services that are operationally down from the list of errors.}
		apdex_server_response_tolerated_factor: ${49:# Server tolerated response latency factor.}
		state: ${50:absent|#present}
		disable_server_analytics: ${51:# Disable analytics on backend servers.}
		conn_server_lossy_timeo_rexmt_threshold: ${52:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
		exclude_client_close_before_request_as_error: ${53:# Exclude client closed connection before an http request could be completed from being classified as an error.}
		hs_security_weak_signature_algo_penalty: ${54:# Penalty for allowing weak signature algorithm(s).}
		conn_lossy_timeo_rexmt_threshold: ${55:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
		apdex_rtt_tolerated_factor: ${56:# Tolerated client to avi round trip time(rtt) factor.}
		description: ${57:# User defined description for the object.}
		hs_security_ssl30_score: ${58:# Score assigned when supporting ssl3.0 encryption protocol.}
		apdex_rum_tolerated_factor: ${59:# Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.}
		hs_security_cipherscore_eq000b: ${60:# Score assigned when the minimum cipher strength is 0 bits.}
		ranges: ${61:# List of http status code ranges to be excluded from being classified as an error.}
		apdex_server_rtt_threshold: ${62:# Satisfactory client to avi round trip time(rtt).}
		exclude_server_dns_error_as_error: ${63:# Exclude server dns error response from the list of errors.}
		hs_security_certscore_le07d: ${64:# Score assigned when the certificate expires in less than or equal to 7 days.}
		resp_code_block: ${65:# Block of http response codes to be excluded from being classified as an error.}
		tenant: ${66:admin}
		hs_pscore_traffic_threshold_l4_server: ${67:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
		hs_max_security_penalty: ${68:# Maximum penalty that may be deducted from health score based on security assessment.}
		tenant_uuid: ${69:}
		url: ${70:# Avi controller URL of the object.}
		hs_security_tls10_score: ${71:# Score assigned when supporting tls1.0 encryption protocol.}
		hs_security_certscore_expired: ${72:# Score assigned when the certificate has expired.}
		apdex_response_threshold: ${73:# If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.}
		exclude_unsupported_dns_query_as_error: ${74:# Exclude unsupported dns queries from the list of errors.}
$0
endsnippet

snippet avi_api_session "Avi API Module"
- name: $1
	avi_api_session:
		http_method: ${2:get|put|post|patch|delete}
		username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		controller: ${4:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		params: ${5:# Query parameters passed to the HTTP API.}
		timeout: ${6:# Timeout (in seconds) for Avi API calls.}
		path: ${7:# Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).}
		password: ${8:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		data: ${9:# HTTP body in YAML or JSON format.}
		tenant_uuid: ${10:}
		tenant: ${11:admin}
$0
endsnippet

snippet avi_applicationpersistenceprofile "Module for setup of ApplicationPersistenceProfile Avi RESTful Object"
- name: $1
	avi_applicationpersistenceprofile:
		persistence_type: ${2:# Method used to persist clients to the same server for a duration of time or a session.}
		name: ${3:# A user-friendly name for the persistence profile.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		uuid: ${5:# Uuid of the persistence profile.}
		app_cookie_persistence_profile: ${6:# Specifies the application cookie persistence profile parameters.}
		tenant_uuid: ${7:}
		tenant_ref: ${8:# It is a reference to an object of type tenant.}
		server_hm_down_recovery: ${9:# Specifies behavior when a persistent server has been marked down by a health monitor.}
		http_cookie_persistence_profile: ${10:# Specifies the http cookie persistence profile parameters.}
		url: ${11:# Avi controller URL of the object.}
		state: ${12:absent|#present}
		ip_persistence_profile: ${13:# Specifies the client ip persistence profile parameters.}
		hdr_persistence_profile: ${14:# Specifies the custom http header persistence profile parameters.}
		password: ${15:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		controller: ${16:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		tenant: ${17:admin}
		description: ${18:# User defined description for the object.}
$0
endsnippet

snippet avi_applicationprofile "Module for setup of ApplicationProfile Avi RESTful Object"
- name: $1
	avi_applicationprofile:
		name: ${2:# The name of the application profile.}
		type: ${3:# Specifies which application layer proxy is enabled for the virtual service.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		tcp_app_profile: ${5:# Specifies the tcp application proxy profile parameters.}
		dns_service_profile: ${6:# Specifies various dns service related controls for virtual service.}
		preserve_client_ip: ${7:# Specifies if client ip needs to be preserved for backend connection.}
		description: ${8:# User defined description for the object.}
		tenant_ref: ${9:# It is a reference to an object of type tenant.}
		controller: ${10:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		http_profile: ${11:# Specifies the http application proxy profile parameters.}
		url: ${12:# Avi controller URL of the object.}
		state: ${13:absent|#present}
		dos_rl_profile: ${14:# Specifies various security related controls for virtual service.}
		password: ${15:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant_uuid: ${16:}
		tenant: ${17:admin}
		uuid: ${18:# Uuid of the application profile.}
$0
endsnippet

snippet avi_certificatemanagementprofile "Module for setup of CertificateManagementProfile Avi RESTful Object"
- name: $1
	avi_certificatemanagementprofile:
		name: ${2:# Name of the pki profile.}
		script_path: ${3:# Script_path of certificatemanagementprofile.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		password: ${5:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		url: ${6:# Avi controller URL of the object.}
		tenant_ref: ${7:# It is a reference to an object of type tenant.}
		controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		state: ${9:absent|#present}
		script_params: ${10:# List of customparams.}
		tenant_uuid: ${11:}
		tenant: ${12:admin}
		uuid: ${13:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_healthmonitor "Module for setup of HealthMonitor Avi RESTful Object"
- name: $1
	avi_healthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		https_monitor: ${5:# Healthmonitorhttp settings for healthmonitor.}
		receive_timeout: ${6:# A valid response from the server is expected within the receive timeout window.}
		description: ${7:# User defined description for the object.}
		controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		udp_monitor: ${9:# Healthmonitorudp settings for healthmonitor.}
		http_monitor: ${10:# Healthmonitorhttp settings for healthmonitor.}
		password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant: ${12:admin}
		successful_checks: ${13:# Number of continuous successful health checks before server is marked up.}
		monitor_port: ${14:# Use this port instead of the port defined for the server in the pool.}
		uuid: ${15:# Uuid of the health monitor.}
		url: ${16:# Avi controller URL of the object.}
		dns_monitor: ${17:# Healthmonitordns settings for healthmonitor.}
		tenant_ref: ${18:# It is a reference to an object of type tenant.}
		failed_checks: ${19:# Number of continuous failed health checks before the server is marked down.}
		tcp_monitor: ${20:# Healthmonitortcp settings for healthmonitor.}
		state: ${21:absent|#present}
		send_interval: ${22:# Frequency, in seconds, that monitors are sent to a server.}
		external_monitor: ${23:# Healthmonitorexternal settings for healthmonitor.}
		tenant_uuid: ${24:}
$0
endsnippet

snippet avi_networkprofile "Module for setup of NetworkProfile Avi RESTful Object"
- name: $1
	avi_networkprofile:
		profile: ${2:# Networkprofileunion settings for networkprofile.}
		name: ${3:# The name of the network profile.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		description: ${5:# User defined description for the object.}
		url: ${6:# Avi controller URL of the object.}
		tenant_ref: ${7:# It is a reference to an object of type tenant.}
		uuid: ${8:# Uuid of the network profile.}
		tenant_uuid: ${9:}
		state: ${10:absent|#present}
		password: ${11:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		controller: ${12:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		tenant: ${13:admin}
$0
endsnippet

snippet avi_pkiprofile "Module for setup of PKIProfile Avi RESTful Object"
- name: $1
	avi_pkiprofile:
		name: ${2:# Name of the pki profile.}
		crls: ${3:# Certificate revocation lists.}
		username: ${4:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		url: ${5:# Avi controller URL of the object.}
		ignore_peer_chain: ${6:# When enabled, avi will not trust intermediate and root certs presented by a client.}
		tenant_ref: ${7:# It is a reference to an object of type tenant.}
		controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		created_by: ${9:# Creator name.}
		ca_certs: ${10:# List of certificate authorities (root and intermediate) trusted that is used for certificate validation.}
		state: ${11:absent|#present}
		validate_only_leaf_crl: ${12:# When enabled, avi will only validate the revocation status of the leaf certificate using crl.}
		crl_check: ${13:# When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.}
		password: ${14:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant_uuid: ${15:}
		tenant: ${16:admin}
		uuid: ${17:# Unique object identifier of the object.}
$0
endsnippet

snippet avi_pool "Module for setup of Pool Avi RESTful Object"
- name: $1
	avi_pool:
		name: ${2:# The name of the pool.}
		lb_algorithm: ${3:# The load balancing algorithm will pick a server within the pool's list of available servers.}
		use_service_port: ${4:# Do not translate the client's destination port when sending the connection to the server.}
		rewrite_host_header_to_server_name: ${5:# Rewrite incoming host header to server name of the server to which the request is proxied.}
		host_check_enabled: ${6:# Enable common name check for server certificate.}
		enabled: ${7:# Enable or disable the pool.}
		rewrite_host_header_to_sni: ${8:# If sni server name is specified, rewrite incoming host header to the sni server name.}
		capacity_estimation: ${9:# Inline estimation of capacity of servers.}
		max_conn_rate_per_server: ${10:# Rate limit connections to each server.}
		servers: ${11:# The pool directs load balanced traffic to this list of destination servers.}
		fewest_tasks_feedback_delay: ${12:# Periodicity of feedback for fewest tasks server selection algorithm.}
		server_auto_scale: ${13:# Server autoscale.}
		ipaddrgroup_ref: ${14:# Use list of servers from ip address group.}
		capacity_estimation_ttfb_thresh: ${15:# The maximum time-to-first-byte of a server.}
		ab_pool: ${16:# A/b pool configuration.}
		fail_action: ${17:# Enable an action - close connection, http redirect, local http response, or backup pool - when a pool failure happens.}
		apic_epg_name: ${18:# Synchronize cisco apic epg members with pool servers.}
		networks: ${19:# (internal-use) networks designated as containing servers for this pool.}
		lb_algorithm_hash: ${20:# Criteria used as a key for determining the hash between the client and  server.}
		health_monitor_refs: ${21:# Verify server health by applying one or more health monitors.}
		sni_enabled: ${22:# Enable tls sni for server connections.}
		server_name: ${23:# Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.}
		lb_algorithm_consistent_hash_hdr: ${24:# Http header name to be used for the hash key.}
		cloud_ref: ${25:# It is a reference to an object of type cloud.}
		created_by: ${26:# Creator name.}
		autoscale_policy_ref: ${27:# Reference to server autoscale policy.}
		ssl_profile_ref: ${28:# When enabled, avi re-encrypts traffic to the backend servers.}
		east_west: ${29:# Inherited config from virtualservice.}
		placement_networks: ${30:# Manually select the networks and subnets used to provide reachability to the pool's servers.}
		graceful_disable_timeout: ${31:# Used to gracefully disable a server.}
		state: ${32:absent|#present}
		tenant: ${33:admin}
		a_pool: ${34:# Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.}
		pki_profile_ref: ${35:# Avi will validate the ssl certificate present by a server against the selected pki profile.}
		vrf_ref: ${36:# Virtual routing context that the pool is bound to.}
		username: ${37:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		application_persistence_profile_ref: ${38:# Persistence will ensure the same user sticks to the same server for a desired duration of time.}
		inline_health_monitor: ${39:# The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.}
		default_server_port: ${40:# Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.}
		description: ${41:# A description of the pool.}
		request_queue_depth: ${42:# Minimum number of requests to be queued when pool is full.}
		server_reselect: ${43:# Server reselect configuration for http requests.}
		ab_priority: ${44:# Priority of this pool in a a-b pool pair.}
		controller: ${45:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		password: ${46:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		server_count: ${47:# Number of server_count.}
		ssl_key_and_certificate_ref: ${48:# Service engines will present a client ssl certificate to the server.}
		uuid: ${49:# Uuid of the pool.}
		autoscale_launch_config_ref: ${50:# Reference to the launch configuration profile.}
		request_queue_enabled: ${51:# Enable request queue when pool is full.}
		max_concurrent_connections_per_server: ${52:# The maximum number of concurrent connections allowed to each server within the pool.}
		url: ${53:# Avi controller URL of the object.}
		prst_hdr_name: ${54:# Header name for custom header persistence.}
		tenant_ref: ${55:# It is a reference to an object of type tenant.}
		autoscale_networks: ${56:# Network ids for the launch configuration.}
		domain_name: ${57:# Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.}
		connection_ramp_duration: ${58:# Duration for which new connections will be gradually ramped up to a server recently brought online.}
		cloud_config_cksum: ${59:# Checksum of cloud configuration for pool.}
		tenant_uuid: ${60:}
$0
endsnippet

snippet avi_poolgroup "Module for setup of PoolGroup Avi RESTful Object"
- name: $1
	avi_poolgroup:
		name: ${2:# The name of the pool group.}
		username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		priority_labels_ref: ${4:# Uuid of the priority labels.}
		description: ${5:# Description of pool group.}
		tenant_uuid: ${6:}
		cloud_ref: ${7:# It is a reference to an object of type cloud.}
		tenant_ref: ${8:# It is a reference to an object of type tenant.}
		controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		created_by: ${10:# Name of the user who created the object.}
		members: ${11:# List of pool group members object of type poolgroupmember.}
		url: ${12:# Avi controller URL of the object.}
		state: ${13:absent|#present}
		cloud_config_cksum: ${14:# Checksum of cloud configuration for poolgroup.}
		min_servers: ${15:# The minimum number of servers to distribute traffic to.}
		fail_action: ${16:# Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.}
		password: ${17:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		deployment_policy_ref: ${18:# When setup autoscale manager will automatically promote new pools into production when deployment goals are met.}
		tenant: ${19:admin}
		uuid: ${20:# Uuid of the pool group.}
$0
endsnippet

snippet avi_role "Module for setup of Role Avi RESTful Object"
- name: $1
	avi_role:
		name: ${2:# Name of the object.}
		username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		uuid: ${4:# Unique object identifier of the object.}
		url: ${5:# Avi controller URL of the object.}
		privileges: ${6:# List of permission.}
		tenant_ref: ${7:# It is a reference to an object of type tenant.}
		controller: ${8:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		state: ${9:absent|#present}
		password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant_uuid: ${11:}
		tenant: ${12:admin}
$0
endsnippet

snippet avi_sslkeyandcertificate "Module for setup of SSLKeyAndCertificate Avi RESTful Object"
- name: $1
	avi_sslkeyandcertificate:
		name: ${2:# Name of the object.}
		certificate: ${3:# Sslcertificate settings for sslkeyandcertificate.}
		status: ${4:# Status of sslkeyandcertificate.}
		username: ${5:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		certificate_management_profile_ref: ${6:# It is a reference to an object of type certificatemanagementprofile.}
		hardwaresecuritymodulegroup_ref: ${7:# It is a reference to an object of type hardwaresecuritymodulegroup.}
		key: ${8:# Private key.}
		key_params: ${9:# Sslkeyparams settings for sslkeyandcertificate.}
		password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant: ${11:admin}
		enckey_base64: ${12:# Encrypted private key corresponding to the private key (e.g.}
		dynamic_params: ${13:# Dynamic parameters needed for certificate management profile.}
		uuid: ${14:# Unique object identifier of the object.}
		url: ${15:# Avi controller URL of the object.}
		enckey_name: ${16:# Name of the encrypted private key (e.g.}
		tenant_ref: ${17:# It is a reference to an object of type tenant.}
		controller: ${18:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		created_by: ${19:# Creator name.}
		state: ${20:absent|#present}
		ca_certs: ${21:# Ca certificates in certificate chain.}
		type: ${22:# Type of sslkeyandcertificate.}
		tenant_uuid: ${23:}
$0
endsnippet

snippet avi_sslprofile "Module for setup of SSLProfile Avi RESTful Object"
- name: $1
	avi_sslprofile:
		name: ${2:# Name of the object.}
		username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		accepted_ciphers: ${4:# Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).}
		prefer_client_cipher_ordering: ${5:# Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.}
		description: ${6:# User defined description for the object.}
		tags: ${7:# List of tag.}
		accepted_versions: ${8:# Set of versions accepted by the server.}
		controller: ${9:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		password: ${10:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant: ${11:admin}
		ssl_session_timeout: ${12:# The amount of time before an ssl session expires.}
		uuid: ${13:# Unique object identifier of the object.}
		url: ${14:# Avi controller URL of the object.}
		tenant_ref: ${15:# It is a reference to an object of type tenant.}
		state: ${16:absent|#present}
		enable_ssl_session_reuse: ${17:# Enable ssl session re-use.}
		cipher_enums: ${18:# Cipher_enums of sslprofile.}
		send_close_notify: ${19:# Send 'close notify' alert message for a clean shutdown of the ssl connection.}
		dhparam: ${20:# Dh parameters used in ssl.}
		ssl_rating: ${21:# Sslrating settings for sslprofile.}
		tenant_uuid: ${22:}
$0
endsnippet

snippet avi_systemconfiguration "Module for setup of SystemConfiguration Avi RESTful Object"
- name: $1
	avi_systemconfiguration:
		username: ${2:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		docker_mode: ${3:# Boolean flag to set docker_mode.}
		dns_configuration: ${4:# Dnsconfiguration settings for systemconfiguration.}
		proxy_configuration: ${5:# Proxyconfiguration settings for systemconfiguration.}
		ssh_hmacs: ${6:# Allowed hmac list for ssh to the management interface on the controller and service engines.}
		linux_configuration: ${7:# Linuxconfiguration settings for systemconfiguration.}
		url: ${8:# Avi controller URL of the object.}
		password: ${9:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		tenant: ${10:admin}
		email_configuration: ${11:# Emailconfiguration settings for systemconfiguration.}
		uuid: ${12:# Unique object identifier of the object.}
		dns_virtualservice_refs: ${13:# Dns virtualservices hosting fqdn records for applications across avi vantage.}
		tech_support_uploader_configuration: ${14:# Techsupportuploaderconfiguration settings for systemconfiguration.}
		controller: ${15:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		global_tenant_config: ${16:# Tenantconfiguration settings for systemconfiguration.}
		snmp_configuration: ${17:# Snmpconfiguration settings for systemconfiguration.}
		state: ${18:absent|#present}
		ntp_configuration: ${19:# Ntpconfiguration settings for systemconfiguration.}
		admin_auth_configuration: ${20:# Adminauthconfiguration settings for systemconfiguration.}
		mgmt_ip_access_control: ${21:# Configure ip access control for controller to restrict open access.}
		ssh_ciphers: ${22:# Allowed ciphers list for ssh to the management interface on the controller and service engines.}
		tenant_uuid: ${23:}
		portal_configuration: ${24:# Portalconfiguration settings for systemconfiguration.}
$0
endsnippet

snippet avi_tenant "Module for setup of Tenant Avi RESTful Object"
- name: $1
	avi_tenant:
		name: ${2:# Name of the object.}
		username: ${3:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		password: ${4:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		url: ${5:# Avi controller URL of the object.}
		controller: ${6:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		uuid: ${7:# Unique object identifier of the object.}
		created_by: ${8:# Creator of this tenant.}
		state: ${9:absent|#present}
		config_settings: ${10:# Tenantconfiguration settings for tenant.}
		local: ${11:# Boolean flag to set local.}
		tenant_uuid: ${12:}
		tenant: ${13:admin}
		description: ${14:# User defined description for the object.}
$0
endsnippet

snippet avi_virtualservice "Module for setup of VirtualService Avi RESTful Object"
- name: $1
	avi_virtualservice:
		name: ${2:# Name for the virtual service.}
		client_auth: ${3:# Http authentication configuration for protected resources.}
		port_uuid: ${4:# (internal-use) network port assigned to the virtual service ip address.}
		availability_zone: ${5:# Availability-zone to place the virtual service.}
		flow_dist: ${6:# Criteria for flow distribution among ses.}
		floating_subnet_uuid: ${7:# If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.}
		delay_fairness: ${8:# Select the algorithm for qos fairness.}
		snat_ip: ${9:# Nat'ted floating source ip address(es) for upstream connection to servers.}
		enable_rhi_snat: ${10:# Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.}
		content_rewrite: ${11:# Profile used to match and rewrite strings in request and/or response body.}
		requests_rate_limit: ${12:# Rate limit the incoming requests to this virtual service.}
		analytics_profile_ref: ${13:# Specifies settings related to analytics.}
		uuid: ${14:# Uuid of the virtualservice.}
		avi_allocated_fip: ${15:# (internal-use) fip allocated by avi in the cloud infrastructure.}
		ssl_profile_ref: ${16:# Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.}
		created_by: ${17:# Creator name.}
		discovered_network_ref: ${18:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
		max_cps_per_client: ${19:# Maximum connections per second per client ip.}
		pool_ref: ${20:# The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.}
		ssl_sess_cache_avg_size: ${21:# Expected number of ssl session cache entries (may be exceeded).}
		ssl_key_and_certificate_refs: ${22:# Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.}
		username: ${23:# Username used for accessing Avi controller. The default value is the environment variable C(AVI_USERNAME).}
		http_policies: ${24:# Http policies applied on the data traffic of the virtual service.}
		application_profile_ref: ${25:# Enable application layer specific features for the virtual service.}
		microservice_ref: ${26:# Microservice representing the virtual service.}
		controller: ${27:# IP address or hostname of the controller. The default value is the environment variable C(AVI_CONTROLLER).}
		password: ${28:# Password of Avi user in Avi controller. The default value is the environment variable C(AVI_PASSWORD).}
		ip_address: ${29:# Ip address of the virtual service.}
		pool_group_ref: ${30:# The pool group is an object that contains pools.}
		east_west_placement: ${31:# Force placement on all se's in service group (mesos mode only).}
		subnet_uuid: ${32:# It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.}
		service_pool_select: ${33:# Select pool based on destination port.}
		flow_label_type: ${34:# Criteria for flow labelling.}
		type: ${35:# Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.}
		enable_autogw: ${36:# Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.}
		discovered_networks: ${37:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
		enabled: ${38:# Enable or disable the virtual service.}
		ipam_network_subnet: ${39:# Subnet and/or network for allocating virtualservice ip by ipam provider module.}
		static_dns_records: ${40:# List of static dns records applied to this virtual service.}
		analytics_policy: ${41:# Determines analytics settings for the application.}
		network_security_policy_ref: ${42:# Network security policies for the virtual service.}
		network_profile_ref: ${43:# Determines network settings such as protocol, tcp or udp, and related options for the protocol.}
		weight: ${44:# The quality of service weight to assign to traffic transmitted from this virtual service.}
		tenant_ref: ${45:# It is a reference to an object of type tenant.}
		remove_listening_port_on_vs_down: ${46:# Remove listening port if virtualservice is down.}
		avi_allocated_vip: ${47:# (internal-use) vip allocated by avi in the cloud infrastructure.}
		dns_info: ${48:# Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.}
		vrf_context_ref: ${49:# Virtual routing context that the virtual service is bound to.}
		subnet: ${50:# Subnet providing reachability for client facing virtual service ip.}
		cloud_type: ${51:# Cloud_type of virtualservice.}
		vh_domain_name: ${52:# The exact name requested from the client's sni-enabled tls hello domain name field.}
		cloud_ref: ${53:# It is a reference to an object of type cloud.}
		enable_rhi: ${54:# Enable route health injection using the bgp config in the vrf context.}
		se_group_ref: ${55:# The service engine group to use for this virtual service.}
		network_ref: ${56:# Manually override the network on which the virtual service is placed.}
		scaleout_ecmp: ${57:# Disable re-distribution of flows across service engines for a virtual service.}
		state: ${58:absent|#present}
		tenant_uuid: ${59:}
		description: ${60:# User defined description for the object.}
		performance_limits: ${61:# Optional settings that determine performance limits like max connections or bandwdith etc.}
		use_bridge_ip_as_vip: ${62:# Use bridge ip as vip on each host in mesos deployments.}
		floating_ip: ${63:# Floating ip to associate with this virtual service.}
		auto_allocate_floating_ip: ${64:# Auto-allocate floating/elastic ip from the cloud infrastructure.}
		host_name_xlate: ${65:# Translate the host name sent to the servers to this value.}
		services: ${66:# List of services defined for this virtual service.}
		connections_rate_limit: ${67:# Rate limit the incoming connections to this virtual service.}
		active_standby_se_tag: ${68:# This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.}
		server_network_profile_ref: ${69:# Determines the network settings profile for the server side of tcp proxied connections.}
		ign_pool_net_reach: ${70:# Ignore pool servers network reachability constraints for virtual service placement.}
		tenant: ${71:admin}
		limit_doser: ${72:# Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.}
		url: ${73:# Avi controller URL of the object.}
		auto_allocate_ip: ${74:# Auto-allocate vip from the provided subnet.}
		fqdn: ${75:# Dns resolvable, fully qualified domain name of the virtualservice.}
		discovered_subnet: ${76:# (internal-use) discovered subnets providing reachability for client facing virtual service ip.}
		vs_datascripts: ${77:# Datascripts applied on the data traffic of the virtual service.}
		cloud_config_cksum: ${78:# Checksum of cloud configuration for vs.}
		vh_parent_vs_uuid: ${79:# Specifies the virtual service acting as virtual hosting (sni) parent.}
$0
endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node"
- name: $1
	get_url:
		dest: ${2:# absolute path of where to download the file to.}
		url: ${3:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		force: ${4:yes|#no}
		url_username: ${5:# The username for use in HTTP basic authentication. This parameter can be used without C(url_password) for sites that allow empty passwords.}
		validate_certs: ${6:#yes|no}
		selevel: ${7:s0}
		force_basic_auth: ${8:yes|#no}
		sha256sum: ${9:# If a SHA-256 checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. This option is deprecated. Use 'checksum'.}
		others: ${10:# all arguments accepted by the M(file) module also work here}
		owner: ${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		url_password: ${12:# The password for use in HTTP basic authentication. If the C(url_username) parameter is not specified, the C(url_password) parameter will not be used.}
		unsafe_writes: ${13:no}
		group: ${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		use_proxy: ${15:#yes|no}
		checksum: ${16:# If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorithm>:<checksum>, e.g.: checksum="sha256:D98291AC[...]B6DC7B97" If you worry about portability, only the sha1 algorithm is available on all platforms and python versions.  The third party hashlib library can be installed for access to additional algorithms. Additionally, if a checksum is passed to this parameter, and the file exist under the C(dest) location, the destination_checksum would be calculated, and if checksum equals destination_checksum, the file download would be skipped (unless C(force) is true). }
		seuser: ${17:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		setype: ${18:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		headers: ${19:# Add custom HTTP headers to a request in the format "key:value,key:value"}
		serole: ${20:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		mode: ${21:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		timeout: ${22:10}
		attributes: ${23:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		backup: ${24:yes|#no}
		tmp_dest: ${25:}
$0
endsnippet

snippet slurp "Slurps a file from remote nodes"
- name: $1
	slurp:
		src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory.}
$0
endsnippet

snippet uri "Interacts with webservices"
- name: $1
	uri:
		url: ${2:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}
		body: ${3:# The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.}
		dest: ${4:# path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.}
		follow_redirects: ${5:all|#safe|none}
		force_basic_auth: ${6:yes|#no}
		removes: ${7:# a filename, when it does not exist, this step will not be run.}
		user: ${8:# username for the module to use for Digest, Basic or WSSE authentication.}
		others: ${9:# all arguments accepted by the M(file) module also work here}
		body_format: ${10:#raw|json}
		password: ${11:# password for the module to use for Digest, Basic or WSSE authentication.}
		HEADER_: ${12:# Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and may be removed in a future release. Use I(headers) instead.}
		creates: ${13:# a filename, when it already exists, this step will not be run.}
		headers: ${14:# Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) for I(body_format).}
		timeout: ${15:30}
		status_code: ${16:200}
		return_content: ${17:yes|#no}
		validate_certs: ${18:#yes|no}
		method: ${19:#GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH}
$0
endsnippet

snippet bigmon_chain "Create and remove a bigmon inline service chain."
- name: $1
	bigmon_chain:
		controller: ${2:# The controller IP address.}
		name: ${3:# The name of the chain.}
		access_token: ${4:# Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}
		state: ${5:#present|absent}
		validate_certs: ${6:#True|False}
$0
endsnippet

snippet bigmon_policy "Create and remove a bigmon out-of-band policy."
- name: $1
	bigmon_policy:
		name: ${2:# The name of the policy.}
		controller: ${3:# The controller address.}
		policy_description: ${4:# Description of policy.}
		access_token: ${5:# Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}
		start_time: ${6:ansible_date_time.iso8601}
		state: ${7:#present|absent}
		priority: ${8:100}
		action: ${9:#forward|drop|flow-gen}
		duration: ${10:0}
		validate_certs: ${11:#True|False}
		delivery_packet_count: ${12:0}
$0
endsnippet

snippet netscaler "Manages Citrix NetScaler entities"
- name: $1
	netscaler:
		name: ${2:hostname}
		nsc_host: ${3:# hostname or ip of your netscaler}
		user: ${4:# username}
		password: ${5:# password}
		type: ${6:#server|service}
		nsc_protocol: ${7:https}
		action: ${8:enable|#disable}
		validate_certs: ${9:#yes|no}
$0
endsnippet

snippet ce_command "Run arbitrary command on HUAWEI CloudEngine devices"
- name: $1
	ce_command:
		commands: ${2:# The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		retries: ${3:10}
		interval: ${4:1}
		provider: ${5:# A dict object containing connection details.}
		wait_for: ${6:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		match: ${7:all}
$0
endsnippet

snippet nclu "Configure network interfaces using NCLU"
- name: $1
	nclu:
		commands: ${2:# A list of strings containing the net commands to run. Mutually exclusive with I(template).}
		abort: ${3:no}
		description: ${4:Ansible-originated commit}
		template: ${5:# A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).}
		commit: ${6:no}
		atomic: ${7:no}
$0
endsnippet

snippet dellos10_command "Run commands on remote devices running Dell OS10"
- name: $1
	dellos10_command:
		commands: ${2:# List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		retries: ${3:10}
		wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		provider: ${5:# A dict object containing connection details.}
		interval: ${6:1}
$0
endsnippet

snippet dellos10_config "Manage Dell EMC Networking OS10 configuration sections"
- name: $1
	dellos10_config:
		src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		config: ${3:# The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node.}
		after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook designer can use this argument  to append a set of commands to be executed after the command set.}
		lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		update: ${6:#merge|check}
		replace: ${7:#line|block}
		parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.}
		provider: ${9:# A dict object containing connection details.}
		save: ${10:yes|no}
		backup: ${11:yes|no}
		match: ${12:#line|strict|exact|none}
		before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can  use this argument to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos10_facts "Collect facts from remote devices running Dell EMC Networking OS10"
- name: $1
	dellos10_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet dellos6_command "Run commands on remote devices running Dell OS6"
- name: $1
	dellos6_command:
		commands: ${2:# List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) as expired.}
		retries: ${3:10}
		wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		provider: ${5:# A dict object containing connection details.}
		interval: ${6:1}
$0
endsnippet

snippet dellos6_config "Manage Dell EMC Networking OS6 configuration sections"
- name: $1
	dellos6_config:
		src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		config: ${3:# The playbook designer can use the C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you specify this argument, the module does not download the running-config from the remote node.}
		after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  As with I(before), the playbook desinger can use this to append a set of commands to be executed after the command set.}
		lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		update: ${6:#merge|check}
		replace: ${7:#line|block}
		parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you do not specify the parents argument, the commands are checked against the set of top level or global commands.}
		provider: ${9:# A dict object containing connection details.}
		save: ${10:yes|no}
		backup: ${11:yes|no}
		match: ${12:#line|strict|exact|none}
		before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos6_facts "Collect facts from remote devices running Dell EMC Networking OS6"
- name: $1
	dellos6_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet dellos9_command "Run commands on remote devices running Dell OS9"
- name: $1
	dellos9_command:
		commands: ${2:# List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		retries: ${3:10}
		wait_for: ${4:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
		provider: ${5:# A dict object containing connection details.}
		interval: ${6:1}
$0
endsnippet

snippet dellos9_config "Manage Dell EMC Networking OS9 configuration sections"
- name: $1
	dellos9_config:
		src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir.  This argument is mutually exclusive with I(lines).}
		config: ${3:# The playbook designer can use the  C(config) argument to supply the base configuration to be used to validate necessary configuration changes.  If you provide this argument, the module does not download the running-config from the remote node.}
		after: ${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made. As with I(before), this the playbook designer can append a set of commands to be executed after the command set.}
		lines: ${5:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Note the configuration command syntax as the device config parser automatically modifies some commands. This argument is mutually exclusive with I(src).}
		update: ${6:#merge|check}
		replace: ${7:#line|block}
		parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If you omit the parents argument, the commands are checked against the set of top level or global commands.}
		provider: ${9:# A dict object containing connection details.}
		save: ${10:yes|no}
		backup: ${11:yes|no}
		match: ${12:#line|strict|exact|none}
		before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  The playbook designer can use this opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet dellos9_facts "Collect facts from remote devices running Dell EMC Networking OS9"
- name: $1
	dellos9_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet eos_banner "Manage multiline banners on Arista EOS devices"
- name: $1
	eos_banner:
		banner: ${2:login|banner}
		authorize: ${3:yes|no}
		state: ${4:#present|absent}
		provider: ${5:# A dict object containing connection details.}
		text: ${6:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).}
		auth_pass: ${7:none}
$0
endsnippet

snippet eos_command "Run arbitrary commands on an Arista EOS device"
- name: $1
	eos_command:
		commands: ${2:# The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		authorize: ${3:yes|no}
		retries: ${4:10}
		auth_pass: ${5:none}
		interval: ${6:1}
		provider: ${7:# A dict object containing connection details.}
		wait_for: ${8:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		match: ${9:any|#all}
$0
endsnippet

snippet eos_config "Manage Arista EOS configuration sections"
- name: $1
	eos_config:
		authorize: ${2:yes|no}
		src: ${3:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
		auth_pass: ${4:none}
		force: ${5:yes|no}
		backup: ${6:yes|no}
		after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${8:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		replace: ${9:#line|block|config}
		parents: ${10:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${11:no}
		provider: ${12:# A dict object containing connection details.}
		save: ${13:no}
		config: ${14:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		match: ${15:#line|strict|exact|none}
		before: ${16:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet eos_eapi "Manage and configure Arista EOS eAPI."
- name: $1
	eos_eapi:
		authorize: ${2:yes|no}
		local_http_port: ${3:8080}
		http_port: ${4:80}
		http: ${5:yes|no}
		https_port: ${6:443}
		auth_pass: ${7:none}
		state: ${8:#started|stopped}
		vrf: ${9:default}
		https: ${10:yes|no}
		provider: ${11:# A dict object containing connection details.}
		config: ${12:nul}
		local_http: ${13:yes|no}
		socket: ${14:yes|no}
$0
endsnippet

snippet eos_facts "Collect facts from remote devices running Arista EOS"
- name: $1
	eos_facts:
		authorize: ${2:yes|no}
		auth_pass: ${3:none}
		gather_subset: ${4:!config}
		provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet eos_system "Manage the system attributes on Arista EOS devices"
- name: $1
	eos_system:
		authorize: ${2:yes|no}
		state: ${3:#present|absent}
		auth_pass: ${4:none}
		provider: ${5:# A dict object containing connection details.}
		lookup_source: ${6:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.}
		name_servers: ${7:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.}
		domain_search: ${8:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		hostname: ${9:# Configure the device hostname parameter. This option takes an ASCII string value.}
		domain_name: ${10:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
$0
endsnippet

snippet eos_user "Manage the collection of local users on EOS devices"
- name: $1
	eos_user:
		username: ${2:# The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(users) argument.}
		authorize: ${3:yes|no}
		update_password: ${4:on_create|#always}
		users: ${5:# The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument.}
		auth_pass: ${6:none}
		purge: ${7:no}
		privilege: ${8:# The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.}
		state: ${9:#present|absent}
		role: ${10:# Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
		provider: ${11:# A dict object containing connection details.}
		nopassword: ${12:# Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.}
		sshkey: ${13:# Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.}
$0
endsnippet

snippet exo_dns_domain "Manages domain records on Exoscale DNS API."
- name: $1
	exo_dns_domain:
		name: ${2:# Name of the record.}
		state: ${3:#present|absent}
		api_key: ${4:# API key of the Exoscale DNS API.}
		api_secret: ${5:# Secret key of the Exoscale DNS API.}
		api_timeout: ${6:10}
		validate_certs: ${7:yes}
		api_region: ${8:cloudstack}
$0
endsnippet

snippet exo_dns_record "Manages DNS records on Exoscale DNS."
- name: $1
	exo_dns_record:
		domain: ${2:# Domain the record is related to.}
		multiple: ${3:# Whether there are more than one records with similar C(name).}
		name: ${4:}
		prio: ${5:# Priority of the record.}
		api_secret: ${6:# Secret key of the Exoscale DNS API.}
		api_timeout: ${7:10}
		api_region: ${8:cloudstack}
		content: ${9:# Content of the record.}
		record_type: ${10:#A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
		state: ${11:#present|absent}
		ttl: ${12:3600}
		api_key: ${13:# API key of the Exoscale DNS API.}
		validate_certs: ${14:yes}
$0
endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings"
- name: $1
	bigip_device_dns:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		search: ${5:# A list of domains that the system searches for local domain lookups, to resolve local host names.}
		cache: ${6:enable|#disable}
		ip_version: ${7:4|6}
		state: ${8:absent|#present}
		server_port: ${9:443}
		forwarders: ${10:# A list of BIND servers that the system can use to perform DNS lookups}
		name_servers: ${11:# A list of name serverz that the system uses to validate DNS lookups}
		validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP"
- name: $1
	bigip_device_ntp:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		ntp_servers: ${5:[]}
		state: ${6:absent|#present}
		server_port: ${7:443}
		timezone: ${8:UTC}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP"
- name: $1
	bigip_device_sshd:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		log_level: ${5:debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose}
		server_port: ${6:443}
		banner_text: ${7:# Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.}
		validate_certs: ${8:#True|False}
		allow: ${9:all|IP address, such as 172.27.1.10|IP range, such as 172.27.*.* or 172.27.0.0/255.255.0.0}
		inactivity_timeout: ${10:# Specifies the number of seconds before inactivity causes an SSH session to log out.}
		login: ${11:enabled|disabled}
		banner: ${12:enabled|disabled}
		port: ${13:# Port that you want the SSH daemon to run on.}
$0
endsnippet

snippet bigip_facts "Collect facts from F5 BIG-IP devices"
- name: $1
	bigip_facts:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		include: ${5:address_class|certificate|client_ssl_profile|device|device_group|interface|key|node|pool|provision|rule|self_ip|software|system_info|traffic_group|trunk|virtual_address|virtual_server|vlan}
		filter: ${6:}
		session: ${7:}
		server_port: ${8:443}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP"
- name: $1
	bigip_gtm_datacenter:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# The name of the data center.}
		description: ${6:# The description of the data center.}
		enabled: ${7:True|False}
		state: ${8:present|absent}
		contact: ${9:# The name of the contact for the data center.}
		location: ${10:# The location of the data center.}
		server_port: ${11:443}
		validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_gtm_facts "Collect facts from F5 BIG-IP GTM devices."
- name: $1
	bigip_gtm_facts:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		include: ${4:pool|wide_ip|virtual_server}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		filter: ${6:# Perform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module.}
		server_port: ${7:443}
		validate_certs: ${8:#True|False}
$0
endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers"
- name: $1
	bigip_gtm_virtual_server:
		virtual_server_name: ${2:# Virtual server name}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		virtual_server_server: ${6:# Virtual server server}
		validate_certs: ${7:#True|False}
		state: ${8:#present|absent|enabled|disabled}
		host: ${9:# Virtual server host}
		server_port: ${10:443}
		port: ${11:# Virtual server port}
$0
endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip"
- name: $1
	bigip_gtm_wide_ip:
		lb_method: ${2:return_to_dns|null|round_robin|ratio|topology|static_persist|global_availability|vs_capacity|least_conn|lowest_rtt|lowest_hops|packet_rate|cpu|hit_ratio|qos|bps|drop_packet|explicit_ip|connection_rate|vs_score}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		wide_ip: ${5:# Wide IP name}
		server: ${6:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		server_port: ${7:443}
		validate_certs: ${8:#True|False}
$0
endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP."
- name: $1
	bigip_hostname:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		hostname: ${4:# Hostname of the BIG-IP host.}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		server_port: ${6:443}
		validate_certs: ${7:#True|False}
$0
endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP."
- name: $1
	bigip_irule:
		src: ${2:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}
		name: ${3:# The name of the iRule.}
		module: ${4:ltm|gtm}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${7:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		partition: ${8:Common}
		content: ${9:# When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.}
		state: ${10:#present|absent}
		server_port: ${11:443}
		validate_certs: ${12:#True|False}
$0
endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors"
- name: $1
	bigip_monitor_http:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${3:# Monitor name}
		receive: ${4:none}
		send: ${5:none}
		server: ${6:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${7:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		receive_disable: ${8:none}
		partition: ${9:Common}
		parent: ${10:http}
		ip: ${11:none}
		interval: ${12:none}
		server_port: ${13:443}
		state: ${14:#present|absent}
		time_until_up: ${15:none}
		timeout: ${16:none}
		parent_partition: ${17:Common}
		validate_certs: ${18:#True|False}
		port: ${19:none}
$0
endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors"
- name: $1
	bigip_monitor_tcp:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		name: ${3:# Monitor name}
		receive: ${4:none}
		send: ${5:none}
		server: ${6:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${7:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		partition: ${8:Common}
		parent: ${9:#tcp|tcp_echo|tcp_half_open}
		ip: ${10:none}
		interval: ${11:none}
		server_port: ${12:443}
		validate_certs: ${13:#True|False}
		state: ${14:#present|absent}
		time_until_up: ${15:none}
		timeout: ${16:none}
		parent_partition: ${17:Common}
		type: ${18:TTYPE_TCP|TTYPE_TCP_ECHO|TTYPE_TCP_HALF_OPEN}
		port: ${19:none}
$0
endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes"
- name: $1
	bigip_node:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		state: ${3:#present|absent}
		server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		host: ${5:}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		session_state: ${7:enabled|disabled}
		name: ${8:}
		monitor_state: ${9:enabled|disabled}
		partition: ${10:}
		monitor_type: ${11:and_list|m_of_n}
		server_port: ${12:443}
		quorum: ${13:}
		validate_certs: ${14:#True|False}
		monitors: ${15:}
		description: ${16:}
$0
endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools"
- name: $1
	bigip_pool:
		name: ${2:}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		lb_method: ${6:#round_robin|ratio_member|least_connection_member|observed_member|predictive_member|ratio_node_address|least_connection_node_address|fastest_node_address|observed_node_address|predictive_node_address|dynamic_ratio|fastest_app_response|least_sessions|dynamic_ratio_member|l3_addr|weighted_least_connection_member|weighted_least_connection_node_address|ratio_session|ratio_least_connection_member|ratio_least_connection_node_address}
		description: ${7:# Specifies descriptive text that identifies the pool.}
		partition: ${8:}
		slow_ramp_time: ${9:}
		state: ${10:#present|absent}
		service_down_action: ${11:none|reset|drop|reselect}
		reselect_tries: ${12:}
		port: ${13:}
		monitor_type: ${14:and_list|m_of_n}
		host: ${15:}
		server_port: ${16:443}
		validate_certs: ${17:#True|False}
		monitors: ${18:}
		quorum: ${19:}
$0
endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members"
- name: $1
	bigip_pool_member:
		state: ${2:#present|absent}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		host: ${4:# Pool member IP}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		port: ${7:# Pool member port}
		pool: ${8:# Pool name. This pool must exist.}
		session_state: ${9:enabled|disabled}
		ratio: ${10:# Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.}
		description: ${11:# Pool member description}
		monitor_state: ${12:enabled|disabled}
		partition: ${13:Common}
		connection_limit: ${14:# Pool member connection limit. Setting this to 0 disables the limit.}
		preserve_node: ${15:True|False}
		server_port: ${16:443}
		rate_limit: ${17:# Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.}
		validate_certs: ${18:#True|False}
$0
endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP"
- name: $1
	bigip_routedomain:
		password: ${2:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		id: ${4:# The unique identifying integer representing the route domain.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		flow_eviction_policy: ${6:# The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.}
		service_policy: ${7:# Service policy to associate with the route domain.}
		description: ${8:# Specifies descriptive text that identifies the route domain.}
		parent: ${9:# S}
		connection_limit: ${10:# The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.}
		strict: ${11:enabled|disabled}
		state: ${12:#present|absent}
		routing_protocol: ${13:BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng}
		server_port: ${14:443}
		bwc_policy: ${15:# The bandwidth controller for the route domain.}
		vlans: ${16:# VLANs for the system to use in the route domain}
		validate_certs: ${17:#True|False}
$0
endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system"
- name: $1
	bigip_selfip:
		name: ${2:Value of C(address)}
		vlan: ${3:# The VLAN that the new self IPs will be on.}
		netmask: ${4:# The netmasks for the self IP.}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${7:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		allow_service: ${8:# Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.}
		state: ${9:absent|#present}
		route_domain: ${10:none}
		server_port: ${11:443}
		address: ${12:# The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.}
		traffic_group: ${13:# The traffic group for the self IP addresses in an active-active, redundant load balancer configuration.}
		validate_certs: ${14:#True|False}
$0
endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP."
- name: $1
	bigip_snat_pool:
		name: ${2:# T}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server_port: ${6:443}
		state: ${7:#present|absent}
		members: ${8:# List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.}
		validate_certs: ${9:#True|False}
		append: ${10:True|#False}
$0
endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP"
- name: $1
	bigip_ssl_certificate:
		name: ${2:# SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partition:name.cer_11111_1 and :Partition_name.key_11111_1).}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		state: ${4:#present|absent}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		validate_certs: ${7:#True|False}
		key_content: ${8:# When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		partition: ${9:Common}
		server_port: ${10:443}
		cert_src: ${11:# This is the local filename of the certificate. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		passphrase: ${12:# Passphrase on certificate private key}
		cert_content: ${13:# When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
		key_src: ${14:# This is the local filename of the private key. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
$0
endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables"
- name: $1
	bigip_sys_db:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		key: ${4:# The database variable to manipulate.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		server_port: ${6:443}
		value: ${7:# The value to set the key to. At least one of value and state C(reset) are required.}
		state: ${8:#present|reset}
		validate_certs: ${9:#True|False}
$0
endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings."
- name: $1
	bigip_sys_global:
		server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		security_banner: ${5:enabled|disabled}
		net_reboot: ${6:enabled|disabled}
		banner_text: ${7:# Specifies the text to present in the advisory banner.}
		console_timeout: ${8:# Specifies the number of seconds of inactivity before the system logs off a user that is logged on.}
		quiet_boot: ${9:# Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.}
		mgmt_dhcp: ${10:enabled|disabled}
		state: ${11:#present}
		server_port: ${12:443}
		gui_setup: ${13:enabled|disabled}
		validate_certs: ${14:#True|False}
		lcd_display: ${15:enabled|disabled}
$0
endsnippet

snippet bigip_virtual_server "Manages F5 BIG-IP LTM virtual servers"
- name: $1
	bigip_virtual_server:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		destination: ${3:# Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist.}
		name: ${4:# Virtual server name}
		server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		route_advertisement_state: ${7:disabled}
		fallback_persistence_profile: ${8:# Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.}
		validate_certs: ${9:#True|False}
		default_persistence_profile: ${10:# Default Profile which manages the session persistence}
		partition: ${11:Common}
		all_profiles: ${12:# List of all Profiles (HTTP,ClientSSL,ServerSSL,etc) that must be used by the virtual server}
		all_rules: ${13:# List of rules to be applied in priority order}
		enabled_vlans: ${14:# List of vlans to be enabled. When a VLAN named C(ALL) is used, all VLANs will be allowed.}
		state: ${15:#present|absent|enabled|disabled}
		all_policies: ${16:# List of all policies enabled for the virtual server.}
		server_port: ${17:443}
		snat: ${18:#None|Automap|Name of a SNAT pool (eg "/Common/snat_pool_name") to enable SNAT with the specific pool}
		port: ${19:# Port of the virtual server. Required when state=present and vs does not exist. If you specify a value for this field, it must be a number between 0 and 65535.}
		pool: ${20:# Default pool for the virtual server}
		description: ${21:# Virtual server description}
$0
endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system"
- name: $1
	bigip_vlan:
		name: ${2:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}
		server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
		untagged_interfaces: ${6:# Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.}
		server_port: ${7:443}
		state: ${8:absent|#present}
		tag: ${9:# Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.}
		tagged_interfaces: ${10:# Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.}
		validate_certs: ${11:#True|False}
		description: ${12:# The description to give to the VLAN.}
$0
endsnippet

snippet fortios_config "Manage fortios firewall config"
- name: $1
	fortios_config:
		username: ${2:# Configures the username used to authenticate to the remote device.}
		host: ${3:# Specifies the DNS hostname or IP address for connecting to the remote fortios device.}
		password: ${4:# Specifies the password used to authenticate to the remote device.}
		src: ${5:# The I(src) argument provides a path to the configuration file to load into the remote device.}
		backup_path: ${6:# Specifies where to store backup files. Required if I(backup=yes).}
		filter: ${7:}
		backup_filename: ${8:# Specifies the backup filename. If omitted filename will be formated like HOST_config.YYYY-MM-DD@HH:MM:SS}
		timeout: ${9:60}
		backup: ${10:yes|no}
		vdom: ${11:# Specifies on which vdom to apply configuration}
$0
endsnippet

snippet fortios_ipv4_policy "Manage fortios firewall IPv4 policy objects"
- name: $1
	fortios_ipv4_policy:
		username: ${2:# Configures the username used to authenticate to the remote device.}
		host: ${3:# Specifies the DNS hostname or IP address for connecting to the remote fortios device.}
		password: ${4:# Specifies the password used to authenticate to the remote device.}
		id: ${5:# Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns}
		comment: ${6:# free text to describe policy.}
		timeout: ${7:60}
		schedule: ${8:always}
		application_list: ${9:# Specifies Application Control name.}
		src_intf: ${10:any}
		service_negate: ${11:true|false}
		ips_sensor: ${12:# Specifies IPS Sensor profile name.}
		dst_addr_negate: ${13:true|false}
		backup_filename: ${14:# Specifies the backup filename. If omitted filename will be formated like HOST_config.YYYY-MM-DD@HH:MM:SS}
		fixedport: ${15:true|false}
		backup_path: ${16:# Specifies where to store backup files. Required if I(backup=yes).}
		webfilter_profile: ${17:# Specifies Webfilter profile name.}
		src_addr: ${18:# Specifies source address (or group) object name(s). Required when I(state=present).}
		service: ${19:# Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).}
		poolname: ${20:# Specifies NAT pool name.}
		policy_action: ${21:accept|deny}
		dst_intf: ${22:any}
		av_profile: ${23:# Specifies Antivirus profile name.}
		state: ${24:#present|absent}
		vdom: ${25:# Specifies on which vdom to apply configuration}
		nat: ${26:true|false}
		src_addr_negate: ${27:true|false}
		backup: ${28:yes|no}
		dst_addr: ${29:# Specifies destination address (or group) object name(s). Required when I(state=present).}
$0
endsnippet

snippet dladm_etherstub "Manage etherstubs on Solaris/illumos systems."
- name: $1
	dladm_etherstub:
		name: ${2:# Etherstub name.}
		state: ${3:#present|absent}
		temporary: ${4:true|false}
$0
endsnippet

snippet dladm_iptun "Manage IP tunnel interfaces on Solaris/illumos systems."
- name: $1
	dladm_iptun:
		name: ${2:# IP tunnel interface name.}
		state: ${3:#present|absent}
		temporary: ${4:no}
		local_address: ${5:# Literat IP address or hostname corresponding to the tunnel source.}
		type: ${6:#ipv4|ipv6|6to4}
		remote_address: ${7:# Literal IP address or hostname corresponding to the tunnel destination.}
$0
endsnippet

snippet dladm_linkprop "Manage link properties on Solaris/illumos systems."
- name: $1
	dladm_linkprop:
		link: ${2:# Link interface name.}
		property: ${3:# Specifies the name of the property we want to manage.}
		state: ${4:#present|absent|reset}
		temporary: ${5:no}
		value: ${6:# Specifies the value we want to set for the link property.}
$0
endsnippet

snippet dladm_vlan "Manage VLAN interfaces on Solaris/illumos systems."
- name: $1
	dladm_vlan:
		link: ${2:# VLAN underlying link name.}
		name: ${3:# VLAN interface name.}
		state: ${4:#present|absent}
		temporary: ${5:no}
		vlan_id: ${6:no}
$0
endsnippet

snippet dladm_vnic "Manage VNICs on Solaris/illumos systems."
- name: $1
	dladm_vnic:
		name: ${2:# VNIC name.}
		link: ${3:# VNIC underlying link name.}
		state: ${4:#present|absent}
		temporary: ${5:true|false}
		vlan: ${6:no}
		mac: ${7:no}
$0
endsnippet

snippet flowadm "Manage bandwidth resource control and priority for protocols, services and zones."
- name: $1
	flowadm:
		name: ${2:# -}
		dsfield: ${3:# -}
		temporary: ${4:true|false}
		maxbw: ${5:# -}
		local_port: ${6:# Identifies a service specified by the local port.}
		local_ip: ${7:# Identifies a network flow by the local IP address.}
		remove_ip: ${8:# Identifies a network flow by the remote IP address.}
		priority: ${9:low|#medium|high}
		state: ${10:absent|#present|resetted}
		link: ${11:# Specifiies a link to configure flow on.}
		transport: ${12:# -}
$0
endsnippet

snippet ipadm_addr "Manage IP addresses on an interface."
- name: $1
	ipadm_addr:
		addrobj: ${2:# Specifies an unique IP address on the system.}
		addrtype: ${3:#static|dhcp|addrconf}
		state: ${4:absent|#present|up|down|enabled|disabled|refreshed}
		temporary: ${5:no}
		address: ${6:# Specifiies an IP address to configure in CIDR notation.}
		wait: ${7:60}
$0
endsnippet

snippet ipadm_addrprop "Manage IP address properties on Solaris/illumos systems."
- name: $1
	ipadm_addrprop:
		property: ${2:# Specifies the name of the address property we want to manage.}
		addrobj: ${3:# Specifies the address object we want to manage.}
		state: ${4:#present|absent|reset}
		temporary: ${5:no}
		value: ${6:# Specifies the value we want to set for the address property.}
$0
endsnippet

snippet ipadm_if "Manage IP interfaces  on Solaris/illumos systems."
- name: $1
	ipadm_if:
		name: ${2:# IP interface name.}
		state: ${3:#present|absent|enabled|disabled}
		temporary: ${4:true|false}
$0
endsnippet

snippet ipadm_ifprop "Manage IP interface properties on Solaris/illumos systems."
- name: $1
	ipadm_ifprop:
		interface: ${2:# Specifies the IP interface we want to manage.}
		protocol: ${3:# Specifies the procotol for which we want to manage properties.}
		property: ${4:# Specifies the name of the property we want to manage.}
		state: ${5:#present|absent|reset}
		temporary: ${6:no}
		value: ${7:# Specifies the value we want to set for the property.}
$0
endsnippet

snippet ipadm_prop "Manage protocol properties on Solaris/illumos systems."
- name: $1
	ipadm_prop:
		protocol: ${2:# Specifies the procotol for which we want to manage properties.}
		property: ${3:# Specifies the name of property we want to manage.}
		state: ${4:#present|absent|reset}
		temporary: ${5:true|false}
		value: ${6:# Specifies the value we want to set for the property.}
$0
endsnippet

snippet ios_banner "Manage multiline banners on Cisco IOS devices"
- name: $1
	ios_banner:
		banner: ${2:login|banner}
		authorize: ${3:yes|no}
		state: ${4:#present|absent}
		provider: ${5:# A dict object containing connection details.}
		text: ${6:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).}
		auth_pass: ${7:none}
$0
endsnippet

snippet ios_command "Run commands on remote devices running Cisco IOS"
- name: $1
	ios_command:
		commands: ${2:# List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		authorize: ${3:yes|no}
		retries: ${4:10}
		auth_pass: ${5:none}
		interval: ${6:1}
		provider: ${7:# A dict object containing connection details.}
		wait_for: ${8:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		match: ${9:any|#all}
$0
endsnippet

snippet ios_config "Manage Cisco IOS configuration sections"
- name: $1
	ios_config:
		multiline_delimiter: ${2:@}
		src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		auth_pass: ${4:none}
		force: ${5:true|false}
		backup: ${6:yes|no}
		after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${8:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		authorize: ${9:yes|no}
		replace: ${10:#line|block}
		parents: ${11:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${12:yes|no}
		provider: ${13:# A dict object containing connection details.}
		save: ${14:yes|no}
		config: ${15:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		match: ${16:#line|strict|exact|none}
		before: ${17:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet ios_facts "Collect facts from remote devices running IOS"
- name: $1
	ios_facts:
		authorize: ${2:yes|no}
		auth_pass: ${3:none}
		gather_subset: ${4:!config}
		provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet ios_system "Manage the system attributes on Cisco IOS devices"
- name: $1
	ios_system:
		authorize: ${2:yes|no}
		state: ${3:#present|absent}
		auth_pass: ${4:none}
		provider: ${5:# A dict object containing connection details.}
		lookup_source: ${6:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
		name_servers: ${7:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
		domain_search: ${8:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		hostname: ${9:# Configure the device hostname parameter. This option takes an ASCII string value.}
		domain_name: ${10:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
		lookup_enabled: ${11:# Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
$0
endsnippet

snippet ios_vrf "Manage the collection of VRF definitions on IOS devices"
- name: $1
	ios_vrf:
		purge: ${2:no}
		rd: ${3:# The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.}
		state: ${4:#present|absent}
		description: ${5:# Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.}
		name: ${6:# The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument}
		provider: ${7:# A dict object containing connection details.}
		interfaces: ${8:# Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.}
		auth_pass: ${9:none}
		authorize: ${10:yes|no}
		vrfs: ${11:# The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.}
$0
endsnippet

snippet iosxr_command "Run commands on remote devices running Cisco iosxr"
- name: $1
	iosxr_command:
		commands: ${2:# List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		retries: ${3:10}
		interval: ${4:1}
		provider: ${5:# A dict object containing connection details.}
		wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		match: ${7:any|#all}
$0
endsnippet

snippet iosxr_config "Manage Cisco IOS XR configuration sections"
- name: $1
	iosxr_config:
		comment: ${2:configured by iosxr_config}
		src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		force: ${4:yes|no}
		config: ${5:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		after: ${6:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${7:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		replace: ${8:#line|block|config}
		parents: ${9:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		provider: ${10:# A dict object containing connection details.}
		backup: ${11:yes|no}
		match: ${12:#line|strict|exact|none}
		before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet iosxr_facts "Collect facts from remote devices running IOS-XR"
- name: $1
	iosxr_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet iosxr_system "Manage the system attributes on Cisco IOS-XR devices"
- name: $1
	iosxr_system:
		state: ${2:#present|absent}
		provider: ${3:# A dict object containing connection details.}
		lookup_source: ${4:# The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
		name_servers: ${5:# The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.}
		domain_search: ${6:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
		hostname: ${7:# Configure the device hostname parameter. This option takes an ASCII string value.}
		domain_name: ${8:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
		lookup_enabled: ${9:# Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
$0
endsnippet

snippet junos_command "Run arbitrary commands on an Juniper JUNOS device"
- name: $1
	junos_command:
		retries: ${2:10}
		commands: ${3:# The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		wait_for: ${4:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		rpcs: ${5:# The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.}
		provider: ${6:# A dict object containing connection details.}
		interval: ${7:1}
		match: ${8:any|#all}
$0
endsnippet

snippet junos_config "Manage configuration on devices running Juniper JUNOS"
- name: $1
	junos_config:
		comment: ${2:configured by junos_config}
		src: ${3:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.}
		rollback: ${4:# The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.}
		confirm: ${5:0}
		lines: ${6:# This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.}
		update: ${7:#merge|override|replace}
		replace: ${8:yes|no}
		zeroize: ${9:# The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.}
		src_format: ${10:xml|set|text|json}
		provider: ${11:# A dict object containing connection details.}
		backup: ${12:yes|no}
$0
endsnippet

snippet junos_facts "Collect facts from remote devices running Junos"
- name: $1
	junos_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet junos_netconf "Configures the Junos Netconf system service"
- name: $1
	junos_netconf:
		state: ${2:#present|absent}
		provider: ${3:# A dict object containing connection details.}
		netconf_port: ${4:830}
$0
endsnippet

snippet junos_package "Installs packages on remote devices running Junos"
- name: $1
	junos_package:
		src: ${2:# The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install.}
		force: ${3:true|false}
		reboot: ${4:true|false}
		version: ${5:# The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename.}
		provider: ${6:# A dict object containing connection details.}
		no_copy: ${7:true|false}
$0
endsnippet

snippet junos_rpc "Runs an arbitrary RPC on the remote device over NetConf"
- name: $1
	junos_rpc:
		rpc: ${2:# The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.}
		output: ${3:xml}
		args: ${4:# The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.}
		provider: ${5:# A dict object containing connection details.}
$0
endsnippet

snippet junos_user "Manage local user accounts on Juniper devices"
- name: $1
	junos_user:
		purge: ${2:no}
		state: ${3:#present|absent}
		role: ${4:operator|#read-only|super-user|unauthorized}
		sshkey: ${5:# The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key}
		full_name: ${6:# The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value.}
		provider: ${7:# A dict object containing connection details.}
		users: ${8:# The C(users) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument.}
		name: ${9:# The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(users) argument.}
$0
endsnippet

snippet cnos_backup "Backup the current running or startup configuration to a remote server on devices running Lenovo CNOS"
- name: $1
	cnos_backup:
		serverpassword: ${2:# Specify the password for the server relating to the protocol used.}
		username: ${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${5:SFTP|SCP|FTP|TFTP}
		configType: ${6:running-config|startup-config}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		password: ${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${11:# -}
		rcpath: ${12:# This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_bgp "Manage BGP resources and attributes on devices running Lenovo CNOS"
- name: $1
	cnos_bgp:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		asNum: ${4:# AS number}
		bgpArg1: ${5:address-family|bestpath|bgp|cluster-id|confederation|enforce-first-as|fast-external-failover|graceful-restart|graceful-restart-helper|log-neighbor-changes|maxas-limit|neighbor|router-id|shutdown|synchronization|timers|vrf}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		bgpArg8: ${9:Un-reachability Half-life time for the penalty(minutes)|backdoor}
		bgpArg4: ${10:Aggregate prefix|Reachability Half-life time|route-map|Distance for routes external|ebgp or ibgp|IP prefix <network>|IP prefix <network>/<length>|synchronization|Delay value|direct|ospf|static|memory}
		bgpArg5: ${11:as-set|summary-only|Value to start reusing a route|Distance for routes internal|Supported multipath numbers|backdoor|map|route-map}
		bgpArg6: ${12:summary-only|as-set|route-map name|Value to start suppressing a route|Distance for local routes|Network mask|Pointer to route-map entries}
		bgpArg7: ${13:Maximum duration to suppress a stable route(minutes)|backdoor|route-map|Name of the route map}
		bgpArg2: ${14:ipv4 or ipv6|always-compare-med|compare-confed-aspath|compare-routerid|dont-compare-originator-id|tie-break-on-age|as-path|med|identifier|peers}
		bgpArg3: ${15:aggregate-address|client-to-client|dampening|distance|maximum-paths|network|nexthop|redistribute|save|synchronization|ignore or multipath-relax|confed or missing-as-worst or non-deterministic or remove-recv-med or remove-send-med}
		enablePassword: ${16:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_command "Execute a single command on devices running Lenovo CNOS"
- name: $1
	cnos_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		clicommand: ${7:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		enablePassword: ${8:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_conditional_command "Execute a single command based on condition on devices running Lenovo CNOS"
- name: $1
	cnos_conditional_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		clicommand: ${4:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		flag: ${6:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		condition: ${9:# If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.}
		enablePassword: ${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_conditional_template "Manage switch configuration using templates based on condition on devices running Lenovo CNOS"
- name: $1
	cnos_conditional_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		flag: ${5:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos}
		condition: ${7:# If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		commandfile: ${9:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_LP21_commands.txt}
		enablePassword: ${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_factory "Reset the switch's startup configuration to default (factory) on devices running Lenovo CNOS"
- name: $1
	cnos_factory:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_facts "Collect facts on devices running Lenovo CNOS"
- name: $1
	cnos_facts:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_image "Perform firmware upgrade/download from a remote server on devices running Lenovo CNOS"
- name: $1
	cnos_image:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${4:SFTP|SCP|FTP|TFTP}
		serverip: ${5:# This specifies the IP Address of the remote server from where the software image will be downloaded.}
		imgpath: ${6:# This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		imgtype: ${10:all|boot|os|onie}
		password: ${11:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		serverpassword: ${12:# Specify the password for the server relating to the protocol used.}
		enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_interface "Manage interface configuration on devices running Lenovo CNOS"
- name: $1
	cnos_interface:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${3:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		interfaceOption: ${5:None|ethernet|loopback|mgmt|port-aggregation|vlan}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos}
		interfaceRange: ${8:# This specifies the interface range in which the port aggregation is envisaged}
		interfaceArg1: ${9:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		interfaceArg4: ${10:key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface}
		interfaceArg5: ${11:name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32}
		interfaceArg6: ${12:Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent}
		interfaceArg7: ${13:Authentication key string|admin-down}
		enablePassword: ${14:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		interfaceArg2: ${15:aggregation-group number|access or mode or trunk|description|auto or full or half|recieve or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port}
		interfaceArg3: ${16:active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queing|Enter the allowed traffic level|ipv6}
$0
endsnippet

snippet cnos_portchannel "Manage portchannel (port aggregation) configuration on devices running Lenovo CNOS"
- name: $1
	cnos_portchannel:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${3:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos}
		interfaceRange: ${7:# This specifies the interface range in which the port aggregation is envisaged}
		interfaceArg1: ${8:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		interfaceArg4: ${9:key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface}
		interfaceArg5: ${10:name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32}
		interfaceArg6: ${11:Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent}
		interfaceArg7: ${12:Authentication key string|admin-down}
		enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		interfaceArg2: ${14:aggregation-group number|access or mode or trunk|description|auto or full or half|recieve or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port}
		interfaceArg3: ${15:active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queing|Enter the allowed traffic level|ipv6}
$0
endsnippet

snippet cnos_reload "Perform switch restart on devices running Lenovo CNOS"
- name: $1
	cnos_reload:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_rollback "Roll back the running or startup configuration from a remote server on devices running Lenovo CNOS"
- name: $1
	cnos_rollback:
		serverpassword: ${2:# Specify the password for the server relating to the protocol used.}
		username: ${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		protocol: ${5:SFTP|SCP|FTP|TFTP}
		configType: ${6:running-config|startup-config}
		host: ${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos}
		serverusername: ${9:# Specify the username for the server relating to the protocol used.}
		password: ${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${11:# This specifies the IP Address of the remote server from where the backup configuration will be downloaded.}
		rcpath: ${12:# This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		enablePassword: ${13:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_save "Save the running configuration as the startup configuration on devices running Lenovo CNOS"
- name: $1
	cnos_save:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_showrun "Collect the current running configuration on devices running Lenovo CNOS"
- name: $1
	cnos_showrun:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		enablePassword: ${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_template "Manage switch configuration using templates on devices running Lenovo CNOS"
- name: $1
	cnos_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		commandfile: ${7:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt}
		enablePassword: ${8:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_vlag "Manage VLAG resources and attributes on devices running Lenovo CNOS"
- name: $1
	cnos_vlag:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		vlagArg1: ${4:enable|auto-recovery|config-consistency|isl|mac-address-table|peer-gateway|priority|startup-delay|tier-id|vrrp|instance|hlthchk}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		vlagArg2: ${8:Interval in seconds|disable or strict|Port Aggregation Number|VLAG priority|Delay time in seconds|VLAG tier-id value|VLAG instance number|keepalive-attempts|keepalive-interval|retry-interval|peer-ip}
		vlagArg3: ${9:enable or port-aggregation|Number of keepalive attempts|Interval in seconds|Interval in seconds|VLAG health check peer IP4 address}
		vlagArg4: ${10:Port Aggregation Number|default or management}
		enablePassword: ${11:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet cnos_vlan "Manage VLAN resources and attributes on devices running Lenovo CNOS"
- name: $1
	cnos_vlan:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		vlanArg1: ${5:access-map|dot1q|filter|<1-3999> VLAN ID 1-3999 or range}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		vlanArg5: ${8:access-list name|Slot/chassis number|Port Aggregation Number}
		vlanArg4: ${9:drop or forward or redirect|ip or mac|Interval in seconds|ethernet|port-aggregation|Querier IP address|Querier Timeout in seconds|Query Interval in seconds|Query Max Response Time in seconds|Robustness Variable value|Number of queries sent at startup|Query Interval at startup}
		vlanArg3: ${10:action|match|statistics|enter VLAN id or range of vlan|ascii name for the VLAN|ipv4 or ipv6|active or suspend|fast-leave|last-member-query-interval|mrouter|querier|querier-timeout|query-interval|query-max-response-time|report-suppression|robustness-variable|startup-query-count|startup-query-interval|static-group}
		vlanArg2: ${11:VLAN Access Map name|egress-only|name|flood|state|ip}
		enablePassword: ${12:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
$0
endsnippet

snippet netconf_config "netconf device configuration"
- name: $1
	netconf_config:
		username: ${2:# the username to authenticate with}
		xml: ${3:# the XML content to send to the device}
		host: ${4:# the hostname or ip address of the netconf device}
		password: ${5:# password of the user to authenticate with}
		hostkey_verify: ${6:yes}
		port: ${7:830}
$0
endsnippet

snippet pn_cluster "CLI command to create/delete a cluster."
- name: $1
	pn_cluster:
		pn_name: ${2:# Specify the name of the cluster.}
		state: ${3:present|absent}
		pn_cluster_node1: ${4:# Specify the name of the first switch in the cluster.}
		pn_clipassword: ${5:# Provide login password if user is not root.}
		pn_cliusername: ${6:# Provide login username if user is not root.}
		pn_validate: ${7:validate|no-validate}
		pn_cliswitch: ${8:# Target switch to run the cli on.}
		pn_cluster_node2: ${9:# Specify the name of the second switch in the cluster.}
$0
endsnippet

snippet pn_ospf "CLI command to add/remove ospf protocol to a vRouter."
- name: $1
	pn_ospf:
		state: ${2:#present|absent}
		pn_vrouter_name: ${3:# Specify the name of the vRouter.}
		pn_network_ip: ${4:# Specify the network IP (IPv4 or IPv6) address.}
		pn_clipassword: ${5:# Provide login password if user is not root.}
		pn_ospf_area: ${6:# Stub area number for the configuration. Required for vrouter-ospf-add.}
		pn_cliswitch: ${7:# Target switch to run the CLI on.}
		pn_cliusername: ${8:# Provide login username if user is not root.}
$0
endsnippet

snippet pn_ospfarea "CLI command to add/remove ospf area to/from a vrouter."
- name: $1
	pn_ospfarea:
		pn_ospf_area: ${2:# Specify the OSPF area number.}
		pn_clipassword: ${3:# Login password.}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		pn_cliusername: ${5:# Login username.}
		state: ${6:present|absent|update}
		pn_prefix_listin: ${7:# OSPF prefix list for filtering incoming packets.}
		pn_prefix_listout: ${8:# OSPF prefix list for filtering outgoing packets.}
		pn_stub_type: ${9:none|stub|stub-no-summary|nssa|nssa-no-summary}
		pn_cliswitch: ${10:# Target switch(es) to run the CLI on.}
		pn_quiet: ${11:yes}
$0
endsnippet

snippet pn_show "Run show commands on nvOS device."
- name: $1
	pn_show:
		pn_command: ${2:# The C(pn_command) takes a CLI show command as value.}
		pn_parameters: ${3:# Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.}
		pn_options: ${4:# Specify formatting options.}
		pn_clipassword: ${5:# Provide login password if user is not root.}
		pn_cliswitch: ${6:# Target switch(es) to run the cli on.}
		pn_cliusername: ${7:# Provide login username if user is not root.}
$0
endsnippet

snippet pn_trunk "CLI command to create/delete/modify a trunk."
- name: $1
	pn_trunk:
		pn_name: ${2:# Specify the name for the trunk configuration.}
		state: ${3:present|absent|update}
		pn_unknown_mcast_level: ${4:# Specify an unknown multicast level in percent. The default value is 100%.}
		pn_jumbo: ${5:# Specify if the port can receive jumbo frames.}
		pn_lacp_fallback_timeout: ${6:# Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.}
		pn_unknown_ucast_level: ${7:# Specify an unknown unicast level in percent. The default value is 100%.}
		pn_lacp_timeout: ${8:slow|fast}
		pn_loopback: ${9:# Specify loopback if you want to use loopback.}
		pn_speed: ${10:disable|10m|100m|1g|2.5g|10g|40g}
		pn_edge_switch: ${11:# Specify if the switch is an edge switch.}
		pn_host: ${12:# Host facing port control setting.}
		pn_port_macaddr: ${13:# Specify the MAC address of the port.}
		pn_lacp_fallback: ${14:bundle|individual}
		pn_routing: ${15:# Specify if the port participates in routing on the network.}
		pn_clipassword: ${16:# Provide login password if user is not root.}
		pn_mirror_receive: ${17:# Specify if the configuration receives mirrored traffic.}
		pn_egress_rate_limit: ${18:# Specify an egress port data rate limit for the configuration.}
		pn_cliusername: ${19:# Provide login username if user is not root.}
		pn_lacp_mode: ${20:off|passive|active}
		pn_ports: ${21:# Specify the port number(s) for the link(s) to aggregate into the trunk.}
		pn_lacp_priority: ${22:# Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.}
		pn_broadcast_level: ${23:# Specify a broadcast level in percent. The default value is 100%.}
		pn_pause: ${24:# Specify if pause frames are sent.}
		pn_cliswitch: ${25:# Target switch(es) to run the cli on.}
		pn_loopvlans: ${26:# Specify a list of looping vlans.}
		pn_description: ${27:# Specify a description for the trunk configuration.}
$0
endsnippet

snippet pn_vlag "CLI command to create/delete/modify vlag."
- name: $1
	pn_vlag:
		pn_name: ${2:# The C(pn_name) takes a valid name for vlag configuration.}
		state: ${3:present|absent|update}
		pn_lacp_fallback: ${4:bundle|individual}
		pn_lacp_fallback_timeout: ${5:# Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.}
		pn_clipassword: ${6:# Provide login password if user is not root.}
		pn_lacp_timeout: ${7:slow|fast}
		pn_cliusername: ${8:# Provide login username if user is not root.}
		pn_lacp_mode: ${9:off|passive|active}
		pn_failover_action: ${10:move|ignore}
		pn_peer_port: ${11:# Specify the peer VLAG port.}
		pn_peer_switch: ${12:# Specify the fabric-name of the peer switch.}
		pn_port: ${13:# Specify the local VLAG port.}
		pn_cliswitch: ${14:# Target switch(es) to run this command on.}
		pn_mode: ${15:active-active|active-standby}
$0
endsnippet

snippet pn_vlan "CLI command to create/delete a VLAN."
- name: $1
	pn_vlan:
		pn_vlanid: ${2:# Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.}
		state: ${3:present|absent}
		pn_scope: ${4:fabric|local}
		pn_clipassword: ${5:# Provide login password if user is not root.}
		pn_cliusername: ${6:# Provide login username if user is not root.}
		pn_ports: ${7:# Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.}
		pn_untagged_ports: ${8:# Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.}
		pn_cliswitch: ${9:# Target switch(es) to run the cli on.}
		pn_stats: ${10:# Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.}
		pn_description: ${11:# Specify a description for the VLAN.}
$0
endsnippet

snippet pn_vrouter "CLI command to create/delete/modify a vrouter."
- name: $1
	pn_vrouter:
		pn_name: ${2:# Specify the name of the vRouter.}
		state: ${3:present|absent|update}
		pn_rip_redistribute: ${4:static|connected|ospf|bgp}
		pn_bgp_options: ${5:# Specify other BGP options as a whitespaces separated string within single quotes ''.}
		pn_router_id: ${6:# Specify the vRouter IP address.}
		pn_ospf_options: ${7:# Specify other OSPF options as a whitespaces separated string within single quotes ''.}
		pn_bgp_as: ${8:# Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).}
		pn_ospf_redistribute: ${9:static|connected|bgp|rip}
		pn_clipassword: ${10:# Provide login password if user is not root.}
		pn_bgp_redistribute: ${11:static|connected|rip|ospf}
		pn_router_type: ${12:hardware|software}
		pn_hw_vrrp_id: ${13:# Specifies the VRRP ID for a hardware vrouter.}
		pn_vnet: ${14:# Specify the name of the VNET.}
		pn_cliusername: ${15:# Provide login username if user is not root.}
		pn_service_state: ${16:enable|disable}
		pn_service_type: ${17:dedicated|shared}
		pn_cliswitch: ${18:# Target switch(es) to run the CLI on.}
		pn_bgp_max_paths: ${19:# Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.}
$0
endsnippet

snippet pn_vrouterbgp "CLI command to add/remove/modify vrouter-bgp."
- name: $1
	pn_vrouterbgp:
		pn_vrouter_name: ${2:# Specify a name for the vRouter service.}
		state: ${3:present|absent|update}
		pn_max_prefix: ${4:# Specify the maximum number of prefixes.}
		pn_route_mapout: ${5:# Specify outbound route map for neighbor.}
		pn_neighbor: ${6:# Specify a neighbor IP address to use for BGP.}
		pn_override_capability: ${7:# Specify if you want to override capability.}
		pn_route_mapin: ${8:# Specify inbound route map for neighbor.}
		pn_soft_reconfig: ${9:# Specify if you want a soft reconfiguration of inbound traffic.}
		pn_ebgp: ${10:# Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.}
		pn_prefix_listin: ${11:# Specify the prefix list to filter traffic inbound.}
		pn_bfd: ${12:# Specify if you want BFD protocol support for fault detection.}
		pn_password: ${13:# Specify a password, if desired.}
		pn_route_reflector: ${14:# Specify if a route reflector client is used.}
		pn_keepalive: ${15:# Specify BGP neighbor keepalive interval in seconds.}
		pn_max_prefix_warn: ${16:# Specify if you want a warning message when the maximum number of prefixes is exceeded.}
		pn_multiprotocol: ${17:ipv4-unicast|ipv6-unicast}
		pn_clipassword: ${18:# Provide login password if user is not root.}
		pn_default_originate: ${19:# Specify if you want announce default routes to the neighbor or not.}
		pn_cliusername: ${20:# Provide login username if user is not root.}
		pn_weight: ${21:# Specify a default weight value between 0 and 65535 for the neighbor routes.}
		pn_prefix_listout: ${22:# Specify the prefix list to filter traffic outbound.}
		pn_remote_as: ${23:# Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.}
		pn_cliswitch: ${24:# Target switch(es) to run the cli on.}
		pn_holdtime: ${25:# Specify BGP neighbor holdtime in seconds.}
		pn_next_hop_self: ${26:# Specify if the next-hop is the same router or not.}
$0
endsnippet

snippet pn_vrouterif "CLI command to add/remove/modify vrouter-interface."
- name: $1
	pn_vrouterif:
		pn_vrouter_name: ${2:# Specify the name of the vRouter interface.}
		state: ${3:present|absent|update}
		pn_nic_enable: ${4:# Specify if the NIC is enabled or not}
		pn_vrrp_adv_int: ${5:# Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.}
		pn_vrrp_priority: ${6:# Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).}
		pn_alias: ${7:# Specify an alias for the interface.}
		pn_secondary_macs: ${8:# Specify a secondary MAC address for the interface.}
		pn_interface_ip: ${9:# Specify the IP address of the interface in x.x.x.x/n format.}
		pn_vlan: ${10:# Specify the VLAN identifier. This is a value between 1 and 4092.}
		pn_vxlan: ${11:# Specify the VXLAN identifier. This is a value between 1 and 16777215.}
		pn_exclusive: ${12:# Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.}
		pn_nic_str: ${13:# Specify the type of NIC. Used for vrouter-interface remove/modify.}
		pn_clipassword: ${14:# Provide login password if user is not root.}
		pn_vrrp_id: ${15:# Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.}
		pn_cliusername: ${16:# Provide login username if user is not root.}
		pn_interface: ${17:mgmt|data|span}
		pn_l3port: ${18:# Specify a Layer 3 port for the interface.}
		pn_cliswitch: ${19:# Target switch to run the cli on.}
		pn_assignment: ${20:none|dhcp|dhcpv6|autov6}
$0
endsnippet

snippet pn_vrouterlbif "CLI command to add/remove vrouter-loopback-interface."
- name: $1
	pn_vrouterlbif:
		pn_interface_ip: ${2:# Specify the IP address.}
		state: ${3:present|absent}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		pn_clipassword: ${5:# Provide login password if user is not root.}
		pn_cliusername: ${6:# Provide login username if user is not root.}
		pn_cliswitch: ${7:# Target switch(es) to run the cli on.}
		pn_index: ${8:# Specify the interface index from 1 to 255.}
$0
endsnippet

snippet nxos_aaa_server "Manages AAA server global configuration."
- name: $1
	nxos_aaa_server:
		server_type: ${2:radius|tacacs}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		state: ${5:#present|default}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		deadtime: ${10:# Duration for which a non-reachable AAA server is skipped, in minutes. Range is 1-1440. Device default is 0.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${13:0 (use common port)}
		server_timeout: ${14:# Global AAA server timeout period, in seconds. Range is 1-60. Device default is 5.}
		encrypt_type: ${15:0|7}
		directed_request: ${16:enabled|disabled}
		global_key: ${17:# Global AAA shared secret.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_aaa_server_host "Manages AAA server host-specific configuration."
- name: $1
	nxos_aaa_server_host:
		server_type: ${2:radius|tacacs}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		address: ${4:# Address or name of the radius or tacacs host.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${8:10}
		encrypt_type: ${9:0|7}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		auth_port: ${11:# Alternate UDP port for RADIUS authentication.}
		tacacs_port: ${12:# Alternate TCP port TACACS Server.}
		host_timeout: ${13:# Timeout period for specified host, in seconds. Range is 1-60.}
		state: ${14:#present|absent}
		key: ${15:# Shared secret for the specified host.}
		acct_port: ${16:# Alternate UDP port for RADIUS accounting.}
		use_ssl: ${17:yes|no}
		password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${19:yes|no}
		port: ${20:0 (use common port)}
$0
endsnippet

snippet nxos_acl "Manages access list entries for ACLs."
- name: $1
	nxos_acl:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		name: ${4:# Case sensitive name of the access list (ACL).}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		src_port_op: ${6:any|eq|gt|lt|neq|range}
		psh: ${7:enable}
		seq: ${8:# Sequence number of the entry (ACE).}
		src: ${9:# Source ip and mask using IP/MASK notation and supports keyword 'any'.}
		dest: ${10:# Destination ip and mask using IP/MASK notation and supports the keyword 'any'.}
		syn: ${11:enable}
		dscp: ${12:af11|af12|af13|af21|af22|af23|af31|af32|af33|af41|af42|af43|cs1|cs2|cs3|cs4|cs5|cs6|cs7|default|ef}
		time-range: ${13:# Name of time-range to apply.}
		ssh_keyfile: ${14:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		dest_port_op: ${15:any|eq|gt|lt|neq|range}
		rst: ${16:enable}
		use_ssl: ${17:yes|no}
		password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		dest_port2: ${19:# Second (end) port when using range operand.}
		established: ${20:enable}
		remark: ${21:# If action is set to remark, this is the description.}
		urg: ${22:enable}
		log: ${23:enable}
		proto: ${24:# Port number or protocol (as supported by the switch).}
		ack: ${25:enable}
		src_port1: ${26:# Port/protocol and also first (lower) port when using range operand.}
		precedence: ${27:critical|flash|flash-override|immediate|internet|network|priority|routine}
		port: ${28:0 (use common port)}
		validate_certs: ${29:yes|no}
		state: ${30:#present|absent|delete_acl}
		timeout: ${31:10}
		provider: ${32:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		action: ${33:permit|deny|remark}
		dest_port1: ${34:# Port/protocol and also first (lower) port when using range operand.}
		fragments: ${35:enable}
		fin: ${36:enable}
		src_port2: ${37:# Second (end) port when using range operand.}
$0
endsnippet

snippet nxos_acl_interface "Manages applying ACLs to interfaces."
- name: $1
	nxos_acl_interface:
		direction: ${2:ingress|egress}
		name: ${3:# Case sensitive name of the access list (ACL).}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${5:# Full name of interface, e.g. I(Ethernet1/1).}
		transport: ${6:cli}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${9:#present|absent}
		timeout: ${10:10}
		provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_bgp "Manages BGP configuration."
- name: $1
	nxos_bgp:
		transport: ${2:cli}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		asn: ${4:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		neighbor_down_fib_accelerate: ${5:true|false}
		confederation_peers: ${6:# AS confederation parameters.}
		confederation_id: ${7:# Routing domain confederation AS.}
		event_history_cli: ${8:size_small|size_medium|size_large|size_disable|default}
		bestpath_always_compare_med: ${9:true|false}
		cluster_id: ${10:# Route Reflector Cluster-ID.}
		shutdown: ${11:true|false}
		log_neighbor_changes: ${12:true|false}
		use_ssl: ${13:yes|no}
		bestpath_aspath_multipath_relax: ${14:true|false}
		port: ${15:0 (use common port)}
		graceful_restart_timers_stalepath_time: ${16:true|false}
		password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		maxas_limit: ${18:# Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.}
		bestpath_med_confed: ${19:true|false}
		isolate: ${20:true|false}
		timer_bgp_keepalive: ${21:# Set BGP keepalive timer.}
		bestpath_cost_community_ignore: ${22:true|false}
		fast_external_fallover: ${23:true|false}
		state: ${24:#present|absent}
		disable_policy_batching: ${25:true|false}
		suppress_fib_pending: ${26:true|false}
		bestpath_med_missing_as_worst: ${27:true|false}
		router_id: ${28:# Router Identifier (ID) of the BGP router VRF instance.}
		timer_bestpath_limit: ${29:# Specify timeout for the first best path after a restart, in seconds.}
		provider: ${30:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		local_as: ${31:# Local AS number to be used within a VRF instance.}
		event_history_periodic: ${32:size_small|size_medium|size_large|size_disable|default}
		timer_bestpath_limit_always: ${33:true|false}
		disable_policy_batching_ipv4_prefix_list: ${34:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
		vrf: ${35:# Name of the VRF. The name 'default' is a valid VRF representing the global BGP.}
		graceful_restart_helper: ${36:true|false}
		timer_bgp_hold: ${37:# Set BGP hold timer.}
		event_history_events: ${38:size_small|size_medium|size_large|size_disable|default}
		disable_policy_batching_ipv6_prefix_list: ${39:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
		event_history_detail: ${40:size_small|size_medium|size_large|size_disable|default}
		ssh_keyfile: ${41:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		graceful_restart: ${42:true|false}
		flush_routes: ${43:true|false}
		enforce_first_as: ${44:true|false}
		bestpath_med_non_deterministic: ${45:true|false}
		username: ${46:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		reconnect_interval: ${47:# The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.}
		timeout: ${48:10}
		graceful_restart_timers_restart: ${49:true|false}
		validate_certs: ${50:yes|no}
		bestpath_compare_routerid: ${51:true|false}
$0
endsnippet

snippet nxos_bgp_af "Manages BGP Address-family configuration."
- name: $1
	nxos_bgp_af:
		transport: ${2:cli}
		afi: ${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${4:unicast|multicast|evpn}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${6:# Name of the VRF. The name 'default' is a valid VRF representing the global bgp.}
		asn: ${7:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		username: ${8:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		dampening_max_suppress_time: ${9:# Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.}
		additional_paths_send: ${10:true|false}
		additional_paths_install: ${11:true|false}
		dampening_state: ${12:true|false}
		additional_paths_receive: ${13:true|false}
		suppress_inactive: ${14:true|false}
		use_ssl: ${15:yes|no}
		dampening_routemap: ${16:# Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.}
		distance_ibgp: ${17:# Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.}
		distance_local: ${18:# Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.}
		advertise_l2vpn_evpn: ${19:true|false}
		default_information_originate: ${20:true|false}
		networks: ${21:# Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24], ['192.168.3.0/24', 'routemap_NYC']].}
		port: ${22:0 (use common port)}
		state: ${23:#present|absent}
		next_hop_route_map: ${24:# Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.}
		provider: ${25:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		table_map_filter: ${26:true|false}
		timeout: ${27:10}
		default_metric: ${28:# Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'}
		client_to_client: ${29:true|false}
		dampen_igp_metric: ${30:# Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.}
		additional_paths_selection: ${31:# Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.}
		maximum_paths_ibgp: ${32:# Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
		distance_ebgp: ${33:# Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.}
		password: ${34:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		redistribute: ${35:# A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].}
		ssh_keyfile: ${36:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		dampening_reuse_time: ${37:# Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.}
		maximum_paths: ${38:# Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
		inject_map: ${39:# An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].}
		dampening_suppress_time: ${40:# Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.}
		table_map: ${41:# Apply table-map to filter routes downloaded into URIB. Valid values are a string.}
		dampening_half_time: ${42:# Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.}
		validate_certs: ${43:yes|no}
$0
endsnippet

snippet nxos_bgp_neighbor "Manages BGP neighbors configurations."
- name: $1
	nxos_bgp_neighbor:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		asn: ${4:# BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${5:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		update_source: ${6:# Specify source interface of BGP session and updates.}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		maximum_peers: ${8:# Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit.}
		timers_holdtime: ${9:# Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.}
		local_as: ${10:# Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
		pwd_type: ${11:3des|cisco_type_7}
		timers_keepalive: ${12:# Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.}
		dynamic_capability: ${13:true|false}
		vrf: ${14:default}
		shutdown: ${15:true|false}
		low_memory_exempt: ${16:true|false}
		log_neighbor_changes: ${17:enable|disable|inherit}
		remove_private_as: ${18:enable|disable|all|replace-as}
		password: ${19:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		suppress_4_byte_as: ${20:true|false}
		connected_check: ${21:true|false}
		timeout: ${22:10}
		ssh_keyfile: ${23:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		remote_as: ${24:# Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
		ebgp_multihop: ${25:# Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.}
		description: ${26:# Description of the neighbor.}
		pwd: ${27:# Specify the password for neighbor. Valid value is string.}
		port: ${28:0 (use common port)}
		state: ${29:#present|absent}
		transport_passive_only: ${30:true|false}
		capability_negotiation: ${31:true|false}
		provider: ${32:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${33:yes|no}
		validate_certs: ${34:yes|no}
$0
endsnippet

snippet nxos_bgp_neighbor_af "Manages BGP address-family's neighbors configuration."
- name: $1
	nxos_bgp_neighbor_af:
		transport: ${2:cli}
		afi: ${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${4:unicast|multicast|evpn}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		asn: ${6:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${7:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		default_originate: ${8:true|false}
		route_reflector_client: ${9:true|false}
		additional_paths_send: ${10:enable|disable|inherit}
		soo: ${11:# Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.}
		additional_paths_receive: ${12:enable|disable|inherit}
		suppress_inactive: ${13:true|false|default}
		unsuppress_map: ${14:# unsuppress-map. Valid values are a string defining a route-map name or 'default'.}
		prefix_list_out: ${15:# Valid values are a string defining a prefix-list name, or 'default'.}
		as_override: ${16:true|false}
		port: ${17:0 (use common port)}
		filter_list_out: ${18:# Valid values are a string defining a filter-list name, or 'default'.}
		allowas_in: ${19:# Activate allowas-in property}
		max_prefix_warning: ${20:true|false}
		max_prefix_threshold: ${21:# Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.}
		state: ${22:#present|absent}
		provider: ${23:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		advertise_map_non_exist: ${24:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.}
		username: ${25:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		default_originate_route_map: ${26:# Optional route-map for the default_originate property. Can be used independently or in conjunction with C(default_originate). Valid values are a string defining a route-map name, or 'default'.}
		send_community: ${27:none|both|extended|standard|default}
		filter_list_in: ${28:# Valid values are a string defining a filter-list name, or 'default'.}
		weight: ${29:# Weight value. Valid values are an integer value or 'default'.}
		ssh_keyfile: ${30:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		vrf: ${31:default}
		max_prefix_limit: ${32:# maximum-prefix limit value. Valid values are an integer value or 'default'.}
		password: ${33:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		route_map_in: ${34:# Valid values are a string defining a route-map name, or 'default'.}
		soft_reconfiguration_in: ${35:enable|always|inherit}
		max_prefix_interval: ${36:# Optional restart interval. Valid values are an integer. Requires max_prefix_limit.}
		timeout: ${37:10}
		route_map_out: ${38:# Valid values are a string defining a route-map name, or 'default'.}
		next_hop_self: ${39:true|false}
		prefix_list_in: ${40:# Valid values are a string defining a prefix-list name, or 'default'.}
		use_ssl: ${41:yes|no}
		next_hop_third_party: ${42:true|false}
		advertise_map_exist: ${43:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.}
		validate_certs: ${44:yes|no}
		allowas_in_max: ${45:# Optional max-occurrences value for allowas_in. Valid values are an integer value or 'default'. Can be used independently or in conjunction with allowas_in.}
$0
endsnippet

snippet nxos_command "Run arbitrary command on Cisco NXOS devices"
- name: $1
	nxos_command:
		commands: ${2:# The commands to send to the remote NXOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		retries: ${6:10}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		interval: ${9:1}
		timeout: ${10:10}
		provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		wait_for: ${13:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
		match: ${16:all}
$0
endsnippet

snippet nxos_config "Manage Cisco NXOS configuration sections"
- name: $1
	nxos_config:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		force: ${5:true|false}
		timeout: ${6:10}
		after: ${7:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		replace: ${8:#line|block}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		before: ${12:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
		src: ${13:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
		ssh_keyfile: ${14:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		config: ${15:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		lines: ${16:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		validate_certs: ${17:yes|no}
		parents: ${18:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${19:no}
		provider: ${20:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		save: ${21:no}
		backup: ${22:yes|no}
		match: ${23:#line|strict|exact|none}
$0
endsnippet

snippet nxos_evpn_global "Handles the EVPN control plane for VXLAN."
- name: $1
	nxos_evpn_global:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		nv_overlay_evpn: ${3:true|false}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_evpn_vni "Manages Cisco EVPN VXLAN Network Identifier (VNI)."
- name: $1
	nxos_evpn_vni:
		vni: ${2:# The EVPN VXLAN Network Identifier.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		route_distinguisher: ${5:# The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		route_target_import: ${7:# Sets the route-target 'import' extended communities.}
		use_ssl: ${8:yes|no}
		route_target_export: ${9:# Sets the route-target 'import' extended communities.}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		route_target_both: ${13:# Enables/Disables route-target settings for both import and export target communities using a single property.}
		state: ${14:#present|absent}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_facts "Gets facts about NX-OS switches"
- name: $1
	nxos_facts:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		gather_subset: ${6:!config}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_feature "Manage features in NX-OS switches."
- name: $1
	nxos_feature:
		feature: ${2:# Name of feature.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${7:#enabled|disabled}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_file_copy "Copy a file to a remote NXOS device over SCP."
- name: $1
	nxos_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		validate_certs: ${7:yes|no}
		port: ${8:0 (use common port)}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		remote_file: ${13:# Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used.}
		file_system: ${14:# The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.}
$0
endsnippet

snippet nxos_gir "Trigger a graceful removal or insertion (GIR) of the switch."
- name: $1
	nxos_gir:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		state: ${4:#present|absent}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		system_mode_maintenance_shutdown: ${6:true|false}
		system_mode_maintenance_on_reload_reset_reason: ${7:hw_error|svc_failure|kern_failure|wdog_timeout|fatal_error|lc_failure|match_any|manual_reload}
		system_mode_maintenance: ${8:true|false}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		system_mode_maintenance_dont_generate_profile: ${13:true|false}
		system_mode_maintenance_timeout: ${14:# Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_gir_profile_management "Create a maintenance-mode or normal-mode profile for GIR."
- name: $1
	nxos_gir_profile_management:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		mode: ${3:maintenance|normal}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		commands: ${6:# List of commands to be included into the profile.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		validate_certs: ${8:yes|no}
		include_defaults: ${9:true|false}
		state: ${10:#present|absent}
		timeout: ${11:10}
		provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${13:yes|no}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		config: ${15:# Specify the configuration string to be used for module operations.}
		port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_hsrp "Manages HSRP configuration on NX-OS switches."
- name: $1
	nxos_hsrp:
		group: ${2:# HSRP group number.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of interface that is being managed for HSRP.}
		transport: ${5:cli}
		auth_type: ${6:text|md5}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		auth_string: ${9:# Authentication string.}
		vip: ${10:# HSRP virtual IP address.}
		priority: ${11:# HSRP priority.}
		state: ${12:#present|absent}
		version: ${13:1|2}
		timeout: ${14:10}
		provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${16:yes|no}
		password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${18:yes|no}
		port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_igmp "Manages IGMP global configuration."
- name: $1
	nxos_igmp:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		enforce_rtr_alert: ${6:true|false}
		flush_routes: ${7:true|false}
		state: ${8:#present|default}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${13:yes|no}
		port: ${14:0 (use common port)}
		restart: ${15:true|false}
$0
endsnippet

snippet nxos_igmp_interface "Manages IGMP interface configuration."
- name: $1
	nxos_igmp_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# The full interface name for IGMP configuration. e.g. I(Ethernet1/2).}
		transport: ${4:cli}
		startup_query_interval: ${5:# Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		group_timeout: ${7:# Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds.}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		oif_routemap: ${9:# Configure a routemap for static outgoing interface (OIF).}
		oif_prefix: ${10:# Configure a prefix for static outgoing interface (OIF).}
		use_ssl: ${11:yes|no}
		querier_timeout: ${12:# Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds.}
		last_member_query_count: ${13:# Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2.}
		port: ${14:0 (use common port)}
		restart: ${15:true|false}
		report_llg: ${16:true|false}
		ssh_keyfile: ${17:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		last_member_qrt: ${18:# Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second.}
		robustness: ${19:# Sets the robustness variable. Values can range from 1 to 7. The default is 2.}
		startup_query_count: ${20:# Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2.}
		immediate_leave: ${21:true|false}
		state: ${22:#present|default}
		version: ${23:2|3}
		timeout: ${24:10}
		provider: ${25:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		oif_source: ${26:# Configure a source for static outgoing interface (OIF).}
		query_interval: ${27:# Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. he default is 125 seconds.}
		validate_certs: ${28:yes|no}
		query_mrt: ${29:# Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds.}
$0
endsnippet

snippet nxos_igmp_snooping "Manages IGMP snooping global configuration."
- name: $1
	nxos_igmp_snooping:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		link_local_grp_supp: ${4:true|false}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		group_timeout: ${6:# Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).}
		use_ssl: ${7:yes|no}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${9:0 (use common port)}
		report_supp: ${10:# Global IGMPv1/IGMPv2 Report Suppression.}
		ssh_keyfile: ${11:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		snooping: ${12:true|false}
		v3_report_supp: ${13:true|false}
		state: ${14:#present|default}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_install_os "Set boot options like boot image and kickstart image."
- name: $1
	nxos_install_os:
		system_image_file: ${2:# Name of the system (or combined) image file on flash.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		kickstart_image_file: ${6:# Name of the kickstart image file on flash.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_interface "Manages physical attributes of interfaces."
- name: $1
	nxos_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		state: ${3:#present|absent|default}
		interface: ${4:# Full name of interface, i.e. Ethernet1/1, port-channel10.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		description: ${8:# Interface description.}
		ip_forward: ${9:enable|disable}
		interface_type: ${10:loopback|portchannel|svi|nve}
		fabric_forwarding_anycast_gateway: ${11:true|false}
		admin_state: ${12:#up|down}
		mode: ${13:layer2|layer3}
		timeout: ${14:10}
		provider: ${15:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${16:yes|no}
		password: ${17:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${18:yes|no}
		port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_interface_ospf "Manages configuration of an OSPF interface instance."
- name: $1
	nxos_interface_ospf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Name of this cisco_interface resource. Valid value is a string.}
		transport: ${4:cli}
		area: ${5:# Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.}
		ospf: ${6:# Name of the ospf instance.}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		message_digest_encryption_type: ${10:cisco_type_7|3des}
		dead_interval: ${11:# Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.}
		hello_interval: ${12:# Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.}
		use_ssl: ${13:yes|no}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${15:0 (use common port)}
		ssh_keyfile: ${16:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		message_digest_algorithm_type: ${17:md5}
		message_digest_key_id: ${18:# Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.}
		validate_certs: ${19:yes|no}
		state: ${20:#present|absent}
		cost: ${21:# The cost associated with this cisco_interface_ospf instance.}
		passive_interface: ${22:true|false}
		message_digest_password: ${23:# Specifies the message_digest password. Valid value is a string.}
		message_digest: ${24:true|false}
$0
endsnippet

snippet nxos_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces."
- name: $1
	nxos_ip_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Full name of interface, i.e. Ethernet1/1, vlan10.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		addr: ${7:# IPv4 or IPv6 Address.}
		mask: ${8:# Subnet mask for IPv4 or IPv6 Address in decimal format.}
		state: ${9:#present|absent}
		timeout: ${10:10}
		provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_ntp "Manages core NTP configuration."
- name: $1
	nxos_ntp:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		password: ${5:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		source_addr: ${7:# Local source address from which NTP messages are sent.}
		use_ssl: ${8:yes|no}
		prefer: ${9:enabled|disabled}
		server: ${10:# Network address of NTP server.}
		state: ${11:#present|absent}
		vrf_name: ${12:# Makes the device communicate with the given NTP server or peer over a specific VRF.}
		timeout: ${13:10}
		provider: ${14:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		peer: ${15:# Network address of NTP peer.}
		key_id: ${16:# Authentication key identifier to use with given NTP server or peer.}
		source_int: ${17:# Local source interface from which NTP messages are sent. Must be fully qualified interface name.}
		validate_certs: ${18:yes|no}
		port: ${19:0 (use common port)}
$0
endsnippet

snippet nxos_ntp_auth "Manages NTP authentication."
- name: $1
	nxos_ntp_auth:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		md5string: ${4:# MD5 String.}
		key_id: ${5:# Authentication key identifier (numeric).}
		auth_type: ${6:#text|encrypt}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		trusted_key: ${8:true|false}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		authentication: ${13:on|off}
		state: ${14:#present|absent}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_ntp_options "Manages NTP options."
- name: $1
	nxos_ntp_options:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		logging: ${6:true|false}
		provider: ${7:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		state: ${8:#present|absent}
		master: ${9:true|false}
		timeout: ${10:10}
		stratum: ${11:# If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_nxapi "Manage NXAPI configuration on an NXOS device."
- name: $1
	nxos_nxapi:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		http: ${5:yes|no}
		https_port: ${6:443}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		use_ssl: ${8:yes|no}
		password: ${9:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${10:0 (use common port)}
		timeout: ${11:10}
		http_port: ${12:80}
		sandbox: ${13:yes|no}
		state: ${14:#present|absent}
		https: ${15:yes|no}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_ospf "Manages configuration of an ospf instance."
- name: $1
	nxos_ospf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		ospf: ${3:# Name of the ospf instance.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		validate_certs: ${7:yes|no}
		state: ${8:#present|absent}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_ospf_vrf "Manages a VRF for an OSPF router."
- name: $1
	nxos_ospf_vrf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		ospf: ${4:# Name of the OSPF instance.}
		router_id: ${5:# Router Identifier (ID) of the OSPF router VRF instance.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		timeout: ${7:10}
		default_metric: ${8:# Specify the default Metric value. Valid values are an integer or the keyword 'default'.}
		ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		vrf: ${10:default}
		timer_throttle_spf_start: ${11:# Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		timer_throttle_spf_hold: ${14:# Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		timer_throttle_lsa_max: ${15:# Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		timer_throttle_spf_max: ${16:# Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		timer_throttle_lsa_hold: ${17:# Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		validate_certs: ${18:yes|no}
		log_adjacency: ${19:log|detail|default}
		timer_throttle_lsa_start: ${20:# Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
		port: ${21:0 (use common port)}
		auto_cost: ${22:# Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.}
		provider: ${23:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
$0
endsnippet

snippet nxos_overlay_global "Configures anycast gateway MAC of the switch."
- name: $1
	nxos_overlay_global:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		anycast_gateway_mac: ${3:# Anycast gateway mac of the switch.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		provider: ${7:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		timeout: ${8:10}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_pim "Manages configuration of a PIM instance."
- name: $1
	nxos_pim:
		ssm_range: ${2:# Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword 'none'.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_pim_interface "Manages PIM interface configuration."
- name: $1
	nxos_pim_interface:
		jp_policy_out: ${2:# Policy for join-prune messages (outbound).}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${4:# Full name of the interface such as Ethernet1/33.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		timeout: ${7:10}
		neighbor_policy: ${8:# Configures a neighbor policy for filtering adjacencies.}
		hello_interval: ${9:true|false}
		use_ssl: ${10:yes|no}
		hello_auth_key: ${11:# Authentication for hellos on this interface.}
		border: ${12:true|false}
		port: ${13:0 (use common port)}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		ssh_keyfile: ${15:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		jp_type_in: ${16:prefix|routemap}
		neighbor_type: ${17:prefix|routemap}
		state: ${18:#present|default}
		sparse: ${19:true|false}
		provider: ${20:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		jp_policy_in: ${21:# Policy for join-prune messages (inbound).}
		validate_certs: ${22:yes|no}
		jp_type_out: ${23:prefix|routemap}
$0
endsnippet

snippet nxos_pim_rp_address "Manages configuration of an PIM static RP address instance."
- name: $1
	nxos_pim_rp_address:
		rp_address: ${2:# Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		bidir: ${6:true|false}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		route_map: ${8:# Route map policy for static RP. Valid values are route-map policy names.}
		group_list: ${9:# Group range for static RP. Valid values are multicast addresses.}
		validate_certs: ${10:yes|no}
		timeout: ${11:10}
		provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${13:yes|no}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		prefix_list: ${15:# Prefix list policy for static RP. Valid values are prefix-list policy names.}
		port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_ping "Tests reachability using ping from Nexus switch."
- name: $1
	nxos_ping:
		dest: ${2:# IP address or hostname (resolvable by switch) of remote node.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		count: ${5:2}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		source: ${8:# Source IP Address.}
		vrf: ${9:# Outgoing VRF.}
		timeout: ${10:10}
		provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_portchannel "Manages port-channel interfaces."
- name: $1
	nxos_portchannel:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		group: ${4:# Channel-group number for the port-channel.}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		force: ${6:true|false}
		members: ${7:# List of interfaces that will be managed in a given portchannel.}
		min_links: ${8:# Min links required to keep portchannel up.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${13:#present|absent}
		mode: ${14:active|passive|on}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_reboot "Reboot a network device."
- name: $1
	nxos_reboot:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${5:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		confirm: ${6:no}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_rollback "Set a checkpoint or rollback to a checkpoint."
- name: $1
	nxos_rollback:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		checkpoint_file: ${4:# Name of checkpoint file to create. Mutually exclusive with rollback_to.}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		rollback_to: ${7:# Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_smu "Perform SMUs on Cisco NX-OS devices."
- name: $1
	nxos_smu:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		pkg: ${3:# Name of the remote package.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		port: ${7:0 (use common port)}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		file_system: ${13:# The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.}
$0
endsnippet

snippet nxos_snapshot "Manage snapshots of the running states of selected features."
- name: $1
	nxos_snapshot:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		action: ${4:create|add|compare|delete}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		description: ${6:# Snapshot description to be used when C(action=create).}
		snapshot1: ${7:# First snapshot to be used when C(action=compare).}
		snapshot2: ${8:# Second snapshot to be used when C(action=compare).}
		snapshot_name: ${9:# Snapshot name, to be used when C(action=create) or C(action=delete).}
		use_ssl: ${10:yes|no}
		path: ${11:./}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		show_command: ${13:# Specify a new show command, to be used when C(action=add).}
		ssh_keyfile: ${14:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		section: ${15:# Used to name the show command output, to be used when C(action=add).}
		comparison_results_file: ${16:# Name of the file where snapshots comparison will be store.}
		compare_option: ${17:summary|ipv4routes|ipv6routes}
		port: ${18:0 (use common port)}
		element_key1: ${19:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
		element_key2: ${20:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
		timeout: ${21:10}
		provider: ${22:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		row_id: ${23:# Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).}
		validate_certs: ${24:yes|no}
		save_snapshot_locally: ${25:true|false}
$0
endsnippet

snippet nxos_snmp_community "Manages SNMP community configs."
- name: $1
	nxos_snmp_community:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		community: ${3:# Case-sensitive community string.}
		state: ${4:#present|absent}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		group: ${8:# Group to which the community belongs.}
		acl: ${9:1}
		access: ${10:ro|rw}
		timeout: ${11:10}
		provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${13:yes|no}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${15:yes|no}
		port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_contact "Manages SNMP contact info."
- name: $1
	nxos_snmp_contact:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		state: ${3:#present|absent}
		contact: ${4:# Contact information.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_host "Manages SNMP host configuration."
- name: $1
	nxos_snmp_host:
		snmp_host: ${2:# IP address of hostname of target host.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		state: ${4:#present|absent}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		vrf_filter: ${7:# Name of VRF to filter.}
		udp: ${8:# UDP port number (0-65535).}
		ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		validate_certs: ${10:yes|no}
		src_intf: ${11:# Source interface.}
		community: ${12:# Community string or v3 username.}
		version: ${13:#v2c|v3}
		vrf: ${14:# VRF to use to source traffic to source.}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${17:yes|no}
		password: ${18:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		type: ${19:trap|inform}
		port: ${20:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_location "Manages SNMP location information."
- name: $1
	nxos_snmp_location:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		location: ${3:# Location information.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${7:#present|absent}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_traps "Manages SNMP traps."
- name: $1
	nxos_snmp_traps:
		group: ${2:aaa|bridge|callhome|cfs|config|entity|feature-control|hsrp|license|link|lldp|ospf|pim|rf|rmon|snmp|storm-control|stpx|sysmgr|system|upgrade|vtp|all}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${7:#enabled|disabled}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_snmp_user "Manages SNMP users for monitoring."
- name: $1
	nxos_snmp_user:
		user: ${2:# Name of the user.}
		group: ${3:# Group to which the user will belong to.}
		transport: ${4:cli}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		auth: ${7:md5|sha}
		pwd: ${8:# Auth password when using md5 or sha.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		encrypt: ${13:true|false}
		privacy: ${14:# Privacy password for the user.}
		state: ${15:#present|absent}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_static_route "Manages static route configuration"
- name: $1
	nxos_static_route:
		prefix: ${2:# Destination prefix of static route.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		state: ${5:present|absent}
		next_hop: ${6:# Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		tag: ${8:# Route tag value (numeric).}
		vrf: ${9:default}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${12:0 (use common port)}
		ssh_keyfile: ${13:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		pref: ${14:# Preference or administrative difference of route (range 1-255).}
		route_name: ${15:# Name of the route. Used with the name parameter on the CLI.}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_switchport "Manages Layer 2 switchport interfaces."
- name: $1
	nxos_switchport:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Full name of the interface, i.e. Ethernet1/1.}
		transport: ${4:cli}
		native_vlan: ${5:# If C(mode=trunk), used as the trunk native VLAN ID.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		use_ssl: ${7:yes|no}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${9:0 (use common port)}
		access_vlan: ${10:# If C(mode=access), used as the access VLAN ID.}
		ssh_keyfile: ${11:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		trunk_vlans: ${12:# If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.}
		state: ${13:#present|absent|unconfigured}
		trunk_allowed_vlans: ${14:# if C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".}
		mode: ${15:access|trunk}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_system "Manage the system attributes on Cisco NXOS devices"
- name: $1
	nxos_system:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		domain_search: ${5:# Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.}
		system_mtu: ${6:# Specifies the mtu, must be an integer.}
		name_servers: ${7:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.}
		use_ssl: ${8:yes|no}
		password: ${9:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${10:0 (use common port)}
		ssh_keyfile: ${11:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		hostname: ${12:# Configure the device hostname parameter. This option takes an ASCII string value.}
		domain_name: ${13:# Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.}
		state: ${14:#present|absent}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		domain_lookup: ${17:# Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_udld "Manages UDLD global configuration params."
- name: $1
	nxos_udld:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		reset: ${4:true|false}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		msg_time: ${7:# Message time in seconds for UDLD packets.}
		state: ${8:#present|absent}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		aggressive: ${12:enabled|disabled}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_udld_interface "Manages UDLD interface configuration params."
- name: $1
	nxos_udld_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		mode: ${3:enabled|disabled|aggressive}
		interface: ${4:# FULL name of the interface, i.e. Ethernet1/1-}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${8:#present|absent}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${13:yes|no}
		port: ${14:0 (use common port)}
$0
endsnippet

snippet nxos_user "Manage the collection of local users on Nexus devices"
- name: $1
	nxos_user:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		update_password: ${5:on_create|#always}
		users: ${6:# The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.}
		use_ssl: ${7:yes|no}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${9:0 (use common port)}
		name: ${10:# The username to be configured on the remote Cisco Nexus device.  This argument accepts a stringv value and is mutually exclusive with the C(users) argument.}
		ssh_keyfile: ${11:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		sshkey: ${12:# The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.}
		purge: ${13:no}
		state: ${14:#present|absent}
		role: ${15:# The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_vlan "Manages VLAN resources and attributes."
- name: $1
	nxos_vlan:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		vlan_state: ${5:#active|suspend}
		admin_state: ${6:#up|down}
		use_ssl: ${7:yes|no}
		vlan_range: ${8:# Range of VLANs such as 2-10 or 2,5,10-15, etc.}
		port: ${9:0 (use common port)}
		vlan_id: ${10:# Single VLAN ID.}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		name: ${13:# Name of VLAN.}
		mapped_vni: ${14:# The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'.}
		state: ${15:#present|absent}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_vpc "Manages global VPC configuration"
- name: $1
	nxos_vpc:
		domain: ${2:# VPC domain}
		auto_recovery: ${3:true|false}
		peer_gw: ${4:true|false}
		state: ${5:present|absent}
		host: ${6:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${7:cli}
		username: ${8:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${9:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		system_priority: ${10:# System priority device.  Remember they must match between peers.}
		role_priority: ${11:# Role priority for device. Remember lower is better.}
		pkl_vrf: ${12:management}
		delay_restore: ${13:# manages delay restore command and config value in seconds}
		port: ${14:0 (use common port)}
		validate_certs: ${15:yes|no}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${18:yes|no}
		password: ${19:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		pkl_dest: ${20:# Destination (remote) IP address used for peer keepalive link}
		pkl_src: ${21:# Source IP address used for peer keepalive link}
$0
endsnippet

snippet nxos_vpc_interface "Manages interface VPC configuration"
- name: $1
	nxos_vpc_interface:
		portchannel: ${2:# Group number of the portchannel that will be configured.}
		state: ${3:present|absent}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${8:10}
		peer_link: ${9:# Set to true/false for peer link config on associated portchannel.}
		vpc: ${10:# VPC group/id that will be configured on associated portchannel.}
		provider: ${11:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		password: ${13:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${14:yes|no}
		port: ${15:0 (use common port)}
$0
endsnippet

snippet nxos_vrf "Manages global VRF configuration."
- name: $1
	nxos_vrf:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${3:# Name of VRF to be managed.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		description: ${6:# Description of the VRF.}
		vni: ${7:# Specify virtual network identifier. Valid values are Integer or keyword 'default'.}
		admin_state: ${8:#up|down}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${13:#present|absent}
		route_distinguisher: ${14:# VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.}
		timeout: ${15:10}
		provider: ${16:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${17:yes|no}
$0
endsnippet

snippet nxos_vrf_af "Manages VRF AF."
- name: $1
	nxos_vrf_af:
		afi: ${2:ipv4|ipv6}
		safi: ${3:unicast|multicast}
		host: ${4:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${5:# Name of the VRF.}
		transport: ${6:cli}
		username: ${7:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${8:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${9:#present|absent}
		route_target_both_auto_evpn: ${10:true|false}
		timeout: ${11:10}
		provider: ${12:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${13:yes|no}
		password: ${14:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${15:yes|no}
		port: ${16:0 (use common port)}
$0
endsnippet

snippet nxos_vrf_interface "Manages interface specific VRF configuration."
- name: $1
	nxos_vrf_interface:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vrf: ${3:# Name of VRF to be managed.}
		interface: ${4:# Full name of interface to be managed, i.e. Ethernet1/1.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${8:#present|absent}
		timeout: ${9:10}
		provider: ${10:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${11:yes|no}
		password: ${12:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${13:yes|no}
		port: ${14:0 (use common port)}
$0
endsnippet

snippet nxos_vrrp "Manages VRRP configuration on NX-OS switches."
- name: $1
	nxos_vrrp:
		interface: ${2:# Full name of interface that is being managed for VRRP.}
		transport: ${3:cli}
		group: ${4:# VRRP group number.}
		host: ${5:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		vip: ${7:# VRRP virtual IP address.}
		admin_state: ${8:shutdown|#no shutdown}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${11:0 (use common port)}
		ssh_keyfile: ${12:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		authentication: ${13:# Clear text authentication string.}
		priority: ${14:# VRRP priority.}
		state: ${15:#present|absent}
		timeout: ${16:10}
		provider: ${17:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_vtp_domain "Manages VTP domain configuration."
- name: $1
	nxos_vtp_domain:
		domain: ${2:# VTP domain name.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_vtp_password "Manages VTP password configuration."
- name: $1
	nxos_vtp_password:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		transport: ${3:cli}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		vtp_password: ${5:# VTP password}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		state: ${7:#present|absent}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${12:yes|no}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet nxos_vtp_version "Manages VTP version configuration."
- name: $1
	nxos_vtp_version:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		version: ${3:1|2}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		timeout: ${7:10}
		provider: ${8:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${9:yes|no}
		password: ${10:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		validate_certs: ${11:yes|no}
		port: ${12:0 (use common port)}
$0
endsnippet

snippet nxos_vxlan_vtep "Manages VXLAN Network Virtualization Endpoint (NVE)."
- name: $1
	nxos_vxlan_vtep:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		interface: ${3:# Interface name for the VXLAN Network Virtualization Endpoint.}
		transport: ${4:cli}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		description: ${6:# Description of the NVE interface.}
		provider: ${7:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		source_interface_hold_down_time: ${8:# Suppresses advertisement of the NVE loopback address until the overlay has converged.}
		shutdown: ${9:true|false}
		use_ssl: ${10:yes|no}
		password: ${11:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		port: ${12:0 (use common port)}
		ssh_keyfile: ${13:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		host_reachability: ${14:true|false}
		state: ${15:#present|absent}
		timeout: ${16:10}
		source_interface: ${17:# Specify the loopback interface whose IP address should be used for the NVE interface.}
		validate_certs: ${18:yes|no}
$0
endsnippet

snippet nxos_vxlan_vtep_vni "Creates a Virtual Network Identifier member (VNI)"
- name: $1
	nxos_vxlan_vtep_vni:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		vni: ${3:# ID of the Virtual Network Identifier.}
		interface: ${4:# Interface name for the VXLAN Network Virtualization Endpoint.}
		transport: ${5:cli}
		username: ${6:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		timeout: ${7:10}
		assoc_vrf: ${8:true|false}
		password: ${9:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(nxapi) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		suppress_arp: ${10:true|false}
		multicast_group: ${11:# The multicast group (range) of the VNI. Valid values are string and keyword 'default'.}
		validate_certs: ${12:yes|no}
		use_ssl: ${13:yes|no}
		include_defaults: ${14:true|true}
		state: ${15:#present|absent}
		ssh_keyfile: ${16:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		peer_list: ${17:# Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.}
		provider: ${18:# Convenience method that allows all I(nxos) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		ingress_replication: ${19:bgp|static}
		save: ${20:true|false}
		config: ${21:# Configuration string to be used for module operations. If not specified, the module will use the current running configuration.}
		port: ${22:0 (use common port)}
$0
endsnippet

snippet ops_command "Run arbitrary commands on OpenSwitch devices."
- name: $1
	ops_command:
		commands: ${2:# List of commands to send to the remote ops device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		host: ${3:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.}
		transport: ${4:#ssh|cli|rest}
		username: ${5:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		retries: ${6:10}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		password: ${8:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(rest) transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		interval: ${9:1}
		timeout: ${10:10}
		provider: ${11:# Convenience method that allows all I(openswitch) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${12:yes|no}
		wait_for: ${13:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		port: ${14:0 (use common port)}
		match: ${15:any|#all}
$0
endsnippet

snippet ops_config "Manage OpenSwitch configuration using CLI"
- name: $1
	ops_config:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.}
		transport: ${3:#ssh|cli|rest}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		src: ${5:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
		password: ${6:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(rest) transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		ssh_keyfile: ${7:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		force: ${8:yes|no}
		after: ${9:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${10:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		replace: ${11:#line|block}
		parents: ${12:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		timeout: ${13:10}
		provider: ${14:# Convenience method that allows all I(openswitch) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${15:yes|no}
		save: ${16:yes|no}
		config: ${17:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
		port: ${18:0 (use common port)}
		match: ${19:#line|strict|exact|none}
		before: ${20:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet ops_facts "Collect device specific facts from OpenSwitch"
- name: $1
	ops_facts:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.}
		transport: ${3:#ssh|cli|rest}
		username: ${4:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
		password: ${5:# Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either I(cli) or I(rest) transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
		ssh_keyfile: ${6:# Specifies the SSH key to use to authenticate the connection to the remote device.  This argument is only used for the I(cli) transports. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
		gather_subset: ${7:!config}
		timeout: ${8:10}
		provider: ${9:# Convenience method that allows all I(openswitch) arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.}
		use_ssl: ${10:yes|no}
		endpoints: ${11:# Accepts a list of endpoints to retrieve from the remote device using the REST API.  The endpoints should be valid endpoints available on the device.  This argument is only valid when the C(transport=rest).}
		config: ${12:True|#False}
		port: ${13:0 (use common port)}
$0
endsnippet

snippet ordnance_config "Manage Ordnance configuration sections"
- name: $1
	ordnance_config:
		multiline_delimiter: ${2:@}
		src: ${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		commands: ${4:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		backup: ${5:yes|no}
		after: ${6:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		replace: ${7:#line|block}
		parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${9:yes|no}
		save: ${10:yes|no}
		config: ${11:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		match: ${12:#line|strict|exact|none}
		before: ${13:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet ordnance_facts "Collect facts from Ordnance Virtual Routers over SSH"
- name: $1
	ordnance_facts:
		gather_subset: ${2:!config}
$0
endsnippet

snippet openvswitch_bridge "Manage Open vSwitch bridges"
- name: $1
	openvswitch_bridge:
		bridge: ${2:# Name of bridge or fake bridge to manage}
		fail_mode: ${3:secure|standalone}
		parent: ${4:# Bridge parent of the fake bridge to manage}
		vlan: ${5:# The VLAN id of the fake bridge to manage (must be between 0 and 4095)}
		state: ${6:#present|absent}
		set: ${7:# Set a single property on a bridge.}
		timeout: ${8:5}
		external_ids: ${9:# A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.}
$0
endsnippet

snippet openvswitch_db "Configure open vswitch database."
- name: $1
	openvswitch_db:
		record: ${2:# Identifies the recoard in the table.}
		key: ${3:# Identifies the key in the record column}
		column: ${4:# Identifies the column in the record.}
		table: ${5:# Identifies the table in the database.}
		value: ${6:# Expected value for the table, record, column and key.}
		timeout: ${7:5}
$0
endsnippet

snippet openvswitch_port "Manage Open vSwitch ports"
- name: $1
	openvswitch_port:
		bridge: ${2:# Name of bridge to manage}
		port: ${3:# Name of port to manage on the bridge}
		state: ${4:#present|absent}
		set: ${5:# Set a single property on a port.}
		timeout: ${6:5}
		external_ids: ${7:{}}
		tag: ${8:# VLAN tag for this port}
$0
endsnippet

snippet panos_address "Create address service object on PanOS devices"
- name: $1
	panos_address:
		address_name: ${2:# Human readable name of the address.}
		address: ${3:# IP address with or without mask, range, or FQDN.}
		password: ${4:# Password credentials to use for authentication.}
		ip_address: ${5:# IP address (or hostname) of PAN-OS device being configured.}
		username: ${6:admin}
		description: ${7:# Description of the address object.}
		type: ${8:ip-netmask|fqdn|ip-range}
		tag: ${9:# Tag of the address object.}
		commit: ${10:yes}
$0
endsnippet

snippet panos_admin "Add or modify PAN-OS user accounts password."
- name: $1
	panos_admin:
		admin_password: ${2:# password for admin user}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		username: ${5:admin}
		role: ${6:# role for admin user}
		commit: ${7:yes}
		admin_username: ${8:admin}
$0
endsnippet

snippet panos_admpwd "change admin password of PAN-OS device using SSH with SSH key"
- name: $1
	panos_admpwd:
		newpassword: ${2:# password to configure for admin on the PAN-OS device}
		key_filename: ${3:# filename of the SSH Key to use for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		username: ${5:admin}
$0
endsnippet

snippet panos_cert_gen_ssh "generates a self-signed certificate using SSH protocol with SSH key"
- name: $1
	panos_cert_gen_ssh:
		password: ${2:# Password credentials to use for auth. Either I(key_filename) or I(password) is required.}
		cert_cn: ${3:# Certificate CN (common name) embeded in the certificate signature.}
		cert_friendly_name: ${4:# Human friendly certificate name (not CN but just a friendly name).}
		key_filename: ${5:# Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.}
		ip_address: ${6:# IP address (or hostname) of PAN-OS device being configured.}
		signed_by: ${7:# Undersigning authority (CA) that MUST already be presents on the device.}
		rsa_nbits: ${8:2048}
$0
endsnippet

snippet panos_check "check if PAN-OS device is ready for configuration"
- name: $1
	panos_check:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		username: ${4:admin}
		timeout: ${5:0}
		interval: ${6:0}
$0
endsnippet

snippet panos_commit "commit firewall's candidate configuration"
- name: $1
	panos_commit:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		username: ${4:admin}
		timeout: ${5:# timeout for commit job}
		interval: ${6:0.5}
		sync: ${7:yes}
$0
endsnippet

snippet panos_dag "create a dynamic address group"
- name: $1
	panos_dag:
		dag_name: ${2:# name of the dynamic address group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		dag_filter: ${5:# dynamic filter user by the dynamic address group}
		username: ${6:admin}
		commit: ${7:yes}
$0
endsnippet

snippet panos_import "import file on PAN-OS devices"
- name: $1
	panos_import:
		password: ${2:# Password for device authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		username: ${4:admin}
		category: ${5:software}
		file: ${6:# Location of the file to import into device.}
		url: ${7:# URL of the file that will be imported to device.}
$0
endsnippet

snippet panos_interface "configure data-port network interface for DHCP"
- name: $1
	panos_interface:
		zone_name: ${2:# N}
		password: ${3:# Password credentials to use for auth.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		if_name: ${5:# Name of the interface to configure.}
		username: ${6:admin}
		create_default_route: ${7:false}
		commit: ${8:yes}
$0
endsnippet

snippet panos_lic "apply authcode to a device/instance"
- name: $1
	panos_lic:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device}
		password: ${3:# password for authentication}
		auth_code: ${4:# authcode to be applied}
		username: ${5:admin}
		force: ${6:false}
$0
endsnippet

snippet panos_loadcfg "load configuration on PAN-OS device"
- name: $1
	panos_loadcfg:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		username: ${4:admin}
		commit: ${5:yes}
		file: ${6:# configuration file to load}
$0
endsnippet

snippet panos_mgtconfig "configure management settings of device"
- name: $1
	panos_mgtconfig:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		username: ${4:admin}
		panorama_primary: ${5:# address of primary Panorama server}
		dns_server_secondary: ${6:# address of secondary DNS server}
		dns_server_primary: ${7:# address of primary DNS server}
		panorama_secondary: ${8:# address of secondary Panorama server}
		commit: ${9:yes}
$0
endsnippet

snippet panos_nat_policy "create a policy NAT rule"
- name: $1
	panos_nat_policy:
		rule_name: ${2:# name of the SNAT rule}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		to_zone: ${5:# destination zone}
		from_zone: ${6:# list of source zones}
		username: ${7:admin}
		snat_bidirectional: ${8:false}
		dnat_port: ${9:# dnat translated port}
		snat_interface_address: ${10:# snat interface address}
		snat_address: ${11:# snat translated address}
		dnat_address: ${12:# dnat translated address}
		service: ${13:any}
		snat_type: ${14:# type of source translation}
		destination: ${15:[u'any']}
		source: ${16:[u'any']}
		override: ${17:false}
		commit: ${18:yes}
		snat_interface: ${19:# snat interface}
$0
endsnippet

snippet panos_pg "create a security profiles group"
- name: $1
	panos_pg:
		pg_name: ${2:# name of the security profile group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		username: ${5:admin}
		wildfire: ${6:# name of the wildfire analysis profile}
		data_filtering: ${7:# name of the data filtering profile}
		file_blocking: ${8:# name of the file blocking profile}
		vulnerability: ${9:# name of the vulnerability profile}
		spyware: ${10:# name of the spyware profile}
		url_filtering: ${11:# name of the url filtering profile}
		virus: ${12:# name of the anti-virus profile}
		commit: ${13:yes}
$0
endsnippet

snippet panos_restart "restart a device"
- name: $1
	panos_restart:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		username: ${4:admin}
$0
endsnippet

snippet panos_security_policy "Create security rule policy on PanOS devices."
- name: $1
	panos_security_policy:
		password: ${2:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device being configured.}
		rule_name: ${4:# Name of the security rule.}
		wildfire_analysis: ${5:# Name of the already defined wildfire_analysis profile.}
		username: ${6:admin}
		vulnerability: ${7:# Name of the already defined vulnerability profile.}
		devicegroup: ${8:# D}
		data_filtering: ${9:# Name of the already defined data_filtering profile.}
		spyware: ${10:# Name of the already defined spyware profile.}
		hip_profiles: ${11:any}
		file_blocking: ${12:# Name of the already defined file_blocking profile.}
		tag: ${13:# Administrative tags that can be added to the rule. Note, tags must be already defined.}
		antivirus: ${14:# Name of the already defined antivirus profile.}
		log_start: ${15:no}
		log_end: ${16:yes}
		url_filtering: ${17:# Name of the already defined url_filtering profile.}
		description: ${18:# Description for the security rule.}
		rule_type: ${19:universal}
		to_zone: ${20:any}
		service: ${21:application-default}
		source: ${22:any}
		destination: ${23:any}
		from_zone: ${24:any}
		source_user: ${25:any}
		application: ${26:any}
		group_profile: ${27:# S}
		action: ${28:allow}
		commit: ${29:yes}
		api_key: ${30:# API key that can be used instead of I(username)/I(password) credentials.}
$0
endsnippet

snippet panos_service "create a service object"
- name: $1
	panos_service:
		protocol: ${2:# protocol for the service, should be tcp or udp}
		service_name: ${3:# name of the service}
		password: ${4:# password for authentication}
		ip_address: ${5:# IP address (or hostname) of PAN-OS device}
		port: ${6:# destination port}
		username: ${7:admin}
		source_port: ${8:# source port}
		commit: ${9:yes}
$0
endsnippet

snippet sros_command "Run commands on remote devices running Nokia SR OS"
- name: $1
	sros_command:
		commands: ${2:# List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		retries: ${3:10}
		interval: ${4:1}
		provider: ${5:# A dict object containing connection details.}
		wait_for: ${6:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
		match: ${7:any|#all}
$0
endsnippet

snippet sros_config "Manage Nokia SR OS device configuration"
- name: $1
	sros_config:
		src: ${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
		force: ${3:true|false}
		backup: ${4:yes|no}
		after: ${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
		lines: ${6:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		replace: ${7:#line|block}
		parents: ${8:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
		defaults: ${9:yes|no}
		provider: ${10:# A dict object containing connection details.}
		save: ${11:yes|no}
		config: ${12:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
		match: ${13:#line|strict|exact|none}
		before: ${14:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
$0
endsnippet

snippet sros_rollback "Configure Nokia SR OS rollback"
- name: $1
	sros_rollback:
		state: ${2:#present|absent}
		rescue_location: ${3:# The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS}
		remote_max_checkpoints: ${4:# The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50}
		local_max_checkpoints: ${5:# The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50}
		provider: ${6:# A dict object containing connection details.}
		rollback_location: ${7:# The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS}
$0
endsnippet

snippet vyos_command "Run one or more commands on VyOS devices"
- name: $1
	vyos_command:
		commands: ${2:# The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.}
		retries: ${3:10}
		interval: ${4:1}
		provider: ${5:# A dict object containing connection details.}
		wait_for: ${6:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.}
		match: ${7:any|#all}
$0
endsnippet

snippet vyos_config "Manage VyOS configuration on remote device"
- name: $1
	vyos_config:
		comment: ${2:configured by vyos_config}
		src: ${3:# The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.}
		provider: ${4:# A dict object containing connection details.}
		config: ${5:# The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.}
		lines: ${6:# The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.}
		save: ${7:yes|no}
		backup: ${8:yes|no}
		match: ${9:#line|none}
$0
endsnippet

snippet vyos_facts "Collect facts from remote devices running VyOS"
- name: $1
	vyos_facts:
		gather_subset: ${2:!config}
		provider: ${3:# A dict object containing connection details.}
$0
endsnippet

snippet vyos_system "Run `set system` commands on VyOS devices"
- name: $1
	vyos_system:
		state: ${2:#present|absent}
		name_server: ${3:# A list of name servers to use with the device. Mutually exclusive with I(domain_search)}
		provider: ${4:# A dict object containing connection details.}
		domain_search: ${5:# A list of domain names to search. Mutually exclusive with I(name_server)}
		hostname: ${6:# Configure the device hostname parameter. This option takes an ASCII string value.}
		domain_name: ${7:# The new domain name to apply to the device.}
$0
endsnippet

snippet campfire "Send a message to Campfire"
- name: $1
	campfire:
		msg: ${2:# The message body.}
		token: ${3:# API token.}
		subscription: ${4:# The subscription name to use.}
		room: ${5:# Room number to which the message should be sent.}
		notify: ${6:56k|bell|bezos|bueller|clowntown|cottoneyejoe|crickets|dadgummit|dangerzone|danielsan|deeper|drama|greatjob|greyjoy|guarantee|heygirl|horn|horror|inconceivable|live|loggins|makeitso|noooo|nyan|ohmy|ohyeah|pushit|rimshot|rollout|rumble|sax|secret|sexyback|story|tada|tmyk|trololo|trombone|unix|vuvuzela|what|whoomp|yeah|yodel}
$0
endsnippet

snippet cisco_spark "Send a message to a Cisco Spark Room or Individual."
- name: $1
	cisco_spark:
		personal_token: ${2:# Your personal access token required to validate the Spark API.}
		message: ${3:# The message you would like to send.}
		recipient_id: ${4:# The unique identifier associated with the supplied C(recipient_type).}
		recipient_type: ${5:roomId|toPersonEmail|toPersonId}
		message_type: ${6:#text|markdown}
$0
endsnippet

snippet flowdock "Send a message to a flowdock"
- name: $1
	flowdock:
		type: ${2:inbox|chat}
		token: ${3:# API token.}
		msg: ${4:# Content of the message}
		from_name: ${5:# (inbox only) Name of the message sender}
		from_address: ${6:# (inbox only - required) Email address of the message sender}
		tags: ${7:# tags of the message, separated by commas}
		external_user_name: ${8:# (chat only - required) Name of the "user" sending the message}
		project: ${9:# (inbox only) Human readable identifier for more detailed message categorization}
		source: ${10:# (inbox only - required) Human readable identifier of the application that uses the Flowdock API}
		link: ${11:# (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.}
		reply_to: ${12:# (inbox only) Email address for replies}
		subject: ${13:# (inbox only - required) Subject line of the message}
		validate_certs: ${14:#yes|no}
$0
endsnippet

snippet grove "Sends a notification to a grove.io channel"
- name: $1
	grove:
		message: ${2:# Message content}
		channel_token: ${3:# Token of the channel to post to.}
		service: ${4:ansible}
		url: ${5:# Service URL for the web client}
		icon_url: ${6:# Icon for the service}
		validate_certs: ${7:#yes|no}
$0
endsnippet

snippet hall "Send notification to Hall"
- name: $1
	hall:
		msg: ${2:# The message you wish to deliver as a notifcation}
		room_token: ${3:# Room token provided to you by setting up the Ansible room integation on U(https://hall.com)}
		title: ${4:# The title of the message}
		picture: ${5:# The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)}
$0
endsnippet

snippet hipchat "Send a message to Hipchat."
- name: $1
	hipchat:
		room: ${2:# ID or name of the room.}
		token: ${3:# API token.}
		msg: ${4:# The message body.}
		from: ${5:Ansible}
		color: ${6:#yellow|red|green|purple|gray|random}
		msg_format: ${7:#text|html}
		api: ${8:https://api.hipchat.com/v1}
		notify: ${9:#yes|no}
		validate_certs: ${10:#yes|no}
$0
endsnippet

snippet irc "Send a message to an IRC channel"
- name: $1
	irc:
		msg: ${2:# The message body.}
		channel: ${3:# Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.}
		style: ${4:bold|underline|reverse|italic}
		key: ${5:# Channel key}
		passwd: ${6:# Server password}
		color: ${7:#none|white|black|blue|green|red|brown|purple|orange|yellow|light_green|teal|light_cyan|light_blue|pink|gray|light_gray}
		server: ${8:localhost}
		topic: ${9:# Set the channel topic}
		nick: ${10:ansible}
		part: ${11:yes}
		nick_to: ${12:# A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.}
		timeout: ${13:30}
		use_ssl: ${14:no}
		port: ${15:6667}
$0
endsnippet

snippet jabber "Send a message to jabber user or chat room"
- name: $1
	jabber:
		to: ${2:# user ID or name of the room, when using room use a slash to indicate your nick.}
		user: ${3:# User as which to connect}
		msg: ${4:# The message body.}
		password: ${5:# password for user to connect}
		host: ${6:# host to connect, overrides user info}
		encoding: ${7:# message encoding}
		port: ${8:5222}
$0
endsnippet

snippet mail "Send an email"
- name: $1
	mail:
		subject: ${2:# The subject of the email being sent.}
		body: ${3:$subject}
		username: ${4:# If SMTP requires username}
		secure: ${5:always|never|#try|starttls}
		cc: ${6:# The email-address(es) the mail is being copied to. This is a comma-separated list, which may contain address and phrase portions.}
		host: ${7:localhost}
		password: ${8:# If SMTP requires password}
		port: ${9:25}
		to: ${10:root}
		from: ${11:root}
		headers: ${12:# A vertical-bar-separated list of headers which should be added to the message. Each individual header is specified as C(header=value) (see example below).}
		charset: ${13:us-ascii}
		bcc: ${14:# The email-address(es) the mail is being 'blind' copied to. This is a comma-separated list, which may contain address and phrase portions.}
		attach: ${15:# A space-separated list of pathnames of files to attach to the message. Attached files will have their content-type set to C(application/octet-stream).}
		timeout: ${16:20}
		subtype: ${17:plain}
$0
endsnippet

snippet mattermost "Send Mattermost notifications"
- name: $1
	mattermost:
		url: ${2:# Mattermost url (i.e. http://mattermost.yourcompany.com).}
		text: ${3:# Text to send. Note that the module does not handle escaping characters.}
		api_key: ${4:# Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incomming Webhook -> Add Incomming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)}
		username: ${5:Ansible}
		icon_url: ${6:https://www.ansible.com/favicon.ico}
		validate_certs: ${7:yes|no}
		channel: ${8:# Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).}
$0
endsnippet

snippet mqtt "Publish a message on an MQTT topic for the IoT"
- name: $1
	mqtt:
		topic: ${2:# MQTT topic name}
		payload: ${3:# Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.}
		username: ${4:# Username to authenticate against the broker.}
		certfile: ${5:# The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
		port: ${6:1883}
		server: ${7:localhost}
		client_id: ${8:hostname + pid}
		ca_certs: ${9:# The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.}
		retain: ${10:no}
		password: ${11:# Password for C(username) to authenticate against the broker.}
		keyfile: ${12:# The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
		qos: ${13:0|1|2}
$0
endsnippet

snippet nexmo "Send a SMS via nexmo"
- name: $1
	nexmo:
		src: ${2:# Nexmo Number to send from}
		dest: ${3:# Phone number(s) to send SMS message to}
		api_secret: ${4:# Nexmo API Secret}
		api_key: ${5:# Nexmo API Key}
		msg: ${6:# Message to text to send. Messages longer than 160 characters will be split into multiple messages}
		validate_certs: ${7:#yes|no}
$0
endsnippet

snippet osx_say "Makes an OSX computer to speak."
- name: $1
	osx_say:
		msg: ${2:# W}
		voice: ${3:# W}
$0
endsnippet

snippet pushbullet "Sends notifications to Pushbullet"
- name: $1
	pushbullet:
		title: ${2:# Title of the notification.}
		api_key: ${3:# Push bullet API token}
		body: ${4:# Body of the notification, e.g. Details of the fault you're alerting.}
		device: ${5:# The device NAME you wish to send a push notification, as seen on the Pushbullet main page.}
		push_type: ${6:#note|link}
		channel: ${7:# The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.}
$0
endsnippet

snippet pushover "Send notifications via U(https://pushover.net)"
- name: $1
	pushover:
		msg: ${2:# What message you wish to send.}
		user_key: ${3:# Pushover issued authentication key for your user.}
		app_token: ${4:# Pushover issued token identifying your pushover app.}
		pri: ${5:# Message priority (see U(https://pushover.net) for details.)}
$0
endsnippet

snippet rocketchat "Send notifications to Rocket Chat"
- name: $1
	rocketchat:
		domain: ${2:# The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))}
		token: ${3:# Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.}
		username: ${4:Ansible}
		protocol: ${5:http|#https}
		attachments: ${6:# Define a list of attachments.}
		color: ${7:#normal|good|warning|danger}
		icon_url: ${8:https://www.ansible.com/favicon.ico}
		icon_emoji: ${9:# Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)}
		link_names: ${10:#1|0}
		msg: ${11:# Message to be sent.}
		validate_certs: ${12:#yes|no}
		channel: ${13:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specifed during the creation of webhook.}
$0
endsnippet

snippet sendgrid "Sends an email with the SendGrid API"
- name: $1
	sendgrid:
		from_address: ${2:# the address in the "from" field for the email}
		subject: ${3:# the desired subject for the email}
		to_addresses: ${4:# a list with one or more recipient email addresses}
		username: ${5:# username for logging into the SendGrid account.}
		from_name: ${6:# the name you want to appear in the from field, i.e 'John Doe'}
		cc: ${7:# a list of email addresses to cc}
		bcc: ${8:# a list of email addresses to bcc}
		headers: ${9:# a dict to pass on as headers}
		html_body: ${10:no}
		api_key: ${11:# sendgrid API key to use instead of username/password}
		password: ${12:# password that corresponds to the username}
		attachments: ${13:# a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)}
$0
endsnippet

snippet slack "Send Slack notifications"
- name: $1
	slack:
		token: ${2:# Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.}
		username: ${3:Ansible}
		domain: ${4:# Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.}
		attachments: ${5:# Define a list of attachments. This list mirrors the Slack JSON API. For more information, see https://api.slack.com/docs/attachments}
		color: ${6:#normal|good|warning|danger}
		icon_url: ${7:# Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))}
		parse: ${8:full|none}
		icon_emoji: ${9:# Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)}
		link_names: ${10:#1|0}
		msg: ${11:# Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.}
		validate_certs: ${12:#yes|no}
		channel: ${13:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token).}
$0
endsnippet

snippet sns "Send Amazon Simple Notification Service (SNS) messages"
- name: $1
	sns:
		topic: ${2:# The topic you want to publish to.}
		msg: ${3:# Default message to send.}
		message_structure: ${4:#json|string}
		aws_secret_key: ${5:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
		aws_access_key: ${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
		http: ${7:# Message to send to HTTP-only subscription}
		sqs: ${8:# Message to send to SQS-only subscription}
		region: ${9:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		sms: ${10:# Message to send to SMS-only subscription}
		https: ${11:# Message to send to HTTPS-only subscription}
		message_attributes: ${12:# Dictionary of message attributes. These are optional structured data entries to be sent along to the endpoint.}
		email: ${13:# Message to send to email-only subscription}
		subject: ${14:# Subject line for email delivery.}
$0
endsnippet

snippet telegram "module for sending notifications via telegram"
- name: $1
	telegram:
		msg: ${2:# What message you wish to send.}
		token: ${3:# Token identifying your telegram bot.}
		chat_id: ${4:# Telegram group or user chat_id}
$0
endsnippet

snippet twilio "Sends a text message to a mobile phone through Twilio."
- name: $1
	twilio:
		from_number: ${2:# t}
		msg: ${3:# t}
		auth_token: ${4:# u}
		to_number: ${5:# o}
		account_sid: ${6:# u}
		media_url: ${7:# a}
$0
endsnippet

snippet typetalk "Send a message to typetalk"
- name: $1
	typetalk:
		topic: ${2:# topic id to post message}
		client_secret: ${3:# OAuth2 client secret}
		client_id: ${4:# OAuth2 client ID}
		msg: ${5:# message body}
$0
endsnippet

snippet bower "Manage bower packages with bower"
- name: $1
	bower:
		path: ${2:# The base path where to install the bower packages}
		state: ${3:#present|absent|latest}
		production: ${4:yes|no}
		name: ${5:# The name of a bower package to install}
		version: ${6:# The version to be installed}
		relative_execpath: ${7:# Relative path to bower executable from install path}
		offline: ${8:yes|no}
$0
endsnippet

snippet bundler "Manage Ruby Gem dependencies with Bundler"
- name: $1
	bundler:
		executable: ${2:# The path to the bundler executable}
		chdir: ${3:temporary working directory}
		gemfile: ${4:Gemfile in current directory}
		clean: ${5:True|False}
		user_install: ${6:True|False}
		extra_args: ${7:# A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information}
		state: ${8:#present|latest}
		deployment_mode: ${9:True|False}
		binstub_directory: ${10:# Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)}
		exclude_groups: ${11:# A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set}
		local: ${12:True|False}
		gem_path: ${13:RubyGems gem paths}
$0
endsnippet

snippet composer "Dependency Manager for PHP"
- name: $1
	composer:
		working_dir: ${2:# Directory of your project (see --working-dir).}
		no_scripts: ${3:True|#False}
		prefer_source: ${4:True|#False}
		prefer_dist: ${5:True|#False}
		command: ${6:install}
		arguments: ${7:# Composer arguments like required package, version and so on.}
		ignore_platform_reqs: ${8:True|#False}
		no_dev: ${9:#True|False}
		no_plugins: ${10:True|#False}
		optimize_autoloader: ${11:#True|False}
$0
endsnippet

snippet cpanm "Manages Perl library dependencies."
- name: $1
	cpanm:
		executable: ${2:# Override the path to the cpanm executable}
		name: ${3:# The name of the Perl library to install. You may use the "full distribution path", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz}
		installdeps: ${4:no}
		system_lib: ${5:no}
		mirror_only: ${6:no}
		from_path: ${7:# The local directory from where to install}
		version: ${8:no}
		mirror: ${9:no}
		locallib: ${10:no}
		notest: ${11:no}
$0
endsnippet

snippet easy_install "Installs Python libraries"
- name: $1
	easy_install:
		name: ${2:# A Python library name}
		virtualenv: ${3:# an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically}
		virtualenv_site_packages: ${4:yes|#no}
		virtualenv_command: ${5:virtualenv}
		state: ${6:#present|latest}
		executable: ${7:# The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.}
$0
endsnippet

snippet gem "Manage Ruby gems"
- name: $1
	gem:
		name: ${2:# The name of the gem to be managed.}
		include_dependencies: ${3:#yes|no}
		executable: ${4:# Override the path to the gem executable}
		repository: ${5:# The repository from which the gem will be installed}
		build_flags: ${6:# Allow adding build flags for gem compilation}
		include_doc: ${7:no}
		user_install: ${8:yes}
		pre_release: ${9:no}
		env_shebang: ${10:no}
		state: ${11:#present|absent|latest}
		version: ${12:# Version of the gem to be installed/removed.}
		gem_source: ${13:# The path to a local gem used as installation source.}
$0
endsnippet

snippet maven_artifact "Downloads an Artifact from a Maven Repository"
- name: $1
	maven_artifact:
		group_id: ${2:# The Maven groupId coordinate}
		artifact_id: ${3:# The maven artifactId coordinate}
		dest: ${4:no}
		state: ${5:#present|absent}
		username: ${6:# The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3}
		extension: ${7:jar}
		version: ${8:latest}
		timeout: ${9:10}
		repository_url: ${10:http://repo1.maven.org/maven2}
		password: ${11:# The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3}
		validate_certs: ${12:#yes|no}
		classifier: ${13:# The maven classifier coordinate}
$0
endsnippet

snippet npm "Manage node.js packages with npm"
- name: $1
	npm:
		executable: ${2:# The executable location for npm.}
		name: ${3:# The name of a node.js library to install}
		global: ${4:yes|no}
		ignore_scripts: ${5:yes|no}
		state: ${6:#present|absent|latest}
		production: ${7:yes|no}
		registry: ${8:# The registry to install modules from.}
		version: ${9:# The version to be installed}
		path: ${10:# The base path where to install the node.js libraries}
$0
endsnippet

snippet pear "Manage pear/pecl packages"
- name: $1
	pear:
		name: ${2:# Name of the package to install, upgrade, or remove.}
		state: ${3:#present|absent|latest}
$0
endsnippet

snippet pip "Manages Python library dependencies."
- name: $1
	pip:
		virtualenv: ${2:# An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.}
		virtualenv_site_packages: ${3:yes|#no}
		virtualenv_command: ${4:virtualenv}
		chdir: ${5:# cd into this directory before running the command}
		requirements: ${6:# The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.}
		name: ${7:# The name of a Python library to install or the url of the remote package.}
		virtualenv_python: ${8:# The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used.}
		editable: ${9:yes}
		umask: ${10:# The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077).}
		executable: ${11:# The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.}
		extra_args: ${12:# Extra arguments passed to pip.}
		state: ${13:#present|absent|latest|forcereinstall}
		version: ${14:# The version number to install of the Python library specified in the I(name) parameter}
$0
endsnippet

snippet apk "Manages apk packages"
- name: $1
	apk:
		state: ${2:#present|absent|latest}
		upgrade: ${3:yes|no}
		update_cache: ${4:yes|no}
		name: ${5:# A package name, like C(foo), or mutliple packages, like C(foo, bar).}
$0
endsnippet

snippet apt "Manages apt-packages"
- name: $1
	apt:
		dpkg_options: ${2:force-confdef,force-confold}
		upgrade: ${3:#no|yes|safe|full|dist}
		force: ${4:yes|#no}
		name: ${5:# A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have "fo" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)}
		purge: ${6:yes|no}
		allow_unauthenticated: ${7:yes|#no}
		state: ${8:latest|absent|#present|build-dep}
		autoremove: ${9:yes|no}
		update_cache: ${10:yes|no}
		default_release: ${11:# Corresponds to the C(-t) option for I(apt) and sets pin priorities}
		only_upgrade: ${12:no}
		cache_valid_time: ${13:0}
		deb: ${14:# Path to a .deb package on the remote machine.}
		install_recommends: ${15:yes|no}
$0
endsnippet

snippet apt_key "Add or remove an apt key"
- name: $1
	apt_key:
		keyserver: ${2:none}
		url: ${3:none}
		data: ${4:none}
		keyring: ${5:none}
		state: ${6:absent|#present}
		file: ${7:none}
		validate_certs: ${8:#yes|no}
		id: ${9:none}
$0
endsnippet

snippet apt_repository "Add and remove APT repositories"
- name: $1
	apt_repository:
		repo: ${2:none}
		state: ${3:absent|#present}
		update_cache: ${4:#yes|no}
		mode: ${5:420}
		codename: ${6:# Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)}
		validate_certs: ${7:#yes|no}
		filename: ${8:# Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.}
$0
endsnippet

snippet apt_rpm "apt_rpm package manager"
- name: $1
	apt_rpm:
		pkg: ${2:# name of package to install, upgrade or remove.}
		state: ${3:absent|#present}
		update_cache: ${4:yes|no}
$0
endsnippet

snippet dnf "Manages packages with the I(dnf) package manager"
- name: $1
	dnf:
		name: ${2:# Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.}
		list: ${3:# Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.}
		disable_gpg_check: ${4:yes|#no}
		conf_file: ${5:# The remote dnf configuration file to use for the transaction.}
		state: ${6:#present|latest|absent}
		disablerepo: ${7:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		enablerepo: ${8:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		installroot: ${9:/}
$0
endsnippet

snippet dpkg_selections "Dpkg package selection selections"
- name: $1
	dpkg_selections:
		selection: ${2:install|hold|deinstall|purge}
		name: ${3:# Name of the package}
$0
endsnippet

snippet homebrew "Package manager for Homebrew"
- name: $1
	homebrew:
		install_options: ${2:# options flags to install a package}
		state: ${3:head|latest|#present|absent|linked|unlinked}
		name: ${4:# name of package to install/remove}
		update_homebrew: ${5:yes|no}
		path: ${6:/usr/local/bin}
		upgrade_all: ${7:yes|no}
$0
endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks."
- name: $1
	homebrew_cask:
		name: ${2:# name of cask to install/remove}
		update_homebrew: ${3:yes|no}
		path: ${4:/usr/local/bin}
		state: ${5:#present|absent}
		install_options: ${6:# options flags to install a package}
$0
endsnippet

snippet homebrew_tap "Tap a Homebrew repository."
- name: $1
	homebrew_tap:
		name: ${2:# The GitHub user/organization repository to tap.}
		url: ${3:# The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.}
		state: ${4:#present|absent}
$0
endsnippet

snippet layman "Manage Gentoo overlays"
- name: $1
	layman:
		name: ${2:# The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated)).}
		list_url: ${3:# An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration.}
		validate_certs: ${4:#yes|no}
		state: ${5:#present|absent|updated}
$0
endsnippet

snippet macports "Package manager for MacPorts"
- name: $1
	macports:
		name: ${2:# name of package to install/remove}
		state: ${3:#present|absent|active|inactive}
		update_cache: ${4:yes|#no}
$0
endsnippet

snippet openbsd_pkg "Manage packages on OpenBSD."
- name: $1
	openbsd_pkg:
		state: ${2:present|latest|absent}
		name: ${3:# Name of the package.}
		ports_dir: ${4:/usr/ports}
		clean: ${5:True|#False}
		quick: ${6:True|#False}
		build: ${7:True|#False}
$0
endsnippet

snippet opkg "Package manager for OpenWrt"
- name: $1
	opkg:
		name: ${2:# name of package to install/remove}
		force: ${3:|depends|maintainer|reinstall|overwrite|downgrade|space|postinstall|remove|checksum|removal-of-dependent-packages}
		state: ${4:#present|absent}
		update_cache: ${5:yes|#no}
$0
endsnippet

snippet package "Generic OS package manager"
- name: $1
	package:
		state: ${2:# Whether to install (C(present), C(latest)), or remove (C(absent)) a package.}
		name: ${3:# Package name, or package specifier with version, like C(name-1.0).}
		use: ${4:auto}
$0
endsnippet

snippet pacman "Manage packages with I(pacman)"
- name: $1
	pacman:
		state: ${2:#present|absent|latest}
		upgrade: ${3:yes|no}
		force: ${4:yes|no}
		name: ${5:# Name of the package to install, upgrade, or remove.}
		update_cache: ${6:yes|no}
		recurse: ${7:yes|no}
$0
endsnippet

snippet pkg5 "Manages packages with the Solaris 11 Image Packaging System"
- name: $1
	pkg5:
		name: ${2:# An FRMI of the package(s) to be installed/removed/updated.}
		accept_licenses: ${3:True|#False}
		state: ${4:#present|latest|absent}
$0
endsnippet

snippet pkg5_publisher "Manages Solaris 11 Image Packaging System publishers"
- name: $1
	pkg5_publisher:
		name: ${2:# The publisher's name.}
		origin: ${3:# A path or URL to the repository.}
		state: ${4:#present|absent}
		mirror: ${5:# A path or URL to the repository mirror.}
		enabled: ${6:True|False}
		sticky: ${7:True|False}
$0
endsnippet

snippet pkgin "Package manager for SmartOS, NetBSD, et al."
- name: $1
	pkgin:
		state: ${2:#present|absent}
		upgrade: ${3:yes|no}
		force: ${4:yes|no}
		name: ${5:# Name of package to install/remove;}
		full_upgrade: ${6:yes|no}
		update_cache: ${7:yes|no}
		clean: ${8:yes|no}
$0
endsnippet

snippet pkgng "Package manager for FreeBSD >= 9.0"
- name: $1
	pkgng:
		name: ${2:# Name of package to install/remove.}
		chroot: ${3:# Pkg will chroot in the specified environment.}
		cached: ${4:yes|no}
		pkgsite: ${5:# For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).}
		state: ${6:#present|absent}
		rootdir: ${7:# For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.}
		autoremove: ${8:yes|no}
		annotation: ${9:# A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.}
$0
endsnippet

snippet pkgutil "Manage CSW-Packages on Solaris"
- name: $1
	pkgutil:
		state: ${2:present|absent|latest}
		name: ${3:# Package name, e.g. (C(CSWnrpe))}
		site: ${4:# Specifies the repository path to install the package from.}
		update_catalog: ${5:no}
$0
endsnippet

snippet portage "Package manager for Gentoo"
- name: $1
	portage:
		nodeps: ${2:yes|no}
		onlydeps: ${3:yes|no}
		newuse: ${4:yes|no}
		oneshot: ${5:yes|no}
		update: ${6:yes|no}
		deep: ${7:yes|no}
		sync: ${8:web|yes|no}
		keepgoing: ${9:yes|no}
		depclean: ${10:yes|no}
		jobs: ${11:# Specifies the number of packages to build simultaneously.}
		noreplace: ${12:yes|no}
		loadavg: ${13:# Specifies that no new builds should be started if there are}
		verbose: ${14:yes|no}
		getbinpkg: ${15:yes|no}
		package: ${16:# Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)}
		quiet: ${17:yes|no}
		state: ${18:#present|installed|emerged|absent|removed|unmerged|latest}
		changed_use: ${19:yes|no}
		usepkgonly: ${20:yes|no}
$0
endsnippet

snippet portinstall "Installing packages from FreeBSD's ports system"
- name: $1
	portinstall:
		name: ${2:# name of package to install/remove}
		state: ${3:#present|absent}
		use_packages: ${4:yes|no}
$0
endsnippet

snippet pulp_repo "Add or remove Pulp repos from a remote host."
- name: $1
	pulp_repo:
		relative_url: ${2:# Relative URL for the local repository.}
		name: ${3:# Name of the repo to add or remove. This correlates to repo-id in Pulp.}
		feed: ${4:# Upstream feed URL to receive updates from.}
		repo_type: ${5:rpm}
		pulp_host: ${6:http://127.0.0.1}
		force_basic_auth: ${7:yes|#no}
		importer_ssl_client_cert: ${8:# Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.}
		proxy_port: ${9:# Proxy port setting for the pulp repository importer.}
		serve_http: ${10:no}
		wait_for_completion: ${11:yes|#no}
		add_export_distributor: ${12:no}
		url_password: ${13:# The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used.}
		importer_ssl_client_key: ${14:# Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.}
		publish_distributor: ${15:# Distributor to use when state is C(publish). The default is to publish all distributors.}
		proxy_host: ${16:# Proxy url setting for the pulp repository importer. This is in the format scheme://host.}
		state: ${17:#present|absent|sync|publish}
		serve_https: ${18:yes}
		importer_ssl_ca_cert: ${19:# CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file.}
		url_username: ${20:# The username for use in HTTP basic authentication to the pulp API.}
		validate_certs: ${21:#yes|no}
$0
endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command"
- name: $1
	redhat_subscription:
		username: ${2:# access.redhat.com or Sat6  username}
		server_hostname: ${3:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		password: ${4:# access.redhat.com or Sat6 password}
		consumer_type: ${5:# The type of unit to register, defaults to system}
		org_id: ${6:# Organization ID to use in conjunction with activationkey}
		consumer_id: ${7:# References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.
}
		environment: ${8:# Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello}
		force_register: ${9:no}
		state: ${10:#present|absent}
		autosubscribe: ${11:no}
		activationkey: ${12:# supply an activation key for use with registration}
		server_insecure: ${13:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		consumer_name: ${14:# Name of the system to register, defaults to the hostname}
		rhsm_baseurl: ${15:Current value from C(/etc/rhsm/rhsm.conf) is the default}
		pool: ${16:^$}
$0
endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels"
- name: $1
	rhn_channel:
		sysname: ${2:# name of the system as it is known in RHN/Satellite}
		name: ${3:# name of the software channel}
		url: ${4:# The full url to the RHN/Satellite api}
		password: ${5:# the user's password}
		user: ${6:# RHN/Satellite user}
		state: ${7:present}
$0
endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command"
- name: $1
	rhn_register:
		username: ${2:# Red Hat Network username}
		systemorgid: ${3:# supply an organizational id for use with registration}
		enable_eus: ${4:no}
		server_url: ${5:Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default}
		channels: ${6:[]}
		state: ${7:#present|absent}
		sslcacert: ${8:# supply a custom ssl CA certificate file for use with registration}
		activationkey: ${9:# supply an activation key for use with registration}
		profilename: ${10:# supply an profilename for use with registration}
		password: ${11:# Red Hat Network password}
$0
endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db"
- name: $1
	rpm_key:
		key: ${2:# Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.}
		state: ${3:#present|absent}
		validate_certs: ${4:#yes|no}
$0
endsnippet

snippet slackpkg "Package manager for Slackware >= 12.2"
- name: $1
	slackpkg:
		name: ${2:# name of package to install/remove}
		state: ${3:#present|absent|latest}
		update_cache: ${4:True|#False}
$0
endsnippet

snippet sorcery "Package manager for Source Mage GNU/Linux"
- name: $1
	sorcery:
		depends: ${2:# Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)}
		update_cache: ${3:yes|#no}
		name: ${4:# Name of the spell}
		state: ${5:#present|latest|absent|cast|dispelled|rebuild}
		update: ${6:yes|#no}
		cache_valid_time: ${7:# Time in seconds to invalidate grimoire collection on update}
$0
endsnippet

snippet svr4pkg "Manage Solaris SVR4 packages"
- name: $1
	svr4pkg:
		state: ${2:present|absent}
		name: ${3:# Package name, e.g. C(SUNWcsr)}
		category: ${4:true|false}
		src: ${5:# Specifies the location to install the package from. Required when C(state=present).}
		zone: ${6:current|#all}
		response_file: ${7:# Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)}
		proxy: ${8:# HTTP[s] proxy to be used if C(src) is a URL.}
$0
endsnippet

snippet swdepot "Manage packages with swdepot package manager (HP-UX)"
- name: $1
	swdepot:
		state: ${2:present|latest|absent}
		name: ${3:}
		depot: ${4:}
$0
endsnippet

snippet swupd "Manages updates and bundles in ClearLinux systems."
- name: $1
	swupd:
		contenturl: ${2:# URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.}
		name: ${3:# Name of the (I)bundle to install or remove.}
		format: ${4:# The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.}
		url: ${5:# Overrides both I(contenturl) and I(versionurl).}
		verify: ${6:# Verify content for OS version.}
		update: ${7:no}
		manifest: ${8:# The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.}
		state: ${9:#present|absent}
		versionurl: ${10:# URL for version string download.}
$0
endsnippet

snippet urpmi "Urpmi manager"
- name: $1
	urpmi:
		pkg: ${2:# name of package to install, upgrade or remove.}
		update_cache: ${3:yes|no}
		state: ${4:absent|#present}
		force: ${5:yes|no}
		no-recommends: ${6:yes|no}
$0
endsnippet

snippet xbps "Manage packages with XBPS"
- name: $1
	xbps:
		recurse: ${2:yes|no}
		state: ${3:#present|absent|latest}
		upgrade: ${4:yes|no}
		update_cache: ${5:yes|no}
		name: ${6:# Name of the package to install, upgrade, or remove.}
$0
endsnippet

snippet yum "Manages packages with the I(yum) package manager"
- name: $1
	yum:
		name: ${2:# Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: yum -y update. You can also pass a url or a local path to a rpm file (using state=present).  To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.}
		exclude: ${3:# Package name(s) to exclude when state=present, or latest}
		list: ${4:# Package name to run the equivalent of yum list <package> against.}
		disable_gpg_check: ${5:yes|#no}
		conf_file: ${6:# The remote yum configuration file to use for the transaction.}
		state: ${7:#present|installed|latest|absent|removed}
		disablerepo: ${8:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		update_cache: ${9:yes|#no}
		enablerepo: ${10:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
		skip_broken: ${11:yes|#no}
		validate_certs: ${12:#yes|no}
		installroot: ${13:/}
$0
endsnippet

snippet yum_repository "Add or remove YUM repositories"
- name: $1
	yum_repository:
		name: ${2:# Unique repository ID.}
		seuser: ${3:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
		ip_resolve: ${4:4|6|IPv4|IPv6|#whatever}
		enabled: ${5:#yes|no}
		proxy_password: ${6:# Username to use for proxy.}
		mode: ${7:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		owner: ${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		bandwidth: ${9:0}
		cost: ${10:1000}
		file: ${11:# File to use to save the repo in. Defaults to the value of I(name).}
		mirrorlist_expire: ${12:21600}
		exclude: ${13:# List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.}
		attributes: ${14:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
		keepalive: ${15:yes|#no}
		repo_gpgcheck: ${16:yes|#no}
		sslverify: ${17:#yes|no}
		failovermethod: ${18:#roundrobin|priority}
		unsafe_writes: ${19:no}
		deltarpm_metadata_percentage: ${20:100}
		gpgkey: ${21:# A URL pointing to the ASCII-armored GPG key file for the repository.}
		serole: ${22:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
		http_caching: ${23:#all|packages|none}
		priority: ${24:99}
		state: ${25:absent|#present}
		mirrorlist: ${26:# Specifies a URL to a file containing a list of baseurls.}
		params: ${27:# Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).}
		setype: ${28:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
		gpgcheck: ${29:yes|#no}
		include: ${30:# Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.}
		proxy_username: ${31:# Password for this proxy.}
		username: ${32:# Username to use for basic authentication to a repo or really any url.}
		metadata_expire: ${33:21600}
		description: ${34:# A human readable string describing the repository.}
		retries: ${35:10}
		selevel: ${36:s0}
		sslclientcert: ${37:# Path to the SSL client certificate yum should use to connect to repos/remote sites.}
		baseurl: ${38:# URL to the directory where the yum repository's 'repodata' directory lives.}
		gpgcakey: ${39:# A URL pointing to the ASCII-armored CA key file for the repository.}
		s3_enabled: ${40:yes|#no}
		includepkgs: ${41:# List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.}
		enablegroups: ${42:#yes|no}
		group: ${43:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		password: ${44:# Password to use with the username for basic authentication.}
		ui_repoid_vars: ${45:releasever basearch}
		protect: ${46:yes|#no}
		ssl_check_cert_permissions: ${47:yes|#no}
		throttle: ${48:# Enable bandwidth throttling for downloads.}
		deltarpm_percentage: ${49:75}
		sslclientkey: ${50:# Path to the SSL client key yum should use to connect to repos/remote sites.}
		metalink: ${51:# Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).}
		reposdir: ${52:/etc/yum.repos.d}
		skip_if_unavailable: ${53:yes|#no}
		keepcache: ${54:0|#1}
		sslcacert: ${55:# Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.}
		timeout: ${56:30}
		async: ${57:#yes|no}
		metadata_expire_filter: ${58:never|read-only:past|#read-only:present|read-only:future}
		proxy: ${59:# URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.}
$0
endsnippet

snippet zypper "Manage packages on SUSE and openSUSE"
- name: $1
	zypper:
		name: ${2:# Package name C(name) or package specifier.}
		force: ${3:yes|#no}
		disable_gpg_check: ${4:yes|#no}
		state: ${5:#present|latest|absent}
		oldpackage: ${6:yes|#no}
		update_cache: ${7:yes|#no}
		disable_recommends: ${8:#yes|no}
		type: ${9:#package|patch|pattern|product|srcpackage|application}
$0
endsnippet

snippet zypper_repository "Add and remove Zypper repositories"
- name: $1
	zypper_repository:
		repo: ${2:none}
		name: ${3:none}
		auto_import_keys: ${4:yes|#no}
		enabled: ${5:#yes|no}
		disable_gpg_check: ${6:yes|#no}
		priority: ${7:# Set priority of repository. Packages will always be installed from the repository with the smallest priority number.}
		state: ${8:absent|#present}
		autorefresh: ${9:#yes|no}
		overwrite_multiple: ${10:yes|#no}
		runrefresh: ${11:yes|#no}
		description: ${12:none}
$0
endsnippet

snippet wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet"
- name: $1
	wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		broadcast: ${3:255.255.255.255}
		port: ${4:7}
$0
endsnippet

snippet foreman "Manage Foreman Resources"
- name: $1
	foreman:
		username: ${2:# Username on Foreman server}
		password: ${3:# Password for user accessing Foreman server}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)}
		server_url: ${5:# URL of Foreman server}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host)}
$0
endsnippet

snippet katello "Manage Katello Resources"
- name: $1
	katello:
		username: ${2:# Username on Foreman server}
		password: ${3:# Password for user accessing Foreman server}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)}
		server_url: ${5:# URL of Foreman server}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host)}
$0
endsnippet

snippet hpilo_boot "Boot system using specific media through HP iLO interface"
- name: $1
	hpilo_boot:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		state: ${3:boot_always|#boot_once|connect|disconnect|no_boot|poweroff}
		force: ${4:yes|no}
		media: ${5:cdrom|floppy|hdd|#network|normal|usb}
		image: ${6:# The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename}
		password: ${7:admin}
		login: ${8:Administrator}
$0
endsnippet

snippet hpilo_facts "Gather facts through an HP iLO interface"
- name: $1
	hpilo_facts:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		password: ${3:admin}
		login: ${4:Administrator}
$0
endsnippet

snippet hponcfg "Configure HP iLO interface using hponcfg"
- name: $1
	hponcfg:
		path: ${2:# The XML file as accepted by hponcfg}
		minfw: ${3:# The minimum firmware level needed}
$0
endsnippet

snippet ipmi_boot "Management of order of boot devices"
- name: $1
	ipmi_boot:
		bootdev: ${2:network -- Request network boot|hd -- Boot from hard drive|safe -- Boot from hard drive, requesting 'safe mode'|optical -- boot from CD/DVD/BD drive|setup -- Boot into setup utility|default -- remove any IPMI directed boot device request}
		name: ${3:# Hostname or ip address of the BMC.}
		user: ${4:# Username to use to connect to the BMC.}
		password: ${5:# Password to connect to the BMC.}
		persistent: ${6:no}
		uefiboot: ${7:no}
		state: ${8:present -- Request system turn on|absent -- Request system turn on}
		port: ${9:623}
$0
endsnippet

snippet ipmi_power "Power management for machine"
- name: $1
	ipmi_power:
		state: ${2:on -- Request system turn on|off -- Request system turn off without waiting for OS to shutdown|shutdown -- Have system request OS proper shutdown|reset -- Request system reset without waiting for OS|boot -- If system is off, then 'on', else 'reset'}
		name: ${3:# Hostname or ip address of the BMC.}
		password: ${4:# Password to connect to the BMC.}
		user: ${5:# Username to use to connect to the BMC.}
		timeout: ${6:300}
		port: ${7:623}
$0
endsnippet

snippet stacki_host "Add or remove host to stacki front-end"
- name: $1
	stacki_host:
		name: ${2:# Name of the host to be added to Stacki.}
		stacki_user: ${3:# Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.}
		stacki_endpoint: ${4:# URL for the Stacki API Endpoint.}
		stacki_password: ${5:# Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.}
		prim_intf_ip: ${6:# IP Address for the primary network interface.}
		prim_intf: ${7:# Name of the primary network interface.}
		force_install: ${8:# Set value to True to force node into install state if it already exists in stacki.}
		prim_intf_mac: ${9:# MAC Address for the primary PXE boot network interface.}
$0
endsnippet

snippet bzr "Deploy software (or files) from bzr branches"
- name: $1
	bzr:
		dest: ${2:# Absolute path of where the branch should be cloned to.}
		name: ${3:# SSH or HTTP protocol address of the parent branch.}
		executable: ${4:# Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		version: ${5:head}
		force: ${6:yes|#no}
$0
endsnippet

snippet git "Deploy software (or files) from git checkouts"
- name: $1
	git:
		dest: ${2:# Absolute path of where the repository should be checked out to. This parameter is required, unless C(clone) is set to C(no) This change was made in version 1.8.3. Prior to this version, the C(dest) parameter was always required.}
		repo: ${3:# git, SSH, or HTTP(S) protocol address of the git repository.}
		force: ${4:yes|#no}
		track_submodules: ${5:yes|#no}
		reference: ${6:# Reference repository (see "git clone --reference ...")}
		accept_hostkey: ${7:yes|#no}
		clone: ${8:#yes|no}
		update: ${9:#yes|no}
		ssh_opts: ${10:# Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"}
		bare: ${11:yes|#no}
		verify_commit: ${12:yes|#no}
		recursive: ${13:#yes|no}
		executable: ${14:# Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		remote: ${15:origin}
		refspec: ${16:# Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".}
		umask: ${17:# The umask to set before doing any checkouts, or any other repository maintenance.}
		depth: ${18:# Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.}
		version: ${19:HEAD}
		key_file: ${20:# Specify an optional private key file to use for the checkout.}
$0
endsnippet

snippet git_config "Read and write git configuration"
- name: $1
	git_config:
		repo: ${2:# Path to a git repository for reading and writing values from a specific repo.}
		scope: ${3:local|global|system}
		list_all: ${4:yes|no}
		name: ${5:# The name of the setting. If no value is supplied, the value will be read from the config if it has been set.}
		value: ${6:# When specifying the name of a single setting, supply a value to set that setting to the given value.}
$0
endsnippet

snippet github_hooks "Manages github service hooks."
- name: $1
	github_hooks:
		repo: ${2:# This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.}
		oauthkey: ${3:# The oauth key provided by github. It can be found/generated on github under "Edit Your Profile" >> "Applications" >> "Personal Access Tokens"}
		user: ${4:# Github username.}
		action: ${5:create|cleanall|list|clean504}
		content_type: ${6:#json|form}
		validate_certs: ${7:#yes|no}
		hookurl: ${8:# When creating a new hook, this is the url that you want github to post to. It is only required when creating a new hook.}
$0
endsnippet

snippet github_key "Manage GitHub access keys."
- name: $1
	github_key:
		token: ${2:# GitHub Access Token with permission to list and create public keys.}
		name: ${3:# SSH key name}
		pubkey: ${4:none}
		force: ${5:#yes|no}
		state: ${6:#present|absent}
$0
endsnippet

snippet github_release "Interact with GitHub Releases"
- name: $1
	github_release:
		repo: ${2:# Repository name}
		action: ${3:latest_release}
		token: ${4:# Github Personal Access Token for authenticating}
		user: ${5:# The GitHub account that owns the repository}
$0
endsnippet

snippet gitlab_group "Creates/updates/deletes Gitlab Groups"
- name: $1
	gitlab_group:
		name: ${2:# Name of the group you want to create.}
		server_url: ${3:# Url of Gitlab server, with protocol (http or https).}
		login_user: ${4:# Gitlab user name.}
		login_token: ${5:# Gitlab token for logging in.}
		state: ${6:#present|absent}
		login_password: ${7:# Gitlab password for login_user}
		path: ${8:# The path of the group you want to create, this will be server_url/group_path}
		validate_certs: ${9:yes}
$0
endsnippet

snippet gitlab_project "Creates/updates/deletes Gitlab Projects"
- name: $1
	gitlab_project:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# The name of the project}
		merge_requests_enabled: ${4:yes}
		import_url: ${5:no}
		login_user: ${6:# Gitlab user name.}
		login_password: ${7:# Gitlab password for login_user}
		group: ${8:# The name of the group of which this projects belongs to.}
		wiki_enabled: ${9:yes}
		visibility_level: ${10:0}
		description: ${11:# An description for the project.}
		snippets_enabled: ${12:yes}
		login_token: ${13:# Gitlab token for logging in.}
		state: ${14:#present|absent}
		issues_enabled: ${15:yes}
		path: ${16:# The path of the project you want to create, this will be server_url/<group>/path}
		validate_certs: ${17:yes}
		public: ${18:no}
$0
endsnippet

snippet gitlab_user "Creates/updates/deletes Gitlab Users"
- name: $1
	gitlab_user:
		username: ${2:# The username of the user.}
		name: ${3:# Name of the user you want to create}
		server_url: ${4:# Url of Gitlab server, with protocol (http or https).}
		password: ${5:# The password of the user.}
		email: ${6:# The email that belongs to the user.}
		group: ${7:# Add user as an member to this group.}
		sshkey_file: ${8:# The ssh key itself.}
		sshkey_name: ${9:# The name of the sshkey}
		login_user: ${10:# Gitlab user name.}
		login_token: ${11:# Gitlab token for logging in.}
		access_level: ${12:# The access level to the group. One of the following can be used.}
		state: ${13:#present|absent}
		login_password: ${14:# Gitlab password for login_user}
		validate_certs: ${15:yes}
$0
endsnippet

snippet hg "Manages Mercurial (hg) repositories."
- name: $1
	hg:
		repo: ${2:# The repository address.}
		dest: ${3:# Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no}
		executable: ${4:# Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		force: ${5:yes|#no}
		clone: ${6:#yes|no}
		update: ${7:#yes|no}
		purge: ${8:yes|#no}
		revision: ${9:# Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.}
$0
endsnippet

snippet subversion "Deploys a subversion repository."
- name: $1
	subversion:
		dest: ${2:# Absolute path where the repository should be deployed.}
		repo: ${3:# The subversion URL to the repository.}
		username: ${4:# --username parameter passed to svn.}
		executable: ${5:# Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
		force: ${6:yes|#no}
		update: ${7:#yes|no}
		switch: ${8:#yes|no}
		export: ${9:yes|#no}
		password: ${10:# --password parameter passed to svn.}
		checkout: ${11:#yes|no}
		revision: ${12:HEAD}
$0
endsnippet

snippet infini_export "Create, Delete or Modify NFS Exports on Infinibox"
- name: $1
	infini_export:
		name: ${2:# Export name. Should always start with C(/). (ex. name=/data)}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		filesystem: ${4:# Name of exported file system.}
		inner_path: ${5:/}
		client_list: ${6:All Hosts(*), RW, no_root_squash: True}
		state: ${7:#present|absent}
		user: ${8:# Infinibox User username with sufficient priveledges ( see notes ).}
		password: ${9:# Infinibox User password.}
$0
endsnippet

snippet infini_export_client "Create, Delete or Modify NFS Client(s) for existing exports on Infinibox"
- name: $1
	infini_export_client:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		client: ${3:# Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.}
		export: ${4:# Name of the export.}
		no_root_squash: ${5:yes|no}
		password: ${6:# Infinibox User password.}
		state: ${7:#present|absent}
		user: ${8:# Infinibox User username with sufficient priveledges ( see notes ).}
		access_mode: ${9:#RW|RO}
$0
endsnippet

snippet infini_fs "Create, Delete or Modify filesystems on Infinibox"
- name: $1
	infini_fs:
		name: ${2:# File system name.}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		pool: ${4:# Pool that will host file system.}
		state: ${5:#present|absent}
		user: ${6:# Infinibox User username with sufficient priveledges ( see notes ).}
		password: ${7:# Infinibox User password.}
		size: ${8:# File system size in MB, GB or TB units. See examples.}
$0
endsnippet

snippet infini_host "Create, Delete and Modify Hosts on Infinibox"
- name: $1
	infini_host:
		name: ${2:# Host Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		volume: ${4:# Volume name to map to the host}
		state: ${5:#present|absent}
		user: ${6:# Infinibox User username with sufficient priveledges ( see notes ).}
		password: ${7:# Infinibox User password.}
		wwns: ${8:# List of wwns of the host}
$0
endsnippet

snippet infini_pool "Create, Delete and Modify Pools on Infinibox"
- name: $1
	infini_pool:
		name: ${2:# Pool Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		ssd_cache: ${4:yes|no}
		state: ${5:#present|absent}
		user: ${6:# Infinibox User username with sufficient priveledges ( see notes ).}
		password: ${7:# Infinibox User password.}
		vsize: ${8:# Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.}
		size: ${9:# Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.}
$0
endsnippet

snippet infini_vol "Create, Delete or Modify volumes on Infinibox"
- name: $1
	infini_vol:
		name: ${2:# Volume Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		pool: ${4:# Pool that volume will reside on}
		state: ${5:#present|absent}
		user: ${6:# Infinibox User username with sufficient priveledges ( see notes ).}
		password: ${7:# Infinibox User password.}
		size: ${8:# Volume size in MB, GB or TB units. See examples.}
$0
endsnippet

snippet na_cdot_aggregate "Manage NetApp cDOT aggregates."
- name: $1
	na_cdot_aggregate:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		state: ${3:present|absent}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		name: ${5:# The name of the aggregate to manage.}
		password: ${6:# Password for the specified user.}
		disk_count: ${7:# Number of disks to place into the aggregate, including parity disks.}
$0
endsnippet

snippet na_cdot_license "Manage NetApp cDOT protocol and feature licenses"
- name: $1
	na_cdot_license:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		password: ${4:# Password for the specified user.}
		licenses: ${5:# List of licenses to add or remove.}
		remove_unused: ${6:true|false}
		remove_expired: ${7:true|false}
		serial_number: ${8:# Serial number of the node associated with the license.}
$0
endsnippet

snippet na_cdot_lun "Manage  NetApp cDOT luns"
- name: $1
	na_cdot_lun:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the lun to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		force_remove: ${8:no}
		flexvol_name: ${9:# The name of the FlexVol the lun should exist on.}
		size_unit: ${10:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		force_resize: ${11:no}
		force_remove_fenced: ${12:no}
		size: ${13:# The size of the lun in C(size_unit).}
$0
endsnippet

snippet na_cdot_qtree "Manage qtrees"
- name: $1
	na_cdot_qtree:
		vserver: ${2:# The name of the vserver to use.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		state: ${4:present|absent}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		name: ${6:# The name of the Qtree to manage.}
		password: ${7:# Password for the specified user.}
		flexvol_name: ${8:# The name of the FlexVol the Qtree should exist on. Required when C(state=present).}
$0
endsnippet

snippet na_cdot_svm "Manage NetApp cDOT svm"
- name: $1
	na_cdot_svm:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the SVM to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		root_volume_aggregate: ${7:# The aggregate on which the root volume will be created.}
		root_volume_security_style: ${8:unix|ntfs|mixed|unified}
		root_volume: ${9:# Root volume of the SVM. Required when C(state=present).}
$0
endsnippet

snippet na_cdot_user "useradmin configuration and management"
- name: $1
	na_cdot_user:
		vserver: ${2:# The name of the vserver to use.}
		application: ${3:console|http|ontapi|rsh|snmp|sp|ssh|telnet}
		state: ${4:present|absent}
		name: ${5:# The name of the user to manage.}
		authentication_method: ${6:community|password|publickey|domain|nsswitch|usm}
		username: ${7:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		password: ${8:# Password for the specified user.}
		hostname: ${9:# The hostname or IP address of the ONTAP instance.}
		role_name: ${10:# The name of the role. Required when C(state=present)}
		set_password: ${11:# Password for the user account.}
$0
endsnippet

snippet na_cdot_user_role "useradmin configuration and management"
- name: $1
	na_cdot_user_role:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the role to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		command_directory_name: ${8:# The command or command directory to which the role has an access.}
		access_level: ${9:none|readonly|#all}
$0
endsnippet

snippet na_cdot_volume "Manage NetApp cDOT volumes"
- name: $1
	na_cdot_volume:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		password: ${3:# Password for the specified user.}
		name: ${4:# The name of the lun to manage.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		vserver: ${6:# Name of the vserver to use.}
		state: ${7:present|absent}
		size_unit: ${8:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		online: ${9:#True|False}
		infinite: ${10:True|#False}
		aggregate_name: ${11:# The name of the aggregate the flexvol should exist on. Required when C(state=present).}
		size: ${12:# The size of the volume in (size_unit). Required when C(state=present).}
$0
endsnippet

snippet netapp_e_amg "Create, Remove, and Update Asynchronous Mirror Groups"
- name: $1
	netapp_e_amg:
		name: ${2:# The name of the async array you wish to target, or create.}
		secondaryArrayId: ${3:# The ID of the secondary array to be used in mirroing process}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:# A C(state) of present will either create or update the async mirror group.}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${7:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${8:# The ID of the array to manage. This value must be unique for each array.}
		syncIntervalMinutes: ${9:10}
		recoveryWarnThresholdMinutes: ${10:20}
		repoUtilizationWarnThreshold: ${11:80}
		interfaceType: ${12:iscsi|fibre}
		manualSync: ${13:no}
		syncWarnThresholdMinutes: ${14:10}
		validate_certs: ${15:yes}
$0
endsnippet

snippet netapp_e_amg_role "Update the role of a storage array within an Asynchronous Mirror Group (AMG)."
- name: $1
	netapp_e_amg_role:
		ssid: ${2:# The ID of the primary storage array for the async mirror action}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		role: ${4:primary|secondary}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		force: ${7:no}
		validate_certs: ${8:yes}
		noSync: ${9:True|#False}
$0
endsnippet

snippet netapp_e_amg_sync "Conduct synchronization actions on asynchronous member groups."
- name: $1
	netapp_e_amg_sync:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${3:running|suspended}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${6:# The name of the async mirror group you wish to target}
		ssid: ${7:# The ID of the storage array containing the AMG you wish to target}
		delete_recovery_point: ${8:True|#False}
		validate_certs: ${9:yes}
$0
endsnippet

snippet netapp_e_auth "Sets or updates the password for a storage array."
- name: $1
	netapp_e_auth:
		new_password: ${2:# The password you would like to set. Cannot be more than 30 characters.}
		ssid: ${3:# the identifier of the storage array in the Web Services Proxy.}
		name: ${4:# The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.}
		api_password: ${5:# The password used to authenticate against the API}
		current_password: ${6:# The current admin password. This is not required if the password hasn't been set before.}
		api_username: ${7:# The username used to authenticate against the API}
		validate_certs: ${8:yes}
		set_admin: ${9:no}
		api_url: ${10:# The full API url.}
$0
endsnippet

snippet netapp_e_facts "Get facts about NetApp E-Series arrays"
- name: $1
	netapp_e_facts:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${3:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		validate_certs: ${6:yes}
$0
endsnippet

snippet netapp_e_flashcache "Manage NetApp SSD caches"
- name: $1
	netapp_e_flashcache:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:#present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${7:# The name of the SSD cache to manage}
		cache_size_min: ${8:# The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.}
		io_type: ${9:#filesystem|database|media}
		disk_count: ${10:# The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place}
		size_unit: ${11:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		validate_certs: ${12:yes}
$0
endsnippet

snippet netapp_e_host "manage eseries hosts"
- name: $1
	netapp_e_host:
		ssid: ${2:# the id of the storage array you wish to act against}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
		host_type_index: ${6:# The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.}
		name: ${7:# If the host doesnt yet exist, the label to assign at creation time.}
		group: ${8:# the group you want the host to be a member of}
		validate_certs: ${9:yes}
		ports: ${10:# a list of of dictionaries of host ports you wish to associate with the newly created host}
$0
endsnippet

snippet netapp_e_hostgroup "Manage NetApp Storage Array Host Groups"
- name: $1
	netapp_e_hostgroup:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		new_name: ${7:# specify this when you need to update the name of a host group}
		hosts:: ${8:# a list of host names/labels to add to the group}
		validate_certs: ${9:yes}
		id: ${10:# The id number of the host group to manage. Either this or C(name) must be supplied.}
		name: ${11:# The name of the host group to manage. Either this or C(id_num) must be supplied.}
$0
endsnippet

snippet netapp_e_lun_mapping "Create or Remove LUN Mappings"
- name: $1
	netapp_e_lun_mapping:
		volume_name: ${2:# The name of the volume you wish to include in the mapping.}
		state: ${3:present|absent}
		ssid: ${4:# The storage system array identifier.}
		api_password: ${5:# The password used to authenticate against the API. This can optionally be set via an environment variable, API_PASSWORD}
		target_type: ${6:host|group}
		target: ${7:# The name of host or hostgroup you wish to assign to the mapping}
		api_username: ${8:# The username used to authenticate against the API. This can optionally be set via an environment variable, API_USERNAME}
		validate_certs: ${9:yes}
		lun: ${10:0}
		api_url: ${11:# The full API url. Example: http://ENDPOINT:8080/devmgr/v2}
$0
endsnippet

snippet netapp_e_snapshot_group "Manage snapshot groups"
- name: $1
	netapp_e_snapshot_group:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		name: ${3:# The name to give the snapshot group}
		state: ${4:present|absent}
		storage_pool_name: ${5:# The name of the storage pool on which to allocate the repository volume.}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		base_volume_name: ${7:# The name of the base volume or thin volume to use as the base for the new snapshot group.}
		api_url: ${8:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		repo_pct: ${9:20}
		warning_threshold: ${10:80}
		rollback_priority: ${11:highest|high|#medium|low|lowest|__UNDEFINED}
		delete_limit: ${12:30}
		full_policy: ${13:#purgepit|unknown|failbasewrites|__UNDEFINED}
		validate_certs: ${14:yes}
$0
endsnippet

snippet netapp_e_snapshot_images "Create and delete snapshot images"
- name: $1
	netapp_e_snapshot_images:
		state: ${2:create|remove}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		snapshot_group: ${4:# The name of the snapshot group in which you want to create a snapshot image.}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${6:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		validate_certs: ${7:yes}
$0
endsnippet

snippet netapp_e_snapshot_volume "Manage E/EF-Series snapshot volumes."
- name: $1
	netapp_e_snapshot_volume:
		snapshot_image_id: ${2:# The identifier of the snapshot image used to create the new snapshot volume.}
		ssid: ${3:# storage array ID}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		view_mode: ${5:modeUnknown|readWrite|readOnly|__UNDEFINED}
		state: ${6:absent|present}
		storage_pool_name: ${7:# Name of the storage pool on which to allocate the repository volume.}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${9:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${10:# The name you wish to give the snapshot volume}
		repo_percentage: ${11:20}
		full_threshold: ${12:85}
		validate_certs: ${13:yes}
$0
endsnippet

snippet netapp_e_storage_system "Add/remove arrays from the Web Services Proxy"
- name: $1
	netapp_e_storage_system:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		controller_addresses: ${7:# The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.}
		meta_tags: ${8:# Optional meta tags to associate to this storage system}
		array_wwn: ${9:# The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.}
		array_password: ${10:# The management password of the array to manage, if set.}
		enable_trace: ${11:no}
		validate_certs: ${12:yes}
$0
endsnippet

snippet netapp_e_storagepool "Manage disk groups and disk pools"
- name: $1
	netapp_e_storagepool:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${4:# The name of the storage pool to manage}
		ssid: ${5:# The ID of the array to manage (as configured on the web services proxy).}
		raid_level: ${6:raidAll|raid0|raid1|raid3|raid5|raid6|raidDiskPool}
		state: ${7:present|absent}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		criteria_min_usable_capacity: ${9:# The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.}
		criteria_drive_type: ${10:hdd|ssd}
		remove_volumes: ${11:no}
		criteria_drive_min_size: ${12:# The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.}
		reserve_drive_count: ${13:# Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.}
		criteria_size_unit: ${14:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		criteria_drive_require_fde: ${15:# Whether full disk encryption ability is required for drives to be added to the storage pool}
		criteria_drive_interface_type: ${16:sas|sas4k|fibre|fibre520b|scsi|sata|pata}
		secure_pool: ${17:true|false}
		criteria_drive_count: ${18:# The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place}
		validate_certs: ${19:yes}
		erase_secured_drives: ${20:true|false}
$0
endsnippet

snippet netapp_e_volume "Manage storage volumes (standard and thin)"
- name: $1
	netapp_e_volume:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${4:# The name of the volume to manage}
		ssid: ${5:# The ID of the array to manage (as configured on the web services proxy).}
		state: ${6:present|absent}
		storage_pool_name: ${7:# Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		thin_volume_repo_size: ${9:# Initial size of the thin volume repository volume (in size_unit)}
		size: ${10:# Required only when state = 'present'.  The size of the volume in (size_unit).}
		segment_size_kb: ${11:512}
		thin_provision: ${12:yes|no|true|false}
		ssd_cache_enabled: ${13:yes|no|true|false}
		data_assurance_enabled: ${14:no}
		size_unit: ${15:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		thin_volume_max_repo_size: ${16:same as size (in size_unit)}
		validate_certs: ${17:yes}
$0
endsnippet

snippet netapp_e_volume_copy "Create volume copy pairs"
- name: $1
	netapp_e_volume_copy:
		api_url: ${2:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		create_copy_pair_if_does_not_exist: ${6:#True|False}
		search_volume_id: ${7:# Searches for all valid potential target and source volumes that could be used in a copy_pair}
		source_volume_id: ${8:# The the id of the volume copy source.}
		destination_volume_id: ${9:# The the id of the volume copy destination.}
		volume_copy_pair_id: ${10:# The the id of a given volume copy pair}
		start_stop_copy: ${11:# starts a re-copy or stops a copy in progress}
		validate_certs: ${12:yes}
$0
endsnippet

snippet sf_account_manager "Manage SolidFire accounts"
- name: $1
	sf_account_manager:
		password: ${2:# Password for the specified user.}
		name: ${3:# Unique username for this account. (May be 1 to 64 characters in length).}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		username: ${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		state: ${6:present|absent}
		new_name: ${7:# New name for the user account.}
		status: ${8:# Status of the account.}
		initiator_secret: ${9:# CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.}
		attributes: ${10:# L}
		target_secret: ${11:# CHAP secret to use for the target (mutual CHAP authentication).}
		account_id: ${12:# The ID of the account to manage or update.}
$0
endsnippet

snippet sf_check_connections "Check connectivity to MVIP and SVIP."
- name: $1
	sf_check_connections:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		password: ${4:# Password for the specified user.}
		svip: ${5:# Optionally, use to test connection of a different SVIP.}
		skip: ${6:svip|mvip}
		mvip: ${7:# Optionally, use to test connection of a different MVIP.}
$0
endsnippet

snippet sf_snapshot_schedule_manager "Manage SolidFire snapshot schedules"
- name: $1
	sf_snapshot_schedule_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# Name for the snapshot schedule.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		time_interval_days: ${7:1}
		time_interval_minutes: ${8:0}
		time_interval_hours: ${9:0}
		paused: ${10:# Pause / Resume a schedule.}
		schedule_id: ${11:# The schedule ID for the schedule that you want to update or delete.}
		snapshot_name: ${12:# Name for the created snapshots.}
		volumes: ${13:# Volume IDs that you want to set the snapshot schedule for.}
		starting_date: ${14:# Starting date for the schedule.}
		recurring: ${15:# Should the schedule recur?}
		retention: ${16:# Retention period for the snapshot.}
$0
endsnippet

snippet sf_volume_access_group_manager "Manage SolidFire Volume Access Groups"
- name: $1
	sf_volume_access_group_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		password: ${3:# Password for the specified user.}
		name: ${4:# Name of the volume access group. It is not required to be unique, but recommended.}
		hostname: ${5:# The hostname or IP address of the SolidFire cluster.}
		state: ${6:present|absent}
		virtual_network_id: ${7:# The ID of the SolidFire Virtual Network ID to associate the volume access group with.}
		volumes: ${8:# List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.}
		initiators: ${9:# List of initiators to include in the volume access group. If unspecified, the access group will start out without configured initiators.}
		attributes: ${10:# L}
		virtual_network_tags: ${11:# The ID of the VLAN Virtual Network Tag to associate the volume access group with.}
		volume_access_group_id: ${12:# The ID of the volume access group to modify or delete.}
$0
endsnippet

snippet sf_volume_manager "Manage SolidFire volumes"
- name: $1
	sf_volume_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# The name of the volume to manage.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		account_id: ${5:# Account ID for the owner of this volume.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		qos: ${8:# I}
		size_unit: ${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
		access: ${10:readOnly|readWrite|locked|replicationTarget}
		volume_id: ${11:# The ID of the volume to manage or update.}
		512emulation: ${12:# Should the volume provide 512-byte sector emulation?}
		attributes: ${13:# A}
		size: ${14:# The size of the volume in (size_unit).}
$0
endsnippet

snippet zfs "Manage zfs"
- name: $1
	zfs:
		state: ${2:present|absent}
		name: ${3:# File system, snapshot or volume name e.g. C(rpool/myfs)}
		origin: ${4:# Snapshot from which to create a clone}
		key_value: ${5:# The C(zfs) module takes key=value pairs for zfs properties to be set. See the zfs(8) man page for more information.}
$0
endsnippet

snippet zfs_facts "Gather facts about ZFS datasets."
- name: $1
	zfs_facts:
		name: ${2:# ZFS dataset name.}
		parsable: ${3:no}
		depth: ${4:# Specifiies recurion depth.}
		type: ${5:#all|filesystem|volume|snapshot|bookmark}
		recurse: ${6:no}
		properties: ${7:all}
$0
endsnippet

snippet zpool_facts "Gather facts about ZFS pools."
- name: $1
	zpool_facts:
		parsable: ${2:no}
		name: ${3:# ZFS pool name.}
		properties: ${4:all}
$0
endsnippet

snippet aix_inittab "Manages the inittab on AIX."
- name: $1
	aix_inittab:
		action: ${2:respawn|wait|once|boot|bootwait|powerfail|powerwait|off|hold|ondemand|initdefault|sysinit}
		command: ${3:# W}
		name: ${4:# N}
		runlevel: ${5:# R}
		state: ${6:#present|absent}
		insertafter: ${7:# A}
$0
endsnippet

snippet alternatives "Manages alternative programs for common commands"
- name: $1
	alternatives:
		path: ${2:# The path to the real executable that the link should point to.}
		name: ${3:# The generic name of the link.}
		priority: ${4:50}
		link: ${5:# The path to the symbolic link that should point to the real executable.}
$0
endsnippet

snippet at "Schedule the execution of a command or script file via the at command."
- name: $1
	at:
		count: ${2:# The count of units in the future to execute the command or script file.}
		units: ${3:minutes|hours|days|weeks}
		state: ${4:#present|absent}
		command: ${5:# A command to be executed in the future.}
		unique: ${6:no}
		script_file: ${7:# An existing script file to be executed in the future.}
$0
endsnippet

snippet authorized_key "Adds or removes an SSH authorized key"
- name: $1
	authorized_key:
		user: ${2:# The username on the remote host whose authorized_keys file will be modified}
		key: ${3:# The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)}
		exclusive: ${4:yes|#no}
		key_options: ${5:# A string of ssh key options to be prepended to the key in the authorized_keys file}
		state: ${6:#present|absent}
		path: ${7:(homedir)+/.ssh/authorized_keys}
		validate_certs: ${8:#yes|no}
		manage_dir: ${9:#yes|no}
$0
endsnippet

snippet beadm "Manage ZFS boot environments on FreeBSD/Solaris/illumos systems."
- name: $1
	beadm:
		name: ${2:# ZFS boot environment name.}
		state: ${3:#present|absent|activated|mounted|unmounted}
		force: ${4:true|false}
		mountpoint: ${5:no}
		snapshot: ${6:no}
		options: ${7:no}
		description: ${8:no}
$0
endsnippet

snippet capabilities "Manage Linux capabilities"
- name: $1
	capabilities:
		capability: ${2:# Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))}
		path: ${3:# Specifies the path to the file to be managed.}
		state: ${4:#present|absent}
$0
endsnippet

snippet cron "Manage cron.d and crontab entries."
- name: $1
	cron:
		cron_file: ${2:# If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). To use the C(cron_file) parameter you must specify the C(user) as well.}
		month: ${3:*}
		disabled: ${4:no}
		job: ${5:# The command to execute or, if env is set, the value of environment variable. Required if state=present.}
		special_time: ${6:reboot|yearly|annually|monthly|weekly|daily|hourly}
		user: ${7:root}
		insertafter: ${8:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable.}
		insertbefore: ${9:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable.}
		day: ${10:*}
		minute: ${11:*}
		name: ${12:# Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.}
		hour: ${13:*}
		reboot: ${14:yes|#no}
		state: ${15:#present|absent}
		weekday: ${16:*}
		env: ${17:yes|#no}
		backup: ${18:yes|no}
$0
endsnippet

snippet cronvar "Manage variables in crontabs"
- name: $1
	cronvar:
		name: ${2:# Name of the crontab variable.}
		insertbefore: ${3:# Used with C(state=present). If specified, the variable will be inserted just before the variable specified.}
		cron_file: ${4:# If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.}
		value: ${5:# The value to set this variable to.  Required if state=present.}
		state: ${6:#present|absent}
		user: ${7:root}
		insertafter: ${8:# Used with C(state=present). If specified, the variable will be inserted after the variable specified.}
		backup: ${9:no}
$0
endsnippet

snippet crypttab "Encrypted Linux block devices"
- name: $1
	crypttab:
		state: ${2:present|absent|opts_present|opts_absent}
		name: ${3:# Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionaly prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).}
		backing_device: ${4:# Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=)}
		path: ${5:/etc/crypttab}
		password: ${6:none}
		opts: ${7:# A comma-delimited list of options. See C(crypttab(5) ) for details.}
$0
endsnippet

snippet debconf "Configure a .deb package"
- name: $1
	debconf:
		name: ${2:# Name of package to configure.}
		value: ${3:# Value to set the configuration to}
		vtype: ${4:string|password|boolean|select|multiselect|note|error|title|text|seen}
		question: ${5:# A debconf configuration setting}
		unseen: ${6:no}
$0
endsnippet

snippet facter "Runs the discovery program I(facter) on the remote system"
- name: $1
	facter:
$0
endsnippet

snippet filesystem "Makes file system on block device"
- name: $1
	filesystem:
		dev: ${2:# Target block device.}
		fstype: ${3:# File System type to be created.}
		resizefs: ${4:yes|#no}
		force: ${5:yes|#no}
		opts: ${6:# List of options to be passed to mkfs command.}
$0
endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld"
- name: $1
	firewalld:
		state: ${2:enabled|disabled}
		zone: ${3:work|drop|internal|external|trusted|home|dmz|public|block}
		service: ${4:# Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.}
		masquerade: ${5:# The masquerade setting you would like to enable/disable to/from zones within firewalld}
		immediate: ${6:no}
		source: ${7:# The source/network you would like to add/remove to/from firewalld}
		permanent: ${8:# Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9)}
		timeout: ${9:0}
		interface: ${10:# The interface you would like to add/remove to/from a zone in firewalld}
		port: ${11:# Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.}
		rich_rule: ${12:# Rich rule to add/remove to/from firewalld.}
$0
endsnippet

snippet gconftool2 "Edit GNOME Configurations"
- name: $1
	gconftool2:
		state: ${2:get|present|absent}
		key: ${3:# A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)}
		value_type: ${4:int|bool|float|string}
		direct: ${5:yes|no}
		value: ${6:# Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)}
		config_source: ${7:# Specify a configuration source to use rather than the default path. See man gconftool-2(1)}
$0
endsnippet

snippet getent "a wrapper to the unix getent utility"
- name: $1
	getent:
		database: ${2:# the name of a getent database supported by the target system (passwd, group, hosts, etc).}
		fail_key: ${3:yes}
		split: ${4:# character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database}
		key: ${5:}
$0
endsnippet

snippet gluster_volume "Manage GlusterFS volumes"
- name: $1
	gluster_volume:
		name: ${2:# The volume name}
		state: ${3:present|absent|started|stopped}
		force: ${4:# If brick is being created in the root partition, module will fail. Set force to true to override this behaviour}
		replicas: ${5:# Replica count for volume}
		bricks: ${6:# Brick paths on servers. Multiple brick paths can be separated by commas}
		quota: ${7:# Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list)}
		stripes: ${8:# Stripe count for volume}
		cluster: ${9:# List of hosts to use for probing and brick setup}
		host: ${10:# Override local hostname (for peer probing purposes)}
		arbiter: ${11:# Arbiter count for volume}
		redundancies: ${12:# Redundancy count for volume}
		transport: ${13:#tcp|rdma|tcp,rdma}
		disperses: ${14:# Disperse count for volume}
		directory: ${15:# Directory for limit-usage}
		start_on_create: ${16:#yes|no}
		rebalance: ${17:yes|#no}
		options: ${18:# A dictionary/hash with options/settings for the volume}
$0
endsnippet

snippet group "Add or remove groups"
- name: $1
	group:
		name: ${2:# Name of the group to manage.}
		state: ${3:#present|absent}
		gid: ${4:# Optional I(GID) to set for the group.}
		system: ${5:yes|#no}
$0
endsnippet

snippet hostname "Manage hostname"
- name: $1
	hostname:
		name: ${2:# Name of the host}
$0
endsnippet

snippet iptables "Modify the systems iptables"
- name: $1
	iptables:
		comment: ${2:# This specifies a comment that will be added to the rule}
		protocol: ${3:# The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword "all", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default when this option is omitted.}
		goto: ${4:# This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.}
		chain: ${5:# Chain to operate on. This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'.}
		fragment: ${6:# This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.}
		out_interface: ${7:# Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
		to_source: ${8:# This specifies a source address to use with SNAT: without this, the source address is never altered.}
		limit_burst: ${9:# Specifies the maximum burst before the above limit kicks in.}
		ctstate: ${10:[]}
		jump: ${11:# This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto paramater is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.}
		policy: ${12:# Set the policy for the chain to the given target. Valid targets are ACCEPT, DROP, QUEUE, RETURN. Only built in chains can have policies. This parameter requires the chain parameter. Ignores all other parameters.}
		source_port: ${13:# Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
		to_ports: ${14:# This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.}
		flush: ${15:# Flushes the specified table and chain of all rules. If no chain is specified then the entire table is purged. Ignores all other parameters.}
		table: ${16:#filter|nat|mangle|raw|security}
		destination_port: ${17:# Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
		icmp_type: ${18:# This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'}
		to_destination: ${19:# This specifies a destination address to use with DNAT: without this, the destination address is never altered.}
		in_interface: ${20:# Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
		uid_owner: ${21:# Specifies the UID or username to use in match by owner rule.}
		set_dscp_mark_class: ${22:# This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark. Mutually exclusive with C(set_dscp_mark).}
		destination: ${23:# Destination specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.}
		set_dscp_mark: ${24:# This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value. Mutually exclusive with C(set_dscp_mark_class).}
		reject_with: ${25:# Specifies the error packet type to return while rejecting.}
		source: ${26:# Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.}
		state: ${27:#present|absent}
		limit: ${28:# Specifies the maximum average number of matches to allow per second. The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s').}
		action: ${29:#append|insert}
		set_counters: ${30:# This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).}
		ip_version: ${31:#ipv4|ipv6}
		match: ${32:[]}
$0
endsnippet

snippet java_cert "Uses keytool to import/remove key from java keystore(cacerts)"
- name: $1
	java_cert:
		keystore_pass: ${2:# Keystore password.}
		keystore_create: ${3:# Create keystore if it doesn't exist}
		cert_alias: ${4:# Imported certificate alias.}
		executable: ${5:keytool}
		cert_port: ${6:443}
		state: ${7:#present|absent}
		cert_url: ${8:# Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate.}
		cert_path: ${9:# Local path to load certificate from. One of cert_url or cert_path is required to load certificate.}
		keystore_path: ${10:# Path to keystore.}
$0
endsnippet

snippet kernel_blacklist "Blacklist kernel modules"
- name: $1
	kernel_blacklist:
		name: ${2:# Name of kernel module to black- or whitelist.}
		blacklist_file: ${3:# If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).}
		state: ${4:#present|absent}
$0
endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file"
- name: $1
	known_hosts:
		name: ${2:# The host to add or remove (must match a host specified in key)}
		path: ${3:(homedir)+/.ssh/known_hosts}
		state: ${4:#present|absent}
		hash_host: ${5:no}
		key: ${6:# The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(1), section "SSH_KNOWN_HOSTS FILE FORMAT")}
$0
endsnippet

snippet locale_gen "Creates or removes locales."
- name: $1
	locale_gen:
		name: ${2:# Name and encoding of the locale, such as "en_GB.UTF-8".}
		state: ${3:#present|absent}
$0
endsnippet

snippet lvg "Configure LVM volume groups"
- name: $1
	lvg:
		vg: ${2:# The name of the volume group.}
		vg_options: ${3:# Additional options to pass to C(vgcreate) when creating the volume group.}
		pvs: ${4:# List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.}
		force: ${5:yes|#no}
		pesize: ${6:4}
		state: ${7:#present|absent}
$0
endsnippet

snippet lvol "Configure LVM logical volumes"
- name: $1
	lvol:
		vg: ${2:# The volume group this logical volume is part of.}
		lv: ${3:# The name of the logical volume.}
		pvs: ${4:# Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb}
		force: ${5:yes|#no}
		state: ${6:#present|absent}
		snapshot: ${7:# The name of the snapshot volume}
		active: ${8:#yes|no}
		shrink: ${9:yes}
		opts: ${10:# Free-form options to be passed to the lvcreate command}
		size: ${11:# The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.}
$0
endsnippet

snippet make "Run targets in a Makefile"
- name: $1
	make:
		chdir: ${2:# cd into this directory before running make}
		params: ${3:none}
		target: ${4:none}
$0
endsnippet

snippet modprobe "Add or remove kernel modules"
- name: $1
	modprobe:
		name: ${2:# Name of kernel module to manage.}
		state: ${3:#present|absent}
		params: ${4:}
$0
endsnippet

snippet mount "Control active and configured mount points"
- name: $1
	mount:
		state: ${2:present|absent|mounted|unmounted}
		path: ${3:# Path to the mount point (e.g. C(/mnt/files)).}
		src: ${4:# Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted).}
		dump: ${5:0}
		passno: ${6:0}
		fstab: ${7:/etc/fstab (/etc/vfstab on Solaris)}
		boot: ${8:yes|no}
		fstype: ${9:# Filesystem type. Required when I(state) is C(present) or C(mounted).}
		opts: ${10:# Mount options (see fstab(5), or vfstab(4) on Solaris).}
$0
endsnippet

snippet ohai "Returns inventory data from I(Ohai)"
- name: $1
	ohai:
$0
endsnippet

snippet open_iscsi "Manage iscsi targets with open-iscsi"
- name: $1
	open_iscsi:
		auto_node_startup: ${2:True|False}
		target: ${3:# the iscsi target name}
		show_nodes: ${4:True|False}
		node_auth: ${5:CHAP}
		node_pass: ${6:# discovery.sendtargets.auth.password}
		discover: ${7:True|False}
		portal: ${8:# the ip address of the iscsi target}
		login: ${9:True|False}
		node_user: ${10:# discovery.sendtargets.auth.username}
		port: ${11:3260}
$0
endsnippet

snippet openwrt_init "Manage services on OpenWrt."
- name: $1
	openwrt_init:
		name: ${2:# Name of the service.}
		pattern: ${3:# If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.}
		state: ${4:started|stopped|restarted|reloaded}
		enabled: ${5:yes|no}
$0
endsnippet

snippet osx_defaults "osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible"
- name: $1
	osx_defaults:
		key: ${2:# The key of the user preference}
		domain: ${3:NSGlobalDomain}
		array_add: ${4:true|false}
		host: ${5:# The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.}
		type: ${6:array|bool|boolean|date|float|int|integer|#string}
		state: ${7:#present|absent}
		value: ${8:# The value to write. Only required when state = present.}
$0
endsnippet

snippet pam_limits "Modify Linux PAM limits"
- name: $1
	pam_limits:
		domain: ${2:# A username, @groupname, wildcard, uid/gid range.}
		value: ${3:# The value of the limit.}
		limit_item: ${4:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
		limit_type: ${5:hard|soft|-}
		comment: ${6:}
		use_max: ${7:yes|#no}
		dest: ${8:/etc/security/limits.conf}
		use_min: ${9:yes|#no}
		backup: ${10:yes|#no}
$0
endsnippet

snippet pamd "Manage PAM Modules"
- name: $1
	pamd:
		control: ${2:# The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.}
		name: ${3:# The name generally refers to the PAM service file to change, for example system-auth.}
		module_path: ${4:# The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		type: ${5:# The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		new_module_path: ${6:# The control to assign to the new rule.}
		new_type: ${7:# The type to assign to the new rule.}
		state: ${8:#updated|before|after|args_present|args_absent}
		new_control: ${9:# The control to assign to the new rule.}
		path: ${10:/etc/pam.d/}
		module_arguments: ${11:# When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.}
$0
endsnippet

snippet parted "Configure block device partitions"
- name: $1
	parted:
		device: ${2:# T}
		part_start: ${3:0%}
		part_end: ${4:100%}
		name: ${5:# Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).}
		align: ${6:none|cylinder|minimal|#optimal}
		number: ${7:# The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.}
		label: ${8:aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun|}
		state: ${9:present|absent|#info}
		part_type: ${10:primary|extended|logical}
		flags: ${11:# A}
		unit: ${12:s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact}
$0
endsnippet

snippet ping "Try to connect to host, verify a usable python and return C(pong) on success."
- name: $1
	ping:
$0
endsnippet

snippet puppet "Runs puppet"
- name: $1
	puppet:
		logdest: ${2:#stdout|syslog}
		execute: ${3:# Execute a specific piece of Puppet code. It has no effect with a puppetmaster.}
		facter_basename: ${4:ansible}
		tags: ${5:# A comma-separated list of puppet tags to be used.}
		puppetmaster: ${6:# The hostname of the puppetmaster to contact.}
		certname: ${7:# The name to use when handling certificates.}
		manifest: ${8:# Path to the manifest file to run puppet apply on.}
		environment: ${9:# Puppet environment to be used.}
		timeout: ${10:30m}
		facts: ${11:# A dict of values to pass in as persistent external facter facts}
$0
endsnippet

snippet runit "Manage runit services."
- name: $1
	runit:
		name: ${2:# Name of the service to manage.}
		state: ${3:started|stopped|restarted|killed|reloaded|once}
		enabled: ${4:yes|no}
		service_dir: ${5:/var/service}
		service_src: ${6:/etc/sv}
$0
endsnippet

snippet seboolean "Toggles SELinux booleans."
- name: $1
	seboolean:
		state: ${2:yes|no}
		name: ${3:# Name of the boolean to configure}
		persistent: ${4:yes|no}
$0
endsnippet

snippet sefcontext "Manages SELinux file context mapping definitions"
- name: $1
	sefcontext:
		setype: ${2:# SELinux type for the specified target.}
		target: ${3:# Target path (expression).}
		reload: ${4:yes}
		ftype: ${5:a}
		selevel: ${6:# SELinux range for the specified target.}
		seuser: ${7:# SELinux user for the specified target.}
		state: ${8:#present|absent}
$0
endsnippet

snippet selinux "Change policy and state of SELinux"
- name: $1
	selinux:
		state: ${2:enforcing|permissive|disabled}
		policy: ${3:# name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)}
		conf: ${4:/etc/selinux/config}
$0
endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy"
- name: $1
	selinux_permissive:
		domain: ${2:# the domain that will be added or removed from the list of permissive domains}
		permissive: ${3:True|False}
		no_reload: ${4:True|False}
		store: ${5:# name of the SELinux policy store to use}
$0
endsnippet

snippet seport "Manages SELinux network port type definitions"
- name: $1
	seport:
		setype: ${2:# SELinux type for the specified port.}
		proto: ${3:tcp|udp}
		state: ${4:#present|absent}
		ports: ${5:# Ports or port ranges, separated by a comma}
		reload: ${6:yes}
$0
endsnippet

snippet service "Manage services."
- name: $1
	service:
		name: ${2:# Name of the service.}
		use: ${3:auto}
		pattern: ${4:# If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.}
		enabled: ${5:yes|no}
		state: ${6:started|stopped|restarted|reloaded}
		sleep: ${7:# If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.}
		arguments: ${8:# Additional arguments provided on the command line}
		runlevel: ${9:default}
$0
endsnippet

snippet setup "Gathers facts about remote hosts"
- name: $1
	setup:
		filter: ${2:*}
		gather_subset: ${3:all}
		fact_path: ${4:/etc/ansible/facts.d}
		gather_timeout: ${5:10}
$0
endsnippet

snippet solaris_zone "Manage Solaris zones"
- name: $1
	solaris_zone:
		name: ${2:# Zone name.}
		state: ${3:#present|installed|started|running|stopped|absent|configured|attached|detached}
		install_options: ${4:empty string}
		sparse: ${5:no}
		create_options: ${6:empty string}
		root_password: ${7:# The password hash for the root account. If not specified, the zone's root account will not have a password.}
		timeout: ${8:600}
		path: ${9:# The path where the zone will be created. This is required when the zone is created, but not used otherwise.}
		config: ${10:empty string}
		attach_options: ${11:empty string}
$0
endsnippet

snippet svc "Manage daemontools services."
- name: $1
	svc:
		name: ${2:# Name of the service to manage.}
		service_dir: ${3:/service}
		downed: ${4:yes|no}
		enabled: ${5:yes|no}
		state: ${6:started|stopped|restarted|reloaded|once}
		service_src: ${7:# directory where services are defined, the source of symlinks to service_dir.}
$0
endsnippet

snippet sysctl "Manage entries in sysctl.conf."
- name: $1
	sysctl:
		name: ${2:# The dot-separated path (aka I(key)) specifying the sysctl variable.}
		reload: ${3:#yes|no}
		state: ${4:#present|absent}
		sysctl_set: ${5:yes|no}
		ignoreerrors: ${6:yes|no}
		sysctl_file: ${7:/etc/sysctl.conf}
		value: ${8:# Desired value of the sysctl key.}
$0
endsnippet

snippet systemd "Manage services."
- name: $1
	systemd:
		name: ${2:# Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service).}
		masked: ${3:yes|no}
		state: ${4:started|stopped|restarted|reloaded}
		no_block: ${5:yes|no}
		enabled: ${6:yes|no}
		daemon_reload: ${7:yes|no}
		user: ${8:yes|no}
$0
endsnippet

snippet timezone "Configure timezone setting"
- name: $1
	timezone:
		hwclock: ${2:# Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS. B(At least one of name and hwclock are required.) I(Only used on Linux.)}
		name: ${3:# Name of the timezone for the system clock. Default is to keep current setting. B(At least one of name and hwclock are required.)}
$0
endsnippet

snippet ufw "Manage firewall with UFW"
- name: $1
	ufw:
		direction: ${2:in|out|incoming|outgoing|routed}
		from_port: ${3:# Source port.}
		to_ip: ${4:any}
		to_port: ${5:# Destination port.}
		from_ip: ${6:any}
		interface: ${7:# Specify interface for rule.}
		name: ${8:# Use profile located in C(/etc/ufw/applications.d)}
		insert: ${9:# Insert the corresponding rule as rule number NUM}
		logging: ${10:on|off|low|medium|high|full}
		log: ${11:yes|no}
		proto: ${12:any|tcp|udp|ipv6|esp|ah}
		route: ${13:yes|no}
		rule: ${14:allow|deny|reject|limit}
		state: ${15:enabled|disabled|reloaded|reset}
		policy: ${16:allow|deny|reject}
		delete: ${17:yes|no}
$0
endsnippet

snippet user "Manage user accounts"
- name: $1
	user:
		name: ${2:# Name of the user to create, remove or modify.}
		comment: ${3:# Optionally sets the description (aka I(GECOS)) of user account.}
		ssh_key_bits: ${4:default set by ssh-keygen}
		update_password: ${5:#always|on_create}
		non_unique: ${6:yes|#no}
		force: ${7:yes|#no}
		ssh_key_type: ${8:rsa}
		expires: ${9:# An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux and FreeBSD.}
		ssh_key_passphrase: ${10:# Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.}
		groups: ${11:# Puts the user in  list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.}
		home: ${12:# Optionally set the user's home directory.}
		move_home: ${13:yes|#no}
		password: ${14:# Optionally set the user's password to this crypted value.  See the user example in the github examples directory for what this looks like in a playbook. See U(http://docs.ansible.com/ansible/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module) for details on various ways to generate these password values. Note on Darwin system, this value has to be cleartext. Beware of security issues.}
		skeleton: ${15:# Optionally set a home skeleton directory. Requires createhome option!}
		generate_ssh_key: ${16:yes|#no}
		append: ${17:yes|#no}
		uid: ${18:# Optionally sets the I(UID) of the user.}
		ssh_key_comment: ${19:ansible-generated on $HOSTNAME}
		group: ${20:# Optionally sets the user's primary group (takes a group name).}
		createhome: ${21:#yes|no}
		system: ${22:yes|#no}
		remove: ${23:yes|#no}
		seuser: ${24:# Optionally sets the seuser type (user_u) on selinux enabled systems.}
		state: ${25:#present|absent}
		ssh_key_file: ${26:.ssh/id_rsa}
		login_class: ${27:# Optionally sets the user's login class for FreeBSD, OpenBSD and NetBSD systems.}
		shell: ${28:# Optionally set the user's shell.}
$0
endsnippet

snippet meta "Execute Ansible 'actions'"
- name: $1
	meta:
		${2:free_form=noop|flush_handlers|refresh_inventory|clear_facts|clear_host_errors|end_play}
$0
endsnippet

snippet assert "Asserts given expressions are true"
- name: $1
	assert:
		that: ${2:# A string expression of the same form that can be passed to the 'when' statement}
		msg: ${3:# The customized message used for a failing assertion}
$0
endsnippet

snippet async_status "Obtain status of asynchronous task"
- name: $1
	async_status:
		jid: ${2:# Job or task identifier}
		mode: ${3:#status|cleanup}
$0
endsnippet

snippet debug "Print statements during execution"
- name: $1
	debug:
		msg: ${2:Hello world!}
		var: ${3:# A variable name to debug.  Mutually exclusive with the 'msg' option.}
		verbosity: ${4:0}
$0
endsnippet

snippet fail "Fail with custom message"
- name: $1
	fail:
		msg: ${2:'Failed as requested from task'}
$0
endsnippet

snippet include "include a play or task list."
- name: $1
	include:
		free-form: ${2:# This module allows you to specify the name of the file directly w/o any other options.}
$0
endsnippet

snippet include_role "Load and execute a role"
- name: $1
	include_role:
		name: ${2:# The name of the role to be executed.}
		allow_duplicates: ${3:yes}
		tasks_from: ${4:main}
		vars_from: ${5:main}
		defaults_from: ${6:main}
		private: ${7:# If True the variables from defaults/ and vars/ in a role will not be made available to the rest of the play.}
$0
endsnippet

snippet include_vars "Load variables from files, dynamically within a task."
- name: $1
	include_vars:
		ignore_files: ${2:# List of file names to ignore.}
		free-form: ${3:# This module allows you to specify the 'file' option directly w/o any other options. There is no 'free-form' option, this is just an indicator, see example below.}
		files_matching: ${4:# Limit the files that are loaded within any directory to this regular expression.}
		depth: ${5:0}
		extensions: ${6:[u'yaml', u'yml', u'json']}
		file: ${7:# The file name from which variables should be loaded.}
		dir: ${8:# The directory name from which the variables should be loaded.}
		name: ${9:# The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars.}
$0
endsnippet

snippet pause "Pause playbook execution"
- name: $1
	pause:
		seconds: ${2:# A positive number of seconds to pause for.}
		minutes: ${3:# A positive number of minutes to pause for.}
		prompt: ${4:# Optional text to use for the prompt message.}
$0
endsnippet

snippet set_fact "Set host facts from a task"
- name: $1
	set_fact:
		key_value: ${2:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}
$0
endsnippet

snippet set_stats "Set stats for the current ansible run"
- name: $1
	set_stats:
		data: ${2:# A dictionary of which each key represents a stat (or variable) you want to keep track of}
		aggregate: ${3:yes}
		per_host: ${4:no}
$0
endsnippet

snippet wait_for "Waits for a condition before continuing."
- name: $1
	wait_for:
		active_connection_states: ${2:[u'ESTABLISHED', u'SYN_SENT', u'SYN_RECV', u'FIN_WAIT1', u'FIN_WAIT2', u'TIME_WAIT']}
		host: ${3:127.0.0.1}
		connect_timeout: ${4:5}
		delay: ${5:0}
		state: ${6:present|#started|stopped|absent|drained}
		sleep: ${7:1}
		timeout: ${8:300}
		exclude_hosts: ${9:# list of hosts or IPs to ignore when looking for active TCP connections for C(drained) state}
		search_regex: ${10:# Can be used to match a string in either a file or a socket connection. Defaults to a multiline regex.}
		path: ${11:# path to a file on the filesytem that must exist before continuing}
		port: ${12:# port number to poll}
$0
endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable"
- name: $1
	wait_for_connection:
		delay: ${2:0}
		sleep: ${3:1}
		connect_timeout: ${4:5}
		timeout: ${5:600}
$0
endsnippet

snippet apache2_mod_proxy "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool"
- name: $1
	apache2_mod_proxy:
		balancer_vhost: ${2:# (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.}
		tls: ${3:true|false}
		member_host: ${4:# (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.}
		validate_certs: ${5:true|false}
		state: ${6:present|absent|enabled|disabled|drained|hot_standby|ignore_errors}
		balancer_url_suffix: ${7:/balancer-manager/}
$0
endsnippet

snippet apache2_module "enables/disables a module of the Apache2 webserver"
- name: $1
	apache2_module:
		name: ${2:# name of the module to enable/disable}
		state: ${3:#present|absent}
		force: ${4:True|False}
		ignore_configcheck: ${5:True|False}
$0
endsnippet

snippet deploy_helper "Manages some of the steps common in deploying projects."
- name: $1
	deploy_helper:
		path: ${2:# the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact.}
		unfinished_filename: ${3:DEPLOY_UNFINISHED}
		keep_releases: ${4:5}
		current_path: ${5:current}
		state: ${6:#present|finalize|absent|clean|query}
		shared_path: ${7:shared}
		releases_path: ${8:releases}
		clean: ${9:yes}
		release: ${10:# the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).}
$0
endsnippet

snippet django_manage "Manages a Django application."
- name: $1
	django_manage:
		app_path: ${2:# The path to the root of the Django application where B(manage.py) lives.}
		command: ${3:cleanup|collectstatic|flush|loaddata|migrate|runfcgi|syncdb|test|validate}
		virtualenv: ${4:# An optional path to a I(virtualenv) installation to use while running the manage application.}
		settings: ${5:# The Python path to the application's settings module, such as 'myapp.settings'.}
		pythonpath: ${6:# A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.}
		database: ${7:# The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands.}
		apps: ${8:# A list of space-delimited apps to target. Used by the 'test' command.}
		cache_table: ${9:# The name of the table used for database-backed caching. Used by the 'createcachetable' command.}
		merge: ${10:# Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command}
		skip: ${11:# Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)}
		link: ${12:# Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command}
		fixtures: ${13:# A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command.}
		failfast: ${14:yes|#no}
$0
endsnippet

snippet ejabberd_user "Manages users for ejabberd servers"
- name: $1
	ejabberd_user:
		username: ${2:# the name of the user to manage}
		host: ${3:# the ejabberd host associated with this username}
		password: ${4:# the password to assign to the username}
		logging: ${5:true|false|yes|no}
		state: ${6:#present|absent}
$0
endsnippet

snippet htpasswd "manage user files for basic authentication"
- name: $1
	htpasswd:
		name: ${2:# User name to add or remove}
		path: ${3:# Path to the file that contains the usernames and passwords}
		state: ${4:#present|absent}
		create: ${5:#yes|no}
		password: ${6:# Password associated with user.}
		crypt_scheme: ${7:#apr_md5_crypt|des_crypt|ldap_sha1|plaintext}
$0
endsnippet

snippet jboss "deploy applications to JBoss"
- name: $1
	jboss:
		deployment: ${2:# The name of the deployment}
		src: ${3:# The remote path of the application ear or war to deploy}
		deploy_path: ${4:/var/lib/jbossas/standalone/deployments}
		state: ${5:#present|absent}
$0
endsnippet

snippet jenkins_job "Manage jenkins jobs"
- name: $1
	jenkins_job:
		name: ${2:# Name of the Jenkins job.}
		url: ${3:http://localhost:8080}
		enabled: ${4:# Whether the job should be enabled or disabled.}
		state: ${5:#present|absent}
		token: ${6:# API token used to authenticate alternatively to password.}
		user: ${7:# User to authenticate with the Jenkins server.}
		password: ${8:# Password to authenticate with the Jenkins server.}
		config: ${9:# config in XML format.}
$0
endsnippet

snippet jenkins_plugin "Add or remove Jenkins plugin"
- name: $1
	jenkins_plugin:
		name: ${2:# Plugin name.}
		jenkins_home: ${3:/var/lib/jenkins}
		group: ${4:jenkins}
		url: ${5:http://localhost:8080}
		updates_url: ${6:https://updates.jenkins-ci.org}
		with_dependencies: ${7:#yes|no}
		state: ${8:absent|#present|pinned|unpinned|enabled|disabled|latest}
		version: ${9:# Plugin version number.}
		params: ${10:# Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).}
		mode: ${11:0664}
		timeout: ${12:30}
		owner: ${13:jenkins}
		updates_expiration: ${14:86400}
$0
endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance"
- name: $1
	jenkins_script:
		script: ${2:# The groovy script to be executed. This gets passed as a string Template if args is defined.}
		password: ${3:# The password to connect to the jenkins server with.}
		user: ${4:# The username to connect to the jenkins server with.}
		url: ${5:http://localhost:8080}
		args: ${6:# A dict of key-value pairs used in formatting the script.}
		validate_certs: ${7:yes}
$0
endsnippet

snippet jira "create and modify issues in a JIRA instance"
- name: $1
	jira:
		username: ${2:# The username to log-in with.}
		operation: ${3:create|comment|edit|fetch|transition}
		password: ${4:# The password to log-in with.}
		uri: ${5:# Base URI for the JIRA instance.}
		comment: ${6:# The comment text to add.}
		description: ${7:# The issue description, where appropriate.}
		assignee: ${8:# Sets the assignee on create or transition operations. Note not all transitions will allow this.}
		inwardissue: ${9:# Set issue from which link will be created.}
		linktype: ${10:# Set type of link, when action 'link' selected.}
		fields: ${11:# This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.}
		outwardissue: ${12:# Set issue to which link will be created.}
		summary: ${13:# The issue summary, where appropriate.}
		project: ${14:# The project for this operation. Required for issue creation.}
		status: ${15:# The desired status; only relevant for the transition operation.}
		timeout: ${16:10}
		issuetype: ${17:# The issue type, for issue creation.}
		issue: ${18:# An existing issue key to operate on.}
$0
endsnippet

snippet letsencrypt "Create SSL certificates with Let's Encrypt"
- name: $1
	letsencrypt:
		dest: ${2:# T}
		account_key: ${3:# File containing the the Let's Encrypt account RSA key.}
		csr: ${4:# File containing the CSR for the new certificate.}
		acme_directory: ${5:https://acme-staging.api.letsencrypt.org/directory}
		account_email: ${6:# The email address associated with this account.}
		data: ${7:# The data to validate ongoing challenges.}
		challenge: ${8:#http-01|dns-01|tls-sni-02}
		agreement: ${9:https://letsencrypt.org/documents/LE-SA-v1.1.1-August-1-2016.pdf}
		remaining_days: ${10:10}
$0
endsnippet

snippet nginx_status_facts "Retrieve nginx status facts."
- name: $1
	nginx_status_facts:
		url: ${2:# URL of the nginx status.}
		timeout: ${3:10}
$0
endsnippet

snippet supervisorctl "Manage the state of a program or group of programs running via supervisord"
- name: $1
	supervisorctl:
		state: ${2:present|started|stopped|restarted|absent}
		name: ${3:# The name of the supervisord program or group to manage.}
		username: ${4:# username to use for authentication}
		supervisorctl_path: ${5:# path to supervisorctl executable}
		password: ${6:# password to use for authentication}
		config: ${7:# The supervisor configuration file path}
		server_url: ${8:# URL on which supervisord server is listening}
$0
endsnippet

snippet taiga_issue "Creates/deletes an issue in a Taiga Project Management Platform"
- name: $1
	taiga_issue:
		project: ${2:# Name of the project containing the issue. Must exist previously.}
		issue_type: ${3:# The issue type. Must exist previously.}
		subject: ${4:# The issue subject.}
		status: ${5:New}
		severity: ${6:Normal}
		tags: ${7:[]}
		priority: ${8:Normal}
		taiga_host: ${9:https://api.taiga.io}
		state: ${10:#present|absent}
		attachment: ${11:# Path to a file to be attached to the issue.}
		attachment_description: ${12:}
		description: ${13:}
$0
endsnippet

snippet tower_credential "create, update, or destroy Ansible Tower credential."
- name: $1
	tower_credential:
		kind: ${2:ssh|net|scm|aws|rax|vmware|satellite6|cloudforms|gce|azure|azure_rm|openstack}
		name: ${3:# The name to use for the credential.}
		authorize: ${4:no}
		username: ${5:# Username for this credential. access_key for AWS.}
		domain: ${6:# Domain for openstack type.}
		description: ${7:# The description to use for the credential.}
		tower_host: ${8:# URL to your Tower instance.}
		vault_password: ${9:# Valut password. Use ASK for prompting.}
		team: ${10:# Team that should own this credential.}
		tower_config_file: ${11:# Path to the Tower config file. See notes.}
		host: ${12:# Host for this credential.}
		user: ${13:# User that should own this credential.}
		become_password: ${14:# Become password. Use ASK for prompting.}
		tower_password: ${15:# Password for your Tower instance.}
		tower_username: ${16:# Username for your Tower instance.}
		become_username: ${17:# Become username. Use ASK for prompting.}
		password: ${18:# Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX.}
		tenant: ${19:# Tenant ID for azure_rm type.}
		subscription: ${20:# Subscription ID for azure_rm type.}
		become_method: ${21:#None|sudo|su|pbrun|pfexec}
		tower_verify_ssl: ${22:yes}
		secret: ${23:# Secret token for azure_rm type.}
		project: ${24:# Project that should for this credential.}
		state: ${25:#present|absent}
		client: ${26:# Client or application ID for azure_rm type.}
		ssh_key_data: ${27:# Path to SSH private key.}
		ssh_key_unlock: ${28:# Unlock password for ssh_key. Use ASK for prompting.}
		organization: ${29:# Organization that should own the credential.}
		authorize_password: ${30:# Password for net credentials that require authroize.}
$0
endsnippet

snippet tower_group "create, update, or destroy Ansible Tower group."
- name: $1
	tower_group:
		name: ${2:# The name to use for the group.}
		inventory: ${3:# Inventory the group should be made a member of.}
		credential: ${4:# Credential to use for the group.}
		description: ${5:# The description to use for the group.}
		overwrite_vars: ${6:# Override vars in child groups and hosts with those from external source.}
		source_regions: ${7:# Regions for cloud provider.}
		variables: ${8:# Variables to use for the group, use '@' for a file.}
		tower_username: ${9:# Username for your Tower instance.}
		tower_password: ${10:# Password for your Tower instance.}
		tower_config_file: ${11:# Path to the Tower config file. See notes.}
		overwrite: ${12:no}
		source_vars: ${13:# Override variables from source with variables from this field.}
		source_script: ${14:# Inventory script to be used when group type is "custom".}
		update_on_launch: ${15:no}
		tower_verify_ssl: ${16:yes}
		instance_filters: ${17:# Comma-separated list of filter expressions for matching hosts.}
		source: ${18:manual|file|ec2|rax|vmware|gce|azure|azure_rm|openstack|satellite6|cloudforms|custom}
		state: ${19:#present|absent}
		group_by: ${20:# Limit groups automatically created from inventory source.}
		tower_host: ${21:# URL to your Tower instance.}
$0
endsnippet

snippet tower_host "create, update, or destroy Ansible Tower host."
- name: $1
	tower_host:
		name: ${2:# The name to use for the host.}
		inventory: ${3:# Inventory the host should be made a member of.}
		tower_host: ${4:# URL to your Tower instance.}
		variables: ${5:# Variables to use for the host. Use '@' for a file.}
		enabled: ${6:yes}
		tower_username: ${7:# Username for your Tower instance.}
		state: ${8:#present|absent}
		tower_password: ${9:# Password for your Tower instance.}
		tower_config_file: ${10:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${11:yes}
		description: ${12:# The description to use for the host.}
$0
endsnippet

snippet tower_inventory "create, update, or destroy Ansible Tower inventory."
- name: $1
	tower_inventory:
		name: ${2:# The name to use for the inventory.}
		organization: ${3:# Organization the inventory belongs to.}
		tower_host: ${4:# URL to your Tower instance.}
		variables: ${5:# Inventory variables. Use '@' to get from file.}
		tower_username: ${6:# Username for your Tower instance.}
		state: ${7:#present|absent}
		tower_password: ${8:# Password for your Tower instance.}
		tower_config_file: ${9:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${10:yes}
		description: ${11:# The description to use for the inventory.}
$0
endsnippet

snippet tower_job_cancel "Cancel an Ansible Tower Job."
- name: $1
	tower_job_cancel:
		job_id: ${2:# ID of the job to cancel}
		tower_config_file: ${3:# Path to the Tower config file. See notes.}
		tower_password: ${4:# Password for your Tower instance.}
		tower_username: ${5:# Username for your Tower instance.}
		tower_host: ${6:# URL to your Tower instance.}
		tower_verify_ssl: ${7:yes}
		fail_if_not_running: ${8:no}
$0
endsnippet

snippet tower_job_launch "Launch an Ansible Job."
- name: $1
	tower_job_launch:
		job_template: ${2:# Name of the job_template to use.}
		credential: ${3:# Credential to use for job, only used if prompt for credential is set.}
		use_job_endpoint: ${4:no}
		tags: ${5:# Specific tags to use for from playbook.}
		extra_vars: ${6:# Extra_vars to use for the job_template. Use '@' for a file.}
		job_explanation: ${7:# Job explanation field.}
		tower_password: ${8:# Password for your Tower instance.}
		job_type: ${9:run|check|scan}
		tower_config_file: ${10:# Path to the Tower config file. See notes.}
		limit: ${11:# Limit to use for the job_template.}
		inventory: ${12:# Inventory to use for the job, only used if prompt for inventory is set.}
		tower_verify_ssl: ${13:yes}
		tower_username: ${14:# Username for your Tower instance.}
		tower_host: ${15:# URL to your Tower instance.}
$0
endsnippet

snippet tower_job_list "List Ansible Tower jobs."
- name: $1
	tower_job_list:
		status: ${2:pending|waiting|running|error|failed|canceled|successful}
		tower_host: ${3:# URL to your Tower instance.}
		tower_password: ${4:# Password for your Tower instance.}
		tower_config_file: ${5:# Path to the Tower config file. See notes.}
		all_pages: ${6:no}
		tower_verify_ssl: ${7:yes}
		tower_username: ${8:# Username for your Tower instance.}
		query: ${9:# Query used to further filter the list of jobs. {"foo":"bar"} will be passed at ?foo=bar}
		page: ${10:# Page number of the results to fetch.}
$0
endsnippet

snippet tower_job_template "create, update, or destroy Ansible Tower job_template."
- name: $1
	tower_job_template:
		job_type: ${2:run|check|scan}
		playbook: ${3:# Playbook to use for the job_template.}
		name: ${4:# Name to use for the job_template.}
		project: ${5:# Project to use for the job_template.}
		network_credential: ${6:# The network_credential to use for the job_template.}
		description: ${7:# Description to use for the job_template.}
		tower_host: ${8:# URL to your Tower instance.}
		ask_inventory: ${9:no}
		ask_job_type: ${10:no}
		tower_username: ${11:# Username for your Tower instance.}
		skip_tags: ${12:# The skip_tags to use for the job_template.}
		tower_password: ${13:# Password for your Tower instance.}
		tower_config_file: ${14:# Path to the Tower config file. See notes.}
		ask_tags: ${15:no}
		host_config_key: ${16:# Allow provisioning callbacks using this host config key.}
		machine_credential: ${17:# Machine_credential to use for the job_template.}
		tower_verify_ssl: ${18:yes}
		ask_credential: ${19:no}
		job_tags: ${20:# The job_tags to use for the job_template.}
		verbosity: ${21:verbose|debug}
		state: ${22:#present|absent}
		ask_extra_vars: ${23:no}
		extra_vars_path: ${24:# Path to the extra_vars yaml file.}
		inventory: ${25:# Inventory to use for the job_template.}
		limit: ${26:# A host pattern to further constrain the list of hosts managed or affected by the playbook}
		forks: ${27:# The number of parallel or simultaneous processes to use while executing the playbook.}
		cloud_credential: ${28:# Cloud_credential to use for the job_template.}
		become_enabled: ${29:no}
$0
endsnippet

snippet tower_job_wait "Wait for Ansible Tower job to finish."
- name: $1
	tower_job_wait:
		job_id: ${2:# ID of the job to monitor.}
		min_interval: ${3:1}
		tower_host: ${4:# URL to your Tower instance.}
		tower_config_file: ${5:# Path to the Tower config file. See notes.}
		max_interval: ${6:30}
		timeout: ${7:# Maximum time in seconds to wait for a job to finish.}
		tower_password: ${8:# Password for your Tower instance.}
		tower_username: ${9:# Username for your Tower instance.}
		tower_verify_ssl: ${10:yes}
$0
endsnippet

snippet tower_label "create, update, or destroy Ansible Tower label."
- name: $1
	tower_label:
		name: ${2:# Name to use for the label.}
		organization: ${3:# Organization the label should be applied to.}
		tower_host: ${4:# URL to your Tower instance.}
		tower_username: ${5:# Username for your Tower instance.}
		state: ${6:#present|absent}
		tower_password: ${7:# Password for your Tower instance.}
		tower_config_file: ${8:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${9:yes}
$0
endsnippet

snippet tower_organization "create, update, or destroy Ansible Tower organizations"
- name: $1
	tower_organization:
		name: ${2:# Name to use for the organization.}
		tower_host: ${3:# URL to your Tower instance.}
		tower_username: ${4:# Username for your Tower instance.}
		state: ${5:#present|absent}
		tower_password: ${6:# Password for your Tower instance.}
		tower_config_file: ${7:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${8:yes}
		description: ${9:# The description to use for the organization.}
$0
endsnippet

snippet tower_project "create, update, or destroy Ansible Tower projects"
- name: $1
	tower_project:
		name: ${2:# Name to use for the project.}
		scm_branch: ${3:# The branch to use for the scm resource.}
		description: ${4:# Description to use for the project.}
		tower_host: ${5:# URL to your Tower instance.}
		scm_update_on_launch: ${6:no}
		scm_clean: ${7:no}
		scm_type: ${8:#manual|git|hg|svn}
		scm_delete_on_update: ${9:no}
		tower_username: ${10:# Username for your Tower instance.}
		tower_password: ${11:# Password for your Tower instance.}
		tower_config_file: ${12:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${13:yes}
		scm_credential: ${14:# Name of the credential to use with this scm resource.}
		scm_url: ${15:# URL of scm resource.}
		state: ${16:#present|absent}
		local_path: ${17:# The server playbook directory for manual projects.}
		organization: ${18:# Primary key of organization for project.}
$0
endsnippet

snippet tower_role "create, update, or destroy Ansible Tower role."
- name: $1
	tower_role:
		role: ${2:admin|read|member|execute|adhoc|update|use|auditor}
		credential: ${3:# Credential the role acts on.}
		job_template: ${4:# The job_template the role acts on.}
		tower_host: ${5:# URL to your Tower instance.}
		team: ${6:# Team that receives the permissions specified by the role.}
		project: ${7:# Project the role acts on.}
		tower_username: ${8:# Username for your Tower instance.}
		state: ${9:#present|absent}
		inventory: ${10:# Inventory the role acts on.}
		tower_password: ${11:# Password for your Tower instance.}
		tower_config_file: ${12:# Path to the Tower config file. See notes.}
		organization: ${13:# Organiation the role acts on.}
		target_team: ${14:# Team that the role acts on.}
		tower_verify_ssl: ${15:yes}
		user: ${16:# User that receives the permissions specified by the role.}
$0
endsnippet

snippet tower_team "create, update, or destroy Ansible Tower team."
- name: $1
	tower_team:
		name: ${2:# Name to use for the team.}
		organization: ${3:# Organization the team should be made a member of.}
		tower_host: ${4:# URL to your Tower instance.}
		tower_username: ${5:# Username for your Tower instance.}
		state: ${6:#present|absent}
		tower_password: ${7:# Password for your Tower instance.}
		tower_config_file: ${8:# Path to the Tower config file. See notes.}
		tower_verify_ssl: ${9:yes}
$0
endsnippet

snippet tower_user "create, update, or destroy Ansible Tower user."
- name: $1
	tower_user:
		username: ${2:# The username of the user.}
		email: ${3:# Email address of the user.}
		superuser: ${4:no}
		first_name: ${5:# First name of the user.}
		last_name: ${6:# Last name of the user.}
		tower_host: ${7:# URL to your Tower instance.}
		tower_username: ${8:# Username for your Tower instance.}
		state: ${9:#present|absent}
		auditor: ${10:no}
		tower_password: ${11:# Password for your Tower instance.}
		tower_config_file: ${12:# Path to the Tower config file. See notes.}
		organization: ${13:# Organization the user should be made a member of.}
		password: ${14:# Password of the user.}
		tower_verify_ssl: ${15:yes}
$0
endsnippet

snippet win_acl "Set file/directory permissions for a system user or group."
- name: $1
	win_acl:
		user: ${2:none}
		rights: ${3:AppendData|ChangePermissions|Delete|DeleteSubdirectoriesAndFiles|ExecuteFile|FullControl|ListDirectory|Modify|Read|ReadAndExecute|ReadAttributes|ReadData|ReadExtendedAttributes|ReadPermissions|Synchronize|TakeOwnership|Traverse|Write|WriteAttributes|WriteData|WriteExtendedAttributes}
		path: ${4:# File or Directory}
		type: ${5:allow|deny}
		propagation: ${6:#None|NoPropagateInherit|InheritOnly}
		state: ${7:#present|absent}
		inherit: ${8:ContainerInherit|ObjectInherit|None}
$0
endsnippet

snippet win_acl_inheritance "Change ACL inheritance"
- name: $1
	win_acl_inheritance:
		path: ${2:# Path to be used for changing inheritance}
		state: ${3:present|#absent}
		reorganize: ${4:#False|True}
$0
endsnippet

snippet win_chocolatey "Installs packages using chocolatey"
- name: $1
	win_chocolatey:
		name: ${2:# Name of the package to be installed.}
		upgrade: ${3:True|#False}
		force: ${4:True|#False}
		ignore_checksums: ${5:no}
		allow_empty_checksums: ${6:no}
		install_args: ${7:# Arguments to pass to the native installer.}
		source: ${8:# Specify source rather than using default chocolatey repository.}
		state: ${9:#present|absent|latest|reinstalled}
		version: ${10:# Specific version of the package to be installed.}
		params: ${11:# Parameters to pass to the package}
		ignore_dependencies: ${12:no}
		timeout: ${13:2700}
$0
endsnippet

snippet win_command "Executes a command on a remote Windows node"
- name: $1
	win_command:
		${2:free_form=# the win_command module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!}
		creates: ${3:# a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
		chdir: ${4:# set the specified path as the current working directory before executing a command}
		removes: ${5:# a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
$0
endsnippet

snippet win_copy "Copies files to remote locations on windows hosts."
- name: $1
	win_copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		src: ${3:# Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.}
		content: ${4:# When used instead of C(src), sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.}
		remote_src: ${5:True|#False}
		force: ${6:#True|False}
$0
endsnippet

snippet win_disk_image "Manage ISO/VHD/VHDX mounts on Windows hosts"
- name: $1
	win_disk_image:
		image_path: ${2:# path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)}
		state: ${3:#present|absent}
$0
endsnippet

snippet win_dns_client "Configures DNS lookup on Windows hosts"
- name: $1
	win_dns_client:
		adapter_names: ${2:# Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value). The adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection).}
		ipv4_addresses: ${3:# Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.}
$0
endsnippet

snippet win_domain "Ensures the existence of a Windows domain."
- name: $1
	win_domain:
		dns_domain_name: ${2:# the DNS name of the domain which should exist and be reachable or reside on the target Windows host}
		safe_mode_password: ${3:# safe mode password for the domain controller}
$0
endsnippet

snippet win_domain_controller "Manage domain controller/member server state for a Windows host"
- name: $1
	win_domain_controller:
		domain_admin_user: ${2:# username of a domain admin for the target domain (necessary to promote or demote a domain controller)}
		domain_admin_password: ${3:# password for the specified C(domain_admin_user)}
		state: ${4:domain_controller|member_server}
		local_admin_password: ${5:# password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server))}
		dns_domain_name: ${6:# when C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC}
		safe_mode_password: ${7:# safe mode password for the domain controller (required when C(state) is C(domain_controller))}
$0
endsnippet

snippet win_domain_membership "Manage domain/workgroup membership for a Windows host"
- name: $1
	win_domain_membership:
		domain_admin_user: ${2:# username of a domain admin for the target domain (required to join or leave the domain)}
		workgroup_name: ${3:# when C(state) is C(workgroup), the name of the workgroup that the Windows host should be in}
		state: ${4:domain|workgroup}
		dns_domain_name: ${5:# when C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined}
		hostname: ${6:# the desired hostname for the Windows host}
		domain_admin_password: ${7:# password for the specified C(domain_admin_user)}
$0
endsnippet

snippet win_dotnet_ngen "Runs ngen to recompile DLLs after .NET  updates"
- name: $1
	win_dotnet_ngen:
$0
endsnippet

snippet win_environment "Modifies environment variables on windows hosts."
- name: $1
	win_environment:
		name: ${2:no default}
		level: ${3:machine|process|user}
		state: ${4:#present|absent}
		value: ${5:no default}
$0
endsnippet

snippet win_feature "Installs and uninstalls Windows Features on Windows Server"
- name: $1
	win_feature:
		name: ${2:# Names of roles or features to install as a single feature or a comma-separated list of features}
		source: ${3: {driveletter}:\sources\sxs| {IP}\Share\sources\sxs}
		state: ${4:#present|absent}
		include_management_tools: ${5:True|False}
		include_sub_features: ${6:True|False}
		restart: ${7:True|False}
$0
endsnippet

snippet win_file "Creates, touches or removes files or directories."
- name: $1
	win_file:
		path: ${2:# path to the file being managed.  Aliases: I(dest), I(name)}
		state: ${3:file|directory|touch|absent}
$0
endsnippet

snippet win_file_version "Get DLL or EXE file build version"
- name: $1
	win_file_version:
		path: ${2:# File to get version(provide absolute path)}
$0
endsnippet

snippet win_find "return a list of files based on specific criteria"
- name: $1
	win_find:
		paths: ${2:# List of paths of directories to search for files or folders in. This can be supplied as a single path or a list of paths.}
		file_type: ${3:#file|directory}
		checksum_algorithm: ${4:md5|#sha1|sha256|sha384|sha512}
		age: ${5:# Select files or folders whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., "2s", "10d", 1w").}
		recurse: ${6:true|false}
		age_stamp: ${7:atime|#mtime|ctime}
		patterns: ${8:# One or more (powershell or regex) patterns to compare filenames with. The type of pattern matching is controlled by C(use_regex) option. The patterns retrict the list of files or folders to be returned based on the filenames. For a file to be matched it only has to match with one pattern in a list provided.}
		get_checksum: ${9:true|false}
		use_regex: ${10:true|false}
		follow: ${11:true|false}
		hidden: ${12:true|false}
		size: ${13:no}
$0
endsnippet

snippet win_firewall_rule "Windows firewall automation"
- name: $1
	win_firewall_rule:
		direction: ${2:in|out}
		name: ${3:# the rules name}
		state: ${4:#present|absent}
		action: ${5:allow|block|bypass}
		profile: ${6:any}
		remoteport: ${7:any}
		enable: ${8:yes}
		protocol: ${9:any}
		service: ${10:any}
		description: ${11:# description for the firewall rule}
		localip: ${12:any}
		program: ${13:# the program this rule applies to}
		remoteip: ${14:any}
		force: ${15:no}
		localport: ${16:any}
$0
endsnippet

snippet win_get_url "Fetches a file from a given URL"
- name: $1
	win_get_url:
		url: ${2:# The full URL of a file to download}
		dest: ${3:# The absolute path of the location to save the file at the URL. Be sure to include a filename and extension as appropriate.}
		username: ${4:# Basic authentication username}
		force: ${5:yes|no}
		skip_certificate_validation: ${6:no}
		proxy_url: ${7:# The full URL of the proxy server to download through.}
		proxy_password: ${8:# Proxy authentication password}
		proxy_username: ${9:# Proxy authentication username}
		password: ${10:# Basic authentication password}
$0
endsnippet

snippet win_group "Add and remove local groups"
- name: $1
	win_group:
		name: ${2:# Name of the group}
		state: ${3:#present|absent}
		description: ${4:# Description of the group}
$0
endsnippet

snippet win_iis_virtualdirectory "Configures a virtual directory in IIS."
- name: $1
	win_iis_virtualdirectory:
		name: ${2:# The name of the virtual directory to create or remove}
		site: ${3:# The site name under which the virtual directory is created or exists.}
		application: ${4:# The application under which the virtual directory is created or exists.}
		state: ${5:absent|#present}
		physical_path: ${6:# The physical path to the folder in which the new virtual directory is created. The specified folder must already exist.}
$0
endsnippet

snippet win_iis_webapplication "Configures IIS web applications."
- name: $1
	win_iis_webapplication:
		name: ${2:# Name of the web application.}
		site: ${3:# Name of the site on which the application is created.}
		state: ${4:present|absent}
		application_pool: ${5:# The application pool in which the new site executes.}
		physical_path: ${6:# The physical path on the remote host to use for the new application. The specified folder must already exist.}
$0
endsnippet

snippet win_iis_webapppool "Configures an IIS Web Application Pool."
- name: $1
	win_iis_webapppool:
		name: ${2:# Name of application pool}
		attributes: ${3:# Application Pool attributes from string where attributes are separated by a pipe and attribute name/values by colon Ex. "foo:1|bar:2".}
		state: ${4:absent|stopped|started|restarted}
$0
endsnippet

snippet win_iis_webbinding "Configures a IIS Web site."
- name: $1
	win_iis_webbinding:
		name: ${2:# Names of web site}
		protocol: ${3:# The protocol to be used for the Web binding (usually HTTP, HTTPS, or FTP).}
		certificate_hash: ${4:# Certificate hash for the SSL binding. The certificate hash is the unique identifier for the certificate.}
		ip: ${5:# The IP address to bind to / use for the new site.}
		host_header: ${6:# The host header to bind to / use for the new site.}
		state: ${7:present|absent}
		port: ${8:# The port to bind to / use for the new site.}
		certificate_store_name: ${9:My}
$0
endsnippet

snippet win_iis_website "Configures a IIS Web site."
- name: $1
	win_iis_website:
		name: ${2:# Names of web site}
		application_pool: ${3:# The application pool in which the new site executes.}
		parameters: ${4:# Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. "foo:1|bar:2"}
		ip: ${5:# The IP address to bind to / use for the new site.}
		physical_path: ${6:# The physical path on the remote host to use for the new site. The specified folder must already exist.}
		hostname: ${7:# The host header to bind to / use for the new site.}
		site_id: ${8:# Explicitly set the IIS numeric ID for a site. Note that this value cannot be changed after the website has been created.}
		ssl: ${9:# Enables HTTPS binding on the site..}
		state: ${10:started|restarted|stopped|absent}
		port: ${11:# The port to bind to / use for the new site.}
$0
endsnippet

snippet win_lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression."
- name: $1
	win_lineinfile:
		path: ${2:# The path of the file to modify.}
		insertbefore: ${3:BOF|*regex*}
		encoding: ${4:auto}
		create: ${5:yes|#no}
		newline: ${6:#windows|unix}
		backrefs: ${7:yes|#no}
		state: ${8:#present|absent}
		insertafter: ${9:#EOF|*regex*}
		regexp: ${10:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).}
		line: ${11:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
		backup: ${12:yes|#no}
		validate: ${13:# Validation to run before copying into place. Use %s in the command to indicate the current file to validate.}
$0
endsnippet

snippet win_msg "Sends a message to logged in users on Windows hosts."
- name: $1
	win_msg:
		msg: ${2:Hello world!}
		to: ${3:*}
		display_seconds: ${4:10}
		wait: ${5:no}
$0
endsnippet

snippet win_msi "Installs and uninstalls Windows MSI files"
- name: $1
	win_msi:
		path: ${2:# File system path to the MSI file to install}
		extra_args: ${3:# Additional arguments to pass to the msiexec.exe command}
		state: ${4:#present|absent}
		creates: ${5:# Path to a file created by installing the MSI to prevent from attempting to reinstall the package on every run}
		wait: ${6:True|#False}
$0
endsnippet

snippet win_nssm "NSSM - the Non-Sucking Service Manager"
- name: $1
	win_nssm:
		name: ${2:# Name of the service to operate on}
		start_mode: ${3:#auto|manual|disabled}
		state: ${4:present|#started|stopped|restarted|absent}
		app_parameters_free_form: ${5:# Single string of parameters to be passed to the service.}
		application: ${6:# The application binary to run as a service}
		stderr_file: ${7:# Path to receive error output}
		dependencies: ${8:# Service dependencies that has to be started to trigger startup, separated by comma.}
		user: ${9:# User to be used for service startup}
		password: ${10:# Password to be used for service startup}
		stdout_file: ${11:# Path to receive output}
		app_parameters: ${12:# Parameters to be passed to the application when it starts.}
$0
endsnippet

snippet win_owner "Set owner"
- name: $1
	win_owner:
		path: ${2:# Path to be used for changing owner}
		user: ${3:# Name to be used for changing owner}
		recurse: ${4:#False|True}
$0
endsnippet

snippet win_package "Installs/Uninstalls an installable package, either from local file system or url"
- name: $1
	win_package:
		path: ${2:# Location of the package to be installed (either on file system, network share or url)}
		product_id: ${3:# Product id of the installed package (used for checking if already installed)}
		name: ${4:# Name of the package, if name isn't specified the path will be used for log messages}
		user_password: ${5:# Password of an account with access to the package if it's located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_name for this to function properly.}
		expected_return_code: ${6:0}
		state: ${7:#present|absent}
		arguments: ${8:# Any arguments the installer needs}
		user_name: ${9:# Username of an account with access to the package if it's located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_password for this to function properly.}
$0
endsnippet

snippet win_path "Manage Windows path environment variables"
- name: $1
	win_path:
		elements: ${2:# A single path element, or a list of path elements (ie, directories) to add or remove.}
		scope: ${3:#machine|user}
		state: ${4:present|absent}
		name: ${5:PATH}
$0
endsnippet

snippet win_ping "A windows version of the classic ping module."
- name: $1
	win_ping:
		data: ${2:pong}
$0
endsnippet

snippet win_psexec "Runs commands (remotely) as another (privileged) user"
- name: $1
	win_psexec:
		command: ${2:# The command line to run through PsExec (limited to 260 characters).}
		username: ${3:# The (remote) user to run the command as.}
		limited: ${4:no}
		executable: ${5:psexec.exe}
		chdir: ${6:# Run the command from this (remote) directory.}
		interactive: ${7:no}
		noprofile: ${8:no}
		system: ${9:no}
		elevated: ${10:no}
		priority: ${11:background|low|belownormal|abovenormal|high|realtime}
		hostnames: ${12:# The hostnames to run the command.}
		timeout: ${13:# The connection timeout in seconds}
		password: ${14:# The password for the (remote) user to run the command as.}
		wait: ${15:yes}
$0
endsnippet

snippet win_reboot "Reboot a windows machine"
- name: $1
	win_reboot:
		test_command: ${2:whoami}
		connect_timeout_sec: ${3:5}
		msg: ${4:Reboot initiated by Ansible}
		pre_reboot_delay_sec: ${5:2}
		shutdown_timeout_sec: ${6:600}
		reboot_timeout_sec: ${7:600}
$0
endsnippet

snippet win_reg_stat "returns information about a Windows registry key or property of a key"
- name: $1
	win_reg_stat:
		path: ${2:# T}
		name: ${3:# The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.}
$0
endsnippet

snippet win_regedit "Add, change, or remove registry keys and values"
- name: $1
	win_regedit:
		path: ${2:# Name of registry path.}
		state: ${3:#present|absent}
		data: ${4:# Value of the registry entry C(name) in C(path).}
		name: ${5:# Name of registry entry in C(path).}
		type: ${6:binary|dword|expandstring|multistring|#string|qword}
$0
endsnippet

snippet win_region "Set the region and format settings"
- name: $1
	win_region:
		unicode_language: ${2:# The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect.}
		copy_settings: ${3:true|false}
		location: ${4:# The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to. This needs to be set if C(format) or C(unicode_language) is not set.}
		format: ${5:# The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(unicode_language) is not set.}
$0
endsnippet

snippet win_regmerge "Merges the contents of a registry file into the windows registry"
- name: $1
	win_regmerge:
		path: ${2:no default}
		compare_key: ${3:no default}
$0
endsnippet

snippet win_robocopy "Synchronizes the contents of two directories using Robocopy."
- name: $1
	win_robocopy:
		dest: ${2:# Destination file/directory to sync (Will receive contents of src).}
		src: ${3:# Source file/directory to sync.}
		recurse: ${4:True|#False}
		purge: ${5:True|#False}
		flags: ${6:# Directly supply Robocopy flags. If set, purge and recurse will be ignored.}
$0
endsnippet

snippet win_say "Text to speech module for Windows to speak messages and optionally play sounds"
- name: $1
	win_say:
		end_sound_path: ${2:# Full path to a C(.wav) file containing a sound to play after the text has been spoken.  Useful on conference calls to alert other speakers that ansible has finished speaking.}
		msg: ${3:none}
		start_sound_path: ${4:# Full path to a C(.wav) file containing a sound to play before the text is spoken.  Useful on conference calls to alert other speakers that ansible has something to say.}
		voice: ${5:system default voice}
		msg_file: ${6:none}
		speech_speed: ${7:0}
$0
endsnippet

snippet win_scheduled_task "Manage scheduled tasks"
- name: $1
	win_scheduled_task:
		name: ${2:# Name of the scheduled task}
		state: ${3:present|absent}
		executable: ${4:# Command the scheduled task should execute}
		description: ${5:# The description for the scheduled task}
		enabled: ${6:#True|False}
		days_of_week: ${7:# Days of the week to run a weekly task, not idempotent}
		frequency: ${8:once|daily|weekly}
		arguments: ${9:# Arguments to provide scheduled task action}
		time: ${10:# Time to execute scheduled task, not idempotent}
		path: ${11:\}
		user: ${12:# User to run scheduled task as}
$0
endsnippet

snippet win_service "Manages Windows services"
- name: $1
	win_service:
		name: ${2:# Name of the service}
		username: ${3:# The username to set the service to start as.}
		display_name: ${4:# The display name to set for the service.}
		desktop_interact: ${5:no}
		force_dependent_services: ${6:no}
		dependency_action: ${7:#set|add|remove}
		description: ${8:# The description to set for the service.}
		start_mode: ${9:auto|manual|disabled|delayed}
		state: ${10:started|stopped|restarted|absent}
		dependencies: ${11:# A list of service dependencies to set for this particular service.}
		path: ${12:# The path to the executable to set for the service.}
		password: ${13:# The password to set the service to start as.}
$0
endsnippet

snippet win_share "Manage Windows shares"
- name: $1
	win_share:
		name: ${2:# Share name}
		path: ${3:# Share directory}
		deny: ${4:# Specify user list that should get no access, regardless of implied access on share, separated by comma.}
		full: ${5:# Specify user list that should get full access on share, separated by comma.}
		read: ${6:# Specify user list that should get read access on share, separated by comma.}
		list: ${7:True|False}
		state: ${8:#present|absent}
		caching_mode: ${9:BranchCache|Documents|#Manual|None|Programs|Unknown}
		change: ${10:# Specify user list that should get read and write access on share, separated by comma.}
		description: ${11:# Share description}
$0
endsnippet

snippet win_shell "Execute shell commands on target hosts."
- name: $1
	win_shell:
		${2:free_form=# the win_shell module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!}
		creates: ${3:# a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
		chdir: ${4:# set the specified path as the current working directory before executing a command}
		removes: ${5:# a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
		executable: ${6:# change the shell used to execute the command (eg, C(cmd)). The target shell must accept a C(/c) parameter followed by the raw command line to be executed.}
$0
endsnippet

snippet win_shortcut "Manage shortcuts on Windows"
- name: $1
	win_shortcut:
		dest: ${2:# Destination file for the shortcuting file.}
		windowstyle: ${3:default|maximized|minimized}
		src: ${4:# Executable or URL the shortcut points to.}
		description: ${5:# Description for the shortcut.}
		args: ${6:# Additional arguments for the executable defined in C(src).}
		directory: ${7:# Working directory for executable defined in C(src).}
		state: ${8:#present|absent}
		hotkey: ${9:# Key combination for the shortcut.}
		icon: ${10:# Icon used for the shortcut}
$0
endsnippet

snippet win_stat "returns information about a Windows file"
- name: $1
	win_stat:
		path: ${2:# The full path of the file/object to get the facts of; both forward and back slashes are accepted.}
		get_md5: ${3:yes}
		get_checksum: ${4:yes}
		checksum_algorithm: ${5:md5|#sha1|sha256|sha384|sha512}
$0
endsnippet

snippet win_tempfile "Creates temporary files and directories."
- name: $1
	win_tempfile:
		path: ${2:%TEMP%}
		state: ${3:#file|directory}
		prefix: ${4:ansible.}
		suffix: ${5:}
$0
endsnippet

snippet win_template "Templates a file out to a remote server."
- name: $1
	win_template:
		dest: ${2:# Location to render the template to on the remote machine.}
		src: ${3:# Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.}
$0
endsnippet

snippet win_timezone "Sets Windows machine timezone"
- name: $1
	win_timezone:
		timezone: ${2:# Timezone to set to.  Example Central Standard Time}
$0
endsnippet

snippet win_unzip "Unzips compressed files and archives on the Windows node"
- name: $1
	win_unzip:
		dest: ${2:# Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.}
		src: ${3:# File to be unzipped (provide absolute path)}
		recurse: ${4:True|#False|True|#False}
		creates: ${5:# If this file or directory exists the specified src will not be extracted.}
		rm: ${6:True|#False|True|#False}
$0
endsnippet

snippet win_updates "Download and install Windows updates"
- name: $1
	win_updates:
		log_path: ${2:# If set, win_updates will append update progress to the specified file. The directory must already exist.}
		state: ${3:#installed|searched}
		category_names: ${4:[Application, Connectors, #CriticalUpdates, DefinitionUpdates, DeveloperKits, FeaturePacks, Guidance, #SecurityUpdates, ServicePacks, Tools, #UpdateRollups, Updates}
$0
endsnippet

snippet win_uri "Interacts with webservices."
- name: $1
	win_uri:
		url: ${2:# HTTP or HTTPS URL in the form of (http|https)://host.domain:port/path}
		body: ${3:# The body of the HTTP request/response to the web service.}
		headers: ${4:# Key Value pairs for headers. Example "Host: www.somesite.com"}
		dest: ${5:# Output the response body to a file.}
		content_type: ${6:# Sets the "Content-Type" header.}
		method: ${7:#GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH}
		use_basic_parsing: ${8:#True|False}
$0
endsnippet

snippet win_user "Manages local Windows user accounts"
- name: $1
	win_user:
		name: ${2:# Name of the user to create, remove or modify.}
		update_password: ${3:#always|on_create}
		password: ${4:# Optionally set the user's password to this (plain text) value.}
		description: ${5:# Description of the user}
		groups_action: ${6:#replace|add|remove}
		password_expired: ${7:yes|no}
		state: ${8:#present|absent|query}
		groups: ${9:# Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.}
		account_disabled: ${10:yes|no}
		fullname: ${11:# Full name of the user}
		password_never_expires: ${12:yes|no}
		account_locked: ${13:no}
		user_cannot_change_password: ${14:yes|no}
$0
endsnippet

snippet win_webpicmd "Installs packages using Web Platform Installer command-line"
- name: $1
	win_webpicmd:
		name: ${2:# Name of the package to be installed}
$0
endsnippet

