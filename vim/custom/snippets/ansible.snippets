priority 50

# THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DON'T MODIFY BY HAND

snippet play "Execute an Ansible play" b
- name: ${1:name}
	hosts: ${2:host_group}
	become: ${3:true}
	tasks:
		$0
endsnippet

snippet when "Conditionally execute play" b
when:
	- ansible_os_family == "RedHat"
	- foo is defined
endsnippet

snippet with_items "Loop over items" b
with_items:
	- $1
	- $2
	- $0
endsnippet

snippet block "Example block task" b
- name: Install Apache
	block:
		- yum: name={{ item }} state=installed
			with_items:
				- httpd
				- memcached
		- template: src=templates/src.j2 dest=/etc/foo.conf
		- service: name=bar state=started enabled=True
	when: ansible_distribution == 'CentOS'
	become: true
	become_user: root
$0
endsnippet

snippet bundler "Manage Ruby Gem dependencies with Bundler" b
- name: $1
	bundler:
		# executable: # The path to the bundler executable
		# chdir: temporary working directory
		# gemfile: Gemfile in current directory
		# clean: True|False
		# user_install: True|False
		# extra_args: # A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information
		# state: #present|latest
		# deployment_mode: True|False
		# binstub_directory: # Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)
		# exclude_groups: # A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set
		# local: True|False
		# gem_path: RubyGems gem paths
$0
endsnippet

snippet easy_install "Installs Python libraries" b
- name: $1
	easy_install:
		name: ${2:# A Python library name}
		# virtualenv: # an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically
		# virtualenv_site_packages: yes|#no
		# virtualenv_command: virtualenv
		# state: #present|latest
		# executable: # The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.
$0
endsnippet

snippet composer "Dependency Manager for PHP" b
- name: $1
	composer:
		# executable: # Path to PHP Executable on the remote host, if PHP is not in PATH.
		# no_scripts: True|#False
		# prefer_source: True|#False
		# prefer_dist: True|#False
		# working_dir: # Directory of your project (see --working-dir). This is required when the command is not run globally.
		# global_command: True|#False
		# command: install
		# arguments: # Composer arguments like required package, version and so on.
		# ignore_platform_reqs: True|#False
		# no_dev: #True|False
		# no_plugins: True|#False
		# optimize_autoloader: #True|False
$0
endsnippet

snippet maven_artifact "Downloads an Artifact from a Maven Repository" b
- name: $1
	maven_artifact:
		state: ${2:#present|absent}
		artifact_id: ${3:# The maven artifactId coordinate}
		dest: ${4:no}
		group_id: ${5:# The Maven groupId coordinate}
		# repository_url: http://repo1.maven.org/maven2
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# keep_name: yes|#no
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# version: latest
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# username: # The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3
		# selevel: s0
		# password: # The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3
		# extension: jar
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# timeout: 10
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate_certs: #yes|no
		# classifier: # The maven classifier coordinate
$0
endsnippet

snippet npm "Manage node.js packages with npm" b
- name: $1
	npm:
		# executable: # The executable location for npm.
		# name: # The name of a node.js library to install
		# global: yes|no
		# ignore_scripts: yes|no
		# state: #present|absent|latest
		# production: yes|no
		# registry: # The registry to install modules from.
		# version: # The version to be installed
		# path: # The base path where to install the node.js libraries
$0
endsnippet

snippet bower "Manage bower packages with bower" b
- name: $1
	bower:
		path: ${2:# The base path where to install the bower packages}
		# state: #present|absent|latest
		# production: yes|no
		# name: # The name of a bower package to install
		# version: # The version to be installed
		# relative_execpath: # Relative path to bower executable from install path
		# offline: yes|no
$0
endsnippet

snippet pear "Manage pear/pecl packages" b
- name: $1
	pear:
		name: ${2:# Name of the package to install, upgrade, or remove.}
		# state: #present|absent|latest
		# executable: # Path to the pear executable
$0
endsnippet

snippet cpanm "Manages Perl library dependencies." b
- name: $1
	cpanm:
		# executable: # Override the path to the cpanm executable
		# name: # The name of the Perl library to install. You may use the "full distribution path", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz
		# installdeps: no
		# system_lib: no
		# mirror_only: no
		# from_path: # The local directory from where to install
		# version: no
		# mirror: no
		# locallib: no
		# notest: no
$0
endsnippet

snippet pip "Manages Python library dependencies" b
- name: $1
	pip:
		# virtualenv: # An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.
		# virtualenv_site_packages: no
		# virtualenv_command: virtualenv
		# chdir: # cd into this directory before running the command
		# requirements: # The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.
		# name: # The name of a Python library to install or the url of the remote package.
		# virtualenv_python: # The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.
		# editable: no
		# umask: # The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077).
		# executable: # The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.
		# extra_args: # Extra arguments passed to pip.
		# state: absent|forcereinstall|latest|#present
		# version: # The version number to install of the Python library specified in the I(name) parameter.
$0
endsnippet

snippet gem "Manage Ruby gems" b
- name: $1
	gem:
		name: ${2:# The name of the gem to be managed.}
		# include_dependencies: #yes|no
		# executable: # Override the path to the gem executable
		# repository: # The repository from which the gem will be installed
		# build_flags: # Allow adding build flags for gem compilation
		# include_doc: no
		# user_install: #yes|no
		# pre_release: no
		# env_shebang: no
		# state: #present|absent|latest
		# version: # Version of the gem to be installed/removed.
		# gem_source: # The path to a local gem used as installation source.
$0
endsnippet

snippet package "Generic OS package manager" b
- name: $1
	package:
		state: ${2:# Whether to install (C(present), or remove (C(absent)) a package. Other states depend on the underlying package module, i.e C(latest).}
		name: ${3:# Package name, or package specifier with version, like C(name-1.0).}
		# use: auto
$0
endsnippet

snippet xbps "Manage packages with XBPS" b
- name: $1
	xbps:
		# recurse: yes|no
		# state: #present|absent|latest
		# upgrade: yes|no
		# update_cache: yes|no
		# name: # Name of the package to install, upgrade, or remove.
$0
endsnippet

snippet pkgutil "Manage CSW-Packages on Solaris" b
- name: $1
	pkgutil:
		state: ${2:present|absent|latest}
		name: ${3:# Package name, e.g. (C(CSWnrpe))}
		# site: # Specifies the repository path to install the package from.
		# update_catalog: no
$0
endsnippet

snippet pacman "Manage packages with I(pacman)" b
- name: $1
	pacman:
		# state: absent|latest|#present
		# upgrade: no
		# force: no
		# name: # Name or list of names of the packages to install, upgrade, or remove.
		# update_cache: no
		# recurse: no
$0
endsnippet

snippet pulp_repo "Add or remove Pulp repos from a remote host." b
- name: $1
	pulp_repo:
		relative_url: ${2:# Relative URL for the local repository.}
		name: ${3:# Name of the repo to add or remove. This correlates to repo-id in Pulp.}
		# feed: # Upstream feed URL to receive updates from.
		# repo_type: rpm
		# pulp_host: http://127.0.0.1
		# force: no
		# force_basic_auth: yes|#no
		# importer_ssl_client_cert: # Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.
		# proxy_port: # Proxy port setting for the pulp repository importer.
		# serve_http: no
		# http_agent: ansible-httpget
		# wait_for_completion: yes|#no
		# add_export_distributor: no
		# use_proxy: yes
		# url_password: # The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used.
		# importer_ssl_client_key: # Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.
		# publish_distributor: # Distributor to use when state is C(publish). The default is to publish all distributors.
		# proxy_host: # Proxy url setting for the pulp repository importer. This is in the format scheme://host.
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# state: #present|absent|sync|publish
		# serve_https: yes
		# importer_ssl_ca_cert: # CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file.
		# url_username: # The username for use in HTTP basic authentication to the pulp API.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet pkgng "Package manager for FreeBSD >= 9.0" b
- name: $1
	pkgng:
		name: ${2:# Name or list of names of packages to install/remove.}
		# chroot: # Pkg will chroot in the specified environment.
		# cached: yes|no
		# pkgsite: # For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).
		# state: #present|absent
		# rootdir: # For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.
		# autoremove: yes|no
		# jail: # Pkg will execute in the given jail name or id.
		# annotation: # A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.
$0
endsnippet

snippet zypper "Manage packages on SUSE and openSUSE" b
- name: $1
	zypper:
		name: ${2:# Package name C(name) or package specifier or a list of either.}
		# force: yes|#no
		# disable_gpg_check: yes|#no
		# extra_args: # Add additional options to C(zypper) command.
		# state: #present|latest|absent|dist-upgrade
		# oldpackage: yes|#no
		# update_cache: yes|#no
		# disable_recommends: #yes|no
		# type: #package|patch|pattern|product|srcpackage|application
$0
endsnippet

snippet apt_repository "Add and remove APT repositories" b
- name: $1
	apt_repository:
		repo: ${2:# A source string for the repository.}
		# state: absent|#present
		# update_cache: yes
		# mode: 420
		# codename: # Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)
		# validate_certs: yes
		# filename: # Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.
$0
endsnippet

snippet swdepot "Manage packages with swdepot package manager (HP-UX)" b
- name: $1
	swdepot:
		state: ${2:present|latest|absent}
		name: ${3:}
		# depot: 
$0
endsnippet

snippet yum_repository "Add or remove YUM repositories" b
- name: $1
	yum_repository:
		name: ${2:# Unique repository ID.}
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# ip_resolve: 4|6|IPv4|IPv6|#whatever
		# enabled: #yes|no
		# proxy_password: # Username to use for proxy.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# bandwidth: 0
		# cost: 1000
		# file: # File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name).
		# mirrorlist_expire: 21600
		# exclude: # List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# keepalive: yes|#no
		# repo_gpgcheck: yes|#no
		# sslverify: #yes|no
		# failovermethod: #roundrobin|priority
		# unsafe_writes: no
		# deltarpm_metadata_percentage: 100
		# gpgkey: # A URL pointing to the ASCII-armored GPG key file for the repository.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# http_caching: #all|packages|none
		# priority: 99
		# state: absent|#present
		# mirrorlist: # Specifies a URL to a file containing a list of baseurls.
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# gpgcheck: yes|#no
		# include: # Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.
		# proxy_username: # Password for this proxy.
		# username: # Username to use for basic authentication to a repo or really any url.
		# metadata_expire: 21600
		# description: # A human readable string describing the repository.
		# retries: 10
		# selevel: s0
		# sslclientcert: # Path to the SSL client certificate yum should use to connect to repos/remote sites.
		# baseurl: # URL to the directory where the yum repository's 'repodata' directory lives.
		# gpgcakey: # A URL pointing to the ASCII-armored CA key file for the repository.
		# s3_enabled: yes|#no
		# includepkgs: # List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.
		# enablegroups: #yes|no
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# password: # Password to use with the username for basic authentication.
		# ui_repoid_vars: releasever basearch
		# protect: yes|#no
		# ssl_check_cert_permissions: yes|#no
		# throttle: # Enable bandwidth throttling for downloads.
		# deltarpm_percentage: 75
		# sslclientkey: # Path to the SSL client key yum should use to connect to repos/remote sites.
		# metalink: # Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).
		# reposdir: /etc/yum.repos.d
		# skip_if_unavailable: yes|#no
		# keepcache: 0|#1
		# sslcacert: # Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.
		# timeout: 30
		# async: #yes|no
		# metadata_expire_filter: never|read-only:past|#read-only:present|read-only:future
		# proxy: # URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.
$0
endsnippet

snippet package_facts "package information as facts" b
- name: $1
	package_facts:
		# manager: #auto|rpm|apt
$0
endsnippet

snippet layman "Manage Gentoo overlays" b
- name: $1
	layman:
		name: ${2:# The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated)).}
		# list_url: # An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration.
		# validate_certs: #yes|no
		# state: #present|absent|updated
$0
endsnippet

snippet portage "Package manager for Gentoo" b
- name: $1
	portage:
		# nodeps: yes|no
		# onlydeps: yes|no
		# newuse: yes|no
		# oneshot: yes|no
		# update: yes|no
		# deep: yes|no
		# sync: web|yes|no
		# keepgoing: yes|no
		# depclean: yes|no
		# jobs: # Specifies the number of packages to build simultaneously.
		# noreplace: yes|no
		# loadavg: # Specifies that no new builds should be started if there are
		# verbose: yes|no
		# getbinpkg: yes|no
		# package: # Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)
		# quiet: yes|no
		# state: #present|installed|emerged|absent|removed|unmerged|latest
		# changed_use: yes|no
		# usepkgonly: yes|no
$0
endsnippet

snippet apk "Manages apk packages" b
- name: $1
	apk:
		# available: yes|no
		# state: #present|absent|latest
		# upgrade: yes|no
		# update_cache: yes|no
		# name: # A package name, like C(foo), or multiple packages, like C(foo, bar).
		# repository: # A package repository or multiple repositories. Unlike with the underlying apk command, this list will override the system repositories rather than supplement them.
$0
endsnippet

snippet homebrew "Package manager for Homebrew" b
- name: $1
	homebrew:
		# install_options: # options flags to install a package
		# state: head|latest|#present|absent|linked|unlinked
		# name: # list of names of packages to install/remove
		# update_homebrew: yes|no
		# path: /usr/local/bin
		# upgrade_all: yes|no
$0
endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command" b
- name: $1
	redhat_subscription:
		# username: # access.redhat.com or Sat6  username
		# server_hostname: # Specify an alternative Red Hat Subscription Management or Sat6 server
		# pool_ids: []
		# consumer_id: # References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.

		# auto_attach: no
		# server_insecure: # Enable or disable https server certificate verification when connecting to C(server_hostname)
		# activationkey: # supply an activation key for use with registration
		# server_proxy_password: # Specify a password for HTTP proxy with basic authentication
		# consumer_name: # Name of the system to register, defaults to the hostname
		# rhsm_baseurl: # Specify CDN baseurl
		# pool: ^$
		# server_proxy_port: # Specify a HTTP proxy port
		# password: # access.redhat.com or Sat6 password
		# consumer_type: # The type of unit to register, defaults to system
		# org_id: # Organization ID to use in conjunction with activationkey
		# environment: # Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello
		# force_register: no
		# state: #present|absent
		# server_proxy_user: # Specify a user for HTTP proxy with basic authentication
		# server_proxy_hostname: # Specify a HTTP proxy hostname
$0
endsnippet

snippet openbsd_pkg "Manage packages on OpenBSD" b
- name: $1
	openbsd_pkg:
		name: ${2:# A name or a list of names of the packages.}
		# state: absent|latest|#present
		# ports_dir: /usr/ports
		# clean: no
		# quick: no
		# build: no
$0
endsnippet

snippet zypper_repository "Add and remove Zypper repositories" b
- name: $1
	zypper_repository:
		# repo: none
		# name: none
		# auto_import_keys: yes|#no
		# enabled: #yes|no
		# disable_gpg_check: yes|#no
		# priority: # Set priority of repository. Packages will always be installed from the repository with the smallest priority number.
		# state: absent|#present
		# autorefresh: #yes|no
		# overwrite_multiple: yes|#no
		# runrefresh: yes|#no
		# description: none
$0
endsnippet

snippet urpmi "Urpmi manager" b
- name: $1
	urpmi:
		pkg: ${2:# Name of package to install, upgrade or remove.}
		# no-recommends: yes
		# force: yes
		# update_cache: no
		# root: /
		# state: absent|#present
$0
endsnippet

snippet apt_key "Add or remove an apt key" b
- name: $1
	apt_key:
		# keyserver: # The keyserver to retrieve key from.
		# url: # The URL to retrieve key from.
		# data: # The keyfile contents to add to the keyring.
		# keyring: # The path to specific keyring file in /etc/apt/trusted.gpg.d/
		# state: absent|#present
		# file: # The path to a keyfile on the remote server to add to the keyring.
		# validate_certs: yes
		# id: # The identifier of the key.
$0
endsnippet

snippet swupd "Manages updates and bundles in ClearLinux systems." b
- name: $1
	swupd:
		# contenturl: # URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.
		# name: # Name of the (I)bundle to install or remove.
		# format: # The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.
		# url: # Overrides both I(contenturl) and I(versionurl).
		# verify: # Verify content for OS version.
		# update: no
		# manifest: # The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.
		# state: #present|absent
		# versionurl: # URL for version string download.
$0
endsnippet

snippet homebrew_tap "Tap a Homebrew repository." b
- name: $1
	homebrew_tap:
		name: ${2:# The GitHub user/organization repository to tap.}
		# url: # The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.
		# state: #present|absent
$0
endsnippet

snippet yum "Manages packages with the I(yum) package manager" b
- name: $1
	yum:
		name: ${2:# A package name , or package specifier with version, like C(name-1.0).}
		# update_cache: no
		# exclude: # Package name(s) to exclude when state=present, or latest
		# installroot: /
		# allow_downgrade: no
		# validate_certs: yes
		# list: # Package name to run the equivalent of yum list <package> against. In addition to listing packages, use can also list the following: C(installed), C(updates), C(available) and C(repos).
		# disable_gpg_check: no
		# conf_file: # The remote yum configuration file to use for the transaction.
		# update_only: yes|#no
		# state: absent|installed|latest|#present|removed
		# disablerepo: # I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# skip_broken: no
		# enablerepo: # I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# disable_plugin: # I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.
		# security: no
		# enable_plugin: # I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.
$0
endsnippet

snippet dnf "Manages packages with the I(dnf) package manager" b
- name: $1
	dnf:
		name: ${2:# A list of package names, or package specifier with version, like C(name-1.0) When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.}
		# autoremove: yes|no
		# list: # Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.
		# disable_gpg_check: yes|#no
		# conf_file: # The remote dnf configuration file to use for the transaction.
		# state: #present|latest|absent
		# disablerepo: # I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# enablerepo: # I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# installroot: /
$0
endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels" b
- name: $1
	rhn_channel:
		sysname: ${2:# Name of the system as it is known in RHN/Satellite.}
		name: ${3:# Name of the software channel.}
		url: ${4:# The full URL to the RHN/Satellite API.}
		password: ${5:# RHN/Satellite password.}
		user: ${6:# RHN/Satellite login.}
		# state: present
$0
endsnippet

snippet pkgin "Package manager for SmartOS, NetBSD, et al." b
- name: $1
	pkgin:
		# state: #present|absent
		# upgrade: yes|no
		# force: yes|no
		# name: # Name of package to install/remove;
		# full_upgrade: yes|no
		# update_cache: yes|no
		# clean: yes|no
$0
endsnippet

snippet svr4pkg "Manage Solaris SVR4 packages" b
- name: $1
	svr4pkg:
		state: ${2:present|absent}
		name: ${3:# Package name, e.g. C(SUNWcsr)}
		# category: true|false
		# src: # Specifies the location to install the package from. Required when C(state=present).
		# zone: current|#all
		# response_file: # Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)
		# proxy: # HTTP[s] proxy to be used if C(src) is a URL.
$0
endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks." b
- name: $1
	homebrew_cask:
		name: ${2:# name of cask to install/remove}
		# install_options: # options flags to install a package
		# upgrade: no
		# update_homebrew: yes|no
		# upgrade_all: no
		# accept_external_apps: no
		# state: #present|absent|upgraded
		# path: /usr/local/bin
$0
endsnippet

snippet sorcery "Package manager for Source Mage GNU/Linux" b
- name: $1
	sorcery:
		# depends: # Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)
		# update_cache: yes|#no
		# name: # Name of the spell
		# state: #present|latest|absent|cast|dispelled|rebuild
		# update: yes|#no
		# cache_valid_time: # Time in seconds to invalidate grimoire collection on update
$0
endsnippet

snippet slackpkg "Package manager for Slackware >= 12.2" b
- name: $1
	slackpkg:
		name: ${2:# name of package to install/remove}
		# state: #present|absent|latest
		# update_cache: True|#False
$0
endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db" b
- name: $1
	rpm_key:
		key: ${2:# Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.}
		# state: absent|#present
		# validate_certs: yes
$0
endsnippet

snippet apt "Manages apt-packages" b
- name: $1
	apt:
		# autoremove: no
		# force: no
		# force_apt_get: no
		# update_cache: no
		# only_upgrade: no
		# deb: # Path to a .deb package on the remote machine.
		# cache_valid_time: 0
		# dpkg_options: force-confdef,force-confold
		# upgrade: dist|full|#no|safe|yes
		# name: # A list of package names, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.
		# autoclean: no
		# purge: no
		# allow_unauthenticated: no
		# state: absent|build-dep|latest|#present
		# default_release: # Corresponds to the C(-t) option for I(apt) and sets pin priorities
		# install_recommends: # Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.
$0
endsnippet

snippet portinstall "Installing packages from FreeBSD's ports system" b
- name: $1
	portinstall:
		name: ${2:# name of package to install/remove}
		# state: #present|absent
		# use_packages: yes|no
$0
endsnippet

snippet rhsm_repository "Manage RHSM repositories using the subscription-manager command" b
- name: $1
	rhsm_repository:
		state: ${2:#present|enabled|absent|disabled}
		name: ${3:# The ID of repositories to enable.}
$0
endsnippet

snippet pkg5 "Manages packages with the Solaris 11 Image Packaging System" b
- name: $1
	pkg5:
		name: ${2:# An FRMI of the package(s) to be installed/removed/updated.}
		# accept_licenses: no
		# state: absent|latest|#present
$0
endsnippet

snippet opkg "Package manager for OpenWrt" b
- name: $1
	opkg:
		name: ${2:# name of package to install/remove}
		# force: |depends|maintainer|reinstall|overwrite|downgrade|space|postinstall|remove|checksum|removal-of-dependent-packages
		# state: #present|absent
		# update_cache: yes|#no
$0
endsnippet

snippet pkg5_publisher "Manages Solaris 11 Image Packaging System publishers" b
- name: $1
	pkg5_publisher:
		name: ${2:# The publisher's name.}
		# origin: # A path or URL to the repository.
		# state: #present|absent
		# mirror: # A path or URL to the repository mirror.
		# enabled: True|False
		# sticky: True|False
$0
endsnippet

snippet dpkg_selections "Dpkg package selection selections" b
- name: $1
	dpkg_selections:
		selection: ${2:install|hold|deinstall|purge}
		name: ${3:# Name of the package}
$0
endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command" b
- name: $1
	rhn_register:
		# username: # Red Hat Network username
		# systemorgid: # supply an organizational id for use with registration
		# enable_eus: no
		# server_url: Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default
		# channels: []
		# state: #present|absent
		# sslcacert: # supply a custom ssl CA certificate file for use with registration
		# activationkey: # supply an activation key for use with registration
		# profilename: # supply an profilename for use with registration
		# password: # Red Hat Network password
		# nopackages: no
$0
endsnippet

snippet apt_rpm "apt_rpm package manager" b
- name: $1
	apt_rpm:
		pkg: ${2:# name of package to install, upgrade or remove.}
		# state: absent|#present
		# update_cache: no
$0
endsnippet

snippet macports "Package manager for MacPorts" b
- name: $1
	macports:
		name: ${2:# name of package to install/remove}
		# state: #present|absent|active|inactive
		# update_cache: yes|#no
$0
endsnippet

snippet kibana_plugin "Manage Kibana plugins" b
- name: $1
	kibana_plugin:
		name: ${2:# Name of the plugin to install}
		# force: yes|no
		# url: # Set exact URL to download the plugin from. For local file, prefix its absolute path with file://
		# state: #present|absent
		# version: # Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes
		# timeout: 1m
		# plugin_dir: /opt/kibana/installedPlugins/
		# plugin_bin: /opt/kibana/bin/kibana
$0
endsnippet

snippet elasticsearch_plugin "Manage Elasticsearch plugins" b
- name: $1
	elasticsearch_plugin:
		name: ${2:# Name of the plugin to install. In Eleasticsearch >= 2.0, the name can be an URL or file location.}
		# proxy_host: # Proxy host to use during plugin installation
		# url: # Set exact URL to download the plugin from (Only works for ES 1.x)
		# proxy_port: # Proxy port to use during plugin installation
		# state: #present|absent
		# version: # Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated
		# timeout: 1m
		# plugin_dir: /usr/share/elasticsearch/plugins/
		# plugin_bin: # Location of the plugin binary. If this file is not found, the default plugin binaries will be used.
$0
endsnippet

snippet riak "This module handles some common Riak operations" b
- name: $1
	riak:
		# target_node: riak@127.0.0.1
		# config_dir: /etc/riak
		# wait_for_service: kv
		# http_conn: 127.0.0.1:8098
		# wait_for_ring: # Number of seconds to wait for all nodes to agree on the ring.
		# wait_for_handoffs: # Number of seconds to wait for handoffs to complete.
		# command: ping|kv_test|join|plan|commit
		# validate_certs: #yes|no
$0
endsnippet

snippet redis "Various redis commands, slave and flush" b
- name: $1
	redis:
		command: ${2:config|flush|slave}
		# login_port: 6379
		# name: # A redis config key.
		# flush_mode: #all|db
		# master_host: # The host of the master instance [slave command]
		# login_host: localhost
		# master_port: # The port of the master instance [slave command]
		# db: # The database to flush (used in db mode) [flush command]
		# value: # A redis config value.
		# login_password: # The password used to authenticate with (usually not used)
		# slave_mode: master|#slave
$0
endsnippet

snippet postgresql_user "Adds or removes a users (roles) from a PostgreSQL database." b
- name: $1
	postgresql_user:
		name: ${2:# name of the user (role) to add or remove}
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# login_user: postgres
		# login_host: localhost
		# expires: # The date at which the user's password is to expire.
		# db: # name of database where permissions will be granted
		# conn_limit: # Specifies the user connection limit.
		# login_unix_socket: # Path to a Unix domain socket for local connections
		# login_password: # Password used to authenticate with PostgreSQL
		# password: # set the user's password, before 1.4 this was required.
		# port: 5432
		# fail_on_user: True|False
		# priv: # PostgreSQL privileges string in the format: C(table:priv1,priv2)
		# no_password_changes: True|False
		# state: #present|absent
		# encrypted: no
		# role_attr_flags: [NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION|[NO]BYPASSRLS
$0
endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database." b
- name: $1
	postgresql_lang:
		lang: ${2:# name of the procedural language to add, remove or change}
		# force_trust: yes|no
		# login_user: postgres
		# login_host: localhost
		# db: # name of database where the language will be added, removed or changed
		# cascade: yes|no
		# state: #present|absent
		# login_password: # Password used to authenticate with PostgreSQL (must match C(login_user))
		# trust: yes|no
		# fail_on_drop: #yes|no
		# port: 5432
$0
endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects." b
- name: $1
	postgresql_privs:
		roles: ${2:# Comma separated list of role (user/group) names to set permissions for.}
		database: ${3:# Name of database to connect to.}
		# objs: # Comma separated list of database objects to set privileges on.
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# privs: # Comma separated list of privileges to grant/revoke.
		# login_user: postgres
		# login_host: # Host running the database
		# login_unix_socket: # Path to a Unix domain socket for local connections
		# state: #present|absent
		# unix_socket: # Path to a Unix domain socket for local connections.
		# host: # Database host address. If unspecified, connect via Unix socket.
		# login_password: # The password used to authenticate with
		# login: postgres
		# password: # The password to authenticate with.
		# type: #table|sequence|function|database|schema|language|tablespace|group
		# port: 5432
		# grant_option: yes|no
		# schema: # Schema that contains the database objects specified via I(objs).
$0
endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema from a remote host" b
- name: $1
	postgresql_schema:
		name: ${2:# Name of the schema to add or remove.}
		# database: postgres
		# login_user: # The username used to authenticate with.
		# login_host: localhost
		# login_unix_socket: # Path to a Unix domain socket for local connections.
		# state: #present|absent
		# login_password: # The password used to authenticate with.
		# owner: # Name of the role to set as owner of the schema.
		# port: 5432
$0
endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database." b
- name: $1
	postgresql_ext:
		name: ${2:# name of the extension to add or remove}
		db: ${3:# name of the database to add or remove the extension to/from}
		# state: #present|absent
		# login_password: # The password used to authenticate with
		# login_user: # The username used to authenticate with
		# login_host: localhost
		# port: 5432
$0
endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host." b
- name: $1
	postgresql_db:
		name: ${2:# name of the database to add or remove}
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s).
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# login_unix_socket: # Path to a Unix domain socket for local connections
		# encoding: # Encoding of the database
		# login_user: postgres
		# lc_collate: # Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.
		# target_opts: # Further arguments for pg_dump or pg_restore. Used when state is "dump" or "restore"
		# lc_ctype: # Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.
		# port: 5432
		# owner: # Name of the role to set as owner of the database
		# state: #present|absent|dump|restore
		# template: # Template used to create the database
		# login_password: # The password used to authenticate with
		# maintenance_db: postgres
		# login_host: # Host running the database
		# target: # File to back up or restore from. Used when state is "dump" or "restore"
$0
endsnippet

snippet mongodb_user "Adds or removes a user from a MongoDB database." b
- name: $1
	mongodb_user:
		name: ${2:# The name of the user to add or remove}
		database: ${3:# The name of the database to add/remove the user from}
		# login_port: 27017
		# update_password: #always|on_create
		# roles: readWrite
		# login_user: # The username used to authenticate with
		# login_host: localhost
		# login_database: # The database where login credentials are stored
		# ssl_cert_reqs: #CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE
		# ssl: no
		# state: #present|absent
		# login_password: # The password used to authenticate with
		# password: # The password to use for the user
		# replica_set: # Replica set to connect to (automatically connects to primary for writes)
$0
endsnippet

snippet mongodb_parameter "Change an administrative parameter on a MongoDB server." b
- name: $1
	mongodb_parameter:
		database: ${2:# The name of the database to add/remove the user from}
		param: ${3:# MongoDB administrative parameter to modify}
		value: ${4:# MongoDB administrative parameter value to set}
		# login_port: 27017
		# login_user: # The username used to authenticate with
		# login_host: localhost
		# login_database: # The database where login credentials are stored
		# ssl: no
		# param_type: str
		# login_password: # The password used to authenticate with
		# replica_set: # Replica set to connect to (automatically connects to primary for writes)
$0
endsnippet

snippet influxdb_user "Manage InfluxDB users" b
- name: $1
	influxdb_user:
		user_name: ${2:# Name of the user.}
		# username: root
		# retries: 3
		# use_udp: no
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
		# admin: True|#False
		# validate_certs: yes
		# user_password: # Password to be set for the user.
		# hostname: localhost
		# udp_port: 4444
		# ssl: no
		# state: #present|absent
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# password: root
		# port: 8086
$0
endsnippet

snippet influxdb_write "Write data points into InfluxDB." b
- name: $1
	influxdb_write:
		data_points: ${2:# Data points as dict to write into the database.}
		database_name: ${3:# Name of the database.}
		# username: root
		# retries: 3
		# use_udp: no
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
		# hostname: localhost
		# udp_port: 4444
		# ssl: no
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# password: root
		# validate_certs: yes
		# port: 8086
$0
endsnippet

snippet influxdb_query "Query data points from InfluxDB." b
- name: $1
	influxdb_query:
		database_name: ${2:# Name of the database.}
		query: ${3:# Query to be executed.}
		# username: root
		# retries: 3
		# use_udp: no
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
		# hostname: localhost
		# udp_port: 4444
		# ssl: no
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# password: root
		# validate_certs: yes
		# port: 8086
$0
endsnippet

snippet influxdb_database "Manage InfluxDB databases" b
- name: $1
	influxdb_database:
		database_name: ${2:# Name of the database.}
		# username: root
		# retries: 3
		# use_udp: no
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
		# hostname: localhost
		# udp_port: 4444
		# ssl: no
		# state: #present|absent
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# password: root
		# validate_certs: yes
		# port: 8086
$0
endsnippet

snippet influxdb_retention_policy "Manage InfluxDB retention policies" b
- name: $1
	influxdb_retention_policy:
		default: ${2:# Sets the retention policy as default retention policy}
		database_name: ${3:# Name of the database.}
		policy_name: ${4:# Name of the retention policy}
		replication: ${5:# Determines how many independent copies of each point are stored in the cluster}
		duration: ${6:# Determines how long InfluxDB should keep the data}
		# username: root
		# retries: 3
		# use_udp: no
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
		# ssl: no
		# hostname: localhost
		# udp_port: 4444
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# password: root
		# validate_certs: yes
		# port: 8086
$0
endsnippet

snippet mysql_variables "Manage MySQL global variables" b
- name: $1
	mysql_variables:
		variable: ${2:# Variable name to operate}
		# login_port: 3306
		# ssl_cert: # The path to a client public key certificate.
		# config_file: ~/.my.cnf
		# ssl_key: # The path to the client private key.
		# login_user: # The username used to authenticate with.
		# login_host: localhost
		# value: # If set, then sets variable value to this
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# login_password: # The password used to authenticate with.
		# connect_timeout: 30
$0
endsnippet

snippet mysql_replication "Manage MySQL replication" b
- name: $1
	mysql_replication:
		# master_ssl_cert: # same as mysql variable
		# master_auto_position: # does the host uses GTID based replication or not
		# config_file: ~/.my.cnf
		# master_password: # same as mysql variable
		# master_host: # same as mysql variable
		# login_host: localhost
		# login_password: # The password used to authenticate with.
		# master_ssl_capath: # same as mysql variable
		# master_ssl_ca: # same as mysql variable
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# master_connect_retry: # same as mysql variable
		# master_user: # same as mysql variable
		# master_port: # same as mysql variable
		# master_log_file: # same as mysql variable
		# master_ssl_cipher: # same as mysql variable
		# relay_log_file: # same as mysql variable
		# login_port: 3306
		# ssl_cert: # The path to a client public key certificate.
		# master_ssl: 0|1
		# ssl_key: # The path to the client private key.
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# master_ssl_key: # same as mysql variable
		# mode: #getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall
		# login_user: # The username used to authenticate with.
		# master_log_pos: # same as mysql variable
		# connect_timeout: 30
		# relay_log_pos: # same as mysql variable
$0
endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host." b
- name: $1
	mysql_db:
		name: ${2:# name of the database to add or remove}
		# ssl_key: # The path to the client private key.
		# config_file: ~/.my.cnf
		# encoding: # Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)
		# login_user: # The username used to authenticate with.
		# login_host: localhost
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# login_password: # The password used to authenticate with.
		# collation: # Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# single_transaction: no
		# login_port: 3306
		# ssl_cert: # The path to a client public key certificate.
		# target: # Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.
		# state: #present|absent|dump|import
		# quick: yes
		# connect_timeout: 30
$0
endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database." b
- name: $1
	mysql_user:
		name: ${2:# name of the user (role) to add or remove}
		# login_port: 3306
		# update_password: #always|on_create
		# ssl_cert: # The path to a client public key certificate.
		# config_file: ~/.my.cnf
		# ssl_key: # The path to the client private key.
		# encrypted: yes|#no
		# login_host: localhost
		# append_privs: yes|#no
		# sql_log_bin: #yes|no
		# host_all: yes|#no
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# login_password: # The password used to authenticate with.
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# state: #present|absent
		# login_user: # The username used to authenticate with.
		# host: localhost
		# check_implicit_admin: yes|#no
		# password: # set the user's password.
		# connect_timeout: 30
		# priv: # MySQL privileges string in the format: C(db.table:priv1,priv2).
$0
endsnippet

snippet proxysql_global_variables "Gets or sets the proxysql global variables." b
- name: $1
	proxysql_global_variables:
		variable: ${2:# Defines which variable should be returned, or if I(value) is specified which variable should be updated.}
		# login_port: 6032
		# config_file: 
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# value: # Defines a value the variable specified using I(variable) should be set to.
		# load_to_runtime: yes
		# save_to_disk: yes
$0
endsnippet

snippet proxysql_manage_config "Writes the proxysql configuration settings between layers." b
- name: $1
	proxysql_manage_config:
		direction: ${2:FROM|TO}
		config_settings: ${3:MYSQL USERS|MYSQL SERVERS|MYSQL QUERY RULES|MYSQL VARIABLES|ADMIN VARIABLES|SCHEDULER}
		config_layer: ${4:MEMORY|DISK|RUNTIME|CONFIG}
		action: ${5:LOAD|SAVE}
		# login_port: 6032
		# config_file: 
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_password: # The password used to authenticate to ProxySQL admin interface.
$0
endsnippet

snippet proxysql_scheduler "Adds or removes schedules from proxysql admin interface." b
- name: $1
	proxysql_scheduler:
		filename: ${2:# Full path of the executable to be executed.}
		# comment: # Text field that can be used for any purposed defined by the user.
		# login_port: 6032
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# config_file: 
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# arg1: # Argument that can be passed to the job.
		# arg2: # Argument that can be passed to the job.
		# arg3: # Argument that can be passed to the job.
		# arg4: # Argument that can be passed to the job.
		# arg5: # Argument that can be passed to the job.
		# state: #present|absent
		# interval_ms: 10000
		# load_to_runtime: yes
		# force_delete: no
		# active: yes
		# save_to_disk: yes
		# login_host: 127.0.0.1
$0
endsnippet

snippet proxysql_backend_servers "Adds or removes mysql hosts from proxysql admin interface." b
- name: $1
	proxysql_backend_servers:
		hostname: ${2:# The ip address at which the mysqld instance can be contacted.}
		# status: ONLINE|OFFLINE_SOFT|OFFLINE_HARD
		# comment: 
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# config_file: 
		# compression: # If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.
		# weight: # The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.
		# login_port: 6032
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# hostgroup_id: 0
		# state: #present|absent
		# load_to_runtime: yes
		# save_to_disk: yes
		# use_ssl: # If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
		# max_connections: # The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.
		# port: 3306
		# max_latency_ms: # Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.
		# max_replication_lag: # If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.
$0
endsnippet

snippet proxysql_mysql_users "Adds or removes mysql users from proxysql admin interface." b
- name: $1
	proxysql_mysql_users:
		username: ${2:# Name of the user connecting to the mysqld or ProxySQL instance.}
		# default_hostgroup: # If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.
		# frontend: yes
		# default_schema: # The schema to which the connection should change to by default.
		# transaction_persistent: # If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).
		# login_port: 6032
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# config_file: 
		# backend: yes
		# state: #present|absent
		# fast_forward: # If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).
		# load_to_runtime: yes
		# save_to_disk: yes
		# active: # A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).
		# use_ssl: # If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
		# password: # Password of the user connecting to the mysqld or ProxySQL instance.
		# max_connections: # The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.
$0
endsnippet

snippet proxysql_query_rules "Modifies query rules using the proxysql admin interface." b
- name: $1
	proxysql_query_rules:
		# comment: # Free form text field, usable for a descriptive comment of the query rule.
		# username: # Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.
		# config_file: 
		# flagOUT: # Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.
		# login_port: 6032
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# match_pattern: # Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
		# destination_hostgroup: # Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).
		# proxy_port: # Match incoming traffic on a specific local port.
		# active: # A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.
		# load_to_runtime: yes
		# save_to_disk: yes
		# mirror_flagOUT: # Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.
		# apply: # Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.
		# schemaname: # Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.
		# replace_pattern: # This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.
		# cache_ttl: # The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.
		# digest: # Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.
		# retries: # The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.
		# match_digest: # Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
		# mirror_hostgroup: # Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.
		# log: # Query will be logged.
		# negate_match_pattern: # If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.
		# flagIN: # Used in combination with I(flagOUT) and I(apply) to create chains of rules.
		# client_addr: # Match traffic from a specific source.
		# error_msg: # Query will be blocked, and the specified error_msg will be returned to the client.
		# delay: # Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.
		# state: #present|absent
		# proxy_addr: # Match incoming traffic on a specific local IP.
		# timeout: # The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.
		# force_delete: no
		# rule_id: # The unique id of the rule. Rules are processed in rule_id order.
$0
endsnippet

snippet proxysql_replication_hostgroups "Manages replication hostgroups using the proxysql admin interface." b
- name: $1
	proxysql_replication_hostgroups:
		reader_hostgroup: ${2:# Id of the reader hostgroup.}
		writer_hostgroup: ${3:# Id of the writer hostgroup.}
		# comment: # Text field that can be used for any purposed defined by the user.
		# login_port: 6032
		# config_file: 
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# state: #present|absent
		# load_to_runtime: yes
		# save_to_disk: yes
$0
endsnippet

snippet vertica_role "Adds or removes Vertica database roles and assigns roles to them." b
- name: $1
	vertica_role:
		name: ${2:# Name of the role to add or remove.}
		# assigned_roles: # Comma separated list of roles to assign to the role.
		# login_user: dbadmin
		# db: # Name of the Vertica database.
		# cluster: localhost
		# state: #present|absent
		# login_password: # The password used to authenticate with.
		# port: 5433
$0
endsnippet

snippet vertica_user "Adds or removes Vertica database users and assigns roles." b
- name: $1
	vertica_user:
		name: ${2:# Name of the user to add or remove.}
		# profile: # Sets the user's profile.
		# resource_pool: # Sets the user's resource pool.
		# roles: # Comma separated list of roles to assign to the user.
		# login_user: dbadmin
		# ldap: # Set to true if users are authenticated via LDAP.
		# db: # Name of the Vertica database.
		# cluster: localhost
		# state: #present|absent|locked
		# login_password: # The password used to authenticate with.
		# password: # The user's password encrypted by the MD5 algorithm.
		# expired: # Sets the user's password expiration.
		# port: 5433
$0
endsnippet

snippet vertica_configuration "Updates Vertica configuration parameters." b
- name: $1
	vertica_configuration:
		name: ${2:# Name of the parameter to update.}
		value: ${3:# Value of the parameter to be set.}
		# cluster: localhost
		# login_password: # The password used to authenticate with.
		# login_user: dbadmin
		# db: # Name of the Vertica database.
		# port: 5433
$0
endsnippet

snippet vertica_facts "Gathers Vertica database facts." b
- name: $1
	vertica_facts:
		# login_user: dbadmin
		# cluster: localhost
		# db: # Name of the database running the schema.
		# port: 5433
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet vertica_schema "Adds or removes Vertica database schema and roles." b
- name: $1
	vertica_schema:
		name: ${2:# Name of the schema to add or remove.}
		# create_roles: # Comma separated list of roles to create and grant usage and create access to the schema.
		# login_user: dbadmin
		# db: # Name of the Vertica database.
		# usage_roles: # Comma separated list of roles to create and grant usage access to the schema.
		# cluster: localhost
		# state: #present|absent
		# login_password: # The password used to authenticate with.
		# owner: # Name of the user to set as owner of the schema.
		# port: 5433
$0
endsnippet

snippet mssql_db "Add or remove MSSQL databases from a remote host." b
- name: $1
	mssql_db:
		name: ${2:# name of the database to add or remove}
		# autocommit: false|true
		# login_port: 1433
		# login_user: # The username used to authenticate with
		# login_host: # Host running the database
		# state: #present|absent|import
		# login_password: # The password used to authenticate with
		# target: # Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.
$0
endsnippet

snippet openssl_certificate "Generate and/or check OpenSSL certificates" b
- name: $1
	openssl_certificate:
		path: ${2:# Remote absolute path where the generated certificate file should be created or is already located.}
		provider: ${3:selfsigned|assertonly|acme}
		# privatekey_passphrase: # The passphrase for the I(privatekey_path).
		# subject_alt_name_strict: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# force: no
		# csr_path: # Path to the Certificate Signing Request (CSR) used to generate this certificate. This is not required in C(assertonly) mode.
		# acme_chain: yes
		# extended_key_usage_strict: no
		# key_usage: # The I(key_usage) extension field must contain all these values.
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# not_before: # The certificate must start to become valid at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# subject: # Key/value pairs that must be present in the subject name field of the certificate. If you need to specify more than one value with the same key, use a list as value.
		# subject_strict: no
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# selfsigned_version: 3
		# unsafe_writes: no
		# has_expired: no
		# state: #present|absent
		# version: # Version of the certificate. Nowadays it should almost always be 3.
		# selfsigned_digest: sha256
		# issuer: # Key/value pairs that must be present in the issuer name field of the certificate. If you need to specify more than one value with the same key, use a list as value.
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# key_usage_strict: no
		# subject_alt_name: # The I(subject_alt_name) extension field must contain these values.
		# selevel: s0
		# selfsigned_not_after: # The timestamp at which the certificate stops being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will stop being valid 10 years from now.
		# acme_challenge_path: # Path to the ACME challenge directory that is served on U(http://<HOST>:80/.well-known/acme-challenge/)
		# privatekey_path: # Path to the private key to use when signing the certificate.
		# issuer_strict: no
		# invalid_at: # The certificate must be invalid at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# acme_accountkey_path: # Path to the accountkey for the C(acme) provider
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# extended_key_usage: # The I(extended_key_usage) extension field must contain all these values.
		# not_after: # The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# signature_algorithms: # list of algorithms that you would accept the certificate to be signed with (e.g. ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']).
		# selfsigned_not_before: # The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# valid_in: # The certificate must still be valid in I(valid_in) seconds from now.
		# valid_at: # The certificate must be valid at this point in time. The timestamp is formatted as an ASN.1 TIME.
$0
endsnippet

snippet openssl_publickey "Generate an OpenSSL public key from its private key." b
- name: $1
	openssl_publickey:
		privatekey_path: ${2:# Path to the TLS/SSL private key from which to generate the public key.}
		path: ${3:# Name of the file in which the generated TLS/SSL public key will be written.}
		# privatekey_passphrase: # The passphrase for the privatekey.
		# force: True|#False
		# format: #PEM|OpenSSH
		# selevel: s0
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet openssl_dhparam "Generate OpenSSL Diffie-Hellman Parameters" b
- name: $1
	openssl_dhparam:
		path: ${2:# Name of the file in which the generated parameters will be saved.}
		# force: True|#False
		# unsafe_writes: no
		# selevel: s0
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# size: 4096
$0
endsnippet

snippet openssl_privatekey "Generate OpenSSL private keys." b
- name: $1
	openssl_privatekey:
		path: ${2:# Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.}
		# force: True|#False
		# selevel: s0
		# cipher: # The cipher to encrypt the private key. (cipher can be found by running `openssl list-cipher-algorithms`)
		# passphrase: # The passphrase for the private key.
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# size: 4096
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# type: #RSA|DSA
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet openssl_csr "Generate OpenSSL Certificate Signing Request (CSR)" b
- name: $1
	openssl_csr:
		privatekey_path: ${2:# Path to the privatekey to use when signing the certificate signing request}
		path: ${3:# Name of the file into which the generated OpenSSL certificate signing request will be written}
		# privatekey_passphrase: # The passphrase for the privatekey.
		# state_or_province_name: # stateOrProvinceName field of the certificate signing request subject
		# extended_key_usage_critical: # Should the extkeyUsage extension be considered as critical
		# force: True|#False
		# subject_alt_name: # SAN extension to attach to the certificate signing request
		# selevel: s0
		# basic_constraints: # Indicates basic constraints, such as if the certificate is a CA.
		# subject_alt_name_critical: # Should the subjectAltName extension be considered as critical
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# ocsp_must_staple: # Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools.ietf.org/html/rfc7633)).
		# key_usage: # This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.
		# common_name: # commonName field of the certificate signing request subject
		# email_address: # emailAddress field of the certificate signing request subject
		# digest: sha256
		# subject: # Key/value pairs that will be present in the subject name field of the certificate signing request.
		# key_usage_critical: # Should the keyUsage extension be considered as critical
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# extended_key_usage: # Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.
		# organizational_unit_name: # organizationalUnitName field of the certificate signing request subject
		# unsafe_writes: no
		# locality_name: # localityName field of the certificate signing request subject
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# organization_name: # organizationName field of the certificate signing request subject
		# state: #present|absent
		# version: 1
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# basic_constraints_critical: # Should the basicConstraints extension be considered as critical
		# country_name: # countryName field of the certificate signing request subject
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# ocsp_must_staple_critical: # Should the OCSP Must Staple extension be considered as critical
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet ipa_role "Manage FreeIPA role" b
- name: $1
	ipa_role:
		cn: ${2:# Role name.}
		ipa_pass: ${3:# Password of administrative user.}
		# ipa_port: 443
		# group: # List of group names assign to this role.
		# service: # List of service names to assign.
		# ipa_prot: http|#https
		# host: # List of host names to assign.
		# hostgroup: # List of host group names to assign.
		# state: #present|absent
		# ipa_host: ipa.example.com
		# user: # List of user names to assign.
		# ipa_user: admin
		# privilege: # List of privileges granted to the role.
		# validate_certs: yes
		# description: # A description of this role-group.
$0
endsnippet

snippet ipa_hbacrule "Manage FreeIPA HBAC rule" b
- name: $1
	ipa_hbacrule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# servicecategory: all
		# sourcehostcategory: all
		# service: # List of service names to assign.
		# ipa_port: 443
		# description: # D
		# ipa_prot: http|#https
		# hostcategory: all
		# hostgroup: # List of hostgroup names to assign.
		# usercategory: all
		# state: #present|absent|enabled|disabled
		# ipa_host: ipa.example.com
		# user: # List of user names to assign.
		# ipa_user: admin
		# usergroup: # List of user group names to assign.
		# host: # List of host names to assign.
		# servicegroup: # List of service group names to assign.
		# validate_certs: yes
		# sourcehostgroup: # List of source host group names to assign.
		# sourcehost: # List of source host names to assign.
$0
endsnippet

snippet ipa_host "Manage FreeIPA host" b
- name: $1
	ipa_host:
		fqdn: ${2:# Full qualified domain name.}
		ipa_pass: ${3:# Password of administrative user.}
		# ipa_port: 443
		# force: # Force host name even if not in DNS.
		# description: # A description of this host.
		# ns_os_version: # Host operating system and version (e.g. "Fedora 9")
		# ipa_prot: http|#https
		# ipa_host: ipa.example.com
		# validate_certs: yes
		# state: #present|absent|disabled
		# random_password: no
		# ns_host_location: # Host location (e.g. "Lab 2")
		# ipa_user: admin
		# mac_address: # List of Hardware MAC address(es) off this host.
		# user_certificate: # List of Base-64 encoded server certificates.
		# ip_address: # Add the host to DNS with this IP address.
		# ns_hardware_platform: # Host hardware platform (e.g. "Lenovo T61")
		# update_dns: no
$0
endsnippet

snippet ipa_group "Manage FreeIPA group" b
- name: $1
	ipa_group:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# external: # Allow adding external non-IPA members from trusted domains.
		# ipa_port: 443
		# group: # List of group names assigned to this group.
		# user: # List of user names assigned to this group.
		# ipa_prot: http|#https
		# gidnumber: # GID (use this option to set it manually).
		# state: #present|absent
		# ipa_user: admin
		# validate_certs: yes
		# nonposix: # Create as a non-POSIX group.
		# ipa_host: ipa.example.com
$0
endsnippet

snippet ipa_sudocmdgroup "Manage FreeIPA sudo command group" b
- name: $1
	ipa_sudocmdgroup:
		cn: ${2:# Sudo Command Group.}
		ipa_pass: ${3:# Password of administrative user.}
		# ipa_port: 443
		# ipa_user: admin
		# ipa_prot: http|#https
		# state: #present|absent
		# ipa_host: ipa.example.com
		# sudocmd: # List of sudo commands to assign to the group.
		# validate_certs: yes
		# description: # Group description.
$0
endsnippet

snippet ipa_user "Manage FreeIPA users" b
- name: $1
	ipa_user:
		uid: ${2:# u}
		ipa_pass: ${3:# Password of administrative user.}
		# telephonenumber: # List of telephone numbers assigned to the user.
		# sshpubkey: # List of public SSH key.
		# ipa_port: 443
		# password: # Password for new user
		# displayname: # D
		# krbpasswordexpiration: # Date at which the user password will expire
		# title: # T
		# loginshell: # L
		# uidnumber: # Account Settings UID/Posix User ID number
		# state: #present|absent|enabled|disabled
		# ipa_prot: http|#https
		# gidnumber: # Posix Group ID
		# sn: # S
		# ipa_user: admin
		# mail: # List of mail addresses assigned to the user.
		# givenname: # F
		# validate_certs: yes
		# ipa_host: ipa.example.com
$0
endsnippet

snippet ipa_dnszone "Manage FreeIPA DNS Zones" b
- name: $1
	ipa_dnszone:
		ipa_pass: ${2:# Password of administrative user.}
		zone_name: ${3:# The DNS zone name to which needs to be managed.}
		# ipa_port: 443
		# ipa_prot: http|#https
		# state: #present|absent
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet ipa_sudorule "Manage FreeIPA sudo rule" b
- name: $1
	ipa_sudorule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# ipa_port: 443
		# runasgroupcategory: all
		# runasusercategory: all
		# cmd: # List of commands assigned to the rule.
		# ipa_prot: http|#https
		# host: # List of hosts assigned to the rule.
		# hostgroup: # List of host groups assigned to the rule.
		# usercategory: all
		# hostcategory: all
		# state: #present|absent|enabled|disabled
		# user: # List of users assigned to the rule.
		# ipa_user: admin
		# usergroup: # List of user groups assigned to the rule.
		# cmdcategory: all
		# validate_certs: yes
		# ipa_host: ipa.example.com
$0
endsnippet

snippet ipa_service "Manage FreeIPA service" b
- name: $1
	ipa_service:
		krbcanonicalname: ${2:# principal of the service}
		ipa_pass: ${3:# Password of administrative user.}
		# ipa_port: 443
		# force: # Force principal name even if host is not in DNS.
		# ipa_prot: http|#https
		# state: #present|absent
		# hosts: # defines the list of 'ManagedBy' hosts
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet ipa_subca "Manage FreeIPA Lightweight Sub Certificate Authorities." b
- name: $1
	ipa_subca:
		subca_name: ${2:# The Sub Certificate Authority name which needs to be managed.}
		subca_subject: ${3:# The Sub Certificate Authority's Subject. e.g., 'CN=SampleSubCA1,O=testrelm.test'}
		ipa_pass: ${4:# Password of administrative user.}
		subca_desc: ${5:# The Sub Certificate Authority's description.}
		# ipa_port: 443
		# ipa_prot: http|#https
		# state: #present|absent|enable|disable
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet ipa_sudocmd "Manage FreeIPA sudo command" b
- name: $1
	ipa_sudocmd:
		ipa_pass: ${2:# Password of administrative user.}
		sudocmd: ${3:# Sudo Command.}
		# ipa_port: 443
		# description: # A description of this command.
		# ipa_prot: http|#https
		# state: #present|absent
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet ipa_hostgroup "Manage FreeIPA host-group" b
- name: $1
	ipa_hostgroup:
		ipa_pass: ${2:# Password of administrative user.}
		cn: ${3:# Name of host-group.}
		# ipa_port: 443
		# description: # Description
		# ipa_prot: http|#https
		# state: #present|absent
		# hostgroup: # List of host-groups than belong to that host-group.
		# host: # List of hosts that belong to the host-group.
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet ipa_dnsrecord "Manage FreeIPA DNS records" b
- name: $1
	ipa_dnsrecord:
		record_name: ${2:# The DNS record name to manage.}
		record_value: ${3:# Manage DNS record name with this value.}
		ipa_pass: ${4:# Password of administrative user.}
		zone_name: ${5:# The DNS zone name to which DNS record needs to be managed.}
		# ipa_port: 443
		# ipa_prot: http|#https
		# record_type: #A|AAAA|A6|CNAME|DNAME|PTR|TXT
		# state: #present|absent
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# validate_certs: yes
$0
endsnippet

snippet cyberark_user "Module for CyberArk User Management using PAS Web Services SDK" b
- name: $1
	cyberark_user:
		username: ${2:# The name of the user who will be queried (for details), added, updated or deleted.}
		cyberark_session: ${3:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session, please see M(cyberark_authentication) module for an example of cyberark_session.}
		# first_name: # The user first name.
		# last_name: # The user last name.
		# initial_password: # The password that the new user will use to log on the first time. This password must meet the password policy requirements. this parameter is required when state is present -- Add User.
		# user_type_name: EPVUser
		# new_password: # The user updated password. Make sure that this password meets the password policy requirements.
		# group_name: # The name of the group the user will be added to.
		# disabled: no
		# change_password_on_the_next_logon: no
		# state: #present|absent
		# expiry_date: # The date and time when the user account will expire and become disabled.
		# location: # The Vault Location for the user.
		# email: # The user email address.
$0
endsnippet

snippet cyberark_authentication "Module for CyberArk Vault Authentication using PAS Web Services SDK" b
- name: $1
	cyberark_authentication:
		# username: # The name of the user who will logon to the Vault.
		# use_radius_authentication: no
		# new_password: # The new password of the user. This parameter is optional, and enables you to change a password.
		# cyberark_session: # Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session.
		# state: #present|absent
		# password: # The password of the user.
		# validate_certs: yes
		# use_shared_logon_authentication: no
		# api_base_url: # A string containing the base URL of the server hosting CyberArk's Privileged Account Security Web Services SDK.
$0
endsnippet

snippet keycloak_client "Allows administration of Keycloak clients via Keycloak API" b
- name: $1
	keycloak_client:
		auth_realm: ${2:# Keycloak realm name to authenticate to for API access.}
		auth_password: ${3:# Password to authenticate for API access with.}
		auth_keycloak_url: ${4:# URL to the Keycloak instance.}
		auth_client_id: ${5:# OpenID Connect I(client_id) to authenticate to the API with.}
		auth_username: ${6:# Username to authenticate for API access with.}
		# default_roles: # list of default roles for this client. If the client roles referenced do not exist yet, they will be created. This is 'defaultRoles' in the Keycloak REST API.
		# protocol: openid-connect|saml
		# auth_client_secret: # Client Secret to use in conjunction with I(auth_client_id) (if required).
		# use_template_config: # Whether or not to use configuration from the I(client_template). This is 'useTemplateConfig' in the Keycloak REST API.
		# authorization_settings: # a data structure defining the authorization settings for this client. For reference, please see the Keycloak API docs at U(http://www.keycloak.org/docs-api/3.3/rest-api/index.html#_resourceserverrepresentation). This is 'authorizationSettings' in the Keycloak REST API.
		# frontchannel_logout: # Is frontchannel logout enabled for this client or not. This is 'frontchannelLogout' in the Keycloak REST API.
		# use_template_scope: # Whether or not to use scope configuration from the I(client_template). This is 'useTemplateScope' in the Keycloak REST API.
		# registration_access_token: # The registration access token provides access for clients to the client registration service. This is 'registrationAccessToken' in the Keycloak REST API.
		# authorization_services_enabled: # Are authorization services enabled for this client or not (OpenID connect). This is 'authorizationServicesEnabled' in the Keycloak REST API.
		# standard_flow_enabled: # Enable standard flow for this client or not (OpenID connect). This is 'standardFlowEnabled' in the Keycloak REST API.
		# direct_access_grants_enabled: # Are direct access grants enabled for this client or not (OpenID connect). This is 'directAccessGrantsEnabled' in the Keycloak REST API.
		# id: # Id of client to be worked on. This is usually an UUID. Either this or I(client_id) is required. If you specify both, this takes precedence.
		# surrogate_auth_required: # Whether or not surrogate auth is required. This is 'surrogateAuthRequired' in the Keycloak REST API.
		# implicit_flow_enabled: # Enable implicit flow for this client or not (OpenID connect). This is 'implictFlowEnabled' in the Keycloak REST API.
		# node_re_registration_timeout: # Cluster node re-registration timeout for this client. This is 'nodeReRegistrationTimeout' in the Keycloak REST API.
		# root_url: # Root URL appended to relative URLs for this client This is 'rootUrl' in the Keycloak REST API.
		# base_url: # Default URL to use when the auth server needs to redirect or link back to the client This is 'baseUrl' in the Keycloak REST API.
		# web_origins: # List of allowed CORS origins. This is 'webOrigins' in the Keycloak REST API.
		# full_scope_allowed: # Is the "Full Scope Allowed" feature set for this client or not. This is 'fullScopeAllowed' in the Keycloak REST API.
		# secret: # When using I(client_authenticator_type) C(client-secret) (the default), you can specify a secret here (otherwise one will be generated if it does not exit). If changing this secret, the module will not register a change currently (but the changed secret will be saved).
		# bearer_only: # The access type of this client is bearer-only. This is 'bearerOnly' in the Keycloak REST API.
		# not_before: # Revoke any tokens issued before this date for this client (this is a UNIX timestamp). This is 'notBefore' in the Keycloak REST API.
		# redirect_uris: # Acceptable redirect URIs for this client. This is 'redirectUris' in the Keycloak REST API.
		# description: # Description of the client in Keycloak
		# registered_nodes: # dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in the Keycloak REST API.
		# state: #present|absent
		# client_id: # Client id of client to be worked on. This is usually an alphanumeric name chosen by you. Either this or I(id) is required. If you specify both, I(id) takes precedence. This is 'clientId' in the Keycloak REST API.
		# public_client: # Is the access type for this client public or not. This is 'publicClient' in the Keycloak REST API.
		# service_accounts_enabled: # Are service accounts enabled for this client or not (OpenID connect). This is 'serviceAccountsEnabled' in the Keycloak REST API.
		# name: # Name of the client (this is not the same as I(client_id))
		# client_authenticator_type: client-secret|client-jwt
		# admin_url: # URL to the admin interface of the client This is 'adminUrl' in the Keycloak REST API.
		# enabled: # Is this client enabled or not?
		# protocol_mappers: # a list of dicts defining protocol mappers for this client. This is 'protocolMappers' in the Keycloak REST API.
		# client_template: # Client template to use for this client. If it does not exist this field will silently be dropped. This is 'clientTemplate' in the Keycloak REST API.
		# use_template_mappers: # Whether or not to use mapper configuration from the I(client_template). This is 'useTemplateMappers' in the Keycloak REST API.
		# attributes: # A dict of further attributes for this client. This can contain various configuration settings; an example is given in the examples section. While an exhaustive list of permissible options is not available; possible options as of Keycloak 3.4 are listed below. The Keycloak API does not validate whether a given option is appropriate for the protocol used; if specified anyway, Keycloak will simply not use it.
		# validate_certs: yes
		# consent_required: # If enabled, users have to consent to client access. This is 'consentRequired' in the Keycloak REST API.
$0
endsnippet

snippet keycloak_clienttemplate "Allows administration of Keycloak client templates via Keycloak API" b
- name: $1
	keycloak_clienttemplate:
		auth_keycloak_url: ${2:# URL to the Keycloak instance.}
		auth_client_id: ${3:# OpenID Connect I(client_id) to authenticate to the API with.}
		auth_password: ${4:# Password to authenticate for API access with.}
		auth_realm: ${5:# Keycloak realm name to authenticate to for API access.}
		auth_username: ${6:# Username to authenticate for API access with.}
		# auth_client_secret: # Client Secret to use in conjunction with I(auth_client_id) (if required).
		# protocol: openid-connect|saml
		# description: # Description of the client template in Keycloak
		# validate_certs: yes
		# protocol_mappers: # a list of dicts defining protocol mappers for this client template. This is 'protocolMappers' in the Keycloak REST API.
		# full_scope_allowed: # Is the "Full Scope Allowed" feature set for this client template or not. This is 'fullScopeAllowed' in the Keycloak REST API.
		# state: #present|absent
		# attributes: # A dict of further attributes for this client template. This can contain various configuration settings, though in the default installation of Keycloak as of 3.4, none are documented or known, so this is usually empty.
		# realm: # Realm this client template is found in.
		# id: # Id of client template to be worked on. This is usually a UUID.
		# name: # Name of the client template
$0
endsnippet

snippet opendj_backendprop "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command." b
- name: $1
	opendj_backendprop:
		name: ${2:# The configuration setting to update.}
		hostname: ${3:# The hostname of the OpenDJ server.}
		value: ${4:# The value for the configuration item.}
		port: ${5:# The Admin port on which the OpenDJ instance is available.}
		backend: ${6:# The name of the backend on which the property needs to be updated.}
		# username: cn=Directory Manager
		# state: present
		# passwordfile: # Location to the password file which holds the password for the cn=Directory Manager user.
		# password: # The password for the cn=Directory Manager user.
		# opendj_bindir: /opt/opendj/bin
$0
endsnippet

snippet mail "Send an email" b
- name: $1
	mail:
		subject: ${2:# The subject of the email being sent.}
		# body: $subject
		# username: # If SMTP requires username.
		# secure: always|never|starttls|#try
		# cc: # The email-address(es) the mail is being copied to.
		# host: localhost
		# password: # If SMTP requires password.
		# port: 25
		# to: root
		# from: root
		# headers: []
		# charset: utf-8
		# bcc: # The email-address(es) the mail is being 'blind' copied to.
		# attach: []
		# timeout: 20
		# subtype: html|#plain
$0
endsnippet

snippet grove "Sends a notification to a grove.io channel" b
- name: $1
	grove:
		message: ${2:# Message content}
		channel_token: ${3:# Token of the channel to post to.}
		# service: ansible
		# url: # Service URL for the web client
		# icon_url: # Icon for the service
		# validate_certs: #yes|no
$0
endsnippet

snippet jabber "Send a message to jabber user or chat room" b
- name: $1
	jabber:
		to: ${2:# user ID or name of the room, when using room use a slash to indicate your nick.}
		user: ${3:# User as which to connect}
		msg: ${4:# The message body.}
		password: ${5:# password for user to connect}
		# host: # host to connect, overrides user info
		# encoding: # message encoding
		# port: 5222
$0
endsnippet

snippet hipchat "Send a message to Hipchat." b
- name: $1
	hipchat:
		room: ${2:# ID or name of the room.}
		token: ${3:# API token.}
		msg: ${4:# The message body.}
		# from: Ansible
		# color: #yellow|red|green|purple|gray|random
		# msg_format: #text|html
		# api: https://api.hipchat.com/v1
		# notify: #yes|no
		# validate_certs: #yes|no
$0
endsnippet

snippet bearychat "Send BearyChat notifications" b
- name: $1
	bearychat:
		url: ${2:# BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like C(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).}
		# text: # Message to send.
		# markdown: #yes
		# attachments: # Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments
		# channel: # Channel to send the message to. If absent, the message goes to the default channel selected by the I(url).
$0
endsnippet

snippet telegram "module for sending notifications via telegram" b
- name: $1
	telegram:
		msg: ${2:# What message you wish to send.}
		token: ${3:# Token identifying your telegram bot.}
		chat_id: ${4:# Telegram group or user chat_id}
		# msg_format: #plain|markdown|html
$0
endsnippet

snippet say "Makes a computer to speak." b
- name: $1
	say:
		msg: ${2:# W}
		# voice: # W
$0
endsnippet

snippet pushover "Send notifications via U(https://pushover.net)" b
- name: $1
	pushover:
		msg: ${2:# What message you wish to send.}
		user_key: ${3:# Pushover issued authentication key for your user.}
		app_token: ${4:# Pushover issued token identifying your pushover app.}
		# pri: # Message priority (see U(https://pushover.net) for details.)
$0
endsnippet

snippet hall "Send notification to Hall" b
- name: $1
	hall:
		msg: ${2:# The message you wish to deliver as a notification}
		room_token: ${3:# Room token provided to you by setting up the Ansible room integation on U(https://hall.com)}
		title: ${4:# The title of the message}
		# picture: # The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)

$0
endsnippet

snippet irc "Send a message to an IRC channel" b
- name: $1
	irc:
		msg: ${2:# The message body.}
		channel: ${3:# Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.}
		# style: bold|underline|reverse|italic
		# key: # Channel key
		# passwd: # Server password
		# color: #none|white|black|blue|green|red|brown|purple|orange|yellow|light_green|teal|light_cyan|light_blue|pink|gray|light_gray
		# server: localhost
		# topic: # Set the channel topic
		# nick: ansible
		# part: yes
		# nick_to: # A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.
		# timeout: 30
		# use_ssl: no
		# port: 6667
$0
endsnippet

snippet mattermost "Send Mattermost notifications" b
- name: $1
	mattermost:
		url: ${2:# Mattermost url (i.e. http://mattermost.yourcompany.com).}
		text: ${3:# Text to send. Note that the module does not handle escaping characters.}
		api_key: ${4:# Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)}
		# username: Ansible
		# icon_url: https://www.ansible.com/favicon.ico
		# validate_certs: yes|no
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).
$0
endsnippet

snippet nexmo "Send a SMS via nexmo" b
- name: $1
	nexmo:
		dest: ${2:# Phone number(s) to send SMS message to}
		api_secret: ${3:# Nexmo API Secret}
		src: ${4:# Nexmo Number to send from}
		msg: ${5:# Message to text to send. Messages longer than 160 characters will be split into multiple messages}
		api_key: ${6:# Nexmo API Key}
		# force: no
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# http_agent: ansible-httpget
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# url_username: # The username for use in HTTP basic authentication.
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet snow_record "Create/Delete/Update records in ServiceNow" b
- name: $1
	snow_record:
		username: ${2:# User to connect to ServiceNow as}
		password: ${3:# Password for username}
		instance: ${4:# The service now instance name}
		state: ${5:present|absent}
		# number: # Record number to update. Required for C(state:absent)
		# attachment: # Attach a file to the record
		# table: incident
		# lookup_field: number
		# data: # key, value pairs of data to load into the record. See Examples. Required for C(state:present)
$0
endsnippet

snippet typetalk "Send a message to typetalk" b
- name: $1
	typetalk:
		topic: ${2:# topic id to post message}
		client_secret: ${3:# OAuth2 client secret}
		client_id: ${4:# OAuth2 client ID}
		msg: ${5:# message body}
$0
endsnippet

snippet mqtt "Publish a message on an MQTT topic for the IoT" b
- name: $1
	mqtt:
		topic: ${2:# MQTT topic name}
		payload: ${3:# Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.}
		# username: # Username to authenticate against the broker.
		# certfile: # The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
		# port: 1883
		# server: localhost
		# client_id: hostname + pid
		# ca_certs: # The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.
		# retain: no
		# password: # Password for C(username) to authenticate against the broker.
		# keyfile: # The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
		# qos: 0|1|2
$0
endsnippet

snippet office_365_connector_card "Use webhooks to create Connector Card messages within an Office 365 group" b
- name: $1
	office_365_connector_card:
		webhook: ${2:# The webhook URL is given to you when you create a new Connector.}
		# sections: # Contains a list of sections to display in the card.
		# title: # A title for the Connector message. Shown at the top of the message.
		# color: # Accent color used for branding or indicating status in the card.
		# text: # The main text of the card.
		# actions: # This array of objects will power the action links
		# summary: # A string used for summarizing card content.
$0
endsnippet

snippet syslogger "Log messages in the syslog" b
- name: $1
	syslogger:
		msg: ${2:# This is the message to place in syslog}
		# priority: emerg|alert|crit|err|warning|notice|#info|debug
		# facility: kern|user|mail|#daemon|auth|lpr|news|uucp|cron|syslog|local0|local1|local2|local3|local4|local5|local6|local7
		# log_pid: no
$0
endsnippet

snippet campfire "Send a message to Campfire" b
- name: $1
	campfire:
		msg: ${2:# The message body.}
		token: ${3:# API token.}
		subscription: ${4:# The subscription name to use.}
		room: ${5:# Room number to which the message should be sent.}
		# notify: 56k|bell|bezos|bueller|clowntown|cottoneyejoe|crickets|dadgummit|dangerzone|danielsan|deeper|drama|greatjob|greyjoy|guarantee|heygirl|horn|horror|inconceivable|live|loggins|makeitso|noooo|nyan|ohmy|ohyeah|pushit|rimshot|rollout|rumble|sax|secret|sexyback|story|tada|tmyk|trololo|trombone|unix|vuvuzela|what|whoomp|yeah|yodel
$0
endsnippet

snippet flowdock "Send a message to a flowdock" b
- name: $1
	flowdock:
		type: ${2:inbox|chat}
		token: ${3:# API token.}
		msg: ${4:# Content of the message}
		# from_name: # (inbox only) Name of the message sender
		# from_address: # (inbox only - required) Email address of the message sender
		# tags: # tags of the message, separated by commas
		# external_user_name: # (chat only - required) Name of the "user" sending the message
		# project: # (inbox only) Human readable identifier for more detailed message categorization
		# source: # (inbox only - required) Human readable identifier of the application that uses the Flowdock API
		# link: # (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.
		# reply_to: # (inbox only) Email address for replies
		# subject: # (inbox only - required) Subject line of the message
		# validate_certs: #yes|no
$0
endsnippet

snippet sendgrid "Sends an email with the SendGrid API" b
- name: $1
	sendgrid:
		from_address: ${2:# the address in the "from" field for the email}
		subject: ${3:# the desired subject for the email}
		to_addresses: ${4:# a list with one or more recipient email addresses}
		# username: # username for logging into the SendGrid account.
		# from_name: # the name you want to appear in the from field, i.e 'John Doe'
		# cc: # a list of email addresses to cc
		# bcc: # a list of email addresses to bcc
		# headers: # a dict to pass on as headers
		# html_body: no
		# api_key: # sendgrid API key to use instead of username/password
		# password: # password that corresponds to the username
		# attachments: # a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)
$0
endsnippet

snippet cisco_spark "Send a message to a Cisco Spark Room or Individual." b
- name: $1
	cisco_spark:
		personal_token: ${2:# Your personal access token required to validate the Spark API.}
		message: ${3:# The message you would like to send.}
		recipient_id: ${4:# The unique identifier associated with the supplied C(recipient_type).}
		recipient_type: ${5:roomId|toPersonEmail|toPersonId}
		# message_type: #text|markdown
$0
endsnippet

snippet twilio "Sends a text message to a mobile phone through Twilio." b
- name: $1
	twilio:
		from_number: ${2:# t}
		msg: ${3:# t}
		auth_token: ${4:# u}
		to_number: ${5:# o}
		account_sid: ${6:# u}
		# media_url: # a
$0
endsnippet

snippet pushbullet "Sends notifications to Pushbullet" b
- name: $1
	pushbullet:
		title: ${2:# Title of the notification.}
		api_key: ${3:# Push bullet API token}
		# body: # Body of the notification, e.g. Details of the fault you're alerting.
		# device: # The device NAME you wish to send a push notification, as seen on the Pushbullet main page.
		# push_type: #note|link
		# channel: # The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.
$0
endsnippet

snippet say "Makes a computer to speak." b
- name: $1
	say:
		msg: ${2:# W}
		# voice: # W
$0
endsnippet

snippet slack "Send Slack notifications" b
- name: $1
	slack:
		token: ${2:# Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.}
		# username: Ansible
		# domain: # Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.
		# attachments: # Define a list of attachments. This list mirrors the Slack JSON API.
		# color: #normal|good|warning|danger
		# icon_url: # Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))
		# parse: full|none
		# icon_emoji: # Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)
		# link_names: #1|0
		# msg: # Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.
		# validate_certs: #yes|no
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(token).
$0
endsnippet

snippet rocketchat "Send notifications to Rocket Chat" b
- name: $1
	rocketchat:
		domain: ${2:# The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))}
		token: ${3:# Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.}
		# username: Ansible
		# protocol: http|#https
		# attachments: # Define a list of attachments.
		# color: #normal|good|warning|danger
		# icon_url: https://www.ansible.com/favicon.ico
		# icon_emoji: # Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)
		# link_names: #1|0
		# msg: # Message to be sent.
		# validate_certs: #yes|no
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specified during the creation of webhook.
$0
endsnippet

snippet logentries_msg "Send a message to logentries." b
- name: $1
	logentries_msg:
		msg: ${2:# The message body.}
		token: ${3:# Log token.}
		# api: data.logentries.com
		# port: 80
$0
endsnippet

snippet catapult "Send a sms / mms using the catapult bandwidth api" b
- name: $1
	catapult:
		src: ${2:# One of your catapult telephone numbers the message should come from (must be in E.164 format, like C(+19195551212)).}
		user_id: ${3:# User Id from Api account page.}
		api_secret: ${4:# Api Secret from Api account page.}
		dest: ${5:# The phone number or numbers the message should be sent to (must be in E.164 format, like C(+19195551212)).}
		api_token: ${6:# Api Token from Api account page.}
		msg: ${7:# The contents of the text message (must be 2048 characters or less).}
		# media: # For MMS messages, a media url to the location of the media to be sent with the message.
$0
endsnippet

snippet wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: 255.255.255.255
		# port: 7
$0
endsnippet

snippet imc_rest "Manage Cisco IMC hardware through its REST API" b
- name: $1
	imc_rest:
		hostname: ${2:# IP Address or hostname of Cisco IMC, resolvable by Ansible control host.}
		# username: admin
		# protocol: http|#https
		# content: # When used instead of C(path), sets the content of the API requests directly.
		# timeout: 60
		# path: # Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.
		# password: password
		# validate_certs: yes
$0
endsnippet

snippet stacki_host "Add or remove host to stacki front-end" b
- name: $1
	stacki_host:
		name: ${2:# Name of the host to be added to Stacki.}
		stacki_user: ${3:# Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.}
		stacki_endpoint: ${4:# URL for the Stacki API Endpoint.}
		stacki_password: ${5:# Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.}
		# prim_intf_ip: # IP Address for the primary network interface.
		# prim_intf: # Name of the primary network interface.
		# force_install: # Set value to True to force node into install state if it already exists in stacki.
		# prim_intf_mac: # MAC Address for the primary PXE boot network interface.
$0
endsnippet

snippet oneview_san_manager "Manage OneView SAN Manager resources" b
- name: $1
	oneview_san_manager:
		data: ${2:# List with SAN Manager properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: #present|absent|connection_information_set
		# validate_etag: true|false
$0
endsnippet

snippet oneview_fcoe_network "Manage OneView FCoE Network resources" b
- name: $1
	oneview_fcoe_network:
		data: ${2:# List with FCoE Network properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: #present|absent
		# validate_etag: true|false
$0
endsnippet

snippet oneview_fcoe_network_facts "Retrieve the facts about one or more of the OneView FCoE Networks" b
- name: $1
	oneview_fcoe_network_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # FCoE Network name.
$0
endsnippet

snippet oneview_datacenter_facts "Retrieve facts about the OneView Data Centers" b
- name: $1
	oneview_datacenter_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Data Center name.
		# options: # Retrieve additional facts. Options available: 'visualContent'.
$0
endsnippet

snippet oneview_enclosure_facts "Retrieve facts about one or more Enclosures" b
- name: $1
	oneview_enclosure_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Enclosure name.
		# options: # List with options to gather additional facts about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters.
$0
endsnippet

snippet oneview_san_manager_facts "Retrieve facts about one or more of the OneView SAN Managers" b
- name: $1
	oneview_san_manager_facts:
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# provider_display_name: # Provider Display Name.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_logical_interconnect_group "Manage OneView Logical Interconnect Group resources" b
- name: $1
	oneview_logical_interconnect_group:
		data: ${2:# List with the Logical Interconnect Group properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: absent|#present
		# validate_etag: true|false
$0
endsnippet

snippet oneview_ethernet_network_facts "Retrieve the facts about one or more of the OneView Ethernet Networks" b
- name: $1
	oneview_ethernet_network_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Ethernet Network name.
		# options: # List with options to gather additional facts about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).
$0
endsnippet

snippet oneview_logical_interconnect_group_facts "Retrieve facts about one or more of the OneView Logical Interconnect Groups" b
- name: $1
	oneview_logical_interconnect_group_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Logical Interconnect Group name.
$0
endsnippet

snippet oneview_network_set "Manage HPE OneView Network Set resources" b
- name: $1
	oneview_network_set:
		data: ${2:# List with the Network Set properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: #present|absent
		# validate_etag: true|false
$0
endsnippet

snippet oneview_fc_network "Manage OneView Fibre Channel Network resources." b
- name: $1
	oneview_fc_network:
		data: ${2:# List with the Fibre Channel Network properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: present|absent
		# validate_etag: true|false
$0
endsnippet

snippet oneview_ethernet_network "Manage OneView Ethernet Network resources" b
- name: $1
	oneview_ethernet_network:
		data: ${2:# List with Ethernet Network properties.}
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# state: #present|absent|default_bandwidth_reset
		# validate_etag: true|false
$0
endsnippet

snippet oneview_network_set_facts "Retrieve facts about the OneView Network Sets" b
- name: $1
	oneview_network_set_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Network Set name.
		# options: # List with options to gather facts about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.
$0
endsnippet

snippet oneview_fc_network_facts "Retrieve the facts about one or more of the OneView Fibre Channel Networks" b
- name: $1
	oneview_fc_network_facts:
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# name: # Fibre Channel Network name.
$0
endsnippet

snippet katello "Manage Katello Resources" b
- name: $1
	katello:
		username: ${2:# Username on Foreman server.}
		password: ${3:# Password for user accessing Foreman server.}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description).}
		server_url: ${5:# URL of Foreman server.}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host).}
$0
endsnippet

snippet foreman "Manage Foreman Resources" b
- name: $1
	foreman:
		username: ${2:# Username on Foreman server.}
		password: ${3:# Password for user accessing Foreman server.}
		params: ${4:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description).}
		server_url: ${5:# URL of Foreman server.}
		entity: ${6:# The Foreman resource that the action will be performed on (e.g. organization, host).}
$0
endsnippet

snippet hpilo_boot "Boot system using specific media through HP iLO interface" b
- name: $1
	hpilo_boot:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# force: yes|no
		# media: cdrom|floppy|hdd|#network|normal|usb
		# image: # The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename
		# ssl_version: SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2
		# state: boot_always|#boot_once|connect|disconnect|no_boot|poweroff
		# login: Administrator
		# password: admin
$0
endsnippet

snippet hpilo_facts "Gather facts through an HP iLO interface" b
- name: $1
	hpilo_facts:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# password: admin
		# ssl_version: SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2
		# login: Administrator
$0
endsnippet

snippet hponcfg "Configure HP iLO interface using hponcfg" b
- name: $1
	hponcfg:
		path: ${2:# The XML file as accepted by hponcfg.}
		# executable: hponcfg
		# minfw: # The minimum firmware level needed.
		# verbose: no
$0
endsnippet

snippet ucs_vsans "Configures VSANs on Cisco UCS Manager" b
- name: $1
	ucs_vsans:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		vlan_id: ${3:# The unique string identifier assigned to the VLAN used for Fibre Channel connections.}
		vsan_id: ${4:# The unique identifier assigned to the VSAN.}
		hostname: ${5:# IP address or hostname of Cisco UCS Manager.}
		name: ${6:# The name assigned to the VSAN.}
		# username: admin
		# fc_zoning: #disabled|enabled
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# fabric: #common|A|B
		# use_proxy: yes
		# state: #present|absent
$0
endsnippet

snippet ucs_lan_connectivity "Configures LAN Connectivity Policies on Cisco UCS Manager" b
- name: $1
	ucs_lan_connectivity:
		hostname: ${2:# IP address or hostname of Cisco UCS Manager.}
		password: ${3:# Password for Cisco UCS Manager authentication.}
		name: ${4:# The name of the LAN Connectivity Policy.}
		# username: admin
		# use_proxy: yes
		# description: # A description of the LAN Connectivity Policy.
		# org_dn: org-root
		# vnic_list: # List of vNICs used by the LAN Connectivity Policy.
		# state: #present|absent
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
$0
endsnippet

snippet ucs_san_connectivity "Configures SAN Connectivity Policies on Cisco UCS Manager" b
- name: $1
	ucs_san_connectivity:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		name: ${3:# The name of the SAN Connectivity Policy.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		# username: admin
		# vhba_list: # List of vHBAs used by the SAN Connectivity Policy.
		# description: # A description of the policy.
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_proxy: yes
		# org_dn: org-root
		# state: #present|absent
		# wwnn_pool: default
$0
endsnippet

snippet ucs_wwn_pool "Configures WWNN or WWPN pools on Cisco UCS Manager" b
- name: $1
	ucs_wwn_pool:
		hostname: ${2:# IP address or hostname of Cisco UCS Manager.}
		purpose: ${3:node|port}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		name: ${5:# The name of the World Wide Node Name (WWNN) or World Wide Port Name (WWPN) pool.}
		# username: admin
		# use_proxy: yes
		# description: # A description of the WWNN or WWPN pool.
		# last_addr: # The last initiator in the Worlde Wide Name (WWN) block.
		# org_dn: org-root
		# first_addr: # The first initiator in the World Wide Name (WWN) block.
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# state: #present|absent
		# use_ssl: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# order: #default|sequential
$0
endsnippet

snippet ucs_vhba_template "Configures vHBA templates on Cisco UCS Manager" b
- name: $1
	ucs_vhba_template:
		hostname: ${2:# IP address or hostname of Cisco UCS Manager.}
		name: ${3:# The name of the virtual HBA template.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# username: admin
		# use_proxy: yes
		# redundancy_type: #none|primary|secondary
		# fabric: #A|B
		# stats_policy: default
		# org_dn: org-root
		# template_type: #initial-template|updating-template
		# max_data: 2048
		# state: #present|absent
		# wwpn_pool: default
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# pin_group: # The SAN pin group that is associated with vHBAs created from this template.
		# use_ssl: yes
		# qos_policy: # The QoS policy that is associated with vHBAs created from this template.
		# vsan: default
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# description: # A user-defined description of the template.
$0
endsnippet

snippet ucs_vlans "Configures VLANs on Cisco UCS Manager" b
- name: $1
	ucs_vlans:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		id: ${3:# The unique string identifier assigned to the VLAN.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		name: ${5:# The name assigned to the VLAN.}
		# username: admin
		# sharing: #none|primary|isolated|community
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# fabric: #common|A|B
		# use_proxy: yes
		# multicast_policy: 
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# state: #present|absent
		# native: #no|yes
$0
endsnippet

snippet ucs_vnic_template "Configures vNIC templates on Cisco UCS Manager" b
- name: $1
	ucs_vnic_template:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		name: ${3:# The name of the vNIC template.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		# username: admin
		# redundancy_type: #none|primary|secondary
		# cdn_name: # CDN Name used when cdn_source is set to user-defined.
		# stats_policy: default
		# network_control_policy: # The network control policy that vNICs created from this vNIC template should use.
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# cdn_source: #vnic-name|user-defined
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# description: # A user-defined description of the vNIC template.
		# use_proxy: yes
		# fabric: #A|B|A-B|B-A
		# vlans_list: # List of VLANs used by the vNIC template.
		# org_dn: org-root
		# mtu: 1500
		# template_type: #initial-template|updating-template
		# state: #present|absent
		# mac_pool: # The MAC address pool that vNICs created from this vNIC template should use.
		# target: adapter
		# pin_group: # The LAN pin group that vNICs created from this vNIC template should use.
		# qos_policy: # The quality of service (QoS) policy that vNICs created from this vNIC template should use.
		# peer_redundancy_template: # The Peer Redundancy Template.
$0
endsnippet

snippet ucs_ip_pool "Configures IP address pools on Cisco UCS Manager" b
- name: $1
	ucs_ip_pool:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		name: ${3:# The name of the IP address pool.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		# ipv6_primary_dns: ::
		# username: admin
		# default_gw: 0.0.0.0
		# org_dn: org-root
		# subnet_mask: 255.255.255.0
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# ipv6_first_addr: # The first IPv6 address in the IPv6 addresses block.
		# use_ssl: yes
		# ipv6_secondary_dns: ::
		# secondary_dns: 0.0.0.0
		# descrption: # The user-defined description of the IP address pool.
		# use_proxy: yes
		# last_addr: # The last IPv4 address in the IPv4 addresses block.
		# primary_dns: 0.0.0.0
		# state: #present|absent
		# first_addr: # The first IPv4 address in the IPv4 addresses block.
		# order: #default|sequential
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# ipv6_last_addr: # The last IPv6 address in the IPv6 addresses block.
		# ipv6_prefix: 64
		# ipv6_default_gw: ::
$0
endsnippet

snippet ucs_mac_pool "Configures MAC address pools on Cisco UCS Manager" b
- name: $1
	ucs_mac_pool:
		password: ${2:# Password for Cisco UCS Manager authentication.}
		name: ${3:# The name of the MAC pool.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		# username: admin
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
		# use_ssl: yes
		# descrption: # A description of the MAC pool.
		# use_proxy: yes
		# last_addr: # The last MAC address in the block of addresses.
		# org_dn: org-root
		# first_addr: # The first MAC address in the block of addresses.
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# state: #present|absent
		# order: #default|sequential
$0
endsnippet

snippet ipmi_boot "Management of order of boot devices" b
- name: $1
	ipmi_boot:
		bootdev: ${2:network -- Request network boot|floppy -- Boot from floppy|hd -- Boot from hard drive|safe -- Boot from hard drive, requesting 'safe mode'|optical -- boot from CD/DVD/BD drive|setup -- Boot into setup utility|default -- remove any IPMI directed boot device request}
		name: ${3:# Hostname or ip address of the BMC.}
		user: ${4:# Username to use to connect to the BMC.}
		password: ${5:# Password to connect to the BMC.}
		# persistent: no
		# uefiboot: no
		# state: present -- Request system turn on|absent -- Request system turn on
		# port: 623
$0
endsnippet

snippet ipmi_power "Power management for machine" b
- name: $1
	ipmi_power:
		state: ${2:on -- Request system turn on|off -- Request system turn off without waiting for OS to shutdown|shutdown -- Have system request OS proper shutdown|reset -- Request system reset without waiting for OS|boot -- If system is off, then 'on', else 'reset'}
		name: ${3:# Hostname or ip address of the BMC.}
		password: ${4:# Password to connect to the BMC.}
		user: ${5:# Username to use to connect to the BMC.}
		# timeout: 300
		# port: 623
$0
endsnippet

snippet manageiq_tags "Management of resource tags in ManageIQ." b
- name: $1
	manageiq_tags:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		resource_name: ${3:# the relevant resource name in manageiq}
		resource_type: ${4:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
		# state: absent|#present|list
		# tags: # tags - list of dictionaries, each includes 'name' and 'category' keys.
$0
endsnippet

snippet manageiq_user "Management of users in ManageIQ." b
- name: $1
	manageiq_user:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		userid: ${3:# The unique userid in manageiq, often mentioned as username.}
		# update_password: #always|on_create
		# group: # The name of the group to which the user belongs.
		# name: # The users' full name.
		# password: # The users' password.
		# state: absent|#present
		# email: # The users' E-mail address.
$0
endsnippet

snippet manageiq_policies "Management of resource policy_profiles in ManageIQ." b
- name: $1
	manageiq_policies:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		resource_name: ${3:# the name of the resource to which the profile should be [un]assigned}
		resource_type: ${4:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
		# state: absent|#present|list
		# policy_profiles: # list of dictionaries, each includes the policy_profile 'name' key.
$0
endsnippet

snippet manageiq_provider "Management of provider in ManageIQ." b
- name: $1
	manageiq_provider:
		name: ${2:# T}
		manageiq_connection: ${3:# ManageIQ connection configuration information.}
		type: ${4:Openshift|Amazon|oVirt|VMware|Azure|Director|OpenStack|GCE}
		# ssh_keypair: # S
		# host_default_vnc_port_start: # T
		# tenant_mapping_enabled: no
		# metrics: # M
		# azure_tenant_id: # T
		# provider_region: # T
		# subscription: # M
		# zone: default
		# host_default_vnc_port_end: # T
		# alerts: # A
		# project: # G
		# state: absent|#present
		# provider: # D
		# api_version: v2|v3
$0
endsnippet

snippet manageiq_alert_profiles "Configuration of alert profiles for ManageIQ" b
- name: $1
	manageiq_alert_profiles:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		# name: # The unique alert profile name in ManageIQ.
		# notes: # Optional notes for this profile
		# alerts: # List of alert descriptions to assign to this profile.
		# state: absent|#present
		# resource_type: Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer
$0
endsnippet

snippet manageiq_alerts "Configuration of alerts in ManageIQ" b
- name: $1
	manageiq_alerts:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		# state: absent|#present
		# description: # The unique alert description in ManageIQ.
		# expression: # The alert expression for ManageIQ.
		# expression_type: #hash|miq
		# enabled: # Enable or disable the alert. Required if state is "present".
		# options: # Additional alert options, such as notification type and frequency
		# resource_type: Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer
$0
endsnippet

snippet nginx_status_facts "Retrieve nginx status facts." b
- name: $1
	nginx_status_facts:
		url: ${2:# URL of the nginx status.}
		# timeout: 10
$0
endsnippet

snippet jenkins_job_facts "Get facts about Jenkins jobs" b
- name: $1
	jenkins_job_facts:
		# url: http://localhost:8080
		# token: # API token used to authenticate alternatively to C(password).
		# name: # Exact name of the Jenkins job to fetch facts about.
		# color: # Only fetch jobs with the given status color.
		# glob: # A shell glob of Jenkins job names to fetch facts about.
		# password: # Password to authenticate with the Jenkins server.
		# user: # User to authenticate with the Jenkins server.
$0
endsnippet

snippet supervisorctl "Manage the state of a program or group of programs running via supervisord" b
- name: $1
	supervisorctl:
		state: ${2:present|started|stopped|restarted|absent}
		name: ${3:# The name of the supervisord program or group to manage.}
		# username: # username to use for authentication
		# supervisorctl_path: # path to supervisorctl executable
		# password: # password to use for authentication
		# config: # The supervisor configuration file path
		# server_url: # URL on which supervisord server is listening
$0
endsnippet

snippet htpasswd "manage user files for basic authentication" b
- name: $1
	htpasswd:
		path: ${2:# Path to the file that contains the usernames and passwords}
		name: ${3:# User name to add or remove}
		# selevel: s0
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# password: # Password associated with user.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# create: #yes|no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# crypt_scheme: #apr_md5_crypt|des_crypt|ldap_sha1|plaintext
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet jboss "deploy applications to JBoss" b
- name: $1
	jboss:
		deployment: ${2:# The name of the deployment}
		# src: # The remote path of the application ear or war to deploy
		# deploy_path: /var/lib/jbossas/standalone/deployments
		# state: #present|absent
$0
endsnippet

snippet apache2_module "Enables/disables a module of the Apache2 webserver." b
- name: $1
	apache2_module:
		name: ${2:# Name of the module to enable/disable as given to C(a2enmod/a2dismod).}
		# state: #present|absent
		# identifier: # Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending C(_module) to I(name) as well as custom exception for popular modules.
		# force: True|False
		# ignore_configcheck: True|False
$0
endsnippet

snippet letsencrypt "Create SSL certificates with Let's Encrypt" b
- name: $1
	letsencrypt:
		csr: ${2:# File containing the CSR for the new certificate.}
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# terms_agreed: no
		# account_email: # The email address associated with this account.
		# dest: # The destination file for the certificate.
		# validate_certs: yes
		# challenge: #http-01|dns-01|tls-sni-02
		# fullchain_dest: # The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).
		# agreement: # URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).
		# data: # The data to validate ongoing challenges. This must be specified for the second run of the module only.
		# account_key_content: # Content of the Let's Encrypt account RSA or Elliptic Curve key.
		# remaining_days: 10
		# acme_version: #1|2
		# chain_dest: # If specified, the intermediate certificate will be written to this file.
		# account_key_src: # Path to a file containing the Let's Encrypt account RSA or Elliptic Curve key.
$0
endsnippet

snippet taiga_issue "Creates/deletes an issue in a Taiga Project Management Platform" b
- name: $1
	taiga_issue:
		project: ${2:# Name of the project containing the issue. Must exist previously.}
		issue_type: ${3:# The issue type. Must exist previously.}
		subject: ${4:# The issue subject.}
		# status: New
		# severity: Normal
		# tags: []
		# priority: Normal
		# taiga_host: https://api.taiga.io
		# state: #present|absent
		# attachment: # Path to a file to be attached to the issue.
		# attachment_description: 
		# description: 
$0
endsnippet

snippet rundeck_project "Manage Rundeck projects." b
- name: $1
	rundeck_project:
		url: ${2:# Sets the rundeck instance URL.}
		token: ${3:# Sets the token to authenticate against Rundeck API.}
		name: ${4:# Sets the project name.}
		# state: #present|absent
		# api_version: 14
$0
endsnippet

snippet gunicorn "Run gunicorn with various settings." b
- name: $1
	gunicorn:
		app: ${2:# The app module. A name refers to a WSGI callable that should be found in the specified module.}
		# venv: # Path to the virtualenv directory.
		# user: # Switch worker processes to run as this user.
		# config: # Path to the gunicorn configuration file.
		# worker: sync|eventlet|gevent|tornado |gthread|gaiohttp
		# chdir: # Chdir to specified directory before apps loading.
		# pid: # A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn.
$0
endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance" b
- name: $1
	jenkins_script:
		script: ${2:# The groovy script to be executed. This gets passed as a string Template if args is defined.}
		# password: # The password to connect to the jenkins server with.
		# user: # The username to connect to the jenkins server with.
		# timeout: 10
		# url: http://localhost:8080
		# args: # A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).
		# validate_certs: yes
$0
endsnippet

snippet jenkins_job "Manage jenkins jobs" b
- name: $1
	jenkins_job:
		name: ${2:# Name of the Jenkins job.}
		# url: http://localhost:8080
		# enabled: # Whether the job should be enabled or disabled.
		# state: #present|absent
		# token: # API token used to authenticate alternatively to password.
		# user: # User to authenticate with the Jenkins server.
		# password: # Password to authenticate with the Jenkins server.
		# config: # config in XML format.
$0
endsnippet

snippet django_manage "Manages a Django application." b
- name: $1
	django_manage:
		app_path: ${2:# The path to the root of the Django application where B(manage.py) lives.}
		command: ${3:cleanup|collectstatic|flush|loaddata|migrate|runfcgi|syncdb|test|validate}
		# virtualenv: # An optional path to a I(virtualenv) installation to use while running the manage application.
		# settings: # The Python path to the application's settings module, such as 'myapp.settings'.
		# pythonpath: # A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.
		# database: # The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands.
		# apps: # A list of space-delimited apps to target. Used by the 'test' command.
		# cache_table: # The name of the table used for database-backed caching. Used by the 'createcachetable' command.
		# merge: # Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command
		# skip: # Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)
		# link: # Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command
		# fixtures: # A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command.
		# failfast: yes|#no
$0
endsnippet

snippet jira "create and modify issues in a JIRA instance" b
- name: $1
	jira:
		username: ${2:# The username to log-in with.}
		operation: ${3:create|comment|edit|fetch|transition|link}
		password: ${4:# The password to log-in with.}
		uri: ${5:# Base URI for the JIRA instance.}
		# comment: # The comment text to add.
		# description: # The issue description, where appropriate.
		# assignee: # Sets the assignee on create or transition operations. Note not all transitions will allow this.
		# inwardissue: # Set issue from which link will be created.
		# linktype: # Set type of link, when action 'link' selected.
		# issue: # An existing issue key to operate on.
		# fields: # This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.
		# outwardissue: # Set issue to which link will be created.
		# summary: # The issue summary, where appropriate.
		# project: # The project for this operation. Required for issue creation.
		# status: # The desired status; only relevant for the transition operation.
		# timeout: 10
		# issuetype: # The issue type, for issue creation.
		# validate_certs: yes
$0
endsnippet

snippet jenkins_plugin "Add or remove Jenkins plugin" b
- name: $1
	jenkins_plugin:
		name: ${2:# Plugin name.}
		# jenkins_home: /var/lib/jenkins
		# url_password: # The password for use in HTTP basic authentication.
		# group: jenkins
		# url: http://localhost:8080
		# force_basic_auth: no
		# url_username: # The username for use in HTTP basic authentication.
		# updates_url: https://updates.jenkins-ci.org
		# http_agent: ansible-httpget
		# with_dependencies: #yes|no
		# state: absent|#present|pinned|unpinned|enabled|disabled|latest
		# version: # Plugin version number.
		# updates_expiration: 86400
		# mode: 0664
		# timeout: 30
		# owner: jenkins
		# force: no
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# use_proxy: yes
$0
endsnippet

snippet apache2_mod_proxy "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool" b
- name: $1
	apache2_mod_proxy:
		balancer_vhost: ${2:# (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.}
		# tls: true|false
		# member_host: # (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.
		# validate_certs: true|false
		# state: present|absent|enabled|disabled|drained|hot_standby|ignore_errors
		# balancer_url_suffix: /balancer-manager/
$0
endsnippet

snippet deploy_helper "Manages some of the steps common in deploying projects." b
- name: $1
	deploy_helper:
		path: ${2:# the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact.}
		# unfinished_filename: DEPLOY_UNFINISHED
		# keep_releases: 5
		# current_path: current
		# state: #present|finalize|absent|clean|query
		# shared_path: shared
		# releases_path: releases
		# clean: yes
		# release: # the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).
$0
endsnippet

snippet rundeck_acl_policy "Manage Rundeck ACL policies." b
- name: $1
	rundeck_acl_policy:
		name: ${2:# Sets the project name.}
		url: ${3:# Sets the rundeck instance URL.}
		token: ${4:# Sets the token to authenticate against Rundeck API.}
		# project: # Sets the project which receive the ACL policy.
		# policy: # Sets the ACL policy content.
		# state: #present|absent
		# api_version: 14
$0
endsnippet

snippet ejabberd_user "Manages users for ejabberd servers" b
- name: $1
	ejabberd_user:
		username: ${2:# the name of the user to manage}
		host: ${3:# the ejabberd host associated with this username}
		# password: # the password to assign to the username
		# logging: true|false|yes|no
		# state: #present|absent
$0
endsnippet

snippet tower_team "create, update, or destroy Ansible Tower team." b
- name: $1
	tower_team:
		name: ${2:# Name to use for the team.}
		organization: ${3:# Organization the team should be made a member of.}
		# tower_host: # URL to your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_verify_ssl: yes
$0
endsnippet

snippet tower_role "create, update, or destroy Ansible Tower role." b
- name: $1
	tower_role:
		role: ${2:admin|read|member|execute|adhoc|update|use|auditor}
		# credential: # Credential the role acts on.
		# job_template: # The job_template the role acts on.
		# tower_host: # URL to your Tower instance.
		# tower_password: # Password for your Tower instance.
		# project: # Project the role acts on.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# inventory: # Inventory the role acts on.
		# team: # Team that receives the permissions specified by the role.
		# tower_username: # Username for your Tower instance.
		# organization: # Organiation the role acts on.
		# target_team: # Team that the role acts on.
		# tower_verify_ssl: yes
		# user: # User that receives the permissions specified by the role.
$0
endsnippet

snippet tower_inventory "create, update, or destroy Ansible Tower inventory." b
- name: $1
	tower_inventory:
		organization: ${2:# Organization the inventory belongs to.}
		name: ${3:# The name to use for the inventory.}
		# description: # The description to use for the inventory.
		# variables: # Inventory variables. Use '@' to get from file.
		# tower_password: # Password for your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# tower_verify_ssl: yes
		# tower_username: # Username for your Tower instance.
		# tower_host: # URL to your Tower instance.
$0
endsnippet

snippet tower_credential "create, update, or destroy Ansible Tower credential." b
- name: $1
	tower_credential:
		kind: ${2:ssh|vault|net|scm|aws|vmware|satellite6|cloudforms|gce|azure_rm|openstack|rhv|insights|tower}
		name: ${3:# The name to use for the credential.}
		# authorize: no
		# username: # Username for this credential. access_key for AWS.
		# domain: # Domain for openstack type.
		# description: # The description to use for the credential.
		# tower_host: # URL to your Tower instance.
		# vault_password: # Valut password. Use ASK for prompting.
		# team: # Team that should own this credential.
		# tower_config_file: # Path to the Tower config file. See notes.
		# host: # Host for this credential.
		# user: # User that should own this credential.
		# become_password: # Become password. Use ASK for prompting.
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# become_username: # Become username. Use ASK for prompting.
		# password: # Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX.
		# tenant: # Tenant ID for azure_rm type.
		# subscription: # Subscription ID for azure_rm type.
		# become_method: #None|sudo|su|pbrun|pfexec|pmrun
		# tower_verify_ssl: yes
		# secret: # Secret token for azure_rm type.
		# project: # Project that should for this credential.
		# state: #present|absent
		# client: # Client or application ID for azure_rm type.
		# ssh_key_data: # Path to SSH private key.
		# ssh_key_unlock: # Unlock password for ssh_key. Use ASK for prompting.
		# organization: # Organization that should own the credential.
		# authorize_password: # Password for net credentials that require authroize.
$0
endsnippet

snippet tower_label "create, update, or destroy Ansible Tower label." b
- name: $1
	tower_label:
		name: ${2:# Name to use for the label.}
		organization: ${3:# Organization the label should be applied to.}
		# tower_host: # URL to your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_verify_ssl: yes
$0
endsnippet

snippet tower_group "create, update, or destroy Ansible Tower group." b
- name: $1
	tower_group:
		inventory: ${2:# Inventory the group should be made a member of.}
		name: ${3:# The name to use for the group.}
		# credential: # Credential to use for the group.
		# source_vars: # Override variables from source with variables from this field.
		# source_script: # Inventory script to be used when group type is "custom".
		# update_on_launch: no
		# overwrite_vars: # Override vars in child groups and hosts with those from external source.
		# source_regions: # Regions for cloud provider.
		# tower_config_file: # Path to the Tower config file. See notes.
		# variables: # Variables to use for the group, use '@' for a file.
		# description: # The description to use for the group.
		# instance_filters: # Comma-separated list of filter expressions for matching hosts.
		# tower_password: # Password for your Tower instance.
		# source: manual|file|ec2|rax|vmware|gce|azure|azure_rm|openstack|satellite6|cloudforms|custom
		# state: #present|absent
		# group_by: # Limit groups automatically created from inventory source.
		# tower_verify_ssl: yes
		# tower_username: # Username for your Tower instance.
		# tower_host: # URL to your Tower instance.
		# overwrite: no
$0
endsnippet

snippet tower_job_cancel "Cancel an Ansible Tower Job." b
- name: $1
	tower_job_cancel:
		job_id: ${2:# ID of the job to cancel}
		# tower_host: # URL to your Tower instance.
		# fail_if_not_running: no
		# tower_config_file: # Path to the Tower config file. See notes.
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_verify_ssl: yes
$0
endsnippet

snippet tower_host "create, update, or destroy Ansible Tower host." b
- name: $1
	tower_host:
		name: ${2:# The name to use for the host.}
		inventory: ${3:# Inventory the host should be made a member of.}
		# description: # The description to use for the host.
		# variables: # Variables to use for the host. Use '@' for a file.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# tower_verify_ssl: yes
		# enabled: yes
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
$0
endsnippet

snippet tower_user "create, update, or destroy Ansible Tower user." b
- name: $1
	tower_user:
		username: ${2:# The username of the user.}
		email: ${3:# Email address of the user.}
		# superuser: no
		# first_name: # First name of the user.
		# last_name: # Last name of the user.
		# tower_host: # URL to your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# auditor: no
		# tower_verify_ssl: yes
		# tower_username: # Username for your Tower instance.
		# password: # Password of the user.
$0
endsnippet

snippet tower_organization "create, update, or destroy Ansible Tower organizations" b
- name: $1
	tower_organization:
		name: ${2:# Name to use for the organization.}
		# tower_host: # URL to your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_verify_ssl: yes
		# description: # The description to use for the organization.
$0
endsnippet

snippet tower_job_list "List Ansible Tower jobs." b
- name: $1
	tower_job_list:
		# status: pending|waiting|running|error|failed|canceled|successful
		# tower_host: # URL to your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# all_pages: no
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
		# query: # Query used to further filter the list of jobs. {"foo":"bar"} will be passed at ?foo=bar
		# page: # Page number of the results to fetch.
$0
endsnippet

snippet tower_job_launch "Launch an Ansible Job." b
- name: $1
	tower_job_launch:
		job_template: ${2:# Name of the job_template to use.}
		# credential: # Credential to use for job, only used if prompt for credential is set.
		# use_job_endpoint: no
		# tags: # Specific tags to use for from playbook.
		# extra_vars: # Extra_vars to use for the job_template. Prepend '@' if a file.
		# job_explanation: # Job explanation field.
		# tower_password: # Password for your Tower instance.
		# job_type: run|check|scan
		# tower_config_file: # Path to the Tower config file. See notes.
		# limit: # Limit to use for the job_template.
		# inventory: # Inventory to use for the job, only used if prompt for inventory is set.
		# tower_verify_ssl: yes
		# tower_username: # Username for your Tower instance.
		# tower_host: # URL to your Tower instance.
$0
endsnippet

snippet tower_project "create, update, or destroy Ansible Tower projects" b
- name: $1
	tower_project:
		name: ${2:# Name to use for the project.}
		# scm_branch: # The branch to use for the scm resource.
		# tower_password: # Password for your Tower instance.
		# tower_host: # URL to your Tower instance.
		# scm_credential: # Name of the credential to use with this scm resource.
		# scm_clean: no
		# scm_url: # URL of scm resource.
		# scm_delete_on_update: no
		# tower_config_file: # Path to the Tower config file. See notes.
		# state: #present|absent
		# local_path: # The server playbook directory for manual projects.
		# scm_type: #manual|git|hg|svn
		# scm_update_on_launch: no
		# tower_username: # Username for your Tower instance.
		# organization: # Primary key of organization for project.
		# tower_verify_ssl: yes
		# description: # Description to use for the project.
$0
endsnippet

snippet tower_job_template "create, update, or destroy Ansible Tower job_template." b
- name: $1
	tower_job_template:
		job_type: ${2:run|check|scan}
		playbook: ${3:# Playbook to use for the job_template.}
		name: ${4:# Name to use for the job_template.}
		project: ${5:# Project to use for the job_template.}
		# network_credential: # The network_credential to use for the job_template.
		# description: # Description to use for the job_template.
		# tower_config_file: # Path to the Tower config file. See notes.
		# tower_host: # URL to your Tower instance.
		# tower_password: # Password for your Tower instance.
		# ask_job_type: no
		# tower_username: # Username for your Tower instance.
		# skip_tags: # The skip_tags to use for the job_template.
		# ask_inventory: no
		# host_config_key: # Allow provisioning callbacks using this host config key.
		# ask_tags: no
		# machine_credential: # Machine_credential to use for the job_template.
		# tower_verify_ssl: yes
		# ask_credential: no
		# job_tags: # The job_tags to use for the job_template.
		# verbosity: verbose|debug
		# state: #present|absent
		# ask_extra_vars: no
		# extra_vars_path: # Path to the extra_vars yaml file.
		# inventory: # Inventory to use for the job_template.
		# limit: # A host pattern to further constrain the list of hosts managed or affected by the playbook
		# forks: # The number of parallel or simultaneous processes to use while executing the playbook.
		# cloud_credential: # Cloud_credential to use for the job_template.
		# become_enabled: no
$0
endsnippet

snippet tower_job_wait "Wait for Ansible Tower job to finish." b
- name: $1
	tower_job_wait:
		job_id: ${2:# ID of the job to monitor.}
		# min_interval: 1
		# tower_host: # URL to your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
		# max_interval: 30
		# timeout: # Maximum time in seconds to wait for a job to finish.
		# tower_password: # Password for your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_verify_ssl: yes
$0
endsnippet

snippet dellos10_config "Manage Dell EMC Networking OS10 configuration sections" b
- name: $1
	dellos10_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# update: #merge|check
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# save: yes|no
		# backup: no
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet dellos10_facts "Collect facts from remote devices running Dell EMC Networking OS10" b
- name: $1
	dellos10_facts:
		# gather_subset: !config
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos10_command "Run commands on remote devices running Dell OS10" b
- name: $1
	dellos10_command:
		commands: ${2:# List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet aireos_config "Manage Cisco WLC configurations" b
- name: $1
	aireos_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured. The commands must be the exact same commands as found in the device run-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# diff_against: intended|running
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# provider: # A dict object containing connection details.
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# save: no
		# backup: no
		# match: #line|none
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
$0
endsnippet

snippet aireos_command "Run commands on remote devices running Cisco WLC" b
- name: $1
	aireos_command:
		commands: ${2:# List of commands to send to the remote aireos device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet ce_vxlan_gateway "Manages gateway for the VXLAN network on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_gateway:
		# dfs_source_vpn: # Specifies the name of a VPN instance bound to a DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# dfs_id: # Specifies the ID of a DFS group. The value must be 1.
		# arp_direct_route: enable|disable
		# dfs_peer_vpn: # Specifies the name of the VPN instance that is associated with all-active gateway peer. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# vbdif_name: # Full name of VBDIF interface, i.e. Vbdif100.
		# vpn_vni: # Specifies a VNI ID. Binds a VXLAN network identifier (VNI) to a virtual private network (VPN) instance. The value is an integer ranging from 1 to 16000000.
		# vbdif_mac: # Specifies a MAC address for a VBDIF interface. The value is in the format of H-H-H. Each H is a 4-digit hexadecimal number, such as C(00e0) or C(fc01). If an H contains less than four digits, 0s are added ahead. For example,  C(e0) is equal to C(00e0). A MAC address cannot be all 0s or 1s or a multicast MAC address.
		# vbdif_bind_vpn: # Specifies the name of the VPN instance that is associated with the interface. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# dfs_source_ip: # Specifies the IPv4 address bound to a DFS group. The value is in dotted decimal notation.
		# dfs_udp_port: # Specifies the UDP port number of the DFS group. The value is an integer that ranges from 1025 to 65535.
		# arp_distribute_gateway: enable|disable
		# state: #present|absent
		# dfs_all_active: enable|disable
		# vpn_instance: # Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# dfs_peer_ip: # Configure the IP address of an all-active gateway peer. The value is in dotted decimal notation.
$0
endsnippet

snippet ce_stp "Manages STP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_stp:
		# loop_protection: enable|disable
		# tc_protection_threshold: # Set the maximum number of TC BPDUs that the MSTP can handle. The value is an integer ranging from 1 to 255. The default value is 1 on the switch.
		# bpdu_filter: enable|disable
		# stp_converge: fast|normal
		# stp_mode: stp|rstp|mstp
		# bpdu_protection: enable|disable
		# root_protection: enable|disable
		# state: #present|absent
		# cost: # Set the path cost of the current port. The default instance is 0.
		# stp_enable: enable|disable
		# interface: # Interface name. If the value is C(all), will apply configuration to all interfaces. if the value is a special name, only support input the full name.
		# tc_protection: enable|disable
		# edged_port: enable|disable
		# tc_protection_interval: # Set the time the MSTP device takes to handle the maximum number of TC BPDUs and immediately refresh forwarding entries. The value is an integer ranging from 1 to 600, in seconds.
$0
endsnippet

snippet ce_info_center_debug "Manages information center debug configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_debug:
		# debug_enable: #no_use|true|false
		# state: #present|absent
		# debug_level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# channel_id: # Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# module_name: # Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
		# debug_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
$0
endsnippet

snippet ce_netconf "Run an arbitrary netconf command on HUAWEI CloudEngine switches." b
- name: $1
	ce_netconf:
		rpc: ${2:get|edit-config|execute-action|execute-cli}
		cfg_xml: ${3:# The config xml string.}
$0
endsnippet

snippet ce_snmp_location "Manages SNMP location configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_location:
		location: ${2:# Location information.}
		# state: #present|absent
$0
endsnippet

snippet ce_netstream_export "Manages netstream export on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_export:
		type: ${2:ip|vxlan}
		# bgp_nexthop: enable|#disable
		# host_port: # Specifies the destination UDP port number of the exported packets. The value is an integer that ranges from 1 to 65535.
		# source_ip: # Specifies source address which can be IPv6 or IPv4 of the exported NetStream packet.
		# host_ip: # Specifies destination address which can be IPv6 or IPv4 of the exported NetStream packet.
		# as_option: origin|peer
		# state: #present|absent
		# version: 5|9
		# host_vpn: # Specifies the VPN instance of the exported packets carrying flow statistics. Ensure the VPN instance has been created on the device.
$0
endsnippet

snippet ce_bgp_neighbor "Manages BGP peer configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor:
		remote_as: ${2:# AS number of a peer. The value is a string of 1 to 11 characters.}
		vrf_name: ${3:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		peer_addr: ${4:# Connection address of a peer, which can be an IPv4 or IPv6 address.}
		# prepend_global_as: #no_use|true|false
		# ebgp_max_hop: # Maximum number of hops in an indirect EBGP connection. The value is an ranging from 1 to 255.
		# is_ignore: #no_use|true|false
		# prepend_fake_as: #no_use|true|false
		# fake_as: # Fake AS number that is specified for a local peer. The value is a string of 1 to 11 characters.
		# is_single_hop: #no_use|true|false
		# conventional: #no_use|true|false
		# hold_time: # Specify the Hold time of a peer or peer group. The value is 0 or an integer ranging from 3 to 65535.
		# tx_interval: # Specify the minimum interval at which BFD packets are sent. The value is an integer ranging from 50 to 1000, in milliseconds.
		# pswd_cipher_text: # The character string in a password identifies the contents of the password, spaces not supported. The value is a string of 1 to 255 characters.
		# local_if_name: # Name of a source interface that sends BGP packets. The value is a string of 1 to 63 characters.
		# rx_interval: # Specify the minimum interval at which BFD packets are received. The value is an integer ranging from 50 to 1000, in milliseconds.
		# state: #present|absent
		# dual_as: #no_use|true|false
		# connect_mode: # The value can be Connect-only, Listen-only, or Both.
		# description: # Description of a peer, which can be letters or digits. The value is a string of 1 to 80 characters.
		# is_log_change: #no_use|true|false
		# keep_alive_time: # Specify the Keepalive time of a peer or peer group. The value is an integer ranging from 0 to 21845. The default value is 60.
		# key_chain_name: # Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string of 1 to 47 case-insensitive characters.
		# conn_retry_time: # ConnectRetry interval. The value is an integer ranging from 1 to 65535.
		# min_hold_time: # Specify the Min hold time of a peer or peer group.
		# multiplier: # Specify the detection multiplier. The default value is 3. The value is an integer ranging from 3 to 50.
		# valid_ttl_hops: # Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. The value is an integer ranging from 1 to 255.
		# is_bfd_block: #no_use|true|false
		# tcp_MSS: # Maximum TCP MSS value used for TCP connection establishment for a peer. The value is an integer ranging from 176 to 4096.
		# is_bfd_enable: #no_use|true|false
		# route_refresh: #no_use|true|false
		# pswd_type: null|cipher|simple
		# mpls_local_ifnet_disable: #no_use|true|false
$0
endsnippet

snippet ce_eth_trunk "Manages Eth-Trunk interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_eth_trunk:
		trunk_id: ${2:# Eth-Trunk interface number. The value is an integer. The value range depends on the assign forward eth-trunk mode command. When 256 is specified, the value ranges from 0 to 255. When 512 is specified, the value ranges from 0 to 511. When 1024 is specified, the value ranges from 0 to 1023.}
		# state: #present|absent
		# force: no
		# mode: manual|lacp-dynamic|lacp-static
		# members: # List of interfaces that will be managed in a given Eth-Trunk. The interface name must be full name.
		# min_links: # Specifies the minimum number of Eth-Trunk member links in the Up state. The value is an integer ranging from 1 to the maximum number of interfaces that can be added to a Eth-Trunk interface.
		# hash_type: src-dst-ip|src-dst-mac|enhanced|dst-ip|dst-mac|src-ip|src-mac
$0
endsnippet

snippet ce_aaa_server_host "Manages AAA server host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server_host:
		# radius_server_port: # Configured server port for a particular server. The value is an integer ranging from 1 to 65535.
		# hwtacacs_server_ipv6: # Server IPv6 address. Must be a valid unicast IP address. The total length is 128 bits.
		# local_service_type: # The type of local user login through, such as ftp ssh snmp telnet.
		# radius_server_name: # Hostname of configured server. The value is a string of 0 to 255 case-sensitive characters.
		# radius_server_mode: Secondary-server|Primary-server
		# hwtacacs_server_type: Authentication|Authorization|Accounting|Common
		# radius_vpn_name: # Set VPN instance. The value is a string of 1 to 31 case-sensitive characters.
		# radius_server_ipv6: # IPv6 address of configured server. The total length is 128 bits.
		# radius_server_type: Authentication|Accounting
		# hwtacacs_server_ip: # Server IPv4 address. Must be a valid unicast IP address. The value is a string of 0 to 255 characters, in dotted decimal notation.
		# local_user_group: # Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
		# local_user_level: # Login level of a local user. The value is an integer ranging from 0 to 15.
		# radius_server_ip: # IPv4 address of configured server. The value is a string of 0 to 255 characters, in dotted decimal notation.
		# local_ftp_dir: # FTP user directory. The value is a string of 1 to 255 characters.
		# hwtacacs_vpn_name: # VPN instance name.
		# hwtacacs_is_secondary_server: true|false
		# radius_group_name: # RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
		# hwtacacs_template: # Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
		# local_password: # Login password of a user. The password can contain letters, numbers, and special characters. The value is a string of 1 to 255 characters.
		# state: #present|absent
		# hwtacacs_server_host_name: # Hwtacacs server host name.
		# local_user_name: # Name of a local user. The value is a string of 1 to 253 characters.
		# hwtacacs_is_public_net: true|false
$0
endsnippet

snippet ce_static_route "Manages static route configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_static_route:
		prefix: ${2:# Destination ip address of static route.}
		aftype: ${3:v4|v6}
		mask: ${4:# Destination ip mask of static route.}
		# description: # Name of the route. Used with the name parameter on the CLI.
		# pref: # Preference or administrative difference of route (range 1-255).
		# destvrf: # VPN instance of next hop ip address.
		# nhp_interface: # Next hop interface full name of static route.
		# state: #present|absent
		# next_hop: # Next hop address of static route.
		# vrf: # VPN instance of destination ip address.
		# tag: # Route tag value (numeric).
$0
endsnippet

snippet ce_ospf "Manages configuration of an OSPF instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf:
		process_id: ${2:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		# addr: # Specifies the address of the network segment where the interface resides. The value is in dotted decimal notation.
		# area: # Specifies the area ID. The area with the area-id being 0 is a backbone area. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.
		# max_load_balance: # The maximum number of paths for forward packets over multiple paths. Valid value is an integer in the range from 1 to 64.
		# mask: # IP network wildcard bits in decimal format between 0 and 32.
		# auth_mode: none|hmac-sha256|md5|hmac-md5|simple
		# auth_key_id: # Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
		# auth_text_simple: # Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
		# state: #present|absent
		# nexthop_addr: # IPv4 address for configure next-hop address's weight. Valid values are a string, formatted as an IP address.
		# auth_text_md5: # Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
		# nexthop_weight: # Indicates the weight of the next hop. The smaller the value is, the higher the preference of the route is. It is an integer that ranges from 1 to 254.
$0
endsnippet

snippet ce_aaa_server "Manages AAA server global configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server:
		# acct_scheme_name: # Accounting scheme name. The value is a string of 1 to 32 characters.
		# first_author_mode: invalid|local|hwtacacs|if-authenticated|none
		# authen_scheme_name: # Name of an authentication scheme. The value is a string of 1 to 32 characters.
		# author_scheme_name: # Name of an authorization scheme. The value is a string of 1 to 32 characters.
		# radius_server_group: # RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
		# domain_name: # Name of a domain. The value is a string of 1 to 64 characters.
		# first_authen_mode: invalid|local|hwtacacs|radius|none
		# state: #present|absent
		# local_user_group: # Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
		# hwtacas_template: # Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
		# accounting_mode: invalid|hwtacacs|radius|none
$0
endsnippet

snippet ce_reboot "Reboot a HUAWEI CloudEngine switches." b
- name: $1
	ce_reboot:
		# save_config: no
		# confirm: no
$0
endsnippet

snippet ce_vxlan_tunnel "Manages VXLAN tunnel configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_tunnel:
		# vni_id: # Specifies a VXLAN network identifier (VNI) ID. The value is an integer ranging from 1 to 16000000.
		# nve_mode: mode-l2|mode-l3
		# source_ip: # Specifies an IP address for a source VTEP. The value is in dotted decimal notation.
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
		# peer_list_ip: # Specifies the IP address of a remote VXLAN tunnel endpoints (VTEP). The value is in dotted decimal notation.
		# state: #present|absent
		# nve_name: # Specifies the number of an NVE interface. The value ranges from 1 to 2.
		# protocol_type: bgp|null
$0
endsnippet

snippet ce_netstream_template "Manages NetStream template configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_template:
		type: ${2:ip|vxlan}
		# state: #present|absent
		# collect_interface: input|output
		# record_name: # Configure the name of netstream record. The value is a string of 1 to 32 case-insensitive characters.
		# description: # Configure the description of netstream record. The value is a string of 1 to 80 case-insensitive characters.
		# collect_counter: bytes|packets
		# match: destination-address|destination-port|tos|protocol|source-address|source-port
$0
endsnippet

snippet ce_evpn_bgp_rr "Manages RR for the VXLAN Network on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp_rr:
		as_number: ${2:# Specifies the number of the AS, in integer format. The value is an integer that ranges from 1 to 4294967295.}
		# bgp_instance: # Specifies the name of a BGP instance. The value of instance-name can be an integer 1 or a string of 1 to 31.
		# reflect_client: enable|disable
		# peer: # Specifies the IPv4 address or the group name of a peer.
		# bgp_evpn_enable: #enable|disable
		# policy_vpn_target: enable|disable
		# peer_type: group_name|ipv4_address
$0
endsnippet

snippet ce_link_status "Get interface link status on HUAWEI CloudEngine switches." b
- name: $1
	ce_link_status:
		interface: ${2:# For the interface parameter, you can enter C(all) to display information about all interface, an interface type such as C(40GE) to display information about interfaces of the specified type, or full name of an interface such as C(40GE1/0/22) or C(vlanif10) to display information about the specific interface.}
$0
endsnippet

snippet ce_info_center_log "Manages information center log configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_log:
		# log_level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# log_enable: #no_use|true|false
		# log_buff_size: # Specifies the maximum number of logs in the log buffer. The value is an integer that ranges from 0 to 10240. If logbuffer-size is 0, logs are not displayed.
		# channel_id: # Specifies a channel ID. The value is an integer ranging from 0 to 9.
		# state: #present|absent
		# log_buff_enable: #no_use|true|false
		# log_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
		# module_name: # Specifies the name of a module. The value is a module name in registration logs.
$0
endsnippet

snippet ce_snmp_traps "Manages SNMP traps configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_traps:
		# feature_name: aaa|arp|bfd|bgp|cfg|configuration|dad|devm|dhcpsnp|dldp|driver|efm|erps|error-down|fcoe|fei|fei_comm|fm|ifnet|info|ipsg|ipv6|isis|l3vpn|lacp|lcs|ldm|ldp|ldt|lldp|mpls_lspm|msdp|mstp|nd|netconf|nqa|nvo3|openflow|ospf|ospfv3|pim|pim-std|qos|radius|rm|rmon|securitytrap|smlktrap|snmp|ssh|stackmng|sysclock|sysom|system|tcp|telnet|trill|trunk|tty|vbst|vfs|virtual-perception|vrrp|vstm|all
		# interface_type: Ethernet|Eth-Trunk|Tunnel|NULL|LoopBack|Vlanif|100GE|40GE|MTunnel|10GE|GE|MEth|Vbdif|Nve
		# trap_name: # Alarm trap name.
		# port_number: # Source port number.
		# interface_number: # Interface number.
$0
endsnippet

snippet ce_snmp_community "Manages SNMP community configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_community:
		# notify_view: # Mib view name for notification.
		# community_name: # Unique name to identify the community.
		# community_mib_view: # Mib view name.
		# read_view: # Mib view name for read.
		# acl_number: # Access control list number.
		# group_name: # Unique name to identify the SNMPv3 group.
		# write_view: # Mib view name for write.
		# state: #present|absent
		# security_level: noAuthNoPriv|authentication|privacy
		# access_right: read|write
$0
endsnippet

snippet ce_netstream_global "Manages global parameters of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_global:
		interface: ${2:# Netstream global interface.}
		# statistics_direction: inbound|outbound
		# index_switch: #16|32
		# state: #present|absent
		# sampler_interval: # Specifies the netstream sampler interval, length is 1 - 65535.
		# statistics_record: # Specifies the flexible netstream statistic record, length is 1 - 32.
		# sampler_direction: inbound|outbound
		# type: #ip|vxlan
$0
endsnippet

snippet ce_vrrp "Manages VRRP interfaces on HUAWEI CloudEngine devices." b
- name: $1
	ce_vrrp:
		# vrrp_type: normal|member|admin
		# auth_mode: simple|md5|none
		# is_plain: no
		# interface: # Name of an interface. The value is a string of 1 to 63 characters.
		# preempt_timer_delay: # Preemption delay. The value is an integer ranging from 0 to 3600. The default value is 0.
		# gratuitous_arp_interval: # Interval at which gratuitous ARP packets are sent, in seconds. The value ranges from 30 to 1200.The default value is 300.
		# auth_key: # This object is set based on the authentication type. When noAuthentication is specified, the value is empty. When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters in plaintext and displayed as a blank text for security.
		# vrid: present
		# priority: # Configured VRRP priority. The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.
		# recover_delay: # Delay in recovering after an interface goes Up. The delay is used for interface flapping suppression. The value is an integer ranging from 0 to 3600. The default value is 0 seconds.
		# state: #present|absent
		# version: v2|v3
		# virtual_ip: # Virtual IP address. The value is a string of 0 to 255 characters.
		# admin_interface: # Tracked mVRRP interface name. The value is a string of 1 to 63 characters.
		# admin_ignore_if_down: no
		# fast_resume: enable|disable
		# admin_flowdown: no
		# holding_multiplier: # The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.
		# admin_vrid: # Tracked mVRRP ID. The value is an integer ranging from 1 to 255.
		# advertise_interval: # Configured interval between sending advertisements, in milliseconds. Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.
$0
endsnippet

snippet ce_command "Run arbitrary command on HUAWEI CloudEngine devices." b
- name: $1
	ce_command:
		commands: ${2:# The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# retries: 10
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# match: all
		# interval: 1
$0
endsnippet

snippet ce_snmp_user "Manages SNMP user configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_user:
		# priv_key: # The encryption password. Password length 8-255 characters.
		# aaa_local_user: # Unique name to identify the local user.
		# auth_key: # The authentication password. Password length, 8-255 characters.
		# usm_user_name: # Unique name to identify the USM user.
		# acl_number: # Access control list number.
		# auth_protocol: noAuth|md5|sha
		# remote_engine_id: # Remote engine id of the USM user.
		# priv_protocol: noPriv|des56|3des168|aes128|aes192|aes256
		# user_group: # Name of the group where user belongs to.
$0
endsnippet

snippet ce_bfd_session "Manages BFD session configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_session:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# src_addr: # Indicates the source IP address carried in BFD packets.
		# out_if_name: # Specifies the type and number of the interface bound to the BFD session.
		# state: #present|absent
		# dest_addr: # Specifies the peer IP address bound to the BFD session.
		# vrf_name: # Specifies the name of a Virtual Private Network (VPN) instance that is bound to a BFD session. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value _public_ is reserved and cannot be used as the VPN instance name.
		# create_type: static|auto
		# use_default_ip: no
		# addr_type: ipv4
$0
endsnippet

snippet ce_mlag_interface "Manages MLAG interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_interface:
		# eth_trunk_id: # Name of the local M-LAG interface. The value is ranging from 0 to 511.
		# mlag_id: # ID of the M-LAG. The value is an integer that ranges from 1 to 2048.
		# mlag_error_down: enable|disable
		# mlag_system_id: # M-LAG global LACP system MAC address. The value is a string of 0 to 255 characters. The default value is the MAC address of the Ethernet port of MPU.
		# state: #present|absent
		# dfs_group_id: present
		# interface: # Name of the interface that enters the Error-Down state when the peer-link fails. The value is a string of 1 to 63 characters.
		# mlag_priority_id: # M-LAG global LACP system priority. The value is an integer ranging from 0 to 65535. The default value is 32768.
$0
endsnippet

snippet ce_mtu "Manages MTU settings on HUAWEI CloudEngine switches." b
- name: $1
	ce_mtu:
		# interface: # Full name of interface, i.e. 40GE1/0/22.
		# state: #present|absent
		# jumbo_max: # Maximum frame size. The default value is 9216. The value is an integer and expressed in bytes. The value range is 1536 to 12224 for the CE12800 and 1536 to 12288 for ToR switches.
		# jumbo_min: # Non-jumbo frame size threshod. The default value is 1518. The value is an integer that ranges from 1518 to jumbo_max, in bytes.
		# mtu: # MTU for a specific interface. The value is an integer ranging from 46 to 9600, in bytes.
$0
endsnippet

snippet ce_facts "Gets facts about HUAWEI CloudEngine switches." b
- name: $1
	ce_facts:
		# gather_subset: !config
$0
endsnippet

snippet ce_bfd_view "Manages BFD session view configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_view:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# local_discr: # Specifies the local discriminator of a BFD session. The value is an integer that ranges from 1 to 16384.
		# detect_multi: # Specifies the local detection multiplier of a BFD session. The value is an integer that ranges from 3 to 50.
		# remote_discr: # Specifies the remote discriminator of a BFD session. The value is an integer that ranges from 1 to 4294967295.
		# description: # Specifies the description of a BFD session. The value is a string of 1 to 51 case-sensitive characters with spaces.
		# admin_down: no
		# tos_exp: # Specifies a priority for BFD control packets. The value is an integer ranging from 0 to 7. The default value is 7, which is the highest priority.
		# min_tx_interval: # Specifies the minimum interval for receiving BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
		# min_rx_interval: # Specifies the minimum interval for sending BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
		# state: #present|absent
		# wtr_interval: # Specifies the WTR time of a BFD session. The value is an integer that ranges from 1 to 60, in minutes. The default value is 0.
$0
endsnippet

snippet ce_evpn_bd_vni "Manages EVPN VXLAN Network Identifier (VNI) on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bd_vni:
		vpn_target_import: ${2:# Add VPN targets to the import VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}
		bridge_domain_id: ${3:# Specify an existed bridge domain (BD).The value is an integer ranging from 1 to 16777215.}
		# vpn_target_export: # Add VPN targets to the export VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.
		# state: #present|absent
		# route_distinguisher: # Configures a route distinguisher (RD) for a BD EVPN instance. The format of an RD can be as follows
		# vpn_target_both: # Add VPN targets to both the import and export VPN target lists of a BD EVPN instance. The format is the same as route_distinguisher.
		# evpn: #enable|disable
$0
endsnippet

snippet ce_evpn_bgp "Manages BGP EVPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp:
		bgp_instance: ${2:# Name of a BGP instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}
		# as_number: # Specifies integral AS number. The value is an integer ranging from 1 to 4294967295.
		# advertise_l2vpn_evpn: enable|disable
		# advertise_router_type: arp|irb
		# vpn_name: # Associates a specified VPN instance with the IPv4 address family. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.
		# peer_group_name: # Specify the name of a peer group that BGP peers need to join. The value is a string of 1 to 47 case-sensitive characters, spaces not supported.
		# state: #present|absent
		# peer_enable: true|false
		# peer_address: # Specifies the IPv4 address of a BGP EVPN peer. The value is in dotted decimal notation.
$0
endsnippet

snippet ce_acl_advance "Manages advanced ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_advance:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 3000 to 3999 indicates a advance ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# acl_step: # ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
		# protocol: ip|icmp|igmp|ipinip|tcp|udp|gre|ospf
		# precedence: # Data packets can be filtered based on the priority field. The value is an integer ranging from 0 to 7.
		# src_port_op: lt|eq|gt|range
		# log_flag: true|false
		# time_range: # Name of a time range in which an ACL rule takes effect.
		# src_port_begin: # Start port number of the source port. The value is an integer ranging from 0 to 65535.
		# frag_type: fragment|clear_fragment
		# dest_port_op: lt|eq|gt|range
		# dest_pool_name: # Name of a destination pool. The value is a string of 1 to 32 characters.
		# acl_description: # ACL description. The value is a string of 1 to 127 characters.
		# ttl_expired: true|false
		# icmp_type: # ICMP type. This parameter is available only when the packet protocol is ICMP. The value is an integer ranging from 0 to 255.
		# src_mask: # Source IP address mask. The value is an integer ranging from 1 to 32.
		# icmp_name: unconfiged|echo|echo-reply|fragmentneed-DFset|host-redirect|host-tos-redirect|host-unreachable|information-reply|information-request|net-redirect|net-tos-redirect|net-unreachable|parameter-problem|port-unreachable|protocol-unreachable|reassembly-timeout|source-quench|source-route-failed|timestamp-reply|timestamp-request|ttl-exceeded|address-mask-reply|address-mask-request|custom
		# established: true|false
		# igmp_type: host-query|mrouter-adver|mrouter-solic|mrouter-termi|mtrace-resp|mtrace-route|v1host-report|v2host-report|v2leave-group|v3host-report
		# tos: # ToS value on which data packet filtering is based. The value is an integer ranging from 0 to 15.
		# acl_num: # ACL number. The value is an integer ranging from 3000 to 3999.
		# rule_action: permit|deny
		# state: #present|absent|delete_acl
		# tcp_flag_mask: # TCP flag mask value. The value is an integer ranging from 0 to 63.
		# src_port_end: # End port number of the source port. The value is an integer ranging from 0 to 65535.
		# dest_ip: # Destination IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# icmp_code: # ICMP message code. Data packets can be filtered based on the ICMP message code. The value is an integer ranging from 0 to 255.
		# dest_port_end: # End port number of the destination port. The value is an integer ranging from 0 to 65535.
		# dscp: # Differentiated Services Code Point. The value is an integer ranging from 0 to 63.
		# rule_name: # Name of a basic ACL rule. The value is a string of 1 to 32 characters.
		# rule_description: # Description about an ACL rule.
		# dest_mask: # Destination IP address mask. The value is an integer ranging from 1 to 32.
		# src_port_pool_name: # Name of a source port pool. The value is a string of 1 to 32 characters.
		# source_ip: # Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# syn_flag: # TCP flag value. The value is an integer ranging from 0 to 63.
		# vrf_name: # VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
		# src_pool_name: # Name of a source pool. The value is a string of 1 to 32 characters.
		# dest_port_begin: # Start port number of the destination port. The value is an integer ranging from 0 to 65535.
		# dest_port_pool_name: # Name of a destination port pool. The value is a string of 1 to 32 characters.
		# rule_id: # ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
$0
endsnippet

snippet ce_vxlan_global "Manages global attributes of VXLAN and bridge domain on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_global:
		# nvo3_prevent_loops: enable|disable
		# nvo3_eth_trunk_hash: enable|disable
		# tunnel_mode_vxlan: enable|disable
		# nvo3_acl_extend: enable|disable
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
		# nvo3_gw_enhanced: l2|l3
		# state: #present|absent
		# nvo3_ecmp_hash: enable|disable
		# nvo3_service_extend: enable|disable
$0
endsnippet

snippet ce_startup "Manages a system startup information on HUAWEI CloudEngine switches." b
- name: $1
	ce_startup:
		# slot: # Position of the device.The value is a string of 1 to 32 characters. The possible value of slot is all, slave-board, or the specific slotID.
		# action: display
		# cfg_file: present
		# patch_file: # Name of the patch file that is applied for the next startup.
		# software_file: # File name of the system software that is applied for the next startup. The value is a string of 5 to 255 characters.
$0
endsnippet

snippet ce_netstream_aging "Manages timeout mode of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_aging:
		# timeout_type: active|inactive|tcp-session|manual
		# state: #present|absent
		# type: ip|vxlan
		# manual_slot: # Specifies the slot number of netstream manual timeout.
		# timeout_interval: 30
$0
endsnippet

snippet ce_vrf_interface "Manages interface specific VPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_interface:
		vrf: ${2:# VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_).}
		vpn_interface: ${3:# An interface that can binding VPN instance, i.e. 40GE1/0/22, Vlanif10. Must be fully qualified interface name. Interface types, such as 10GE, 40GE, 100GE, LoopBack, MEth, Tunnel, Vlanif....}
		# state: #present|absent
$0
endsnippet

snippet ce_acl "Manages base ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 2999 indicates a basic ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# acl_step: # ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
		# log_flag: true|false
		# source_ip: # Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# state: #present|absent|delete_acl
		# src_mask: # Mask of a source IP address. The value is an integer ranging from 1 to 32.
		# rule_action: permit|deny
		# rule_name: # Name of a basic ACL rule. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces or begin with an underscore (_).
		# acl_num: # ACL number. The value is an integer ranging from 2000 to 2999.
		# vrf_name: # VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
		# acl_description: # ACL description. The value is a string of 1 to 127 characters.
		# rule_id: # ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
		# time_range: # Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces. The name must start with an uppercase or lowercase letter. In addition, the word "all" cannot be specified as a time range name.
		# rule_description: # Description about an ACL rule. The value is a string of 1 to 127 characters.
		# frag_type: fragment|clear_fragment
$0
endsnippet

snippet ce_dldp_interface "Manages interface DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp_interface:
		interface: ${2:# Must be fully qualified interface name, i.e. GE1/0/1, 10GE1/0/1, 40GE1/0/22, 100GE1/0/1.}
		# reset: enable|disable
		# state: #present|absent
		# enable: enable|disable
		# mode_enable: enable|disable
		# local_mac: # Set the source MAC address for DLDP packets sent in the DLDP-compatible mode. The value of MAC address is in H-H-H format. H contains 1 to 4 hexadecimal digits.
$0
endsnippet

snippet ce_vxlan_vap "Manages VXLAN virtual access point on HUAWEI CloudEngine Devices." b
- name: $1
	ce_vxlan_vap:
		# state: #present|absent
		# pe_vid: # When I(encapsulation) is 'qinq', specifies an inner VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
		# l2_sub_interface: # Specifies an Sub-Interface full name, i.e. "10GE1/0/41.1". The value is a string of 1 to 63 case-insensitive characters, spaces supported.
		# ce_vid: # When I(encapsulation) is 'dot1q', specifies a VLAN ID in the outer VLAN tag. When I(encapsulation) is 'qinq', specifies an outer VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
		# encapsulation: dot1q|default|untag|qinq|none
		# bind_vlan_id: # Specifies the VLAN binding to a BD(Bridge Domain). The value is an integer ranging ranging from 1 to 4094.
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
$0
endsnippet

snippet ce_vxlan_arp "Manages ARP attributes of VXLAN on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_arp:
		# evn_bgp: enable|disable
		# vbdif_name: # Full name of VBDIF interface, i.e. Vbdif100.
		# bridge_domain_id: # Specifies a BD(bridge domain) ID. The value is an integer ranging from 1 to 16777215.
		# state: #present|absent
		# evn_server: enable|disable
		# evn_peer_ip: # Specifies the IP address of an EVN BGP peer. The value is in dotted decimal notation.
		# evn_source_ip: # Specifies the source address of an EVN BGP peer. The value is in dotted decimal notation.
		# arp_collect_host: enable|disable
		# arp_suppress: enable|disable
		# evn_reflect_client: enable|disable
		# host_collect_protocol: bgp|none
$0
endsnippet

snippet ce_interface "Manages physical attributes of interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_interface:
		state: ${2:#present|absent|default}
		# admin_state: up|down
		# description: # Specifies an interface description. The value is a string of 1 to 242 case-sensitive characters, spaces supported but question marks (?) not supported.
		# interface: # Full name of interface, i.e. 40GE1/0/10, Tunnel1.
		# interface_type: ge|10ge|25ge|4x10ge|40ge|100ge|vlanif|loopback|meth|eth-trunk|nve|tunnel|ethernet|fcoe-port|fabric-port|stack-port|null
		# mode: layer2|layer3
		# l2sub: no
$0
endsnippet

snippet ce_rollback "Set a checkpoint or rollback to a checkpoint on HUAWEI CloudEngine switches." b
- name: $1
	ce_rollback:
		action: ${2:rollback|clear|set|display|commit}
		# commit_id: # Specifies the label of the configuration rollback point to which system configurations are expected to roll back. The value is an integer that the system generates automatically.
		# oldest: # Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
		# last: # Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
		# filename: # Specifies a configuration file for configuration rollback. The value is a string of 5 to 64 case-sensitive characters in the format of *.zip, *.cfg, or *.dat, spaces not supported.
		# label: # Specifies a user label for a configuration rollback point. The value is a string of 1 to 256 case-sensitive ASCII characters, spaces not supported. The value must start with a letter and cannot be presented in a single hyphen (-).
$0
endsnippet

snippet ce_snmp_contact "Manages SNMP contact configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_contact:
		contact: ${2:# Contact information.}
		# state: #present|absent
$0
endsnippet

snippet ce_ntp "Manages core NTP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp:
		# state: #present|absent
		# is_preferred: enable|disable
		# peer: # Network address of NTP peer.
		# key_id: # Authentication key identifier to use with given NTP server or peer.
		# vpn_name: _public_
		# server: # Network address of NTP server.
		# source_int: # Local source interface from which NTP messages are sent. Must be fully qualified interface name, i.e. C(40GE1/0/22), C(vlanif10). Interface types, such as C(10GE), C(40GE), C(100GE), C(Eth-Trunk), C(LoopBack), C(MEth), C(NULL), C(Tunnel), C(Vlanif).
$0
endsnippet

snippet ce_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_ip_interface:
		interface: ${2:# Full name of interface, i.e. 40GE1/0/22, vlanif10.}
		# state: #present|absent
		# version: #v4|v6
		# addr: # IPv4 or IPv6 Address.
		# mask: # Subnet mask for IPv4 or IPv6 Address in decimal format.
		# ipv4_type: #main|sub
$0
endsnippet

snippet ce_bgp_af "Manages BGP Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_af:
		af_type: ${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		vrf_name: ${3:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. The value is a string of 1 to 31 case-sensitive characters.}
		# reflector_cluster_id: # Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. The value is an integer ranging from 1 to 4294967295.
		# ingress_lsp_policy_name: # Ingress lsp policy name.
		# vrf_rid_auto_sel: #no_use|true|false
		# preference_internal: # Set the protocol priority of IBGP routes. The value is an integer ranging from 1 to 255.
		# maximum_load_balance: # Specify the maximum number of equal-cost routes in the BGP routing table. The value is an integer ranging from 1 to 65535.
		# preference_local: # Set the protocol priority of a local BGP route. The value is an integer ranging from 1 to 255.
		# preference_external: # Set the protocol priority of EBGP routes. The value is an integer ranging from 1 to 255.
		# router_id_neglect: #no_use|true|false
		# default_local_pref: # Set the Local-Preference attribute. The value is an integer. The value is an integer ranging from 0 to 4294967295.
		# reflector_cluster_ipv4: # Set a cluster ipv4 address. The value is expressed in the format of an IPv4 address.
		# prefrence_policy_name: # Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The value is a string of 1 to 40 characters.
		# default_rt_import_enable: #no_use|true|false
		# nhp_relay_route_policy_name: # Specify the name of a route-policy for route iteration. The value is a string of 1 to 40 characters.
		# igp_metric_ignore: #no_use|true|false
		# as_path_neglect: #no_use|true|false
		# auto_frr_enable: #no_use|true|false
		# mask_len: # Specify the mask length of an IP address. The value is an integer ranging from 0 to 128.
		# ibgp_ecmp_nexthop_changed: #no_use|true|false
		# nexthop_third_party: #no_use|true|false
		# state: #present|absent
		# default_med: # Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer ranging from 0 to 4294967295.
		# add_path_sel_num: # Number of Add-Path routes. The value is an integer ranging from 2 to 64.
		# med_none_as_maximum: #no_use|true|false
		# ebgp_ecmp_nexthop_changed: #no_use|true|false
		# ecmp_nexthop_changed: #no_use|true|false
		# lowest_priority: #no_use|true|false
		# rr_filter_number: # Set the number of the extended community filter supported by an RR group. The value is a string of 1 to 51 characters.
		# import_process_id: # Process ID of an imported routing protocol. The value is an integer ranging from 0 to 4294967295.
		# router_id: # ID of a router that is in IPv4 address format. The value is a string of 0 to 255 characters. The value is in dotted decimal notation.
		# determin_med: #no_use|true|false
		# load_balancing_as_path_ignore: #no_use|true|false
		# reflect_chg_path: #no_use|true|false
		# always_compare_med: #no_use|true|false
		# allow_invalid_as: #no_use|true|false
		# relay_delay_enable: #no_use|true|false
		# rib_only_policy_name: # Specify the name of a routing policy. The value is a string of 1 to 40 characters.
		# max_load_ebgp_num: # Specify the maximum number of equal-cost EBGP routes. The value is an integer ranging from 1 to 65535.
		# import_protocol: direct|ospf|isis|static|rip|ospfv3|ripng
		# ebgp_if_sensitive: #no_use|true|false
		# network_address: # Specify the IP address advertised by BGP. The value is a string of 0 to 255 characters.
		# supernet_uni_adv: #no_use|true|false
		# next_hop_sel_depend_type: #default|dependTunnel|dependIp
		# originator_prior: #no_use|true|false
		# active_route_advertise: #no_use|true|false
		# reflect_between_client: #no_use|true|false
		# policy_vpn_target: #no_use|true|false
		# summary_automatic: #no_use|true|false
		# rib_only_enable: #no_use|true|false
		# max_load_ibgp_num: # Specify the maximum number of equal-cost IBGP routes. The value is an integer ranging from 1 to 65535.
		# route_sel_delay: # Route selection delay. The value is an integer ranging from 0 to 3600.
		# supernet_label_adv: #no_use|true|false
		# policy_ext_comm_enable: #no_use|true|false
$0
endsnippet

snippet ce_bgp_neighbor_af "Manages BGP neighbor Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor_af:
		af_type: ${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		remote_address: ${3:# IPv4 or IPv6 peer connection address.}
		vrf_name: ${4:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		# import_pref_filt_name: # Specify the IPv4 filtering policy applied to the routes received from a specified peer. The value is a string of 1 to 169 characters.
		# advertise_irb: #no_use|true|false
		# substitute_as_enable: #no_use|true|false
		# advertise_ext_community: #no_use|true|false
		# default_rt_match_mode: null|matchall|matchany
		# redirect_ip: #no_use|true|false
		# route_limit: # Configure the maximum number of routes that can be accepted from a peer. The value is an integer ranging from 1 to 4294967295.
		# import_as_path_filter: # Apply an AS_Path-based filtering policy to the routes received from a specified peer. The value is an integer ranging from 1 to 256.
		# public_as_only_force: #no_use|true|false
		# vpls_enable: #no_use|true|false
		# allow_as_loop_enable: #no_use|true|false
		# advertise_arp: #no_use|true|false
		# import_as_path_name_or_num: # A routing strategy based on the AS path list for routing received by a designated peer.
		# orf_mode: null|receive|send|both
		# nexthop_configure: null|local|invariable
		# discard_ext_community: #no_use|true|false
		# is_nonstd_ipprefix_mod: #no_use|true|false
		# keep_all_routes: #no_use|true|false
		# orftype: # ORF Type. The value is an integer ranging from 0 to 65535.
		# advertise_community: #no_use|true|false
		# export_as_path_name_or_num: # Application of a AS path list based filtering policy to the routing of a specified peer.
		# adv_add_path_num: # The number of addPath advertise route. The value is an integer ranging from 2 to 64.
		# ipprefix_orf_enable: #no_use|true|false
		# route_limit_type: noparameter|alertOnly|idleForever|idleTimeout
		# public_as_only_skip_peer_as: #no_use|true|false
		# origin_as_valid: #no_use|true|false
		# route_limit_idle_timeout: # Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold. The value is an integer ranging from 1 to 1200.
		# reflect_client: #no_use|true|false
		# import_rt_policy_name: # Specify the filtering policy applied to the routes learned from a peer. The value is a string of 1 to 40 characters.
		# route_limit_percent: # Specify the percentage of routes when a router starts to generate an alarm. The value is an integer ranging from 1 to 100.
		# export_rt_policy_name: # Specify the filtering policy applied to the routes to be advertised to a peer. The value is a string of 1 to 40 characters.
		# public_as_only: #no_use|true|false
		# redirect_ip_vaildation: #no_use|true|false
		# import_acl_name_or_num: # Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The value is a string of 1 to 32 characters.
		# allow_as_loop_limit: # Set the maximum number of repetitive local AS number. The value is an integer ranging from 1 to 10.
		# add_path_mode: null|receive|send|both
		# export_as_path_filter: # Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The value is an integer ranging from 1 to 256.
		# vpls_ad_disable: #no_use|true|false
		# public_as_only_replace: #no_use|true|false
		# public_as_only_limited: #no_use|true|false
		# preferred_value: # Assign a preferred value for the routes learned from a specified peer. The value is an integer ranging from 0 to 65535.
		# export_acl_name_or_num: # Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The value is a string of 1 to 32 characters.
		# soostring: # Configure the Site-of-Origin (SoO) extended community attribute. The value is a string of 3 to 21 characters.
		# update_pkt_standard_compatible: #no_use|true|false
		# advertise_remote_nexthop: #no_use|true|false
		# default_rt_adv_policy: # Specify the name of a used policy. The value is a string. The value is a string of 1 to 40 characters.
		# export_pref_filt_name: # Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. The value is a string of 1 to 169 characters.
		# default_rt_adv_enable: #no_use|true|false
		# rt_updt_interval: # Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. The value is an integer ranging from 0 to 600.
$0
endsnippet

snippet ce_switchport "Manages Layer 2 switchport interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_switchport:
		interface: ${2:# Full name of the interface, i.e. 40GE1/0/22.}
		# native_vlan: # If C(mode=trunk), used as the trunk native VLAN ID, in the range from 1 to 4094.
		# access_vlan: # If C(mode=access), used as the access VLAN ID, in the range from 1 to 4094.
		# state: #present|absent|unconfigured
		# mode: access|trunk
		# trunk_vlans: # If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.
$0
endsnippet

snippet ce_file_copy "Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches." b
- name: $1
	ce_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist. The maximum length of I(local_file) is C(4096).}
		# remote_file: # Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used. The maximum length of I(remote_file) is C(4096).
		# file_system: flash:
$0
endsnippet

snippet ce_vrf_af "Manages VPN instance address family on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_af:
		vrf: ${2:# VPN instance.}
		# vpn_target_type: export_extcommunity|import_extcommunity
		# vpn_target_state: present|absent
		# vrf_aftype: #v4|v6
		# state: #present|absent
		# route_distinguisher: # VPN instance route distinguisher,the RD used to distinguish same route prefix from different vpn. The RD must be setted before setting vpn_target_value.
		# evpn: true|false
		# vpn_target_value: # VPN instance target value. Such as X.X.X.X:number<0-65535> or number<0-65535>:number<0-4294967295> or number<0-65535>.number<0-65535>:number<0-65535> or number<65536-4294967295>:number<0-65535> but not support 0:0 and 0.0:0.
$0
endsnippet

snippet ce_info_center_trap "Manages information center trap configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_trap:
		# trap_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
		# trap_buff_size: # Size of a trap buffer. The value is an integer ranging from 0 to 1024. The default value is 256.
		# channel_id: # Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# state: #present|absent
		# trap_level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# trap_buff_enable: #no_use|true|false
		# module_name: # Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
		# trap_enable: #no_use|true|false
$0
endsnippet

snippet ce_acl_interface "Manages applying ACLs to interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_interface:
		interface: ${2:# Interface name. Only support interface full name, such as "40GE2/0/1".}
		direction: ${3:inbound|outbound}
		acl_name: ${4:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 4999. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# state: #present|absent
$0
endsnippet

snippet ce_info_center_global "Manages outputting logs on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_global:
		# server_ip: # Log server address, IPv4 or IPv6 type. The value is a string of 0 to 255 characters. The value can be an valid IPv4 or IPv6 address.
		# filter_log_name: # Name of the filtered log. The value is a string of 1 to 63 case-sensitive characters.
		# facility: local0|local1|local2|local3|local4|local5|local6|local7
		# ssl_policy_name: # SSL policy name. The value is a string of 1 to 23 case-sensitive characters.
		# transport_mode: tcp|udp
		# channel_cfg_name: console
		# suppress_enable: true|false
		# channel_out_direct: console|monitor|trapbuffer|logbuffer|snmp|logfile
		# channel_id: # Number for channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# filter_feature_name: # Feature name of the filtered log. The value is a string of 1 to 31 case-insensitive characters.
		# is_default_vpn: no
		# server_domain: # Server name. The value is a string of 1 to 255 case-sensitive characters.
		# level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# packet_priority: # Set the priority of the syslog packet.The value is an integer ranging from 0 to 7. The default value is 0.
		# source_ip: # Log source ip address, IPv4 or IPv6 type. The value is a string of 0 to 255. The value can be an valid IPv4 or IPv6 address.
		# channel_name: # Channel name. The value is a string of 1 to 30 case-sensitive characters.
		# state: #present|absent
		# vrf_name: # VPN name on a log server. The value is a string of 1 to 31 case-sensitive characters. The default value is _public_.
		# logfile_max_size: 4|8|16|32
		# server_port: # Number of a port sending logs.The value is an integer ranging from 1 to 65535. For UDP, the default value is 514. For TCP, the default value is 601. For TSL, the default value is 6514.
		# timestamp: UTC|localtime
		# info_center_enable: true|false
		# ip_type: ipv4|ipv6
		# logfile_max_num: # Maximum number of log files of the same type. The default value is 200.
$0
endsnippet

snippet ce_dldp "Manages global DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp:
		# reset: enable|disable
		# enable: enable|disable
		# work_mode: enhance|normal
		# auth_pwd: # Specifies authentication password. The value is a string of 1 to 16 case-sensitive plaintexts or 24/32/48/108/128 case-sensitive encrypted characters. The string excludes a question mark (?).
		# time_internal: # Specifies the interval for sending Advertisement packets. The value is an integer ranging from 1 to 100, in seconds. The default interval for sending Advertisement packets is 5 seconds.
		# auth_mode: md5|simple|sha|hmac-sha256|none
$0
endsnippet

snippet ce_bgp "Manages BGP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp:
		# router_id: # ID of a router that is in IPv4 address format.
		# memory_limit: #no_use|true|false
		# vrf_rid_auto_sel: #no_use|true|false
		# suppress_interval: # Suppress interval.
		# as_number: # Local AS number. The value is a string of 1 to 11 characters.
		# confed_id_number: # Confederation ID. The value is a string of 1 to 11 characters.
		# bgp_rid_auto_sel: #no_use|true|false
		# default_af_type: ipv4uni|ipv6uni
		# conn_retry_time: # ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
		# is_shutdown: #no_use|true|false
		# keepalive_time: # If the value of a timer changes, the BGP peer relationship between the routers is disconnected. The value is an integer ranging from 0 to 21845. The default value is 60.
		# confed_peer_as_num: # Confederation AS number, in two-byte or four-byte format. The value is a string of 1 to 11 characters.
		# min_hold_time: # Min hold time, in seconds. The value of the hold time can be 0 or range from 20 to 65535.
		# ebgp_if_sensitive: #no_use|true|false
		# check_first_as: #no_use|true|false
		# clear_interval: # Clear interval.
		# confed_nonstanded: #no_use|true|false
		# time_wait_for_rib: # Period of waiting for the End-Of-RIB flag. The value is an integer ranging from 3 to 3000. The default value is 600.
		# hold_time: # Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535.
		# as_path_limit: # Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
		# hold_interval: # Hold interval.
		# state: #present|absent
		# vrf_name: # Name of a BGP instance. The name is a case-sensitive string of characters.
		# keep_all_routes: #no_use|true|false
		# gr_peer_reset: #no_use|true|false
		# graceful_restart: #no_use|true|false
$0
endsnippet

snippet ce_config "Manage Huawei CloudEngine configuration sections." b
- name: $1
	ce_config:
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
		# backup: no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device current-configuration.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: no
		# save: no
		# config: # The module, by default, will connect to the remote device and retrieve the current current-configuration to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current-configuration for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet ce_evpn_global "Manages global configuration of EVPN on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_global:
		evpn_overlay_enable: ${2:enable|disable}
$0
endsnippet

snippet ce_sflow "Manages sFlow configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_sflow:
		# agent_ip: # Specifies the IPv4/IPv6 address of an sFlow agent.
		# export_route: enable|disable
		# counter_collector: # Indicates the ID list of the counter collector.
		# rate_limit_slot: # Specifies the slot where the rate of output sFlow packets is limited. If this parameter is not specified, the rate of sFlow packets sent from all cards to the control plane is limited. The value is an integer or a string of characters.
		# source_ip: # Specifies the source IPv4/IPv6 address of sFlow packets.
		# collector_datagram_size: # Specifies the maximum length of sFlow packets sent from an sFlow agent to an sFlow collector. The value is an integer, in bytes. It ranges from 1024 to 8100. The default value is 1400.
		# sample_collector: # Indicates the ID list of the collector.
		# rate_limit: # Specifies the rate of sFlow packets sent from a card to the control plane. The value is an integer that ranges from 100 to 1500, in pps.
		# sample_direction: inbound|outbound|both
		# collector_meth: meth|enhanced
		# collector_ip_vpn: # Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# forward_enp_slot: # Enable the Embedded Network Processor (ENP) chip function. The switch uses the ENP chip to perform sFlow sampling, and the maximum sFlow sampling interval is 65535. If you set the sampling interval to be larger than 65535, the switch automatically restores it to 65535. The value is an integer or 'all'.
		# collector_ip: # Specifies the IPv4/IPv6 address of the sFlow collector.
		# sflow_interface: # Full name of interface for Flow Sampling or Counter. It must be a physical interface, Eth-Trunk, or Layer 2 subinterface.
		# sample_length: # Specifies the maximum length of sampled packets. The value is an integer and ranges from 18 to 512, in bytes. The default value is 128.
		# state: #present|absent
		# collector_id: 1|2
		# sample_rate: # Specifies the flow sampling rate in the format 1/rate. The value is an integer and ranges from 1 to 4294967295. The default value is 8192.
		# collector_udp_port: # Specifies the UDP destination port number of sFlow packets. The value is an integer that ranges from 1 to 65535. The default value is 6343.
		# counter_interval: # Indicates the counter sampling interval. The value is an integer that ranges from 10 to 4294967295, in seconds. The default value is 20.
		# collector_description: # Specifies the description of an sFlow collector. The value is a string of 1 to 255 case-sensitive characters without spaces.
$0
endsnippet

snippet ce_snmp_target_host "Manages SNMP target host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_target_host:
		# security_name_v3: # Security Name V3.
		# recv_port: # UDP Port number used by network management to receive alarm messages.
		# security_model: v1|v2c|v3
		# vpn_name: # VPN instance Name.
		# address: # Network Address.
		# security_name: # Security Name.
		# notify_type: trap|inform
		# connect_port: # Udp port used by SNMP agent to connect the Network management.
		# version: none|v1|v2c|v3|v1v2c|v1v3|v2cv3|all
		# host_name: # Unique name to identify target host entry.
		# security_level: noAuthNoPriv|authentication|privacy
		# interface_name: # Name of the interface to send the trap message.
		# is_public_net: #no_use|true|false
$0
endsnippet

snippet ce_vlan "Manages VLAN resources and attributes on Huawei CloudEngine switches." b
- name: $1
	ce_vlan:
		# state: #present|absent
		# vlan_range: # Range of VLANs such as C(2-10) or C(2,5,10-15), etc.
		# name: # Name of VLAN, in the range from 1 to 31.
		# vlan_id: # Single VLAN ID, in the range from 1 to 4094.
		# description: # Specify VLAN description, in the range from 1 to 80.
$0
endsnippet

snippet ce_ospf_vrf "Manages configuration of an OSPF VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf_vrf:
		ospf: ${2:# The ID of the ospf process. Valid values are an integer, 1 - 4294967295, the default value is 1.}
		# description: # Specifies the description information of ospf process.
		# lsaostartinterval: # Specifies the start interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 1000, the default value is 500.
		# lsaastartinterval: # Specifies the start interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
		# lsaointerval: # Specifies the interval of originate LSA . Valid value is an integer, in second, from 0 to 10, the default value is 5.
		# bandwidth: # Specifies the reference bandwidth used to assign ospf cost. Valid values are an integer, in Mbps, 1 - 2147483648, the default value is 100.
		# spfintervalmi: # Specifies the interval to calculate SPF when use millisecond level  timer. Valid value is an integer, in millisecond, from 1 to 10000.
		# spfinterval: # Specifies the interval to calculate SPF when use second level  timer. Valid value is an integer, in second, from 1 to 10.
		# lsaointervalflag: no
		# lsaomaxinterval: # Specifies the max interval of originate LSA . Valid value is an integer, in millisecond, from 1 to 10000, the default value is 5000.
		# lsaalflag: no
		# lsaamaxinterval: # Specifies the max interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 1000.
		# lsaoholdinterval: # Specifies the hold interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 5000, the default value is 1000.
		# spfintervaltype: #intelligent-timer|timer|millisecond
		# lsaainterval: # Specifies the interval of arrive LSA when use the general timer. Valid value is an integer, in millisecond, from 0 to 10000.
		# spfstartinterval: # Specifies the start interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 1000, the default value is 50.
		# route_id: # Specifies the ospf private route id,. Valid values are a string, formatted as an IP address (i.e. "10.1.1.1") the length is 0 - 20.
		# state: #present|absent
		# spfmaxinterval: # Specifies the max interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 20000, the default value is 5000.
		# spfholdinterval: # Specifies the hold interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 5000, the default value is 200.
		# lsaaholdinterval: # Specifies the hold interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
		# vrf: _public_
$0
endsnippet

snippet ce_vrf "Manages VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf:
		vrf: ${2:# VPN instance, the length of vrf name is 1 - 31, i.e. "test", but can not be C(_public_).}
		# state: #present|absent
		# description: # Description of the vrf, the string length is 1 - 242 .
$0
endsnippet

snippet ce_interface_ospf "Manages configuration of an OSPF interface instanceon HUAWEI CloudEngine switches." b
- name: $1
	ce_interface_ospf:
		area: ${2:# Ospf area associated with this ospf process. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}
		process_id: ${3:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		interface: ${4:# Full name of interface, i.e. 40GE1/0/10.}
		# cost: # The cost associated with this interface. Valid values are an integer in the range from 1 to 65535.
		# silent_interface: no
		# auth_mode: none|null|hmac-sha256|md5|hmac-md5|simple
		# auth_key_id: # Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
		# dead_interval: # Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer in the range from 1 to 235926000.
		# auth_text_simple: # Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
		# state: #present|absent
		# hello_interval: # Time between sending successive hello packets. Valid values are an integer in the range from 1 to 65535.
		# auth_text_md5: # Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
$0
endsnippet

snippet ce_ntp_auth "Manages NTP authentication configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp_auth:
		key_id: ${2:# Authentication key identifier (numeric).}
		# auth_type: text|#encrypt
		# state: #present|absent
		# auth_pwd: # Plain text with length of 1 to 255, encrypted text with length of 20 to 392.
		# trusted_key: enable|#disable
		# auth_mode: hmac-sha256|md5
		# authentication: enable|disable
$0
endsnippet

snippet ce_bfd_global "Manages BFD global configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_global:
		# tos_exp_dynamic: # Indicates the priority of BFD control packets for dynamic BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
		# default_ip: # Specifies the default multicast IP address. The value ranges from 224.0.0.107 to 224.0.0.250.
		# damp_init_wait_time: # Specifies an initial flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 2000.
		# bfd_enable: enable|disable
		# delay_up_time: # Specifies the delay before a BFD session becomes Up. The value is an integer ranging from 1 to 600, in seconds. The default value is 0, indicating that a BFD session immediately becomes Up.
		# state: #present|absent
		# damp_max_wait_time: # Specifies a maximum flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 15000.
		# damp_second_wait_time: # Specifies a secondary flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 5000.
		# tos_exp_static: # Indicates the priority of BFD control packets for static BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
$0
endsnippet

snippet ce_mlag_config "Manages MLAG configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_config:
		# eth_trunk_id: # Name of the peer-link interface. The value is in the range from 0 to 511.
		# pseudo_priority: # The priority of a pseudo nickname. The value is an integer that ranges from 128 to 255. The default value is 192. A larger value indicates a higher priority.
		# ip_address: # IP address bound to the DFS group. The value is in dotted decimal notation.
		# priority_id: # Priority of a DFS group. The value is an integer that ranges from 1 to 254. The default value is 100.
		# vpn_instance_name: # Name of the VPN instance bound to the DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value _public_ is reserved and cannot be used as the VPN instance name.
		# peer_link_id: # Number of the peer-link interface. The value is 1.
		# state: #present|absent
		# dfs_group_id: present
		# nickname: # The nickname bound to a DFS group. The value is an integer that ranges from 1 to 65471.
		# pseudo_nickname: # A pseudo nickname of a DFS group. The value is an integer that ranges from 1 to 65471.
$0
endsnippet

snippet net_lldp_interface "Manage LLDP interfaces configuration on network devices" b
- name: $1
	net_lldp_interface:
		# aggregate: # L
		# purge: no
		# state: #present|absent|enabled|disabled
		# name: # Name of the interface LLDP should be configured on.
$0
endsnippet

snippet net_interface "Manage Interface on network devices" b
- name: $1
	net_interface:
		name: ${2:# Name of the Interface.}
		# rx_rate: # Receiver rate in bits per second (bps).
		# duplex: full|half|#auto
		# enabled: # Configure interface link status.
		# mtu: # Maximum size of transmit packet.
		# delay: 10
		# purge: no
		# state: #present|absent|up|down
		# aggregate: # L
		# speed: # Interface link speed.
		# tx_rate: # Transmit rate in bits per second (bps).
		# description: # Description of Interface.
$0
endsnippet

snippet net_linkagg "Manage link aggregation groups on network devices" b
- name: $1
	net_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# purge: no
		# state: #present|absent|up|down
		# min_links: # Minimum members that should be up before bringing up the link aggregation group.
		# aggregate: # L
		# mode: on|active|passive
$0
endsnippet

snippet ipadm_addrprop "Manage IP address properties on Solaris/illumos systems." b
- name: $1
	ipadm_addrprop:
		property: ${2:# Specifies the name of the address property we want to manage.}
		addrobj: ${3:# Specifies the address object we want to manage.}
		# state: #present|absent|reset
		# temporary: no
		# value: # Specifies the value we want to set for the address property.
$0
endsnippet

snippet ipadm_ifprop "Manage IP interface properties on Solaris/illumos systems." b
- name: $1
	ipadm_ifprop:
		interface: ${2:# Specifies the IP interface we want to manage.}
		protocol: ${3:# Specifies the procotol for which we want to manage properties.}
		property: ${4:# Specifies the name of the property we want to manage.}
		# state: #present|absent|reset
		# temporary: no
		# value: # Specifies the value we want to set for the property.
$0
endsnippet

snippet dladm_vlan "Manage VLAN interfaces on Solaris/illumos systems." b
- name: $1
	dladm_vlan:
		link: ${2:# VLAN underlying link name.}
		name: ${3:# VLAN interface name.}
		# state: #present|absent
		# temporary: no
		# vlan_id: no
$0
endsnippet

snippet ipadm_if "Manage IP interfaces  on Solaris/illumos systems." b
- name: $1
	ipadm_if:
		name: ${2:# IP interface name.}
		# state: #present|absent|enabled|disabled
		# temporary: true|false
$0
endsnippet

snippet dladm_linkprop "Manage link properties on Solaris/illumos systems." b
- name: $1
	dladm_linkprop:
		link: ${2:# Link interface name.}
		property: ${3:# Specifies the name of the property we want to manage.}
		# state: #present|absent|reset
		# temporary: no
		# value: # Specifies the value we want to set for the link property.
$0
endsnippet

snippet dladm_iptun "Manage IP tunnel interfaces on Solaris/illumos systems." b
- name: $1
	dladm_iptun:
		name: ${2:# IP tunnel interface name.}
		# state: #present|absent
		# temporary: no
		# local_address: # Literat IP address or hostname corresponding to the tunnel source.
		# type: #ipv4|ipv6|6to4
		# remote_address: # Literal IP address or hostname corresponding to the tunnel destination.
$0
endsnippet

snippet flowadm "Manage bandwidth resource control and priority for protocols, services and zones on Solaris/illumos systems" b
- name: $1
	flowadm:
		name: ${2:# -}
		# dsfield: # -
		# temporary: true|false
		# maxbw: # -
		# local_port: # Identifies a service specified by the local port.
		# local_ip: # Identifies a network flow by the local IP address.
		# priority: low|#medium|high
		# state: absent|#present|resetted
		# link: # Specifiies a link to configure flow on.
		# transport: # -
		# remote_ip: # Identifies a network flow by the remote IP address.
$0
endsnippet

snippet dladm_vnic "Manage VNICs on Solaris/illumos systems." b
- name: $1
	dladm_vnic:
		name: ${2:# VNIC name.}
		link: ${3:# VNIC underlying link name.}
		# state: #present|absent
		# temporary: true|false
		# vlan: no
		# mac: no
$0
endsnippet

snippet ipadm_prop "Manage protocol properties on Solaris/illumos systems." b
- name: $1
	ipadm_prop:
		protocol: ${2:# Specifies the procotol for which we want to manage properties.}
		property: ${3:# Specifies the name of property we want to manage.}
		# state: #present|absent|reset
		# temporary: true|false
		# value: # Specifies the value we want to set for the property.
$0
endsnippet

snippet ipadm_addr "Manage IP addresses on an interface on Solaris/illumos systems" b
- name: $1
	ipadm_addr:
		addrobj: ${2:# Specifies an unique IP address on the system.}
		# addrtype: #static|dhcp|addrconf
		# state: absent|#present|up|down|enabled|disabled|refreshed
		# temporary: no
		# address: # Specifiies an IP address to configure in CIDR notation.
		# wait: 60
$0
endsnippet

snippet dladm_etherstub "Manage etherstubs on Solaris/illumos systems." b
- name: $1
	dladm_etherstub:
		name: ${2:# Etherstub name.}
		# state: #present|absent
		# temporary: true|false
$0
endsnippet

snippet enos_command "Run arbitrary commands on Lenovo ENOS devices" b
- name: $1
	enos_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# authorize: yes|no
		# retries: 10
		# auth_pass: none
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet enos_facts "Collect facts from remote devices running Lenovo ENOS" b
- name: $1
	enos_facts:
		# authorize: yes|no
		# auth_pass: none
		# gather_subset: !config
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet enos_config "Manage Lenovo ENOS configuration sections" b
- name: $1
	enos_config:
		# comment: configured by enos_config
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# auth_pass: none
		# admin: yes|no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# authorize: yes|no
		# replace: #line|block|config
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# backup: yes|no
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet netconf_config "netconf device configuration" b
- name: $1
	netconf_config:
		username: ${2:# the username to authenticate with}
		host: ${3:# the hostname or ip address of the netconf device}
		password: ${4:# password of the user to authenticate with}
		# xml: # the XML content to send to the device
		# save: no
		# allow_agent: yes
		# src: # Specifies the source path to the xml file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(xml).
		# look_for_keys: yes
		# hostkey_verify: yes
		# datastore: auto
		# port: 830
$0
endsnippet

snippet openvswitch_bridge "Manage Open vSwitch bridges" b
- name: $1
	openvswitch_bridge:
		bridge: ${2:# Name of bridge or fake bridge to manage}
		# fail_mode: secure|standalone
		# parent: # Bridge parent of the fake bridge to manage
		# vlan: # The VLAN id of the fake bridge to manage (must be between 0 and 4095). This parameter is required if I(parent) parameter is set.
		# state: #present|absent
		# set: # Run set command after bridge configuration. This parameter is non-idempotent, play will always return I(changed) state if present
		# timeout: 5
		# external_ids: # A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.
$0
endsnippet

snippet openvswitch_port "Manage Open vSwitch ports" b
- name: $1
	openvswitch_port:
		bridge: ${2:# Name of bridge to manage}
		port: ${3:# Name of port to manage on the bridge}
		# state: #present|absent
		# set: # Set a single property on a port.
		# timeout: 5
		# external_ids: {}
		# tag: # VLAN tag for this port. Must be a value between 0 and 4095.
$0
endsnippet

snippet openvswitch_db "Configure open vswitch database." b
- name: $1
	openvswitch_db:
		record: ${2:# Identifies the recoard in the table.}
		key: ${3:# Identifies the key in the record column}
		table: ${4:# Identifies the table in the database.}
		col: ${5:# Identifies the column in the record.}
		value: ${6:# Expected value for the table, record, column and key.}
		# state: #present|absent
		# timeout: 5
$0
endsnippet

snippet avi_controllerproperties "Module for setup of ControllerProperties Avi RESTful Object" b
- name: $1
	avi_controllerproperties:
		# vs_se_ping_fail: # Number of vs_se_ping_fail.
		# portal_token: # Token used for uploading tech-support to portal.
		# cluster_ip_gratuitous_arp_period: # Number of cluster_ip_gratuitous_arp_period.
		# persistence_key_rotate_period: # Allowed values are 1-1051200.
		# bm_use_ansible: # Use ansible for se creation in baremetal.
		# attach_ip_retry_interval: # Number of attach_ip_retry_interval.
		# vs_se_vnic_fail: # Number of vs_se_vnic_fail.
		# secure_channel_se_token_timeout: # Number of secure_channel_se_token_timeout.
		# attach_ip_retry_limit: # Number of attach_ip_retry_limit.
		# se_vnic_cooldown: # Number of se_vnic_cooldown.
		# vnic_op_fail_time: # Number of vnic_op_fail_time.
		# max_pcap_per_tenant: # Maximum number of pcap files stored per tenant.
		# vs_se_bootup_fail: # Number of vs_se_bootup_fail.
		# seupgrade_fabric_pool_size: # Pool size used for all fabric commands during se upgrade.
		# vs_key_rotate_period: # Allowed values are 1-1051200.
		# seupgrade_segroup_min_dead_timeout: # Time to wait before marking segroup upgrade as stuck.
		# dns_refresh_period: # Number of dns_refresh_period.
		# upgrade_lease_time: # Number of upgrade_lease_time.
		# avi_api_patch_op: add|replace|delete
		# se_create_timeout: # Number of se_create_timeout.
		# query_host_fail: # Number of query_host_fail.
		# vs_apic_scaleout_timeout: # Time to wait for the scaled out se to become ready before marking the scaleout done, applies to apic configuration only.
		# unresponsive_se_reboot: # Number of unresponsive_se_reboot.
		# state: absent|#present
		# se_offline_del: # Number of se_offline_del.
		# max_dead_se_in_grp: # Number of max_dead_se_in_grp.
		# upgrade_dns_ttl: # Time to account for dns ttl during upgrade.
		# fatal_error_lease_time: # Number of fatal_error_lease_time.
		# api_version: 16.4.4
		# username: 
		# allow_ip_forwarding: # Field introduced in 17.1.1.
		# vs_se_attach_ip_fail: # Time to wait before marking attach ip operation on an se as failed.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# max_seq_vnic_failures: # Number of max_seq_vnic_failures.
		# allow_unauthenticated_nodes: # Boolean flag to set allow_unauthenticated_nodes.
		# allow_unauthenticated_apis: # Allow unauthenticated access for special apis.
		# controller: 
		# safenet_hsm_version: # Version of the safenet package installed on the controller.
		# warmstart_se_reconnect_wait_time: # Number of warmstart_se_reconnect_wait_time.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
		# tenant: admin
		# dummy: # Number of dummy.
		# max_seq_attach_ip_failures: # Maximum number of consecutive attach ip failures that halts vs placement.
		# secure_channel_cleanup_timeout: # Number of secure_channel_cleanup_timeout.
		# ssl_certificate_expiry_warning_days: # Number of days for ssl certificate expiry warning.
		# vs_se_vnic_ip_fail: # Number of vs_se_vnic_ip_fail.
		# secure_channel_controller_token_timeout: # Number of secure_channel_controller_token_timeout.
		# url: # Avi controller URL of the object.
		# vs_se_create_fail: # Number of vs_se_create_fail.
		# api_idle_timeout: # Allowed values are 0-1440.
		# crashed_se_reboot: # Number of crashed_se_reboot.
		# appviewx_compat_mode: # Export configuration in appviewx compatibility mode.
		# vs_awaiting_se_timeout: # Number of vs_awaiting_se_timeout.
		# se_failover_attempt_interval: # Interval between attempting failovers to an se.
		# dead_se_detection_timer: # Number of dead_se_detection_timer.
		# tenant_uuid: 
$0
endsnippet

snippet avi_ipaddrgroup "Module for setup of IpAddrGroup Avi RESTful Object" b
- name: $1
	avi_ipaddrgroup:
		name: ${2:# Name of the ip address group.}
		# username: 
		# description: # User defined description for the object.
		# marathon_service_port: # Task port associated with marathon service port.
		# ranges: # Configure ip address range(s).
		# controller: 
		# addrs: # Configure ip address(es).
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the ip address group.
		# country_codes: # Populate the ip address ranges from the geo database for this country.
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# apic_epg_name: # Populate ip addresses from members of this cisco apic epg.
		# prefixes: # Configure ip address prefix(es).
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# marathon_app_name: # Populate ip addresses from tasks of this marathon app.
		# ip_ports: # Configure (ip address, port) tuple(s).
		# tenant_uuid: 
$0
endsnippet

snippet avi_clusterclouddetails "Module for setup of ClusterCloudDetails Avi RESTful Object" b
- name: $1
	avi_clusterclouddetails:
		name: ${2:# Field introduced in 17.2.5.}
		# username: 
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# azure_info: # Azure info to configure cluster_vip on the controller.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Field introduced in 17.2.5.
$0
endsnippet

snippet avi_trafficcloneprofile "Module for setup of TrafficCloneProfile Avi RESTful Object" b
- name: $1
	avi_trafficcloneprofile:
		name: ${2:# Name for the traffic clone profile.}
		# username: 
		# password: 
		# uuid: # Uuid of the traffic clone profile.
		# api_version: 16.4.4
		# cloud_ref: # It is a reference to an object of type cloud.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# clone_servers: # Field introduced in 17.1.1.
		# preserve_client_ip: # Specifies if client ip needs to be preserved to clone destination.
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_virtualservice "Module for setup of VirtualService Avi RESTful Object" b
- name: $1
	avi_virtualservice:
		name: ${2:# Name for the virtual service.}
		# client_auth: # Http authentication configuration for protected resources.
		# port_uuid: # (internal-use) network port assigned to the virtual service ip address.
		# availability_zone: # Availability-zone to place the virtual service.
		# error_page_profile_ref: # Error page profile to be used for this virtualservice.this profile is used to send the custom error page to the client generated by the proxy.
		# subnet_uuid: # It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.
		# delay_fairness: # Select the algorithm for qos fairness.
		# vip: # List of virtual service ips.
		# static_dns_records: # List of static dns records applied to this virtual service.
		# enable_rhi_snat: # Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.
		# sideband_profile: # Sideband configuration to be used for this virtualservice.it can be used for sending traffic to sideband vips for external inspection etc.
		# requests_rate_limit: # Rate limit the incoming requests to this virtual service.
		# analytics_profile_ref: # Specifies settings related to analytics.
		# uuid: # Uuid of the virtualservice.
		# ipam_network_subnet: # Subnet and/or network for allocating virtualservice ip by ipam provider module.
		# avi_allocated_fip: # (internal-use) fip allocated by avi in the cloud infrastructure.
		# ssl_profile_ref: # Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.
		# created_by: # Creator name.
		# discovered_network_ref: # (internal-use) discovered networks providing reachability for client facing virtual service ip.
		# max_cps_per_client: # Maximum connections per second per client ip.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# pool_group_ref: # The pool group is an object that contains pools.
		# ssl_sess_cache_avg_size: # Expected number of ssl session cache entries (may be exceeded).
		# vs_datascripts: # Datascripts applied on the data traffic of the virtual service.
		# username: 
		# flow_dist: # Criteria for flow distribution among ses.
		# http_policies: # Http policies applied on the data traffic of the virtual service.
		# application_profile_ref: # Enable application layer specific features for the virtual service.
		# microservice_ref: # Microservice representing the virtual service.
		# controller: 
		# use_vip_as_snat: # Use the virtual ip as the snat ip for health monitoring and sending traffic to the backend servers instead of the service engine interface ip.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# ip_address: # Ip address of the virtual service.
		# avi_api_update_method: #put|patch
		# east_west_placement: # Force placement on all se's in service group (mesos mode only).
		# floating_subnet_uuid: # If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.
		# service_pool_select: # Select pool based on destination port.
		# close_client_conn_on_config_update: # Close client connection on vs config update.
		# type: # Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.
		# enable_autogw: # Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.
		# discovered_networks: # (internal-use) discovered networks providing reachability for client facing virtual service ip.
		# tenant_ref: # It is a reference to an object of type tenant.
		# remove_listening_port_on_vs_down: # Remove listening port if virtualservice is down.
		# ssl_key_and_certificate_refs: # Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.
		# snat_ip: # Nat'ted floating source ip address(es) for upstream connection to servers.
		# host_name_xlate: # Translate the host name sent to the servers to this value.
		# analytics_policy: # Determines analytics settings for the application.
		# sp_pool_refs: # Gslb pools used to manage site-persistence functionality.
		# flow_label_type: # Criteria for flow labelling.
		# network_profile_ref: # Determines network settings such as protocol, tcp or udp, and related options for the protocol.
		# weight: # The quality of service weight to assign to traffic transmitted from this virtual service.
		# dns_info: # Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
		# content_rewrite: # Profile used to match and rewrite strings in request and/or response body.
		# traffic_clone_profile_ref: # Server network or list of servers for cloning traffic.
		# avi_allocated_vip: # (internal-use) vip allocated by avi in the cloud infrastructure.
		# vrf_context_ref: # Virtual routing context that the virtual service is bound to.
		# description: # User defined description for the object.
		# subnet: # Subnet providing reachability for client facing virtual service ip.
		# service_metadata: # Metadata pertaining to the service provided by this virtual service.
		# cloud_type: # Enum options - cloud_none, cloud_vcenter, cloud_openstack, cloud_aws, cloud_vca, cloud_apic, cloud_mesos, cloud_linuxserver, cloud_docker_ucp,
		# vh_domain_name: # The exact name requested from the client's sni-enabled tls hello domain name field.
		# cloud_ref: # It is a reference to an object of type cloud.
		# enable_rhi: # Enable route health injection using the bgp config in the vrf context.
		# se_group_ref: # The service engine group to use for this virtual service.
		# waf_policy_ref: # Waf policy for the virtual service.
		# network_ref: # Manually override the network on which the virtual service is placed.
		# scaleout_ecmp: # Disable re-distribution of flows across service engines for a virtual service.
		# state: absent|#present
		# nsx_securitygroup: # A list of nsx service groups representing the clients which can access the virtual ip of the virtual service.
		# cloud_config_cksum: # Checksum of cloud configuration for vs.
		# api_version: 16.4.4
		# tenant_uuid: 
		# vsvip_ref: # Mostly used during the creation of shared vs, this field refers to entities that can be shared across virtual services.
		# performance_limits: # Optional settings that determine performance limits like max connections or bandwdith etc.
		# use_bridge_ip_as_vip: # Use bridge ip as vip on each host in mesos deployments.
		# enabled: # Enable or disable the virtual service.
		# floating_ip: # Floating ip to associate with this virtual service.
		# auto_allocate_floating_ip: # Auto-allocate floating/elastic ip from the cloud infrastructure.
		# avi_api_patch_op: add|replace|delete
		# vh_parent_vs_uuid: # Specifies the virtual service acting as virtual hosting (sni) parent.
		# services: # List of services defined for this virtual service.
		# connections_rate_limit: # Rate limit the incoming connections to this virtual service.
		# active_standby_se_tag: # This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.
		# pool_ref: # The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.
		# ign_pool_net_reach: # Ignore pool servers network reachability constraints for virtual service placement.
		# tenant: admin
		# limit_doser: # Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.
		# url: # Avi controller URL of the object.
		# auto_allocate_ip: # Auto-allocate vip from the provided subnet.
		# fqdn: # Dns resolvable, fully qualified domain name of the virtualservice.
		# network_security_policy_ref: # Network security policies for the virtual service.
		# dns_policies: # Dns policies applied on the dns traffic of the virtual service.
		# server_network_profile_ref: # Determines the network settings profile for the server side of tcp proxied connections.
		# discovered_subnet: # (internal-use) discovered subnets providing reachability for client facing virtual service ip.
$0
endsnippet

snippet avi_healthmonitor "Module for setup of HealthMonitor Avi RESTful Object" b
- name: $1
	avi_healthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# username: 
		# https_monitor: # Healthmonitorhttp settings for healthmonitor.
		# receive_timeout: # A valid response from the server is expected within the receive timeout window.
		# description: # User defined description for the object.
		# state: absent|#present
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# controller: 
		# udp_monitor: # Healthmonitorudp settings for healthmonitor.
		# http_monitor: # Healthmonitorhttp settings for healthmonitor.
		# password: 
		# avi_api_update_method: #put|patch
		# successful_checks: # Number of continuous successful health checks before server is marked up.
		# monitor_port: # Use this port instead of the port defined for the server in the pool.
		# uuid: # Uuid of the health monitor.
		# url: # Avi controller URL of the object.
		# dns_monitor: # Healthmonitordns settings for healthmonitor.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# is_federated: # This field describes the object's replication scope.
		# failed_checks: # Number of continuous failed health checks before the server is marked down.
		# tcp_monitor: # Healthmonitortcp settings for healthmonitor.
		# avi_api_patch_op: add|replace|delete
		# send_interval: # Frequency, in seconds, that monitors are sent to a server.
		# tenant: admin
		# external_monitor: # Healthmonitorexternal settings for healthmonitor.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_analyticsprofile "Module for setup of AnalyticsProfile Avi RESTful Object" b
- name: $1
	avi_analyticsprofile:
		name: ${2:# The name of the analytics profile.}
		# disable_se_analytics: # Disable node (service engine) level analytics forvs metrics.
		# apdex_server_rtt_tolerated_factor: # Tolerated client to avi round trip time(rtt) factor.
		# hs_security_tls12_score: # Score assigned when supporting tls1.2 encryption protocol.
		# exclude_no_dns_record_as_error: # Exclude queries to domains that did not have configured services/records from the list of errors.
		# conn_server_lossy_zero_win_size_event_threshold: # A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
		# conn_lossy_total_rexmt_threshold: # A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.
		# hs_security_certscore_le07d: # Score assigned when the certificate expires in less than or equal to 7 days.
		# hs_pscore_traffic_threshold_l4_client: # Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
		# exclude_no_valid_gs_member_as_error: # Exclude queries to gslb services that have no available members from the list of errors.
		# hs_security_cipherscore_ge128b: # Score assigned when the minimum cipher strength is greater than equal to 128 bits.
		# uuid: # Uuid of the analytics profile.
		# exclude_invalid_dns_domain_as_error: # Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.
		# exclude_http_error_codes: # List of http status codes to be excluded from being classified as an error.
		# hs_max_anomaly_penalty: # Maximum penalty that may be deducted from health score for anomalies.
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# conn_server_lossy_ooo_threshold: # A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.
		# exclude_persistence_change_as_error: # Exclude persistence server changed while load balancing' from the list of errors.
		# hs_security_selfsignedcert_penalty: # Deprecated.
		# conn_server_lossy_total_rexmt_threshold: # A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.
		# username: 
		# hs_security_certscore_le30d: # Score assigned when the certificate expires in less than or equal to 30 days.
		# exclude_syn_retransmit_as_error: # Exclude 'server unanswered syns' from the list of errors.
		# controller: 
		# hs_security_hsts_penalty: # Penalty for not enabling hsts.
		# apdex_rum_threshold: # If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.
		# password: 
		# avi_api_update_method: #put|patch
		# conn_lossy_zero_win_size_event_threshold: # A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
		# hs_security_encalgo_score_rc4: # Score assigned when rc4 algorithm is used for encryption.
		# apdex_rtt_threshold: # Satisfactory client to avi round trip time(rtt).
		# tenant_ref: # It is a reference to an object of type tenant.
		# apdex_response_tolerated_factor: # Client tolerated response latency factor.
		# exclude_tcp_reset_as_error: # Exclude tcp resets by client from the list of potential errors.
		# hs_security_chain_invalidity_penalty: # Penalty for allowing certificates with invalid chain.
		# exclude_invalid_dns_query_as_error: # Exclude invalid dns queries from the list of errors.
		# conn_lossy_ooo_threshold: # A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.
		# hs_security_cipherscore_lt128b: # Score assigned when the minimum cipher strength is less than 128 bits.
		# hs_security_encalgo_score_none: # Score assigned when no algorithm is used for encryption.
		# hs_event_throttle_window: # Time window (in secs) within which only unique health change events should occur.
		# hs_security_nonpfs_penalty: # Penalty for allowing non-pfs handshakes.
		# hs_security_certscore_gt30d: # Score assigned when the certificate expires in more than 30 days.
		# exclude_server_tcp_reset_as_error: # Exclude server tcp reset from errors.
		# hs_min_dos_rate: # Dos connection rate below which the dos security assessment will not kick in.
		# hs_max_resources_penalty: # Maximum penalty that may be deducted from health score for high resource utilization.
		# client_log_streaming_config: # Configure to stream logs to an external server.
		# apdex_server_response_threshold: # A server http response is considered satisfied if latency is less than the satisfactory latency threshold.
		# hs_performance_boost: # Adds free performance score credits to health score.
		# client_log_config: # Configure which logs are sent to the avi controller from ses and how they are processed.
		# exclude_gs_down_as_error: # Exclude queries to gslb services that are operationally down from the list of errors.
		# apdex_server_response_tolerated_factor: # Server tolerated response latency factor.
		# state: absent|#present
		# disable_server_analytics: # Disable analytics on backend servers.
		# conn_server_lossy_timeo_rexmt_threshold: # A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.
		# exclude_client_close_before_request_as_error: # Exclude client closed connection before an http request could be completed from being classified as an error.
		# hs_security_weak_signature_algo_penalty: # Penalty for allowing weak signature algorithm(s).
		# conn_lossy_timeo_rexmt_threshold: # A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.
		# api_version: 16.4.4
		# apdex_rtt_tolerated_factor: # Tolerated client to avi round trip time(rtt) factor.
		# description: # User defined description for the object.
		# hs_security_ssl30_score: # Score assigned when supporting ssl3.0 encryption protocol.
		# apdex_rum_tolerated_factor: # Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.
		# hs_security_cipherscore_eq000b: # Score assigned when the minimum cipher strength is 0 bits.
		# ranges: # List of http status code ranges to be excluded from being classified as an error.
		# apdex_server_rtt_threshold: # Satisfactory client to avi round trip time(rtt).
		# exclude_server_dns_error_as_error: # Exclude server dns error response from the list of errors.
		# hs_security_tls11_score: # Score assigned when supporting tls1.1 encryption protocol.
		# resp_code_block: # Block of http response codes to be excluded from being classified as an error.
		# tenant: admin
		# hs_pscore_traffic_threshold_l4_server: # Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
		# hs_max_security_penalty: # Maximum penalty that may be deducted from health score based on security assessment.
		# exclude_dns_policy_drop_as_significant: # Exclude dns policy drops from the list of errors.
		# tenant_uuid: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# url: # Avi controller URL of the object.
		# hs_security_tls10_score: # Score assigned when supporting tls1.0 encryption protocol.
		# hs_security_certscore_expired: # Score assigned when the certificate has expired.
		# apdex_response_threshold: # If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.
		# exclude_unsupported_dns_query_as_error: # Exclude unsupported dns queries from the list of errors.
$0
endsnippet

snippet avi_gslb "Module for setup of Gslb Avi RESTful Object" b
- name: $1
	avi_gslb:
		leader_cluster_uuid: ${2:# Mark this site as leader of gslb configuration.}
		name: ${3:# Name for the gslb object.}
		# username: 
		# description: # User defined description for the object.
		# state: absent|#present
		# maintenance_mode: # This field disables the configuration operations on the leader for all federated objects.
		# third_party_sites: # Third party site member belonging to this gslb.
		# sites: # Select avi site member belonging to this gslb.
		# controller: 
		# dns_configs: # Sub domain configuration for the gslb.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the gslb object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# clear_on_max_retries: # Max retries after which the remote site is treated as a fresh start.
		# avi_api_patch_op: add|replace|delete
		# send_interval: # Frequency with which group members communicate.
		# tenant: admin
		# client_ip_addr_group: # Group to specify if the client ip addresses are public or private.
		# view_id: # The view-id is used in change-leader mode to differentiate partitioned groups while they have the same gslb namespace.
		# api_version: 16.4.4
		# tenant_uuid: 
$0
endsnippet

snippet avi_prioritylabels "Module for setup of PriorityLabels Avi RESTful Object" b
- name: $1
	avi_prioritylabels:
		name: ${2:# The name of the priority labels.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the priority labels.
		# tenant_uuid: 
		# cloud_ref: # It is a reference to an object of type cloud.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# equivalent_labels: # Equivalent priority labels in descending order.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# description: # A description of the priority labels.
$0
endsnippet

snippet avi_pool "Module for setup of Pool Avi RESTful Object" b
- name: $1
	avi_pool:
		name: ${2:# The name of the pool.}
		# lb_algorithm: # The load balancing algorithm will pick a server within the pool's list of available servers.
		# use_service_port: # Do not translate the client's destination port when sending the connection to the server.
		# rewrite_host_header_to_server_name: # Rewrite incoming host header to server name of the server to which the request is proxied.
		# host_check_enabled: # Enable common name check for server certificate.
		# enabled: # Enable or disable the pool.
		# rewrite_host_header_to_sni: # If sni server name is specified, rewrite incoming host header to the sni server name.
		# capacity_estimation: # Inline estimation of capacity of servers.
		# max_conn_rate_per_server: # Rate limit connections to each server.
		# servers: # The pool directs load balanced traffic to this list of destination servers.
		# apic_epg_name: # Synchronize cisco apic epg members with pool servers.
		# fewest_tasks_feedback_delay: # Periodicity of feedback for fewest tasks server selection algorithm.
		# server_auto_scale: # Server autoscale.
		# ipaddrgroup_ref: # Use list of servers from ip address group.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# capacity_estimation_ttfb_thresh: # The maximum time-to-first-byte of a server.
		# ab_pool: # A/b pool configuration.
		# fail_action: # Enable an action - close connection, http redirect or local http response - when a pool failure happens.
		# lookup_server_by_name: # Allow server lookup by name.
		# networks: # (internal-use) networks designated as containing servers for this pool.
		# lb_algorithm_hash: # Criteria used as a key for determining the hash between the client and  server.
		# health_monitor_refs: # Verify server health by applying one or more health monitors.
		# sni_enabled: # Enable tls sni for server connections.
		# server_name: # Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.
		# lb_algorithm_consistent_hash_hdr: # Http header name to be used for the hash key.
		# cloud_ref: # It is a reference to an object of type cloud.
		# lb_algorithm_core_nonaffinity: # Degree of non-affinity for core afffinity based server selection.
		# autoscale_policy_ref: # Reference to server autoscale policy.
		# ssl_profile_ref: # When enabled, avi re-encrypts traffic to the backend servers.
		# east_west: # Inherited config from virtualservice.
		# placement_networks: # Manually select the networks and subnets used to provide reachability to the pool's servers.
		# graceful_disable_timeout: # Used to gracefully disable a server.
		# avi_api_patch_op: add|replace|delete
		# nsx_securitygroup: # A list of nsx service groups where the servers for the pool are created.
		# tenant: admin
		# a_pool: # Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.
		# pki_profile_ref: # Avi will validate the ssl certificate present by a server against the selected pki profile.
		# api_version: 16.4.4
		# vrf_ref: # Virtual routing context that the pool is bound to.
		# username: 
		# application_persistence_profile_ref: # Persistence will ensure the same user sticks to the same server for a desired duration of time.
		# inline_health_monitor: # The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.
		# default_server_port: # Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.
		# description: # A description of the pool.
		# request_queue_depth: # Minimum number of requests to be queued when pool is full.
		# state: absent|#present
		# server_reselect: # Server reselect configuration for http requests.
		# ab_priority: # Priority of this pool in a a-b pool pair.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# ssl_key_and_certificate_ref: # Service engines will present a client ssl certificate to the server.
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the pool.
		# autoscale_launch_config_ref: # If configured then avi will trigger orchestration of pool server creation and deletion.
		# request_queue_enabled: # Enable request queue when pool is full.
		# max_concurrent_connections_per_server: # The maximum number of concurrent connections allowed to each server within the pool.
		# url: # Avi controller URL of the object.
		# prst_hdr_name: # Header name for custom header persistence.
		# tenant_ref: # It is a reference to an object of type tenant.
		# server_count: # Number of server_count.
		# autoscale_networks: # Network ids for the launch configuration.
		# domain_name: # Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.
		# connection_ramp_duration: # Duration for which new connections will be gradually ramped up to a server recently brought online.
		# cloud_config_cksum: # Checksum of cloud configuration for pool.
		# external_autoscale_groups: # Names of external auto-scale groups for pool servers.
		# tenant_uuid: 
		# created_by: # Creator name.
		# gslb_sp_enabled: # Indicates if the pool is a site-persistence pool.
$0
endsnippet

snippet avi_snmptrapprofile "Module for setup of SnmpTrapProfile Avi RESTful Object" b
- name: $1
	avi_snmptrapprofile:
		name: ${2:# A user-friendly name of the snmp trap configuration.}
		# username: 
		# api_version: 16.4.4
		# trap_servers: # The ip address or hostname of the snmp trap destination server.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the snmp trap profile object.
$0
endsnippet

snippet avi_applicationprofile "Module for setup of ApplicationProfile Avi RESTful Object" b
- name: $1
	avi_applicationprofile:
		type: ${2:# Specifies which application layer proxy is enabled for the virtual service.}
		name: ${3:# The name of the application profile.}
		# dos_rl_profile: # Specifies various security related controls for virtual service.
		# preserve_client_ip: # Specifies if client ip needs to be preserved for backend connection.
		# tcp_app_profile: # Specifies the tcp application proxy profile parameters.
		# uuid: # Uuid of the application profile.
		# dns_service_profile: # Specifies various dns service related controls for virtual service.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_update_method: #put|patch
		# api_version: 16.4.4
		# username: 
		# description: # User defined description for the object.
		# http_profile: # Specifies the http application proxy profile parameters.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# tenant_uuid: 
$0
endsnippet

snippet avi_poolgroup "Module for setup of PoolGroup Avi RESTful Object" b
- name: $1
	avi_poolgroup:
		name: ${2:# The name of the pool group.}
		# username: 
		# description: # Description of pool group.
		# implicit_priority_labels: # Whether an implicit set of priority labels is generated.
		# controller: 
		# members: # List of pool group members object of type poolgroupmember.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# fail_action: # Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.
		# password: 
		# avi_api_update_method: #put|patch
		# priority_labels_ref: # Uuid of the priority labels.
		# uuid: # Uuid of the pool group.
		# cloud_ref: # It is a reference to an object of type cloud.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# created_by: # Name of the user who created the object.
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# cloud_config_cksum: # Checksum of cloud configuration for poolgroup.
		# tenant: admin
		# min_servers: # The minimum number of servers to distribute traffic to.
		# deployment_policy_ref: # When setup autoscale manager will automatically promote new pools into production when deployment goals are met.
		# api_version: 16.4.4
$0
endsnippet

snippet avi_vsdatascriptset "Module for setup of VSDataScriptSet Avi RESTful Object" b
- name: $1
	avi_vsdatascriptset:
		name: ${2:# Name for the virtual service datascript collection.}
		# pool_refs: # Uuid of pools that could be referred by vsdatascriptset objects.
		# pool_group_refs: # Uuid of pool groups that could be referred by vsdatascriptset objects.
		# string_group_refs: # Uuid of string groups that could be referred by vsdatascriptset objects.
		# ipgroup_refs: # Uuid of ip groups that could be referred by vsdatascriptset objects.
		# uuid: # Uuid of the virtual service datascript collection.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# created_by: # Creator name.
		# avi_api_patch_op: add|replace|delete
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# api_version: 16.4.4
		# username: 
		# description: # User defined description for the object.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# datascript: # Datascripts to execute.
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# tenant_uuid: 
$0
endsnippet

snippet avi_scheduler "Module for setup of Scheduler Avi RESTful Object" b
- name: $1
	avi_scheduler:
		name: ${2:# Name of scheduler.}
		# username: 
		# state: absent|#present
		# enabled: # Boolean flag to set enabled.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# backup_config_ref: # Backup configuration to be executed by this scheduler.
		# controller: 
		# frequency: # Frequency at which custom scheduler will run.
		# scheduler_action: # Define scheduler action.
		# end_date_time: # Scheduler end date and time.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
		# start_date_time: # Scheduler start date and time.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# frequency_unit: # Unit at which custom scheduler will run.
		# avi_api_patch_op: add|replace|delete
		# run_script_ref: # Control script to be executed by this scheduler.
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# run_mode: # Scheduler run mode.
$0
endsnippet

snippet avi_errorpagebody "Module for setup of ErrorPageBody Avi RESTful Object" b
- name: $1
	avi_errorpagebody:
		name: ${2:# Field introduced in 17.2.4.}
		# username: 
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# error_page_body: # Error page body sent to client when match.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Field introduced in 17.2.4.
$0
endsnippet

snippet avi_httppolicyset "Module for setup of HTTPPolicySet Avi RESTful Object" b
- name: $1
	avi_httppolicyset:
		name: ${2:# Name of the http policy set.}
		# http_security_policy: # Http security policy for the virtual service.
		# uuid: # Uuid of the http policy set.
		# state: absent|#present
		# created_by: # Creator name.
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_update_method: #put|patch
		# http_request_policy: # Http request policy for the virtual service.
		# api_version: 16.4.4
		# username: 
		# description: # User defined description for the object.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# cloud_config_cksum: # Checksum of cloud configuration for pool.
		# http_response_policy: # Http response policy for the virtual service.
		# tenant_uuid: 
		# is_internal_policy: # Boolean flag to set is_internal_policy.
$0
endsnippet

snippet avi_alertsyslogconfig "Module for setup of AlertSyslogConfig Avi RESTful Object" b
- name: $1
	avi_alertsyslogconfig:
		name: ${2:# A user-friendly name of the syslog notification.}
		# username: 
		# api_version: 16.4.4
		# syslog_servers: # The list of syslog servers.
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# description: # User defined description for alert syslog config.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_api_version "Avi API Version Module" b
- name: $1
	avi_api_version:
		# username: 
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# api_version: 16.4.4
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant_uuid: 
		# tenant: admin
$0
endsnippet

snippet avi_ipamdnsproviderprofile "Module for setup of IpamDnsProviderProfile Avi RESTful Object" b
- name: $1
	avi_ipamdnsproviderprofile:
		name: ${2:# Name for the ipam/dns provider profile.}
		type: ${3:# Provider type for the ipam/dns provider profile.}
		# username: 
		# state: absent|#present
		# proxy_configuration: # Field introduced in 17.1.1.
		# infoblox_profile: # Provider details if type is infoblox.
		# controller: 
		# allocate_ip_in_vrf: # If this flag is set, only allocate ip from networks in the virtual service vrf.
		# internal_profile: # Provider details if type is avi.
		# aws_profile: # Provider details if type is aws.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the ipam/dns provider profile.
		# azure_profile: # Provider details if type is microsoft azure.
		# openstack_profile: # Provider details if type is openstack.
		# gcp_profile: # Provider details if type is google cloud.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# custom_profile: # Provider details if type is custom.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_microservicegroup "Module for setup of MicroServiceGroup Avi RESTful Object" b
- name: $1
	avi_microservicegroup:
		name: ${2:# Name of the microservice group.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the microservice group.
		# url: # Avi controller URL of the object.
		# description: # User defined description for the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# created_by: # Creator name.
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# service_refs: # Configure microservice(es).
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_errorpageprofile "Module for setup of ErrorPageProfile Avi RESTful Object" b
- name: $1
	avi_errorpageprofile:
		name: ${2:# Field introduced in 17.2.4.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Field introduced in 17.2.4.
		# tenant_uuid: 
		# error_pages: # Defined error pages for http status codes.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant: admin
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# company_name: # Name of the company to show in error page.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# host_name: # Fully qualified domain name for which the error page is generated.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# app_name: # Name of the virtual service which generated the error page.
$0
endsnippet

snippet avi_seproperties "Module for setup of SeProperties Avi RESTful Object" b
- name: $1
	avi_seproperties:
		# username: 
		# se_agent_properties: # Seagentproperties settings for seproperties.
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# se_runtime_properties: # Seruntimeproperties settings for seproperties.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# state: absent|#present
		# api_version: 16.4.4
		# avi_api_patch_op: add|replace|delete
		# se_bootup_properties: # Sebootupproperties settings for seproperties.
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant_uuid: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_gslbservice "Module for setup of GslbService Avi RESTful Object" b
- name: $1
	avi_gslbservice:
		name: ${2:# Name for the gslb service.}
		# username: 
		# application_persistence_profile_ref: # The federated application persistence associated with gslbservice site persistence functionality.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# description: # User defined description for the object.
		# wildcard_match: # Enable wild-card match of fqdn  if an exact match is not found in the dns table, the longest match is chosen by wild-carding the fqdn in the dns
		# enabled: # Enable or disable the gslb service.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# controller: 
		# domain_names: # Fully qualified domain name of the gslb service.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# use_edns_client_subnet: # Use the client ip subnet from the edns option as source ipaddress for client geo-location and consistent hash algorithm.
		# groups: # Select list of pools belonging to this gslb service.
		# ttl: # Ttl value (in seconds) for records served for this gslb service by the dns service.
		# password: 
		# health_monitor_scope: # Health monitor probe can be executed for all the members or it can be executed only for third-party members.
		# avi_api_update_method: #put|patch
		# controller_health_status_enabled: # Gs member's overall health status is derived based on a combination of controller and datapath health-status inputs.
		# uuid: # Uuid of the gslb service.
		# url: # Avi controller URL of the object.
		# down_response: # Response to the client query when the gslb service is down.
		# tenant_ref: # It is a reference to an object of type tenant.
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# api_version: 16.4.4
		# health_monitor_refs: # Verify vs health by applying one or more health monitors.
		# state: absent|#present
		# tenant: admin
		# site_persistence_enabled: # Enable site-persistence for the gslbservice.
		# min_members: # The minimum number of members to distribute traffic to.
		# tenant_uuid: 
		# pool_algorithm: # The load balancing algorithm will pick a gslb pool within the gslb service list of available pools.
		# num_dns_ip: # Number of ip addresses of this gslb service to be returned by the dns service.
$0
endsnippet

snippet avi_backup "Module for setup of Backup Avi RESTful Object" b
- name: $1
	avi_backup:
		file_name: ${2:# The file name of backup.}
		# scheduler_ref: # Scheduler information.
		# username: 
		# api_version: 16.4.4
		# uuid: # Unique object identifier of the object.
		# local_file_url: # Url to download the backup file.
		# url: # Avi controller URL of the object.
		# remote_file_url: # Url to download the backup file.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# backup_config_ref: # Backupconfiguration information.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# timestamp: # Unix timestamp of when the backup file is created.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_customipamdnsprofile "Module for setup of CustomIpamDnsProfile Avi RESTful Object" b
- name: $1
	avi_customipamdnsprofile:
		name: ${2:# Name of the custom ipam dns profile.}
		script_uri: ${3:# Script uri of form controller //ipamdnsscripts/<file-name>.}
		# username: 
		# password: 
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# script_params: # Parameters that are always passed to the ipam/dns script.
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Field introduced in 17.1.1.
$0
endsnippet

snippet avi_serviceenginegroup "Module for setup of ServiceEngineGroup Avi RESTful Object" b
- name: $1
	avi_serviceenginegroup:
		name: ${2:# Name of the object.}
		# se_vs_hb_max_vs_in_pkt: # Maximum number of virtualservices for which heartbeat messages are aggregated in one packet.
		# disable_tso: # Disable tcp segmentation offload (tso) in dpdk poll-mode driver packet transmit path.
		# host_attribute_value: # Value of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
		# async_ssl: # Ssl handshakes will be handled by dedicated ssl threads.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# instance_flavor: # Instance/flavor type for se instance.
		# auto_redistribute_active_standby_load: # Redistribution of virtual services from the takeover se to the replacement se can cause momentary traffic loss.
		# auto_rebalance: # If set, virtual services will be automatically migrated when load on an se is less than minimum or more than maximum thresholds.
		# disk_per_se: # Amount of disk space for each of the service engine virtual machines.
		# se_tunnel_mode: # Determines if dsr from secondary se is active or not  0  automatically determine based on hypervisor type.
		# uuid: # Unique object identifier of the object.
		# se_tunnel_udp_port: # Udp port for tunneled packets from secondary to primary se in docker bridge mode.
		# disable_gro: # Disable generic receive offload (gro) in dpdk poll-mode driver packet receive path.
		# vs_scalein_timeout: # Time to wait for the scaled in se to drain existing flows before marking the scalein done.
		# mgmt_subnet: # Management subnet to use for avi service engines.
		# cloud_ref: # It is a reference to an object of type cloud.
		# se_remote_punt_udp_port: # Udp port for punted packets in docker bridge mode.
		# se_udp_encap_ipc: # Determines if se-se ipc messages are encapsulated in an udp header  0  automatically determine based on hypervisor type.
		# min_cpu_usage: # When cpu usage on an se falls below the minimum threshold, virtual services hosted on the se may be consolidated onto other underutilized ses.
		# custom_securitygroups_data: # Custom security groups to be associated with data vnics for se instances in openstack and aws clouds.
		# ingress_access_data: # Program se security group ingress rules to allow vip data access from remote cidr type.
		# vcenter_clusters: # Vcenterclusters settings for serviceenginegroup.
		# enable_vip_on_all_interfaces: # Enable vip on all interfaces of se.
		# ingress_access_mgmt: # Program se security group ingress rules to allow ssh/icmp management access from remote cidr type.
		# iptables: # Iptable rules.
		# max_vs_per_se: # Maximum number of virtual services that can be placed on a single service engine.
		# connection_memory_percentage: # Percentage of memory for connection state.
		# service_ip_subnets: # Subnets assigned to the se group.
		# placement_mode: # If placement mode is 'auto', virtual services are automatically placed on service engines.
		# max_scaleout_per_vs: # Maximum number of active service engines for the virtual service.
		# os_reserved_memory: # Amount of extra memory to be reserved for use by the operating system on a service engine.
		# enable_routing: # Enable routing for this serviceenginegroup .
		# waf_mempool: # Enable memory pool for waf.
		# controller: 
		# per_app: # Per-app se mode is designed for deploying dedicated load balancers per app (vs).
		# openstack_availability_zones: # Field introduced in 17.1.1.
		# vcenter_datastores_include: # Boolean flag to set vcenter_datastores_include.
		# se_name_prefix: # Prefix to use for virtual machine name of service engines.
		# avi_api_update_method: #put|patch
		# flow_table_new_syn_max_entries: # Maximum number of flow table entries that have not completed tcp three-way handshake yet.
		# se_vs_hb_max_pkts_in_batch: # Maximum number of aggregated vs heartbeat packets to send in a batch.
		# ignore_rtt_threshold: # Ignore rtt samples if it is above threshold.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# host_attribute_key: # Key of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
		# username: 
		# url: # Avi controller URL of the object.
		# dedicated_dispatcher_core: # Dedicate the core that handles packet receive/transmit from the network to just the dispatching function.
		# max_se: # Maximum number of services engines in this group.
		# api_version: 16.4.4
		# mem_reserve: # Boolean flag to set mem_reserve.
		# license_type: # If no license type is specified then default license enforcement for the cloud type is chosen.
		# se_dos_profile: # Dosthresholdprofile settings for serviceenginegroup.
		# enable_vmac: # Use virtual mac address for interfaces on which floating interface ips are placed.
		# tenant_uuid: 
		# disable_csum_offloads: # Stop using tcp/udp and ip checksum offload features of nics.
		# openstack_mgmt_network_name: # Avi management network name.
		# udf_log_throttle: # This setting limits the number of udf logs generated per second per core on this se.
		# vcenter_hosts: # Vcenterhosts settings for serviceenginegroup.
		# se_ipc_udp_port: # Udp port for se_dp ipc in docker bridge mode.
		# vcpus_per_se: # Number of vcpus for each of the service engine virtual machines.
		# hm_on_standby: # Enable active health monitoring from the standby se for all placed virtual services.
		# se_sb_dedicated_core: # Sideband traffic will be handled by a dedicated core.
		# cpu_socket_affinity: # Allocate all the cpu cores for the service engine virtual machines  on the same cpu socket.
		# realtime_se_metrics: # Enable or disable real time se metrics.
		# archive_shm_limit: # Amount of se memory in gb until which shared memory is collected in core archive.
		# hardwaresecuritymodulegroup_ref: # It is a reference to an object of type hardwaresecuritymodulegroup.
		# custom_securitygroups_mgmt: # Custom security groups to be associated with management vnic for se instances in openstack and aws clouds.
		# custom_tag: # Custom tag will be used to create the tags for se instance in aws.
		# floating_intf_ip_se_2: # If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
		# se_deprovision_delay: # Duration to preserve unused service engine virtual machines before deleting them.
		# log_disksz: # Maximum disk capacity (in mb) to be allocated to an se.
		# password: 
		# non_significant_log_throttle: # This setting limits the number of non-significant logs generated per second per core on this se.
		# openstack_availability_zone: # Field deprecated in 17.1.1.
		# extra_shared_config_memory: # Extra config memory to support large geo db configuration.
		# auto_rebalance_interval: # Frequency of rebalance, if 'auto rebalance' is enabled.
		# avi_api_patch_op: add|replace|delete
		# vcenter_datastores: # List of vcenterdatastore.
		# state: absent|#present
		# se_sb_threads: # Number of sideband threads per se.
		# vs_scaleout_timeout: # Time to wait for the scaled out se to become ready before marking the scaleout done.
		# active_standby: # Service engines in active/standby mode for ha failover.
		# auto_rebalance_capacity_per_se: # Capacities of se for auto rebalance for each criteria.
		# num_flow_cores_sum_changes_to_ignore: # Number of changes in num flow cores sum to ignore.
		# se_probe_port: # Tcp port on se where echo service will be run.
		# algo: # In compact placement, virtual services are placed on existing ses until max_vs_per_se limit is reached.
		# extra_config_multiplier: # Multiplier for extra config to support large vs/pool config.
		# async_ssl_threads: # Number of async ssl threads per se_dp.
		# description: # User defined description for the object.
		# openstack_mgmt_network_uuid: # Management network uuid.
		# vcenter_folder: # Folder to place all the service engine virtual machines in vcenter.
		# vs_scalein_timeout_for_upgrade: # During se upgrade, time to wait for the scaled-in se to drain existing flows before marking the scalein done.
		# cpu_reserve: # Boolean flag to set cpu_reserve.
		# allow_burst: # Allow ses to be created using burst license.
		# floating_intf_ip: # If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
		# advertise_backend_networks: # Advertise reach-ability of backend server networks via adc through bgp for default gateway feature.
		# mgmt_network_ref: # Management network to use for avi service engines.
		# memory_per_se: # Amount of memory for each of the service engine virtual machines.
		# max_cpu_usage: # When cpu usage on an se exceeds this threshold, virtual services hosted on this se may be rebalanced to other ses to reduce load.
		# min_scaleout_per_vs: # Minimum number of active service engines for the virtual service.
		# license_tier: # Specifies the license tier which would be used.
		# vss_placement: # If set, virtual services will be placed on only a subset of the cores of an se.
		# host_gateway_monitor: # Enable the host gateway monitor when service engine is deployed as docker container.
		# buffer_se: # Excess service engine capacity provisioned for ha failover.
		# hypervisor: # Override default hypervisor.
		# ha_mode: # High availability mode for all the virtual services using this service engine group.
		# vcenter_datastore_mode: # Enum options - vcenter_datastore_any, vcenter_datastore_local, vcenter_datastore_shared.
		# auto_rebalance_criteria: # Set of criteria for se auto rebalance.
		# distribute_load_active_standby: # Use both the active and standby service engines for virtual service placement in the legacy active standby ha mode.
		# least_load_core_selection: # Select core with least load for new flow.
		# aggressive_failure_detection: # Enable aggressive failover configuration for ha.
		# significant_log_throttle: # This setting limits the number of significant logs generated per second per core on this se.
		# waf_mempool_size: # Memory pool size used for waf.
		# se_bandwidth_type: # Select the se bandwidth for the bandwidth license.
		# se_thread_multiplier: # Multiplier for se threads based on vcpu.
		# vs_host_redundancy: # Ensure primary and secondary service engines are deployed on different physical hosts.
		# tenant: admin
$0
endsnippet

snippet avi_stringgroup "Module for setup of StringGroup Avi RESTful Object" b
- name: $1
	avi_stringgroup:
		type: ${2:# Type of stringgroup.}
		name: ${3:# Name of the string group.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the string group.
		# url: # Avi controller URL of the object.
		# description: # User defined description for the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# kv: # Configure key value in the string group.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# tenant: admin
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_networksecuritypolicy "Module for setup of NetworkSecurityPolicy Avi RESTful Object" b
- name: $1
	avi_networksecuritypolicy:
		# username: 
		# api_version: 16.4.4
		# uuid: # Unique object identifier of the object.
		# tenant_uuid: 
		# rules: # List of networksecurityrule.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# created_by: # Creator name.
		# name: # Name of the object.
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# cloud_config_cksum: # Checksum of cloud configuration for network sec policy.
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# description: # User defined description for the object.
$0
endsnippet

snippet avi_backupconfiguration "Module for setup of BackupConfiguration Avi RESTful Object" b
- name: $1
	avi_backupconfiguration:
		name: ${2:# Name of backup configuration.}
		# remote_hostname: # Remote destination.
		# remote_directory: # Directory at remote destination with write permission for ssh user.
		# uuid: # Unique object identifier of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_patch_op: add|replace|delete
		# state: absent|#present
		# save_local: # Local backup.
		# upload_to_remote_host: # Remote backup.
		# backup_file_prefix: # Prefix of the exported configuration file.
		# api_version: 16.4.4
		# username: 
		# backup_passphrase: # Passphrase of backup configuration.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# tenant: admin
		# ssh_user_ref: # Access credentials for remote destination.
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# maximum_backups_stored: # Rotate the backup files based on this count.
		# tenant_uuid: 
$0
endsnippet

snippet avi_cloud "Module for setup of Cloud Avi RESTful Object" b
- name: $1
	avi_cloud:
		vtype: ${2:# Cloud type.}
		name: ${3:# Name of the object.}
		# vca_configuration: # Vcloudairconfiguration settings for cloud.
		# proxy_configuration: # Proxyconfiguration settings for cloud.
		# docker_configuration: # Dockerconfiguration settings for cloud.
		# oshiftk8s_configuration: # Oshiftk8sconfiguration settings for cloud.
		# mtu: # Mtu setting for the cloud.
		# rancher_configuration: # Rancherconfiguration settings for cloud.
		# uuid: # Unique object identifier of the object.
		# linuxserver_configuration: # Linuxserverconfiguration settings for cloud.
		# custom_tags: # Custom tags for all avi created resources in the cloud infrastructure.
		# state: absent|#present
		# nsx_configuration: # Configuration parameters for nsx manager.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# apic_mode: # Boolean flag to set apic_mode.
		# dns_provider_ref: # Dns profile for the cloud.
		# api_version: 16.4.4
		# username: 
		# mesos_configuration: # Mesosconfiguration settings for cloud.
		# openstack_configuration: # Openstackconfiguration settings for cloud.
		# enable_vip_static_routes: # Use static routes for vip side network resolution during virtualservice placement.
		# controller: 
		# aws_configuration: # Awsconfiguration settings for cloud.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# ipam_provider_ref: # Ipam profile for the cloud.
		# cloudstack_configuration: # Cloudstackconfiguration settings for cloud.
		# password: 
		# avi_api_update_method: #put|patch
		# azure_configuration: # Field introduced in 17.2.1.
		# license_tier: # Specifies the default license tier which would be used by new se groups.
		# state_based_dns_registration: # Dns records for vips are added/deleted based on the operational state of the vips.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# dhcp_enabled: # Select the ip address management scheme.
		# east_west_ipam_provider_ref: # Ipam profile for east-west services.
		# obj_name_prefix: # Default prefix for all automatically created objects in this cloud.
		# apic_configuration: # Apicconfiguration settings for cloud.
		# prefer_static_routes: # Prefer static routes over interface routes during virtualservice placement.
		# license_type: # If no license type is specified then default license enforcement for the cloud type is chosen.
		# vcenter_configuration: # Vcenterconfiguration settings for cloud.
		# tenant_uuid: 
		# east_west_dns_provider_ref: # Dns profile for east-west services.
$0
endsnippet

snippet avi_dnspolicy "Module for setup of DnsPolicy Avi RESTful Object" b
- name: $1
	avi_dnspolicy:
		name: ${2:# Name of the dns policy.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the dns policy.
		# url: # Avi controller URL of the object.
		# description: # Field introduced in 17.1.1.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# created_by: # Creator name.
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# rule: # Dns rules.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# tenant: admin
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_api_session "Avi API Module" b
- name: $1
	avi_api_session:
		http_method: ${2:get|put|post|patch|delete}
		# username: 
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# params: # Query parameters passed to the HTTP API.
		# api_version: 16.4.4
		# timeout: 60
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# path: # Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).
		# password: 
		# data: # HTTP body in YAML or JSON format.
		# tenant_uuid: 
		# tenant: admin
$0
endsnippet

snippet avi_webhook "Module for setup of Webhook Avi RESTful Object" b
- name: $1
	avi_webhook:
		name: ${2:# The name of the webhook profile.}
		# username: 
		# password: 
		# uuid: # Uuid of the webhook profile.
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# description: # Field introduced in 17.1.1.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# verification_token: # Verification token sent back with the callback asquery parameters.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# callback_url: # Callback url for the webhook.
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_tenant "Module for setup of Tenant Avi RESTful Object" b
- name: $1
	avi_tenant:
		name: ${2:# Name of the object.}
		# username: 
		# password: 
		# uuid: # Unique object identifier of the object.
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# state: absent|#present
		# created_by: # Creator of this tenant.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# config_settings: # Tenantconfiguration settings for tenant.
		# local: # Boolean flag to set local.
		# tenant_uuid: 
		# avi_api_update_method: #put|patch
		# description: # User defined description for the object.
$0
endsnippet

snippet avi_alertscriptconfig "Module for setup of AlertScriptConfig Avi RESTful Object" b
- name: $1
	avi_alertscriptconfig:
		name: ${2:# A user-friendly name of the script.}
		# username: 
		# action_script: # User defined alert action script.
		# api_version: 16.4.4
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_gslbhealthmonitor "Module for setup of GslbHealthMonitor Avi RESTful Object" b
- name: $1
	avi_gslbhealthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# username: 
		# https_monitor: # Healthmonitorhttp settings for gslbhealthmonitor.
		# receive_timeout: # A valid response from the server is expected within the receive timeout window.
		# description: # User defined description for the object.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# controller: 
		# udp_monitor: # Healthmonitorudp settings for gslbhealthmonitor.
		# http_monitor: # Healthmonitorhttp settings for gslbhealthmonitor.
		# password: 
		# tenant: admin
		# successful_checks: # Number of continuous successful health checks before server is marked up.
		# monitor_port: # Use this port instead of the port defined for the server in the pool.
		# uuid: # Uuid of the health monitor.
		# url: # Avi controller URL of the object.
		# dns_monitor: # Healthmonitordns settings for gslbhealthmonitor.
		# tenant_ref: # It is a reference to an object of type tenant.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# failed_checks: # Number of continuous failed health checks before the server is marked down.
		# tcp_monitor: # Healthmonitortcp settings for gslbhealthmonitor.
		# state: absent|#present
		# send_interval: # Frequency, in seconds, that monitors are sent to a server.
		# external_monitor: # Healthmonitorexternal settings for gslbhealthmonitor.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_applicationpersistenceprofile "Module for setup of ApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_applicationpersistenceprofile:
		persistence_type: ${2:# Method used to persist clients to the same server for a duration of time or a session.}
		name: ${3:# A user-friendly name for the persistence profile.}
		# server_hm_down_recovery: # Specifies behavior when a persistent server has been marked down by a health monitor.
		# uuid: # Uuid of the persistence profile.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_patch_op: add|replace|delete
		# http_cookie_persistence_profile: # Specifies the http cookie persistence profile parameters.
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# hdr_persistence_profile: # Specifies the custom http header persistence profile parameters.
		# api_version: 16.4.4
		# username: 
		# description: # User defined description for the object.
		# controller: 
		# ip_persistence_profile: # Specifies the client ip persistence profile parameters.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# app_cookie_persistence_profile: # Specifies the application cookie persistence profile parameters.
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# is_federated: # This field describes the object's replication scope.
		# tenant_uuid: 
$0
endsnippet

snippet avi_pkiprofile "Module for setup of PKIProfile Avi RESTful Object" b
- name: $1
	avi_pkiprofile:
		name: ${2:# Name of the pki profile.}
		# username: 
		# uuid: # Unique object identifier of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# created_by: # Creator name.
		# avi_api_patch_op: add|replace|delete
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# validate_only_leaf_crl: # When enabled, avi will only validate the revocation status of the leaf certificate using crl.
		# api_version: 16.4.4
		# crls: # Certificate revocation lists.
		# ignore_peer_chain: # When enabled, avi will not trust intermediate and root certs presented by a client.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# is_federated: # This field describes the object's replication scope.
		# ca_certs: # List of certificate authorities (root and intermediate) trusted that is used for certificate validation.
		# crl_check: # When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.
		# tenant_uuid: 
$0
endsnippet

snippet avi_actiongroupconfig "Module for setup of ActionGroupConfig Avi RESTful Object" b
- name: $1
	avi_actiongroupconfig:
		external_only: ${2:# Generate alert only to external destinations.}
		name: ${3:# Name of the object.}
		level: ${4:# When an alert is generated, mark its priority via the alert level.}
		# email_config_ref: # Select the email notification configuration to use when sending alerts via email.
		# autoscale_trigger_notification: # Trigger notification to autoscale manager.
		# uuid: # Unique object identifier of the object.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_update_method: #put|patch
		# api_version: 16.4.4
		# username: 
		# snmp_trap_profile_ref: # Select the snmp trap notification to use when sending alerts via snmp trap.
		# description: # User defined description for the object.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# url: # Avi controller URL of the object.
		# syslog_config_ref: # Select the syslog notification configuration to use when sending alerts via syslog.
		# tenant_ref: # It is a reference to an object of type tenant.
		# action_script_config_ref: # Reference of the action script configuration to be used.
		# tenant_uuid: 
$0
endsnippet

snippet avi_wafprofile "Module for setup of WafProfile Avi RESTful Object" b
- name: $1
	avi_wafprofile:
		name: ${2:# Field introduced in 17.2.1.}
		config: ${3:# Config params for waf.}
		# files: # List of data files used for waf rules.
		# username: 
		# api_version: 16.4.4
		# uuid: # Field introduced in 17.2.1.
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# description: # Field introduced in 17.2.1.
$0
endsnippet

snippet avi_gslbservice_patch_member "Avi API Module" b
- name: $1
	avi_gslbservice_patch_member:
		name: ${2:# Name of the GSLB Service}
		# username: 
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# state: absent|#present
		# params: # Query parameters passed to the HTTP API.
		# api_version: 16.4.4
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# data: # HTTP body of GSLB Service Member in YAML or JSON format.
		# tenant_uuid: 
		# tenant: admin
$0
endsnippet

snippet avi_vsvip "Module for setup of VsVip Avi RESTful Object" b
- name: $1
	avi_vsvip:
		name: ${2:# Name for the vsvip object.}
		# east_west_placement: # Force placement on all service engines in the service engine group (container clouds only).
		# username: 
		# password: 
		# api_version: 16.4.4
		# state: absent|#present
		# cloud_ref: # It is a reference to an object of type cloud.
		# dns_info: # Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# avi_api_patch_op: add|replace|delete
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# vip: # List of virtual service ips and other shareable entities.
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# vrf_context_ref: # Virtual routing context that the virtual service is bound to.
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the vsvip object.
$0
endsnippet

snippet avi_cloudconnectoruser "Module for setup of CloudConnectorUser Avi RESTful Object" b
- name: $1
	avi_cloudconnectoruser:
		name: ${2:# Name of the object.}
		# username: 
		# public_key: # Public_key of cloudconnectoruser.
		# private_key: # Private_key of cloudconnectoruser.
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# azure_serviceprincipal: # Field introduced in 17.2.1.
		# azure_userpass: # Field introduced in 17.2.1.
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
$0
endsnippet

snippet avi_networkprofile "Module for setup of NetworkProfile Avi RESTful Object" b
- name: $1
	avi_networkprofile:
		profile: ${2:# Networkprofileunion settings for networkprofile.}
		name: ${3:# The name of the network profile.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the network profile.
		# url: # Avi controller URL of the object.
		# description: # User defined description for the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_alertconfig "Module for setup of AlertConfig Avi RESTful Object" b
- name: $1
	avi_alertconfig:
		name: ${2:# Name of the alert configuration.}
		category: ${3:# Determines whether an alert is raised immediately when event occurs (realtime) or after specified number of events occurs within rolling time}
		source: ${4:# Signifies system events or the type of client logsused in this alert configuration.}
		alert_rule: ${5:# List of filters matching on events or client logs used for triggering alerts.}
		# username: 
		# description: # A custom description field.
		# tenant_ref: # It is a reference to an object of type tenant.
		# object_type: # The object type to which the alert config is associated with.
		# autoscale_alert: # This alert config applies to auto scale alerts.
		# controller: 
		# obj_uuid: # Uuid of the resource for which alert was raised.
		# recommendation: # Recommendation of alertconfig.
		# threshold: # An alert is created only when the number of events meets or exceeds this number within the chosen time frame.
		# throttle: # Alerts are suppressed (throttled) for this duration of time since the last alert was raised for this alert config.
		# password: 
		# avi_api_update_method: #put|patch
		# expiry_time: # An alert is expired and deleted after the expiry time has elapsed.
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# enabled: # Enable or disable this alert config from generating new alerts.
		# avi_api_patch_op: add|replace|delete
		# summary: # Summary of reason why alert is generated.
		# rolling_window: # Only if the number of events is reached or exceeded within the time window will an alert be generated.
		# state: absent|#present
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# action_group_ref: # The alert config will trigger the selected alert action, which can send notifications and execute a controlscript.
		# tenant_uuid: 
		# api_version: 16.4.4
		# tenant: admin
$0
endsnippet

snippet avi_serviceengine "Module for setup of ServiceEngine Avi RESTful Object" b
- name: $1
	avi_serviceengine:
		# username: 
		# enable_state: # Inorder to disable se set this field appropriately.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# mgmt_vnic: # Vnic settings for serviceengine.
		# tenant_ref: # It is a reference to an object of type tenant.
		# controller_created: # Boolean flag to set controller_created.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# flavor: # Flavor of serviceengine.
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
		# name: # Name of the object.
		# cloud_ref: # It is a reference to an object of type cloud.
		# hypervisor: # Enum options - default, vmware_esx, kvm, vmware_vsan, xen.
		# se_group_ref: # It is a reference to an object of type serviceenginegroup.
		# container_mode: # Boolean flag to set container_mode.
		# data_vnics: # List of vnic.
		# state: absent|#present
		# container_type: # Enum options - container_type_bridge, container_type_host, container_type_host_dpdk.
		# api_version: 16.4.4
		# host_ref: # It is a reference to an object of type vimgrhostruntime.
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# availability_zone: # Availability_zone of serviceengine.
		# controller_ip: # Controller_ip of serviceengine.
		# tenant_uuid: 
		# resources: # Seresources settings for serviceengine.
$0
endsnippet

snippet avi_gslbapplicationpersistenceprofile "Module for setup of GslbApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_gslbapplicationpersistenceprofile:
		name: ${2:# A user-friendly name for the persistence profile.}
		# username: 
		# description: # Field introduced in 17.1.1.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# tenant: admin
		# uuid: # Uuid of the persistence profile.
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# state: absent|#present
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_systemconfiguration "Module for setup of SystemConfiguration Avi RESTful Object" b
- name: $1
	avi_systemconfiguration:
		# username: 
		# docker_mode: # Boolean flag to set docker_mode.
		# dns_configuration: # Dnsconfiguration settings for systemconfiguration.
		# proxy_configuration: # Proxyconfiguration settings for systemconfiguration.
		# ssh_hmacs: # Allowed hmac list for ssh to the management interface on the controller and service engines.
		# controller: 
		# linux_configuration: # Linuxconfiguration settings for systemconfiguration.
		# url: # Avi controller URL of the object.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# email_configuration: # Emailconfiguration settings for systemconfiguration.
		# uuid: # Unique object identifier of the object.
		# dns_virtualservice_refs: # Dns virtualservices hosting fqdn records for applications across avi vantage.
		# default_license_tier: # Specifies the default license tier which would be used by new clouds.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# state: absent|#present
		# global_tenant_config: # Tenantconfiguration settings for systemconfiguration.
		# snmp_configuration: # Snmpconfiguration settings for systemconfiguration.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# ntp_configuration: # Ntpconfiguration settings for systemconfiguration.
		# admin_auth_configuration: # Adminauthconfiguration settings for systemconfiguration.
		# mgmt_ip_access_control: # Configure ip access control for controller to restrict open access.
		# ssh_ciphers: # Allowed ciphers list for ssh to the management interface on the controller and service engines.
		# tenant_uuid: 
		# api_version: 16.4.4
		# portal_configuration: # Portalconfiguration settings for systemconfiguration.
$0
endsnippet

snippet avi_gslbgeodbprofile "Module for setup of GslbGeoDbProfile Avi RESTful Object" b
- name: $1
	avi_gslbgeodbprofile:
		name: ${2:# A user-friendly name for the geodb profile.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Uuid of the geodb profile.
		# state: absent|#present
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# entries: # List of geodb entries.
		# password: 
		# tenant_uuid: 
		# controller: 
		# avi_api_update_method: #put|patch
		# description: # Field introduced in 17.1.1.
$0
endsnippet

snippet avi_useraccountprofile "Module for setup of UserAccountProfile Avi RESTful Object" b
- name: $1
	avi_useraccountprofile:
		name: ${2:# Name of the object.}
		# username: 
		# max_concurrent_sessions: # Maximum number of concurrent sessions allowed.
		# password: 
		# uuid: # Unique object identifier of the object.
		# state: absent|#present
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# account_lock_timeout: # Lock timeout period (in minutes).
		# api_version: 16.4.4
		# avi_api_patch_op: add|replace|delete
		# max_login_failure_count: # Number of login attempts before lockout.
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# max_password_history_count: # Maximum number of passwords to be maintained in the password history.
		# credentials_timeout_threshold: # The time period after which credentials expire.
		# tenant_uuid: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_role "Module for setup of Role Avi RESTful Object" b
- name: $1
	avi_role:
		name: ${2:# Name of the object.}
		# username: 
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# privileges: # List of permission.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
$0
endsnippet

snippet avi_alertemailconfig "Module for setup of AlertEmailConfig Avi RESTful Object" b
- name: $1
	avi_alertemailconfig:
		to_emails: ${2:# Alerts are sent to the comma separated list of  email recipients.}
		name: ${3:# A user-friendly name of the email notification service.}
		# username: 
		# api_version: 16.4.4
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# description: # User defined description for the object.
		# cc_emails: # Alerts are copied to the comma separated list of  email recipients.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
$0
endsnippet

snippet avi_wafpolicy "Module for setup of WafPolicy Avi RESTful Object" b
- name: $1
	avi_wafpolicy:
		name: ${2:# Field introduced in 17.2.1.}
		waf_profile_ref: ${3:# Waf profile for waf policy.}
		mode: ${4:# Waf policy mode.}
		# pre_crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# uuid: # Field introduced in 17.2.1.
		# post_crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# state: absent|#present
		# created_by: # Creator name.
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# avi_api_update_method: #put|patch
		# api_version: 16.4.4
		# username: 
		# description: # Field introduced in 17.2.1.
		# crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# paranoia_level: # Waf ruleset paranoia  mode.
		# tenant: admin
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# tenant_uuid: 
$0
endsnippet

snippet avi_serverautoscalepolicy "Module for setup of ServerAutoScalePolicy Avi RESTful Object" b
- name: $1
	avi_serverautoscalepolicy:
		name: ${2:# Name of the object.}
		# username: 
		# use_predicted_load: # Use predicted load rather than current load.
		# intelligent_autoscale: # Use avi intelligent autoscale algorithm where autoscale is performed by comparing load on the pool against estimated capacity of all the servers.
		# description: # User defined description for the object.
		# intelligent_scaleout_margin: # Minimum extra capacity as percentage of load used by the intelligent scheme.
		# scaleout_alertconfig_refs: # Trigger scaleout when alerts due to any of these alert configurations are raised.
		# min_size: # No scale-in happens once number of operationally up servers reach min_servers.
		# controller: 
		# scalein_cooldown: # Cooldown period during which no new scalein is triggered to allow previous scalein to successfully complete.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# scaleout_cooldown: # Cooldown period during which no new scaleout is triggered to allow previous scaleout to successfully complete.
		# max_size: # Maximum number of servers after scaleout.
		# tenant: admin
		# password: 
		# intelligent_scalein_margin: # Maximum extra capacity as percentage of load used by the intelligent scheme.
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# max_scalein_adjustment_step: # Maximum number of servers to scalein simultaneously.
		# avi_api_patch_op: add|replace|delete
		# scalein_alertconfig_refs: # Trigger scalein when alerts due to any of these alert configurations are raised.
		# avi_api_update_method: #put|patch
		# max_scaleout_adjustment_step: # Maximum number of servers to scaleout simultaneously.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_sslprofile "Module for setup of SSLProfile Avi RESTful Object" b
- name: $1
	avi_sslprofile:
		name: ${2:# Name of the object.}
		# username: 
		# accepted_ciphers: # Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).
		# prefer_client_cipher_ordering: # Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.
		# description: # User defined description for the object.
		# tags: # List of tag.
		# accepted_versions: # Set of versions accepted by the server.
		# controller: 
		# state: absent|#present
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# ssl_session_timeout: # The amount of time before an ssl session expires.
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# avi_api_patch_op: add|replace|delete
		# enable_ssl_session_reuse: # Enable ssl session re-use.
		# cipher_enums: # Enum options - tls_ecdhe_ecdsa_with_aes_128_gcm_sha256, tls_ecdhe_ecdsa_with_aes_256_gcm_sha384, tls_ecdhe_rsa_with_aes_128_gcm_sha256,
		# send_close_notify: # Send 'close notify' alert message for a clean shutdown of the ssl connection.
		# tenant: admin
		# dhparam: # Dh parameters used in ssl.
		# ssl_rating: # Sslrating settings for sslprofile.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_cloudproperties "Module for setup of CloudProperties Avi RESTful Object" b
- name: $1
	avi_cloudproperties:
		# info: # Properties specific to a cloud type.
		# hyp_props: # Hypervisor properties.
		# api_version: 16.4.4
		# uuid: # Unique object identifier of the object.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# controller: 
		# state: absent|#present
		# tenant_uuid: 
		# username: 
		# avi_api_patch_op: add|replace|delete
		# cc_props: # Cloudconnector properties.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# cc_vtypes: # Cloud types supported by cloudconnector.
		# avi_api_update_method: #put|patch
		# tenant: admin
$0
endsnippet

snippet avi_sslkeyandcertificate "Module for setup of SSLKeyAndCertificate Avi RESTful Object" b
- name: $1
	avi_sslkeyandcertificate:
		name: ${2:# Name of the object.}
		certificate: ${3:# Sslcertificate settings for sslkeyandcertificate.}
		# status: # Enum options - ssl_certificate_finished, ssl_certificate_pending.
		# username: 
		# certificate_management_profile_ref: # It is a reference to an object of type certificatemanagementprofile.
		# controller: 
		# hardwaresecuritymodulegroup_ref: # It is a reference to an object of type hardwaresecuritymodulegroup.
		# key: # Private key.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# key_params: # Sslkeyparams settings for sslkeyandcertificate.
		# password: 
		# avi_api_update_method: #put|patch
		# enckey_base64: # Encrypted private key corresponding to the private key (e.g.
		# uuid: # Unique object identifier of the object.
		# dynamic_params: # Dynamic parameters needed for certificate management profile.
		# url: # Avi controller URL of the object.
		# enckey_name: # Name of the encrypted private key (e.g.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# created_by: # Creator name.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# ca_certs: # Ca certificates in certificate chain.
		# type: # Enum options - ssl_certificate_type_virtualservice, ssl_certificate_type_system, ssl_certificate_type_ca.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet avi_authprofile "Module for setup of AuthProfile Avi RESTful Object" b
- name: $1
	avi_authprofile:
		name: ${2:# Name of the auth profile.}
		type: ${3:# Type of the auth profile.}
		# username: 
		# api_version: 16.4.4
		# http: # Http user authentication params.
		# uuid: # Uuid of the auth profile.
		# saml: # Saml settings.
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# avi_api_patch_op: add|replace|delete
		# tacacs_plus: # Tacacs+ settings.
		# ldap: # Ldap server and directory settings.
		# tenant: admin
		# tenant_uuid: 
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# description: # User defined description for the object.
$0
endsnippet

snippet avi_cluster "Module for setup of Cluster Avi RESTful Object" b
- name: $1
	avi_cluster:
		name: ${2:# Name of the object.}
		# username: 
		# uuid: # Unique object identifier of the object.
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# virtual_ip: # A virtual ip address.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# tenant: admin
		# nodes: # List of clusternode.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# rejoin_nodes_automatically: # Re-join cluster nodes automatically in the event one of the node is reset to factory.
$0
endsnippet

snippet avi_hardwaresecuritymodulegroup "Module for setup of HardwareSecurityModuleGroup Avi RESTful Object" b
- name: $1
	avi_hardwaresecuritymodulegroup:
		name: ${2:# Name of the hsm group configuration object.}
		hsm: ${3:# Hardware security module configuration.}
		# username: 
		# api_version: 16.4.4
		# tenant_uuid: 
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the hsm group configuration object.
$0
endsnippet

snippet avi_vrfcontext "Module for setup of VrfContext Avi RESTful Object" b
- name: $1
	avi_vrfcontext:
		name: ${2:# Name of the object.}
		# system_default: # Boolean flag to set system_default.
		# uuid: # Unique object identifier of the object.
		# cloud_ref: # It is a reference to an object of type cloud.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant: admin
		# gateway_mon: # Configure ping based heartbeat check for gateway in service engines of vrf.
		# bgp_profile: # Bgp local and peer info.
		# username: 
		# description: # User defined description for the object.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# internal_gateway_monitor: # Configure ping based heartbeat check for all default gateways in service engines of vrf.
		# static_routes: # List of staticroute.
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# debugvrfcontext: # Configure debug flags for vrf.
		# api_version: 16.4.4
		# tenant_uuid: 
$0
endsnippet

snippet avi_certificatemanagementprofile "Module for setup of CertificateManagementProfile Avi RESTful Object" b
- name: $1
	avi_certificatemanagementprofile:
		name: ${2:# Name of the pki profile.}
		script_path: ${3:# Script_path of certificatemanagementprofile.}
		# username: 
		# password: 
		# api_version: 16.4.4
		# url: # Avi controller URL of the object.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# tenant_uuid: 
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# script_params: # List of customparams.
		# controller: 
		# avi_api_update_method: #put|patch
		# uuid: # Unique object identifier of the object.
$0
endsnippet

snippet avi_network "Module for setup of Network Avi RESTful Object" b
- name: $1
	avi_network:
		name: ${2:# Name of the object.}
		# dhcp_enabled: # Select the ip address management scheme for this network.
		# vcenter_dvs: # Boolean flag to set vcenter_dvs.
		# configured_subnets: # List of subnet.
		# vrf_context_ref: # It is a reference to an object of type vrfcontext.
		# uuid: # Unique object identifier of the object.
		# cloud_ref: # It is a reference to an object of type cloud.
		# state: absent|#present
		# avi_api_patch_op: add|replace|delete
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant: admin
		# api_version: 16.4.4
		# username: 
		# exclude_discovered_subnets: # When selected, excludes all discovered subnets in this network from consideration for virtual service placement.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# password: 
		# avi_api_update_method: #put|patch
		# url: # Avi controller URL of the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# synced_from_se: # Boolean flag to set synced_from_se.
		# vimgrnw_ref: # It is a reference to an object of type vimgrnwruntime.
		# tenant_uuid: 
$0
endsnippet

snippet avi_poolgroupdeploymentpolicy "Module for setup of PoolGroupDeploymentPolicy Avi RESTful Object" b
- name: $1
	avi_poolgroupdeploymentpolicy:
		name: ${2:# The name of the pool group deployment policy.}
		# username: 
		# target_test_traffic_ratio: # Target traffic ratio before pool is made production.
		# evaluation_duration: # Duration of evaluation period for automatic deployment.
		# description: # User defined description for the object.
		# test_traffic_ratio_rampup: # Ratio of the traffic that is sent to the pool under test.
		# rules: # List of pgdeploymentrule.
		# auto_disable_old_prod_pools: # It will automatically disable old production pools once there is a new production candidate.
		# controller: 
		# api_context: # Avi API context that includes current session ID and CSRF Token.
		# webhook_ref: # Webhook configured with url that avi controller will pass back information about pool group, old and new pool information and current deployment
		# password: 
		# avi_api_update_method: #put|patch
		# uuid: # Uuid of the pool group deployment policy.
		# cloud_ref: # It is a reference to an object of type cloud.
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# tenant_ref: # It is a reference to an object of type tenant.
		# state: absent|#present
		# url: # Avi controller URL of the object.
		# avi_api_patch_op: add|replace|delete
		# tenant: admin
		# scheme: # Deployment scheme.
		# tenant_uuid: 
		# api_version: 16.4.4
$0
endsnippet

snippet ironware_facts "Collect facts from devices running Brocade Ironware" b
- name: $1
	ironware_facts:
		# authorize: yes|no
		# gather_subset: [u'!config', u'!mpls']
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet ironware_command "Run arbitrary commands on Brocade IronWare devices" b
- name: $1
	ironware_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# authorize: yes|no
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet ironware_config "Manage configuration sections on Brocade Ironware devices" b
- name: $1
	ironware_config:
		# authorize: yes|no
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# backup: yes|no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# update: #merge|check
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# commit: #merge|check
		# save_when: always|#never|modified
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system
$0
endsnippet

snippet netscaler_server "Manage server configuration" b
- name: $1
	netscaler_server:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Any information about the server.
		# delay: # Time, in seconds, after which all the services configured on the server are disabled.
		# domain: # Domain name of the server. For a domain based configuration, you must create the server first.
		# name: # Name for the server.
		# ipv6address: no
		# state: #present|absent
		# validate_certs: yes
		# save_config: yes
		# domainresolveretry: 5
		# translationmask: # The netmask of the translation ip.
		# nitro_timeout: 310
		# disabled: no
		# nitro_protocol: #http|https
		# translationip: # IP address used to transform the server's DNS-resolved IP address.
		# graceful: # Shut down gracefully, without accepting any new connections, and disabling each service when all of its connections are closed.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# ipaddress: # IPv4 or IPv6 address of the server. If you create an IP address based server, you can specify the name of the server, instead of its IP address, when creating a service. Note: If you do not create a server entry, the server IP address that you enter when you create a service becomes the name of the server.
$0
endsnippet

snippet netscaler_servicegroup "Manage service group configuration in Netscaler" b
- name: $1
	netscaler_servicegroup:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Any information about the service group.
		# tcpb: # Enable TCP buffering for the service group.
		# cachetype: TRANSPARENT|REVERSE|FORWARD
		# save_config: yes
		# disabled: no
		# nitro_protocol: #http|https
		# maxreq: # Maximum number of requests that can be sent on a persistent connection to the service group.
		# maxbandwidth: # Maximum bandwidth, in Kbps, allocated for all the services in the service group.
		# graceful: # Wait for all existing connections to the service to terminate before shutting down the service.
		# svrtimeout: # Time, in seconds, after which to terminate an idle server connection.
		# clttimeout: # Time, in seconds, after which to terminate an idle client connection.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# cacheable: # Use the transparent cache redirection virtual server to forward the request to the cache server.
		# autoscale: DISABLED|DNS|POLICY
		# maxclient: # Maximum number of simultaneous open connections for the service group.
		# monitorbindings: # A list of monitornames to bind to this service
		# servicegroupname: # Name of the service group. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the name is created.
		# state: #present|absent
		# usip: # Use client's IP address as the source IP address when initiating connection to the server. With the NO setting, which is the default, a mapped IP (MIP) address or subnet IP (SNIP) address is used as the source IP address to initiate server side connections.
		# netprofile: # Network profile for the service group.
		# rtspsessionidremap: # Enable RTSP session ID mapping for the service group.
		# httpprofilename: # Name of the HTTP profile that contains HTTP configuration settings for the service group.
		# pathmonitorindv: # Individual Path monitoring decisions.
		# pathmonitor: # Path monitoring for clustering.
		# appflowlog: enabled|disabled
		# servicemembers: # A list of dictionaries describing each service member of the service group.
		# monthreshold: # Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
		# memberport: # member port.
		# cka: # Enable client keep-alive for the service group.
		# tcpprofilename: # Name of the TCP profile that contains TCP configuration settings for the service group.
		# sp: # Enable surge protection for the service group.
		# downstateflush: enabled|disabled
		# cipheader: # Name of the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If client IP insertion is enabled, and the client IP header is not specified, the value of Client IP Header parameter or the value set by the set ns config command is used as client's IP header name.
		# nitro_timeout: 310
		# cip: enabled|disabled
		# healthmonitor: # Monitor the health of this service. Available settings function as follows:
		# useproxyport: # Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
		# validate_certs: yes
		# cmp: # Enable compression for the specified service.
$0
endsnippet

snippet netscaler_gslb_vserver "Configure gslb vserver entities in Netscaler." b
- name: $1
	netscaler_gslb_vserver:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Any comments that you might want to associate with the GSLB virtual server.
		# save_config: yes
		# sothreshold: # Threshold at which spillover occurs. Specify an integer for the CONNECTION spillover method, a bandwidth value in kilobits per second for the BANDWIDTH method (do not enter the units), or a percentage for the HEALTH method (do not enter the percentage symbol).
		# sopersistence: enabled|disabled
		# appflowlog: enabled|disabled
		# persistenceid: # The persistence ID for the GSLB virtual server. The ID is a positive integer that enables GSLB sites to identify the GSLB virtual server, and is required if source IP address based or spill over based persistence is enabled on the virtual server.
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# domain_bindings: # List of bindings for domains for this glsb vserver.
		# dnsrecordtype: A|AAAA|CNAME|NAPTR
		# disabled: no
		# considereffectivestate: NONE|STATE_ONLY
		# netmask: # IPv4 network mask for use in the SOURCEIPHASH load balancing method.
		# state: #present|absent
		# v6netmasklen: # Number of bits to consider, in an IPv6 source IP address, for creating the hash that is required by the C(SOURCEIPHASH) load balancing method.
		# nitro_protocol: #http|https
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE
		# persistencetype: SOURCEIP|NONE
		# name: # Name for the GSLB virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
		# disableprimaryondown: enabled|disabled
		# backuplbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD
		# dynamicweight: SERVICECOUNT|SERVICEWEIGHT|DISABLED
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# service_bindings: # List of bindings for gslb services bound to this gslb virtual server.
		# nitro_timeout: 310
		# sopersistencetimeout: # Timeout for spillover persistence, in minutes.
		# validate_certs: yes
		# persistmask: # The optional IPv4 network mask applied to IPv4 addresses to establish source IP address based persistence.
		# timeout: # Idle time, in minutes, after which a persistence entry is cleared.
		# v6persistmasklen: # Number of bits to consider in an IPv6 source IP address when creating source IP address based persistence sessions.
		# mir: enabled|disabled
		# tolerance: # Site selection tolerance, in milliseconds, for implementing the RTT load balancing method. If a site's RTT deviates from the lowest RTT by more than the specified tolerance, the site is not considered when the NetScaler appliance makes a GSLB decision. The appliance implements the round robin method of global server load balancing between sites whose RTT values are within the specified tolerance. If the tolerance is 0 (zero), the appliance always sends clients the IP address of the site with the lowest RTT.
		# lbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD
$0
endsnippet

snippet netscaler_save_config "Save Netscaler configuration." b
- name: $1
	netscaler_save_config:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_gslb_service "Manage gslb service entities in Netscaler." b
- name: $1
	netscaler_gslb_service:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Any comments that you might want to associate with the GSLB service.
		# cnameentry: # Canonical name of the GSLB service. Used in CNAME-based GSLB.
		# appflowlog: enabled|disabled
		# servername: # Name of the server hosting the GSLB service.
		# save_config: yes
		# hashid: # Unique hash identifier for the GSLB service, used by hash based load balancing methods.
		# nitro_protocol: #http|https
		# servicename: # Name for the GSLB service. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the GSLB service is created.
		# sitepersistence: ConnectionProxy|HTTPRedirect|NONE
		# monitor_bindings: # Bind monitors to this gslb service
		# maxbandwidth: # Integer specifying the maximum bandwidth allowed for the service. A GSLB service whose bandwidth reaches the maximum is not considered when a GSLB decision is made, until its bandwidth consumption drops below the maximum.
		# publicport: # The public port associated with the GSLB service's public IP address. The port is mapped to the service's private port number. Applicable to the local GSLB service. Optional.
		# port: # Port on which the load balancing entity represented by this GSLB service listens.
		# clttimeout: # Idle time, in seconds, after which a client connection is terminated. Applicable if connection proxy based site persistence is used.
		# state: #present|absent
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE
		# monthreshold: # Monitoring threshold value for the GSLB service. If the sum of the weights of the monitors that are bound to this GSLB service and are in the UP state is not equal to or greater than this threshold value, the service is marked as DOWN.
		# maxaaausers: # Maximum number of SSL VPN users that can be logged on concurrently to the VPN virtual server that is represented by this GSLB service. A GSLB service whose user count reaches the maximum is not considered when a GSLB decision is made, until the count drops below the maximum.
		# maxclient: # The maximum number of open connections that the service can support at any given time. A GSLB service whose connection count reaches the maximum is not considered when a GSLB decision is made, until the connection count drops below the maximum.
		# sitename: # Name of the GSLB site to which the service belongs.
		# ipaddress: # IP address for the GSLB service. Should represent a load balancing, content switching, or VPN virtual server on the NetScaler appliance, or the IP address of another load balancing device.
		# downstateflush: enabled|disabled
		# cipheader: # Name for the HTTP header that stores the client's IP address. Used with the Client IP option. If client IP header insertion is enabled on the service and a name is not specified for the header, the NetScaler appliance uses the name specified by the cipHeader parameter in the set ns param command or, in the GUI, the Client IP Header parameter in the Configure HTTP Parameters dialog box.
		# siteprefix: # The site's prefix string. When the service is bound to a GSLB virtual server, a GSLB site domain is generated internally for each bound service-domain pair by concatenating the site prefix of the service and the name of the domain. If the special string NONE is specified, the site-prefix string is unset. When implementing HTTP redirect site persistence, the NetScaler appliance redirects GSLB requests to GSLB services by using their site domains.
		# publicip: # The public IP address that a NAT device translates to the GSLB service's private IP address. Optional.
		# cip: enabled|disabled
		# healthmonitor: # Monitor the health of the GSLB service.
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_cs_action "Manage content switching actions" b
- name: $1
	netscaler_cs_action:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Comments associated with this cs action.
		# name: # Name for the content switching action. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the content switching action is created.
		# save_config: yes
		# state: #present|absent
		# targetlbvserver: # Name of the load balancing virtual server to which the content is switched.
		# nitro_protocol: #http|https
		# targetvserver: # Name of the VPN virtual server to which the content is switched.
		# validate_certs: yes
		# nitro_timeout: 310
		# targetvserverexpr: # Information about this content switching action.
$0
endsnippet

snippet netscaler_lb_vserver "Manage load balancing vserver configuration" b
- name: $1
	netscaler_lb_vserver:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# servicebindings: # List of services along with the weights that are load balanced.
		# comment: # Any comments that you might want to associate with the virtual server.
		# rtspnat: # Use network address translation (NAT) for RTSP data connections.
		# nitro_timeout: 310
		# disabled: no
		# macmoderetainvlan: enabled|disabled
		# dbslb: enabled|disabled
		# listenpolicy: # Default syntax expression identifying traffic accepted by the virtual server. Can be either an expression (for example, C(CLIENT.IP.DST.IN_SUBNET(192.0.2.0/24)) or the name of a named expression. In the above example, the virtual server accepts all requests whose destination IP address is in the 192.0.2.0/24 subnet.
		# disableprimaryondown: enabled|disabled
		# ipmask: # IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
		# insertvserveripport: OFF|VIPADDR|V6TOV4MAPPING
		# redirectportrewrite: enabled|disabled
		# clttimeout: # Idle time, in seconds, after which a client connection is terminated.
		# authenticationhost: # Fully qualified domain name (FQDN) of the authentication virtual server to which the user must be redirected for authentication. Make sure that the Authentication parameter is set to C(yes).
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|DNS|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|RTSP|PUSH|SSL_PUSH|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|TFTP|ORACLE|SMPP|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# mysqlservercapabilities: # Server capabilities that the virtual server advertises to clients.
		# state: #present|absent
		# vipheader: # Name for the inserted header. The default name is vip-header.
		# pushvserver: # Name of the load balancing virtual server, of type PUSH or SSL_PUSH, to which the server pushes updates received on the load balancing virtual server that you are configuring.
		# dataoffset: # Offset to be considered when extracting a token from the TCP payload. Applicable to virtual servers, of type TCP, using the token method of load balancing. Must be within the first 24 KB of the TCP payload.
		# datalength: # Length of the token to be extracted from the data segment of an incoming packet, for use in the token method of load balancing. The length of the token, specified in bytes, must not be greater than 24 KB. Applicable to virtual servers of type TCP.
		# rhistate: PASSIVE|ACTIVE
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# httpprofilename: # Name of the HTTP profile whose settings are to be applied to the virtual server.
		# newservicerequestincrementinterval: # Interval, in seconds, between successive increments in the load on a new service or a service whose state has just changed from DOWN to UP. A value of 0 (zero) specifies manual slow start.
		# appflowlog: enabled|disabled
		# dbprofilename: # Name of the DB profile whose settings are to be applied to the virtual server.
		# netmask: # IPv4 subnet mask to apply to the destination IP address or source IP address when the load balancing method is C(DESTINATIONIPHASH) or C(SOURCEIPHASH).
		# processlocal: enabled|disabled
		# minautoscalemembers: # Minimum number of members expected to be present when vserver is used in Autoscale.
		# name: # Name for the virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
		# backuplbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|CUSTOMLOAD
		# downstateflush: enabled|disabled
		# pushlabel: # Expression for extracting a label from the server's response. Can be either an expression or the name of a named expression.
		# persistmask: # Persistence mask for IP based persistence types, for IPv4 virtual servers.
		# timeout: # Time period for which a persistence session is in effect.
		# v6persistmasklen: # Persistence mask for IP based persistence types, for IPv6 virtual servers.
		# persistavpno: # Persist AVP number for Diameter Persistency.
		# recursionavailable: # When set to YES, this option causes the DNS replies from this vserver to have the RA bit turned on. Typically one would set this option to YES, when the vserver is load balancing a set of DNS servers thatsupport recursive queries.
		# validate_certs: yes
		# dnsprofilename: # Name of the DNS profile to be associated with the VServer. DNS profile properties will be applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
		# maxautoscalemembers: # Maximum number of members expected to be present when vserver is used in Autoscale.
		# oracleserverversion: 10G|11G
		# m: IP|MAC|IPTUNNEL|TOS
		# save_config: yes
		# bypassaaaa: # If this option is enabled while resolving DNS64 query AAAA queries are not sent to back end dns server.
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# nitro_protocol: #http|https
		# mysqlprotocolversion: # MySQL protocol version that the virtual server advertises to clients.
		# icmpvsrresponse: PASSIVE|ACTIVE
		# authnprofile: # Name of the authentication profile to be used when authentication is turned on.
		# port: # Port number for the virtual server.
		# servicegroupbindings: # List of service groups along with the weights that are load balanced.
		# ssl_certkey: # The name of the ssl certificate that is bound to this service.
		# persistencebackup: SOURCEIP|NONE
		# mysqlserverversion: # MySQL server version string that the virtual server advertises to clients.
		# mysqlcharacterset: # Character set that the virtual server advertises to clients.
		# authn401: # Enable or disable user authentication with HTTP 401 responses.
		# authentication: # Enable or disable user authentication.
		# authnvsname: # Name of an authentication virtual server with which to authenticate users.
		# healththreshold: # Threshold in percent of active services below which vserver state is made down. If this threshold is 0, vserver state will be up even if one bound service is up.
		# netprofile: # Name of the network profile to associate with the virtual server. If you set this parameter, the virtual server uses only the IP addresses in the network profile as source IP addresses when initiating connections with servers.
		# pushmulticlients: # Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
		# mssqlserverversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# lbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|URLHASH|DOMAINHASH|DESTINATIONIPHASH|SOURCEIPHASH|SRCIPDESTIPHASH|LEASTBANDWIDTH|LEASTPACKETS|TOKEN|SRCIPSRCPORTHASH|LRTM|CALLIDHASH|CUSTOMLOAD|LEASTREQUEST|AUDITLOGHASH|STATICPROXIMITY
		# hashlength: # Number of bytes to consider for the hash value used in the URLHASH and DOMAINHASH load balancing methods.
		# resrule: # Default syntax expression specifying which part of a server's response to use for creating rule based persistence sessions (persistence type RULE). Can be either an expression or the name of a named expression.
		# connfailover: DISABLED|STATEFUL|STATELESS
		# sothreshold: # Threshold at which spillover occurs. Specify an integer for the C(CONNECTION) spillover method, a bandwidth value in kilobits per second for the C(BANDWIDTH) method (do not enter the units), or a percentage for the C(HEALTH) method (do not enter the percentage symbol).
		# sopersistence: enabled|disabled
		# dns64: enabled|disabled
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# skippersistency: Bypass|ReLb|None
		# cacheable: # Route cacheable requests to a cache redirection virtual server. The load balancing virtual server can forward requests only to a transparent cache redirection virtual server that has an IP address and port combination of *:80, so such a cache redirection virtual server must be configured on the appliance.
		# l2conn: # Use Layer 2 parameters (channel number, MAC address, and VLAN ID) in addition to the 4-tuple (<source IP>:<source port>::<destination IP>:<destination port>) that is used to identify a connection. Allows multiple TCP and non-TCP connections with the same 4-tuple to co-exist on the NetScaler appliance.
		# v6netmasklen: # Number of bits to consider in an IPv6 destination or source IP address, for creating the hash that is required by the C(DESTINATIONIPHASH) and C(SOURCEIPHASH) load balancing methods.
		# sessionless: enabled|disabled
		# ipv46: # IPv4 or IPv6 address to assign to the virtual server.
		# persistencetype: SOURCEIP|COOKIEINSERT|SSLSESSION|RULE|URLPASSIVE|CUSTOMSERVERID|DESTIP|SRCIPDESTIP|CALLID|RTSPSID|DIAMETER|FIXSESSION|NONE
		# tosid: # TOS ID of the virtual server. Applicable only when the load balancing redirection mode is set to TOS.
		# ippattern: # IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
		# tcpprofilename: # Name of the TCP profile whose settings are to be applied to the virtual server.
		# backuppersistencetimeout: # Time period for which backup persistence is in effect.
		# newservicerequestunit: PER_SECOND|PERCENT
		# redirurl: # URL to which to redirect traffic if the virtual server becomes unavailable.
		# cookiename: # Use this parameter to specify the cookie name for C(COOKIE) peristence type. It specifies the name of cookie with a maximum of 32 characters. If not specified, cookie name is internally generated.
		# listenpriority: # Integer specifying the priority of the listen policy. A higher number specifies a lower priority. If a request matches the listen policies of more than one virtual server the virtual server whose listen policy has the highest priority (the lowest priority number) accepts the request.
		# sopersistencetimeout: # Timeout for spillover persistence, in minutes.
		# range: # Number of IP addresses that the appliance must generate and assign to the virtual server. The virtual server then functions as a network virtual server, accepting traffic on any of the generated IP addresses. The IP addresses are generated automatically, as follows:
		# newservicerequest: # Number of requests, or percentage of the load on existing services, by which to increase the load on a new service at each interval in slow-start mode. A non-zero value indicates that slow-start is applicable. A zero value indicates that the global RR startup parameter is applied. Changing the value to zero will cause services currently in slow start to take the full traffic as determined by the LB method. Subsequently, any new services added will use the global RR factor.
		# push: enabled|disabled
$0
endsnippet

snippet netscaler_cs_vserver "Manage content switching vserver" b
- name: $1
	netscaler_cs_vserver:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Information about this virtual server.
		# oracleserverversion: 10G|11G
		# precedence: RULE|URL
		# domainname: # Domain name for which to change the time to live (TTL) and/or backup service IP address.
		# backupvserver: # Name of the backup virtual server that you are configuring. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the backup virtual server is created. You can assign a different backup virtual server or rename the existing virtual server.
		# rtspnat: # Enable network address translation (NAT) for real-time streaming protocol (RTSP) connections.
		# nitro_timeout: 310
		# backupip: # .
		# disabled: no
		# nitro_protocol: #http|https
		# mysqlprotocolversion: # The protocol version returned by the mysql vserver.
		# listenpolicy: # String specifying the listen policy for the content switching virtual server. Can be either the name of an existing expression or an in-line expression.
		# ssl_certkey: # The name of the ssl certificate that is bound to this service.
		# icmpvsrresponse: PASSIVE|ACTIVE
		# ttl: # .
		# redirecturl: # URL to which traffic is redirected if the virtual server becomes unavailable. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# ipmask: # IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
		# authnprofile: # Name of the authentication profile to be used when authentication is turned on.
		# redirectportrewrite: enabled|disabled
		# port: # Port number for content switching virtual server.
		# clttimeout: # Idle time, in seconds, after which the client connection is terminated. The default values are:
		# authenticationhost: # FQDN of the authentication virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# servicetype: HTTP|SSL|TCP|FTP|RTSP|SSL_TCP|UDP|DNS|SIP_UDP|SIP_TCP|SIP_SSL|ANY|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|DNS_TCP|ORACLE|SMPP
		# insertvserveripport: OFF|VIPADDR|V6TOV4MAPPING
		# sopersistence: enabled|disabled
		# mysqlservercapabilities: # The server capabilities returned by the mysql vserver.
		# mysqlserverversion: # The server version string returned by the mysql vserver.
		# mysqlcharacterset: # The character set returned by the mysql vserver.
		# authn401: # Enable HTTP 401-response based authentication.
		# vipheader: # Name of virtual server IP and port header, for use with the VServer IP Port Insertion parameter.
		# pushvserver: # Name of the load balancing virtual server, of type C(PUSH) or C(SSL_PUSH), to which the server pushes updates received on the client-facing load balancing virtual server.
		# authentication: # Authenticate users who request a connection to the content switching virtual server.
		# authnvsname: # Name of authentication virtual server that authenticates the incoming user requests to this content switching virtual server. .
		# netprofile: # The name of the network profile.
		# pushmulticlients: # Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# mssqlserverversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# lbvserver: # The default Load Balancing virtual server.
		# httpprofilename: # Name of the HTTP profile containing HTTP configuration settings for the virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# rhistate: PASSIVE|ACTIVE
		# targettype: GSLB
		# state: #present|absent
		# save_config: yes
		# sothreshold: # Depending on the spillover method, the maximum number of connections or the maximum total bandwidth (Kbps) that a virtual server can handle before spillover occurs.
		# cookietimeout: # .
		# appflowlog: enabled|disabled
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# dbprofilename: # Name of the DB profile.
		# cookiedomain: # .
		# cacheable: # Use this option to specify whether a virtual server, used for load balancing or content switching, routes requests to the cache redirection virtual server before sending it to the configured servers.
		# l2conn: # Use L2 Parameters to identify a connection.
		# ipv46: # IP address of the content switching virtual server.
		# name: # Name for the content switching virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters.
		# ippattern: # IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
		# disableprimaryondown: enabled|disabled
		# validate_certs: yes
		# tcpprofilename: # Name of the TCP profile containing TCP configuration settings for the virtual server.
		# downstateflush: enabled|disabled
		# sitedomainttl: # .
		# pushlabel: # Expression for extracting the label from the response received from server. This string can be either an existing rule name or an inline expression. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# sopersistencetimeout: # Time-out value, in minutes, for spillover persistence.
		# casesensitive: # Consider case in URLs (for policies that use URLs instead of RULES). For example, with the C(on) setting, the URLs /a/1.html and /A/1.HTML are treated differently and can have different targets (set by content switching policies). With the C(off) setting, /a/1.html and /A/1.HTML are switched to the same target.
		# range: # Number of consecutive IP addresses, starting with the address specified by the IP Address parameter, to include in a range of addresses assigned to this virtual server.
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# push: enabled|disabled
		# stateupdate: enabled|disabled
		# dnsprofilename: # Name of the DNS profile to be associated with the VServer. DNS profile properties will applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
$0
endsnippet

snippet netscaler_nitro_request "Issue Nitro API requests to a Netscaler instance." b
- name: $1
	netscaler_nitro_request:
		expected_nitro_errorcode: ${2:[0]}
		nitro_user: ${3:# The username with which to authenticate to the Netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the Netscaler node.}
		# instance_name: # The name of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
		# args: # A dictionary which defines the key arguments by which we will select the Nitro object to operate on.
		# resource: # The type of resource we are operating on.
		# operation: add|update|get|get_by_args|get_filtered|get_all|delete|delete_by_args|count|mas_login|save_config|action
		# filter: # A dictionary which defines the filter with which to refine the Nitro objects returned by the C(get_filtered) I(operation).
		# instance_ip: # The IP address of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
		# name: # The name of the resource we are operating on.
		# nitro_protocol: #http|https
		# instance_id: # The id of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
		# nsip: # The IP address of the Netscaler or MAS instance where the Nitro API calls will be made.
		# action: # The action to perform when the I(operation) value is set to C(action).
		# attributes: # The attributes of the Nitro object we are operating on.
		# validate_certs: yes
		# nitro_auth_token: # The authentication token provided by the C(mas_login) operation. It is required when issuing Nitro API calls through a MAS proxy.
$0
endsnippet

snippet netscaler_cs_policy "Manage content switching policy" b
- name: $1
	netscaler_cs_policy:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# policyname: # Name for the content switching policy. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Cannot be changed after a policy is created.
		# domain: # The domain name. The string value can range to 63 characters.
		# url: # URL string that is matched with the URL of a request. Can contain a wildcard character. Specify the string value in the following format: C([[prefix] [*]] [.suffix]).
		# save_config: yes
		# state: #present|absent
		# rule: # Expression, or name of a named expression, against which traffic is evaluated. Written in the classic or default syntax.
		# nitro_protocol: #http|https
		# action: # Content switching action that names the target load balancing virtual server to which the traffic is switched.
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_lb_monitor "Manage load balancing monitors" b
- name: $1
	netscaler_lb_monitor:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# lasversion: # Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS) monitor.
		# secure: # Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure connection by default.
		# radnasip: # Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
		# Snmpoid: # SNMP OID for C(SNMP) monitors.
		# storefrontacctservice: # Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For multi-tenancy configuration users my skip account service.
		# radnasid: # NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).
		# firmwarerevision: # Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# ipaddress: # Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A or AAAA. Applicable to C(DNS) monitors.
		# query: # Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).
		# storedb: enabled|disabled
		# vendorid: # Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# authapplicationid: # List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring CER message.
		# group: # Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is found on the server, the service is marked as UP. If the newsgroup does not exist or if the search fails, the service is marked as DOWN. Applicable to NNTP monitors.
		# tos: # Probe the service by encoding the destination IP address in the IP TOS (6) bits.
		# maxforwards: # Maximum number of hops that the SIP request used for monitoring can traverse to reach the server. Applicable only to monitors of type C(SIP-UDP).
		# send: # String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
		# sipreguri: # SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method parameter is set to C(REGISTER).
		# rtsprequest: # RTSP request to send to the server (for example, C("OPTIONS *")).
		# trofscode: # Code expected when the server is under maintenance.
		# successretries: # Number of consecutive successful probes required to transition a service's state from DOWN to UP.
		# iptunnel: # Send the monitoring probe to the service through an IP tunnel. A destination IP address must be specified.
		# monitorname: # Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.
		# nitro_timeout: 310
		# units1: SEC|MSEC|MIN
		# units3: SEC|MSEC|MIN
		# units2: SEC|MSEC|MIN
		# units4: SEC|MSEC|MIN
		# scriptargs: # String of arguments for the script. The string is copied verbatim into the request.
		# destport: # TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the service to which the monitor is bound is considered the destination port. For a monitor of type C(USER), however, the destination port is the port number that is included in the HTTP request sent to the dispatcher. Does not apply to monitors of type C(PING).
		# resptimeout: # Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than the value specified for the Interval parameter.
		# downtime: # Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in milliseconds, seconds, or minutes.
		# password: # Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in conjunction with the user name specified for the C(username) parameter.
		# transparent: # The monitor is bound to a transparent device such as a firewall or router. The state of a transparent device depends on the responsiveness of the services behind it. If a transparent device is being monitored, a destination IP address must be specified. The probe is sent to the specified IP address by using the MAC address of the transparent device.
		# retries: # Maximum number of probes to send to establish the state of a service for which a monitoring probe failed.
		# failureretries: # Number of retries that must fail, out of the number specified for the Retries parameter, for a service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the service is to be marked as DOWN.
		# snmpthreshold: # Threshold for C(SNMP) monitors.
		# nitro_protocol: #http|https
		# radkey: # Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
		# type: PING|TCP|HTTP|TCP-ECV|HTTP-ECV|UDP-ECV|DNS|FTP|LDNS-PING|LDNS-TCP|LDNS-DNS|RADIUS|USER|HTTP-INLINE|SIP-UDP|SIP-TCP|LOAD|FTP-EXTENDED|SMTP|SNMP|NNTP|MYSQL|MYSQL-ECV|MSSQL-ECV|ORACLE-ECV|LDAP|POP3|CITRIX-XML-SERVICE|CITRIX-WEB-INTERFACE|DNS-TCP|RTSP|ARP|CITRIX-AG|CITRIX-AAC-LOGINPAGE|CITRIX-AAC-LAS|CITRIX-XD-DDC|ND6|CITRIX-WI-EXTENDED|DIAMETER|RADIUS_ACCOUNTING|STOREFRONT|APPC|SMPP|CITRIX-XNC-ECV|CITRIX-XDM|CITRIX-STA-SERVICE|CITRIX-STA-SERVICE-NHOP
		# database: # Name of the database to connect to during authentication.
		# snmpcommunity: # Community name for C(SNMP) monitors.
		# validatecred: # Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type C(CITRIX-XD-DDC).
		# productname: # Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# username: # User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.
		# metrictable: # Metric table to which to bind metrics.
		# dispatcherport: # Port number on which the dispatcher listens for the monitoring probe.
		# acctapplicationid: # List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message.
		# oraclesid: # Name of the service identifier that is used to connect to the Oracle database during authentication.
		# radaccounttype: # Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# binddn: # The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server. Optional. Applicable to C(LDAP) monitors.
		# domain: # Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers and Web Interface servers, respectively.
		# vendorspecificacctapplicationids: # List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
		# resptimeoutthresh: # Response time threshold, specified as a percentage of the Response Time-out parameter. If the response to a monitor probe has not arrived when the threshold is reached, the appliance generates an SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be generated, the "MONITOR-RTO-THRESHOLD" alarm must also be enabled.
		# hostipaddress: # Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP) address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.
		# sipuri: # SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of type C(SIP-UDP).
		# attribute: # Attribute to evaluate when the LDAP server responds to the query. Success or failure of the monitoring probe depends on whether the attribute exists in the response. Optional.
		# save_config: yes
		# vendorspecificvendorid: # Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the Vendor-Specific-Application-Id AVPs in a CER monitoring message.
		# destip: # IP address of the service to which to send probes. If the parameter is set to 0, the IP address of the server to which the monitor is bound is considered the destination IP address.
		# scriptname: # Path and name of the script to execute. The script must be available on the NetScaler appliance, in the /nsconfig/monitors/ directory.
		# originrealm: # Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# dispatcherip: # IP address of the dispatcher to which to send the probe.
		# radmsisdn: # Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# secondarypassword: # Secondary password that users might have to provide to log on to the Access Gateway server. Applicable to C(CITRIX-AG) monitors.
		# respcode: # Response codes for which to mark the service as UP. For any other response code, the action performed depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.
		# trofsstring: # String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV monitors.
		# logonpointname: # Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control software. Required if you want to monitor the associated login page or Logon Agent. Applicable to C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.
		# kcdaccount: # KCD Account used by C(MSSQL) monitor.
		# radapn: # Called Station Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# hostname: # Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.
		# radframedip: # Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# filename: # Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.
		# application: # Name of the application used to determine the state of the service. Applicable to monitors of type C(CITRIX-XML-SERVICE).
		# state: enabled|disabled
		# netprofile: # Name of the network profile.
		# alertretries: # Number of consecutive probe failures after which the appliance generates an SNMP trap called monProbeFailed.
		# radaccountsession: # Account Session ID to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# deviation: # Time value added to the learned average response time in dynamic response time monitoring (DRTM). When a deviation is specified, the appliance learns the average response time of bound services and adds the deviation to the average. The final value is then continually adjusted to accommodate response time variations over time. Specified in milliseconds, seconds, or minutes.
		# httprequest: # HTTP request to send to the server (for example, C("HEAD /file.html")).
		# supportedvendorids: # List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a monitoring message.
		# inbandsecurityid: NO_INBAND_SECURITY|TLS
		# basedn: # The base distinguished name of the LDAP service, from where the LDAP server can begin the search for the attributes in the monitoring query. Required for C(LDAP) service monitoring.
		# sitepath: # URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE), C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.
		# storefrontcheckbackendservices: # This option will enable monitoring of services running on storefront server. Storefront services are monitored by probing to a Windows service that runs on the Storefront server and exposes details of which storefront services are running.
		# interval: # Time interval between two successive probes. Must be greater than the value of Response Time-out.
		# sqlquery: # SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server authenticates the connection.
		# evalrule: # Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV monitoring query. Must produce a Boolean result. The result determines the state of the server. If the expression returns TRUE, the probe succeeds.
		# sipmethod: OPTIONS|INVITE|REGISTER
		# customheaders: # Custom header string to include in the monitoring probes.
		# mssqlprotocolversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# recv: # String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
		# querytype: Address|Zone|AAAA
		# tosid: # The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.
		# reverse: # Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN when probe criteria are not satisfied.
		# storename: # Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront service store name. Applicable to C(STOREFRONT) monitors.
		# validate_certs: yes
		# lrtm: enabled|disabled
		# originhost: # Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# filter: # Filter criteria for the LDAP query. Optional.
		# vendorspecificauthapplicationids: # List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
		# snmpversion: V1|V2
		# action: NONE|LOG|DOWN
$0
endsnippet

snippet netscaler_ssl_certkey "Manage ssl cerificate keys." b
- name: $1
	netscaler_ssl_certkey:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# certkey: # Name for the certificate and private-key pair. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the certificate-key pair is created.
		# nitro_protocol: #http|https
		# passplain: # Pass phrase used to encrypt the private-key. Required when adding an encrypted private-key in PEM format.
		# save_config: yes
		# inform: DER|PEM|PFX
		# cert: # Name of and, optionally, path to the X509 certificate file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
		# state: #present|absent
		# key: # Name of and, optionally, path to the private-key file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
		# notificationperiod: # Time, in number of days, before certificate expiration, at which to generate an alert that the certificate is about to expire.
		# expirymonitor: enabled|disabled
		# password: # Passphrase that was used to encrypt the private-key. Use this option to load encrypted private-keys in PEM format.
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_gslb_site "Manage gslb site entities in Netscaler." b
- name: $1
	netscaler_gslb_site:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# publicip: # Public IP address for the local site. Required only if the appliance is deployed in a private address space and the site has a public IP address hosted on an external firewall or a NAT device.
		# siteipaddress: # IP address for the GSLB site. The GSLB site uses this IP address to communicate with other GSLB sites. For a local site, use any IP address that is owned by the appliance (for example, a SNIP or MIP address, or the IP address of the ADNS service).
		# metricexchange: enabled|disabled
		# nwmetricexchange: enabled|disabled
		# sitename: # Name for the GSLB site. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the virtual server is created.
		# sitetype: REMOTE|LOCAL
		# save_config: yes
		# sessionexchange: enabled|disabled
		# state: #present|absent
		# publicclip: # IP address to be used to globally access the remote cluster when it is deployed behind a NAT. It can be same as the normal cluster IP address.
		# naptrreplacementsuffix: # The naptr replacement suffix configured here will be used to construct the naptr replacement field in NAPTR record.
		# nitro_protocol: #http|https
		# parentsite: # Parent site of the GSLB site, in a parent-child topology.
		# clip: # Cluster IP address. Specify this parameter to connect to the remote cluster site for GSLB auto-sync. Note: The cluster IP address is defined when creating the cluster.
		# triggermonitor: ALWAYS|MEPDOWN|MEPDOWN_SVCDOWN
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_service "Manage service configuration in Netscaler" b
- name: $1
	netscaler_service:
		nitro_user: ${2:# The username with which to authenticate to the netscaler node.}
		nsip: ${3:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# comment: # Any information about the service.
		# tcpb: # Enable TCP buffering for the service.
		# cachetype: TRANSPARENT|REVERSE|FORWARD
		# ip: # IP to assign to the service.
		# servername: # Name of the server that hosts the service.
		# save_config: yes
		# disabled: no
		# nitro_protocol: #http|https
		# maxreq: # Maximum number of requests that can be sent on a persistent connection to the service.
		# monitor_bindings: # A list of load balancing monitors to bind to this service.
		# maxbandwidth: # Maximum bandwidth, in Kbps, allocated to the service.
		# svrtimeout: # Time, in seconds, after which to terminate an idle server connection.
		# port: # Port number of the service.
		# clttimeout: # Time, in seconds, after which to terminate an idle client connection.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# cacheable: no
		# cleartextport: # Port to which clear text data must be sent after the appliance decrypts incoming SSL traffic. Applicable to transparent SSL services.
		# maxclient: # Maximum number of simultaneous open connections to the service.
		# processlocal: enabled|disabled
		# graceful: no
		# state: #present|absent
		# usip: # Use the client's IP address as the source IP address when initiating a connection to the server. When creating a service, if you do not set this parameter, the service inherits the global Use Source IP setting (available in the enable ns mode and disable ns mode CLI commands, or in the System > Settings > Configure modes > Configure Modes dialog box). However, you can override this setting after you create the service.
		# netprofile: # Network profile to use for the service.
		# customserverid: # Unique identifier for the service. Used when the persistency type for the virtual server is set to Custom Server ID.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# httpprofilename: # Name of the HTTP profile that contains HTTP configuration settings for the service.
		# pathmonitorindv: # Individual Path monitoring decisions.
		# pathmonitor: # Path monitoring for clustering.
		# appflowlog: enabled|disabled
		# rtspsessionidremap: no
		# monthreshold: # Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
		# hashid: # A numerical identifier that can be used by hash based load balancing methods. Must be unique for each service.
		# serverid: # The identifier for the service. This is used when the persistency type is set to Custom Server ID.
		# ipaddress: # The new IP address of the service.
		# accessdown: no
		# name: # Name for the service. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the service has been created.
		# tcpprofilename: # Name of the TCP profile that contains TCP configuration settings for the service.
		# sp: # Enable surge protection for the service.
		# downstateflush: enabled|disabled
		# cipheader: # Name for the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If you set the Client IP parameter, and you do not specify a name for the header, the appliance uses the header name specified for the global Client IP Header parameter (the cipHeader parameter in the set ns param CLI command or the Client IP Header parameter in the Configure HTTP Parameters dialog box at System > Settings > Change HTTP parameters). If the global Client IP Header parameter is not specified, the appliance inserts a header with the name "client-ip.".
		# nitro_timeout: 310
		# cip: enabled|disabled
		# healthmonitor: yes
		# useproxyport: # Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
		# cka: # Enable client keep-alive for the service.
		# cmp: # Enable compression for the service.
		# validate_certs: yes
		# dnsprofilename: # Name of the DNS profile to be associated with the service. DNS profile properties will applied to the transactions processed by a service. This parameter is valid only for ADNS and ADNS-TCP services.
$0
endsnippet

snippet bcf_switch "Create and remove a bcf switch." b
- name: $1
	bcf_switch:
		name: ${2:# The name of the switch.}
		mac: ${3:# The MAC address of the switch.}
		controller: ${4:# The controller IP address.}
		fabric_role: ${5:spine|leaf}
		# access_token: # Big Cloud Fabric access token. If this isn't set then the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
		# state: #present|absent
		# leaf_group: # The leaf group of the switch if the switch is a leaf.
		# validate_certs: #True|False
$0
endsnippet

snippet bigmon_policy "Create and remove a bigmon out-of-band policy." b
- name: $1
	bigmon_policy:
		name: ${2:# The name of the policy.}
		controller: ${3:# The controller address.}
		# policy_description: # Description of policy.
		# access_token: # Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
		# start_time: ansible_date_time.iso8601
		# state: #present|absent
		# priority: 100
		# action: #forward|drop|flow-gen
		# duration: 0
		# validate_certs: #True|False
		# delivery_packet_count: 0
$0
endsnippet

snippet bigmon_chain "Create and remove a bigmon inline service chain." b
- name: $1
	bigmon_chain:
		controller: ${2:# The controller IP address.}
		name: ${3:# The name of the chain.}
		# access_token: # Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
		# state: #present|absent
		# validate_certs: #True|False
$0
endsnippet

snippet fmgr_script "Add/Edit/Delete and execute scripts" b
- name: $1
	fmgr_script:
		username: ${2:# The username to log into the FortiManager}
		adom: ${3:# The administrative domain (admon) the configuration belongs to}
		host: ${4:# The FortiManager's Address.}
		script_name: ${5:# The name of the script.}
		# script_content: # The script content that will be executed.
		# script_scope: # (datasource) The devices that the script will run on, can have both device member and device group member.
		# state: #present|execute|delete
		# script_target: # The target of the script to be run.
		# script_description: # The description of the script.
		# script_package: # (datasource) Policy package object to run the script against
		# password: # The password associated with the username account.
		# vdom: # The virtual domain (vdom) the configuration belongs to
		# script_type: # The type of script (CLI or TCL).
$0
endsnippet

snippet iosxr_facts "Collect facts from remote devices running IOS XR" b
- name: $1
	iosxr_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_config "Manage Cisco IOS XR configuration sections" b
- name: $1
	iosxr_config:
		# comment: configured by iosxr_config
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# force: yes|no
		# admin: yes|no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# replace: #line|block|config
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # B(Deprecated)
		# backup: no
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet iosxr_system "Manage the system attributes on Cisco IOS XR devices" b
- name: $1
	iosxr_system:
		# lookup_source: # The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# state: #present|absent
		# vrf: # VRF name for domain services
		# provider: # B(Deprecated)
		# name_servers: # The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.
		# lookup_enabled: # Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
$0
endsnippet

snippet iosxr_logging "Configuration management of system logging services on network devices" b
- name: $1
	iosxr_logging:
		# name: # When C(dest) = I(file) name indicates file-name
		# facility: local7
		# dest: host|console|monitor|buffered|file
		# level: debugging
		# hostnameprefix: # To append a hostname prefix to system logging (syslog) messages logged to syslog servers. Optional config for C(dest) = C(host)
		# state: #present|absent
		# vrf: default
		# provider: # B(Deprecated)
		# aggregate: # L
		# size: # Size of buffer when C(dest) = C(buffered). The acceptable value is in the range I(307200 to 125000000 bytes). Default 307200
$0
endsnippet

snippet iosxr_user "Manage the aggregate of local users on Cisco IOS XR device" b
- name: $1
	iosxr_user:
		# public_key: # Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key_contents. If used with multiple users in aggregates, then the same key file is used for all users.
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the Cisco IOS XR device. The password needs to be provided in clear text. Password is encrypted on the device when used with I(cli) and by Ansible when used with I(netconf) using the same MD5 hash technique with salt size of 3. Please note that this option is not same as C(provider password).
		# group: # Configures the group for the username in the device running configuration. The argument accepts a string value defining the group name. This argument does not check if the group has been configured on the device.
		# name: # The username to be configured on the Cisco IOS XR device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# purge: no
		# state: #present|absent
		# public_key_contents: # Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key.If used with multiple users in aggregates, then the same key file is used for all users.
		# groups: # Configures the groups for the username in the device running configuration. The argument accepts a list of group names. This argument does not check if the group has been configured on the device. It is similar to the aggregrate command for usernames, but lets you configure multiple groups for the user(s).
		# provider: # B(Deprecated)
		# aggregate: # The set of username objects to be configured on the remote Cisco IOS XR device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
$0
endsnippet

snippet iosxr_banner "Manage multiline banners on Cisco IOS XR devices" b
- name: $1
	iosxr_banner:
		banner: ${2:login|motd}
		# text: # Banner text to be configured. Accepts multiline string, without empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_command "Run commands on remote devices running Cisco IOS XR" b
- name: $1
	iosxr_command:
		commands: ${2:# List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet iosxr_interface "Manage Interface on Cisco IOS XR network devices" b
- name: $1
	iosxr_interface:
		name: ${2:# Name of the interface to configure in C(type + path) format. e.g. C(GigabitEthernet0/0/0/0)}
		# rx_rate: # Receiver rate in bits per second (bps).
		# duplex: full|half
		# enabled: yes
		# mtu: # Sets the MTU value for the interface. Range is between 64 and 65535'
		# delay: 10
		# active: #active|preconfigure
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
		# aggregate: # List of Interface definitions. Include multiple interface configurations together, one each on a seperate line
		# speed: 10|100|1000
		# tx_rate: # Transmit rate in bits per second (bps).
		# description: # Description of Interface being configured.
$0
endsnippet

snippet iosxr_netconf "Configures NetConf sub-system service on Cisco IOS-XR devices" b
- name: $1
	iosxr_netconf:
		# state: #present|absent
		# netconf_vrf: default
		# provider: # B(Deprecated)
		# netconf_port: 830
$0
endsnippet

snippet a10_virtual_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' virtual servers." b
- name: $1
	a10_virtual_server:
		username: ${2:# An account with administrator privileges.}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		virtual_server: ${4:# The SLB (Server Load Balancing) virtual server name.}
		password: ${5:# Password for the C(username) account.}
		# force: no
		# url_username: # The username for use in HTTP basic authentication.
		# force_basic_auth: no
		# virtual_server_ports: # A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).
		# http_agent: ansible-httpget
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# url_password: # The password for use in HTTP basic authentication.
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# partition: # set active-partition
		# state: #present|absent
		# virtual_server_status: enabled|disabled
		# write_config: yes|#no
		# virtual_server_ip: # The SLB virtual server IPv4 address.
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet a10_server_axapi3 "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices" b
- name: $1
	a10_server_axapi3:
		username: ${2:# An account with administrator privileges.}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		password: ${4:# Password for the C(username) account.}
		server_name: ${5:# The SLB (Server Load Balancer) server name.}
		server_ip: ${6:# The SLB (Server Load Balancer) server IPv4 address.}
		# force: no
		# write_config: yes|#no
		# server_ports: # A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).
		# force_basic_auth: no
		# http_agent: ansible-httpget
		# url_username: # The username for use in HTTP basic authentication.
		# operation: #create|update|remove
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# url_password: # The password for use in HTTP basic authentication.
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# server_status: #enable|disable
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet a10_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' server object." b
- name: $1
	a10_server:
		username: ${2:# An account with administrator privileges.}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		password: ${4:# Password for the C(username) account.}
		server_name: ${5:# The SLB (Server Load Balancer) server name.}
		# force: no
		# write_config: yes|#no
		# server_ports: # A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).
		# force_basic_auth: no
		# http_agent: ansible-httpget
		# url_username: # The username for use in HTTP basic authentication.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# url_password: # The password for use in HTTP basic authentication.
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# partition: # set active-partition
		# server_status: #enabled|disabled
		# state: #present|absent
		# server_ip: # The SLB server IPv4 address.
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet a10_service_group "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' service groups." b
- name: $1
	a10_service_group:
		username: ${2:# An account with administrator privileges.}
		password: ${3:# Password for the C(username) account.}
		service_group: ${4:# The SLB (Server Load Balancing) service-group name}
		host: ${5:# Hostname or IP of the A10 Networks device.}
		# force: no
		# url_username: # The username for use in HTTP basic authentication.
		# force_basic_auth: no
		# servers: # A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.
		# http_agent: ansible-httpget
		# service_group_protocol: #tcp|udp
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# url_password: # The password for use in HTTP basic authentication.
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# partition: # set active-partition
		# state: #present|absent
		# write_config: yes|#no
		# service_group_method: #round-robin|weighted-rr|least-connection|weighted-least-connection|service-least-connection|service-weighted-least-connection|fastest-response|least-request|round-robin-strict|src-ip-only-hash|src-ip-hash
		# validate_certs: #yes|no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet bigip_ucs_fetch "Fetches a UCS file from remote nodes" b
- name: $1
	bigip_ucs_fetch:
		dest: ${2:# A directory to save the UCS file into.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# force: yes
		# fail_on_missing: no
		# create_on_missing: yes
		# src: # The name of the UCS file to create on the remote server for downloading
		# encryption_password: # Password to use to encrypt the UCS file if desired
		# validate_certs: yes
		# server_port: 443
		# provider: # A dict object containing connection details.
		# backup: no
$0
endsnippet

snippet bigip_monitor_tcp_echo "Manages F5 BIG-IP LTM tcp echo monitors" b
- name: $1
	bigip_monitor_tcp_echo:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/tcp_echo
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_ucs "Manage upload, installation and removal of UCS files" b
- name: $1
	bigip_ucs:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# force: True|False
		# reset_trust: True|False
		# no_platform_check: True|False
		# server_port: 443
		# state: absent|installed|#present
		# include_chassis_level_config: True|False
		# passphrase: True|False
		# provider: # A dict object containing connection details.
		# ucs: # The path to the UCS file to install. The parameter must be provided if the C(state) is either C(installed) or C(activated). When C(state) is C(absent), the full path for this parameter will be ignored and only the filename will be used to select a UCS for removal. Therefore you could specify C(/mickey/mouse/test.ucs) and this module would only look for C(test.ucs).
		# no_license: True|False
		# validate_certs: yes
$0
endsnippet

snippet bigip_configsync_action "Perform different actions related to config-sync" b
- name: $1
	bigip_configsync_action:
		device_group: ${2:# The device group that you want to perform config-sync actions on.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# sync_most_recent_to_device: True|False
		# sync_device_to_group: True|False
		# server_port: 443
		# provider: # A dict object containing connection details.
		# overwrite_config: True|#False
		# validate_certs: yes
$0
endsnippet

snippet bigip_vcmp_guest "Manages vCMP guests on a BIG-IP" b
- name: $1
	bigip_vcmp_guest:
		name: ${2:# The name of the vCMP guest to manage.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# mgmt_address: # Specifies the IP address, and subnet or subnet mask that you use to access the guest when you want to manage a module running within the guest. This parameter is required if the C(mgmt_network) parameter is C(bridged).
		# vlans: # VLANs that the guest uses to communicate with other guests, the host, and with the external network. The available VLANs in the list are those that are currently configured on the vCMP host.
		# partition: Common
		# delete_virtual_disk: no
		# initial_image: # Specifies the base software release ISO image file for installing the TMOS hypervisor instance and any licensed BIG-IP modules onto the guest's virtual disk. When creating a new guest, this parameter is required.
		# validate_certs: yes
		# state: configured|disabled|provisioned|#present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# mgmt_route: # Specifies the gateway address for the C(mgmt_address).
		# mgmt_network: bridged|isolated|host only
		# cores_per_slot: # Specifies the number of cores that the system allocates to the guest.
$0
endsnippet

snippet bigip_monitor_udp "Manages F5 BIG-IP LTM udp monitors" b
- name: $1
	bigip_monitor_udp:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/udp
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(default send string) will be used.
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
$0
endsnippet

snippet bigip_gtm_facts "Collect facts from F5 BIG-IP GTM devices" b
- name: $1
	bigip_gtm_facts:
		include: ${2:pool|wide_ip|server}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# filter: # Perform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_remote_syslog "Manipulate remote syslog settings on a BIG-IP" b
- name: $1
	bigip_remote_syslog:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		remote_host: ${5:# Specifies the IP address, or hostname, for the remote system to which the system sends log messages.}
		# remote_port: # Specifies the port that the system uses to send messages to the remote logging server. When creating a remote syslog, if this parameter is not specified, the default value C(514) is used.
		# validate_certs: yes
		# local_ip: # Specifies the local IP address of the system that is logging. To provide no local IP, specify the value C(none). When creating a remote syslog, if this parameter is not specified, the default value C(none) is used.
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_httpd "Manage HTTPD related settings on BIG-IP" b
- name: $1
	bigip_device_httpd:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# auth_pam_validate_ip: # Sets the authPamValidateIp setting.
		# hostname_lookup: # Sets whether or not to display the hostname, if possible.
		# log_level: alert|crit|debug|emerg|error|info|notice|warn
		# server_port: 443
		# auth_name: # Sets the BIG-IP authentication realm name.
		# validate_certs: yes
		# auth_pam_dashboard_timeout: # Sets whether or not the BIG-IP dashboard will timeout.
		# redirect_http_to_https: # Whether or not to redirect http requests to the GUI to https.
		# fast_cgi_timeout: # Sets the timeout of FastCGI.
		# allow: all|IP address, such as 172.27.1.10|IP range, such as 172.27.*.* or 172.27.0.0/255.255.0.0
		# provider: # A dict object containing connection details.
		# ssl_port: # The HTTPS port to listen on.
		# auth_pam_idle_timeout: # Sets the GUI timeout for automatic logout, in seconds.
		# max_clients: # Sets the maximum number of clients that can connect to the GUI at once.
$0
endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors" b
- name: $1
	bigip_monitor_tcp:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/tcp
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# send: # The send string for the monitor call.
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
$0
endsnippet

snippet bigip_security_address_list "Manage address lists on BIG-IP AFM" b
- name: $1
	bigip_security_address_list:
		name: ${2:# Specifies the name of the address list.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# geo_locations: # List of geolocations specified by their C(country) and C(region).
		# addresses: # Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.
		# address_ranges: # A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# address_lists: # Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# fqdns: # A list of fully qualified domain names (FQDNs).
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# description: # Description of the address list
$0
endsnippet

snippet bigip_wait "Wait for a BIG-IP condition before continuing" b
- name: $1
	bigip_wait:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# server_port: 443
		# delay: 0
		# sleep: 1
		# timeout: 7200
		# provider: # A dict object containing connection details.
		# msg: # This overrides the normal error message from a failure to meet the required conditions.
		# validate_certs: yes
$0
endsnippet

snippet bigip_static_route "Manipulate static routes on a BIG-IP" b
- name: $1
	bigip_static_route:
		name: ${2:# Name of the static route.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# destination: # Specifies an IP address for the static entry in the routing table. When creating a new static route, this value is required.
		# gateway_address: # Specifies the router for the system to use when forwarding packets to the destination host or network. Also known as the next-hop router address. This can be either an IPv4 or IPv6 address. When it is an IPv6 address that starts with C(FE80:), the address will be treated as a link-local address. This requires that the C(vlan) parameter also be supplied.
		# validate_certs: yes
		# vlan: # Specifies the VLAN or Tunnel through which the system forwards packets to the destination. When C(gateway_address) is a link-local IPv6 address, this value is required
		# route_domain: # The route domain id of the system. When creating a new static route, if this value is not specified, a default value of C(0) will be used.
		# mtu: # Specifies a specific maximum transmission unit (MTU).
		# state: #present|absent
		# server_port: 443
		# reject: # Specifies that the system drops packets sent to the destination.
		# netmask: # The netmask for the static route. When creating a new static route, this value is required.
		# provider: # A dict object containing connection details.
		# pool: # Specifies the pool through which the system forwards packets to the destination.
		# description: # Descriptive text that identifies the route.
$0
endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers" b
- name: $1
	bigip_gtm_virtual_server:
		virtual_server_name: ${2:# Virtual server name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		virtual_server_server: ${6:# Virtual server server.}
		# validate_certs: yes
		# state: #present|absent|enabled|disabled
		# host: # Virtual server host.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# port: # Virtual server port.
$0
endsnippet

snippet bigip_iapp_template "Manages TCL iApp templates on a BIG-IP" b
- name: $1
	bigip_iapp_template:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# force: # Specifies whether or not to force the uploading of an iApp. When C(yes), will force update the iApp even if there are iApp services using it. This will not update the running service though. Use C(bigip_iapp_service) to do that. When C(no), will update the iApp only if there are no iApp services using the template.
		# name: # The name of the iApp template that you want to delete. This option is only available when specifying a C(state) of C(absent) and is provided as a way to delete templates that you may no longer have the source of.
		# partition: Common
		# content: # Sets the contents of an iApp template directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. C(content) must be provided when creating new templates.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system" b
- name: $1
	bigip_selfip:
		name: ${2:Value of C(address)}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# vlan: # The VLAN that the new self IPs will be on. When creating a new Self IP, this value is required.
		# partition: Common
		# netmask: # The netmask for the self IP. When creating a new Self IP, this value is required.
		# allow_service: # Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.
		# state: absent|#present
		# route_domain: # The route domain id of the system. When creating a new Self IP, if this value is not specified, a default value of C(0) will be used.
		# server_port: 443
		# address: # The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.
		# traffic_group: # The traffic group for the Self IP addresses in an active-active, redundant load balancer configuration. When creating a new Self IP, if this value is not specified, the default of C(/Common/traffic-group-local-only) will be used.
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP" b
- name: $1
	bigip_routedomain:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# flow_eviction_policy: # The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.
		# service_policy: # Service policy to associate with the route domain.
		# description: # Specifies descriptive text that identifies the route domain.
		# parent: # S
		# partition: Common
		# connection_limit: # The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.
		# provider: # A dict object containing connection details.
		# strict: enabled|disabled
		# state: #present|absent
		# routing_protocol: BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng
		# server_port: 443
		# bwc_policy: # The bandwidth controller for the route domain.
		# vlans: # VLANs for the system to use in the route domain
		# validate_certs: yes
		# id: # The unique identifying integer representing the route domain.
		# name: # The name of the route domain.
$0
endsnippet

snippet bigip_gtm_server "Manages F5 BIG-IP GTM servers" b
- name: $1
	bigip_gtm_server:
		name: ${2:# The name of the server.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# link_discovery: enabled|disabled|enabled-no-delete
		# datacenter: # Data center the server belongs to. When creating a new GTM server, this value is required.
		# partition: Common
		# server_type: alteon-ace-director|cisco-css|cisco-server-load-balancer|generic-host|radware-wsd|windows-nt-4.0|bigip|cisco-local-director-v2|extreme|generic-load-balancer|sun-solaris|cacheflow|cisco-local-director-v3|foundry-server-iron|netapp|windows-2000-server
		# state: #present|absent|enabled|disabled
		# devices: # Lists the self IP addresses and translations for each device. When creating a new GTM server, this value is required. This list is a complex list that specifies a number of keys. There are several supported keys.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# virtual_server_discovery: enabled|disabled|enabled-no-delete
		# validate_certs: yes
$0
endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP" b
- name: $1
	bigip_gtm_datacenter:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# The name of the data center.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# description: # The description of the data center.
		# partition: Common
		# state: #present|absent|enabled|disabled
		# contact: # The name of the contact for the data center.
		# location: # The location of the data center.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_security_port_list "Manage port lists on BIG-IP AFM" b
- name: $1
	bigip_security_port_list:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Specifies the name of the port list.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# description: # Description of the port list
		# port_ranges: # A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# partition: Common
		# port_lists: # Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# ports: # Simple list of port values to add to the list
$0
endsnippet

snippet bigip_virtual_server "Manage LTM virtual servers on a BIG-IP" b
- name: $1
	bigip_virtual_server:
		destination: ${2:# Destination IP of the virtual server.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# Virtual server name.}
		server: ${6:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# disabled_vlans: # List of VLANs to be disabled. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.
		# description: # Virtual server description.
		# fallback_persistence_profile: # Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.
		# default_persistence_profile: # Default Profile which manages the session persistence.
		# server_port: 443
		# enabled_vlans: # List of VLANs to be enabled. When a VLAN named C(all) is used, all VLANs will be allowed. VLANs can be specified with or without the leading partition. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.
		# port: # Port of the virtual server. Required when C(state) is C(present) and virtual server does not exist.
		# pool: # Default pool for the virtual server.
		# validate_certs: yes
		# partition: Common
		# profiles: # List of profiles (HTTP, ClientSSL, ServerSSL, etc) to apply to both sides of the connection (client-side and server-side).
		# irules: # List of rules to be applied in priority order.
		# source: # Specifies an IP address or network from which the virtual server accepts traffic.
		# state: #present|absent|enabled|disabled
		# policies: # Specifies the policies for the virtual server
		# provider: # A dict object containing connection details.
		# snat: None|Automap|Name of a SNAT pool (eg "/Common/snat_pool_name") to enable SNAT with the specific pool
		# metadata: # Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a virtual to me managed by Ansible.
$0
endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP" b
- name: $1
	bigip_snat_pool:
		name: ${2:# T}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# partition: Common
		# members: # List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables" b
- name: $1
	bigip_sys_db:
		key: ${2:# The database variable to manipulate.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# value: # The value to set the key to. At least one of value and state C(reset) are required.
		# state: #present|reset
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip" b
- name: $1
	bigip_gtm_wide_ip:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Wide IP name. This name must be formatted as a fully qualified domain name (FQDN). You can also use the alias C(wide_ip) but this is deprecated and will be removed in a future Ansible version.}
		pool_lb_method: ${5:round-robin|ratio|topology|global-availability}
		server: ${6:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# type: a|aaaa|cname|mx|naptr|srv
		# partition: Common
		# state: #present|absent|disabled|enabled
		# server_port: 443
		# provider: # A dict object containing connection details.
		# pools: # The pools that you want associated with the Wide IP.
		# validate_certs: yes
$0
endsnippet

snippet bigip_monitor_snmp_dca "Manages BIG-IP SNMP data collecting agent (DCA) monitors" b
- name: $1
	bigip_monitor_snmp_dca:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Monitor name.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# interval: # Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown. When creating a new monitor, the default is C(10).
		# disk_threshold: # Specifies the maximum acceptable disk usage on the target server. When creating a new monitor, the default is C(90) percent.
		# parent: /Common/snmp_dca
		# community: # Specifies the community name that the system must use to authenticate with the host server through SNMP. When creating a new monitor, the default value is C(public). Note that this value is case sensitive.
		# server_port: 443
		# cpu_threshold: # Specifies the maximum acceptable CPU usage on the target server. When creating a new monitor, the default is C(80) percent.
		# description: # Specifies descriptive text that identifies the monitor.
		# cpu_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the CPU threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.5).
		# time_until_up: # Specifies the number of seconds to wait after a resource first responds correctly to the monitor before setting the resource to 'up'. During the interval, all responses from the resource must be correct. When the interval expires, the resource is marked 'up'. A value of 0, means that the resource is marked up immediately upon receipt of the first correct response. When creating a new monitor, the default is C(0).
		# partition: Common
		# memory_threshold: # Specifies the maximum acceptable memory usage on the target server. When creating a new monitor, the default is C(70) percent.
		# disk_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the disk threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(2.0).
		# state: #present|absent
		# version: v1|v2c
		# agent_type: UCD|WIN2000|GENERIC
		# memory_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the memory threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.0).
		# timeout: # Specifies the number of seconds the target has in which to respond to the monitor request. When creating a new monitor, the default is C(30) seconds. If the target responds within the set time period, it is considered 'up'. If the target does not respond within the set time period, it is considered 'down'. When this value is set to 0 (zero), the system uses the interval from the parent monitor. Note that C(timeout) and C(time_until_up) combine to control when a resource is set to up.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP" b
- name: $1
	bigip_irule:
		module: ${2:ltm|gtm}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		src: ${5:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}
		name: ${6:# The name of the iRule.}
		server: ${7:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# partition: Common
		# content: # When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_provision "Manage BIG-IP module provisioning" b
- name: $1
	bigip_provision:
		name: ${2:am|afm|apm|asm|avr|fps|gtm|ilx|lc|ltm|pem|sam|swg|vcmp}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# level: dedicated|#nominal|minimum
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_virtual_address "Manage LTM virtual addresses on a BIG-IP" b
- name: $1
	bigip_virtual_address:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		address: ${4:# Virtual address. This value cannot be modified after it is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# provider: # A dict object containing connection details.
		# icmp_echo: enabled|disabled|selective
		# auto_delete: enabled|disabled
		# partition: Common
		# connection_limit: # Specifies the number of concurrent connections that the system allows on this virtual address.
		# netmask: 255.255.255.255
		# state: #present|absent|enabled|disabled
		# arp_state: enabled|disabled
		# server_port: 443
		# traffic_group: # The traffic group for the virtual address. When creating a new address, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
		# validate_certs: yes
		# use_route_advertisement: # Specifies whether the system uses route advertisement for this virtual address. When disabled, the system does not advertise routes for this virtual address.
		# advertise_route: always|when_all_available|when_any_available
$0
endsnippet

snippet bigip_user "Manage user accounts and user attributes on a BIG-IP" b
- name: $1
	bigip_user:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		username_credential: ${5:# Name of the user to create, remove or modify. There is a special case that exists for the user C(root).}
		# update_password: always|#on_create
		# shell: bash|none|tmsh
		# server_port: 443
		# password_credential: # Set the users password to this unencrypted value. C(password_credential) is required when creating a new account.
		# partition_access: # Specifies the administrative partition to which the user has access. C(partition_access) is required when creating a new account. Should be in the form "partition:role". Valid roles include C(acceleration-policy-editor), C(admin), C(application-editor), C(auditor) C(certificate-manager), C(guest), C(irule-manager), C(manager), C(no-access) C(operator), C(resource-admin), C(user-manager), C(web-application-security-administrator), and C(web-application-security-editor). Partition portion of tuple should be an existing partition or the value 'all'.
		# partition: Common
		# state: #present|absent
		# full_name: # Full name of the user.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_policy_rule "Manage LTM policy rules on a BIG-IP" b
- name: $1
	bigip_policy_rule:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# The name of the rule.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		policy: ${6:# The name of the policy that you want to associate this rule with.}
		# description: # Description of the policy rule.
		# actions: # The actions that you want the policy rule to perform.
		# validate_certs: yes
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# conditions: # A list of attributes that describe the condition.
$0
endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP" b
- name: $1
	bigip_ssl_certificate:
		name: ${2:# SSL Certificate Name. This is the cert name used when importing a certificate into the F5. It also determines the filenames of the objects on the LTM.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# partition: Common
		# content: # Sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or
		# issuer_cert: # Issuer certificate used for OCSP monitoring.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_facts "Collect facts from F5 BIG-IP devices" b
- name: $1
	bigip_facts:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		include: ${5:address_class|certificate|client_ssl_profile|device|device_group|interface|key|node|pool|provision|rule|self_ip|software|system_info|traffic_group|trunk|virtual_address|virtual_server|vlan}
		# filter: 
		# session: 
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_asm_policy "Manage BIG-IP ASM policies" b
- name: $1
	bigip_asm_policy:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# The ASM policy to manage or create.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# template: ActiveSync v1.0 v2.0 (http)|ActiveSync v1.0 v2.0 (https)|Comprehensive|Drupal|Fundamental|Joomla|LotusDomino 6.5 (http)|LotusDomino 6.5 (https)|OWA Exchange 2003 (http)|OWA Exchange 2003 (https)|OWA Exchange 2003 with ActiveSync (http)|OWA Exchange 2003 with ActiveSync (https)|OWA Exchange 2007 (http)|OWA Exchange 2007 (https)|OWA Exchange 2007 with ActiveSync (http)|OWA Exchange 2007 with ActiveSync (https)|OWA Exchange 2010 (http)|OWA Exchange 2010 (https)|Oracle 10g Portal (http)|Oracle 10g Portal (https)|Oracle Applications 11i (http)|Oracle Applications 11i (https)|PeopleSoft Portal 9 (http)|PeopleSoft Portal 9 (https)|Rapid Deployment Policy|SAP NetWeaver 7 (http)|SAP NetWeaver 7 (https)|SharePoint 2003 (http)|SharePoint 2003 (https)|SharePoint 2007 (http)|SharePoint 2007 (https)|SharePoint 2010 (http)|SharePoint 2010 (https)|Vulnerability Assessment Baseline|Wordpress
		# file: # Full path to a policy file to be imported into the BIG-IP ASM.
		# active: True|#False
		# partition: Common
		# state: present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP" b
- name: $1
	bigip_hostname:
		hostname: ${2:# Hostname of the BIG-IP host.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system" b
- name: $1
	bigip_vlan:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${3:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# dag_round_robin: # Specifies whether some of the stateless traffic on the VLAN should be disaggregated in a round-robin order instead of using a static hash. The stateless traffic includes non-IP L2 traffic, ICMP, some UDP protocols, and so on.
		# untagged_interfaces: # Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.
		# server_port: 443
		# partition: Common
		# provider: # A dict object containing connection details.
		# mtu: # Specifies the maximum transmission unit (MTU) for traffic on this VLAN. When creating a new VLAN, if this parameter is not specified, the default value used will be C(1500).
		# state: absent|#present
		# tag: # Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.
		# tagged_interfaces: # Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.
		# cmp_hash: # Specifies how the traffic on the VLAN will be disaggregated. The value selected determines the traffic disaggregation method. You can choose to disaggregate traffic based on C(source-address) (the source IP address), C(destination-address) (destination IP address), or C(default), which specifies that the default CMP hash uses L4 ports.
		# dag_tunnel: # Specifies how the disaggregator (DAG) distributes received tunnel-encapsulated packets to TMM instances. Select C(inner) to distribute packets based on information in inner headers. Select C(outer) to distribute packets based on information in outer headers without inspecting inner headers.
		# validate_certs: yes
		# description: # The description to give to the VLAN.
$0
endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors" b
- name: $1
	bigip_monitor_http:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/http
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\r\n) will be used.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# validate_certs: yes
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
$0
endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes" b
- name: $1
	bigip_node:
		name: ${2:# Specifies the name of the node.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# provider: # A dict object containing connection details.
		# quorum: # Monitor quorum value when C(monitor_type) is C(m_of_n).
		# partition: Common
		# fqdn: # FQDN name of the node. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").
		# monitors: # Specifies the health monitors that the system currently uses to monitor this node.
		# state: #present|absent|enabled|disabled|offline
		# server_port: 443
		# address: # IP address of the node. This can be either IPv4 or IPv6. When creating a new node, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.
		# validate_certs: yes
		# monitor_type: and_list|m_of_n|single
		# description: # Specifies descriptive text that identifies the node.
$0
endsnippet

snippet bigiq_regkey_pool "Manages registration key pools on BIG-IQ" b
- name: $1
	bigiq_regkey_pool:
		name: ${2:# Specifies the name of the registration key pool.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# description: # A description to attach to the pool.
$0
endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP" b
- name: $1
	bigip_device_ntp:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# ntp_servers: # A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required.
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# timezone: UTC
		# validate_certs: yes
$0
endsnippet

snippet bigip_ssl_key "Import/Delete SSL keys from BIG-IP" b
- name: $1
	bigip_ssl_key:
		name: ${2:# The name of the key.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# partition: Common
		# server_port: 443
		# content: # Sets the contents of a key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. This must be provided when C(state) is C(present).
		# state: #present|absent
		# passphrase: # Passphrase on key.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools" b
- name: $1
	bigip_pool:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		name: ${5:# Pool name}
		# monitors: # Monitor template name list. If the partition is not provided as part of the monitor name, then the C(partition) option will be used instead.
		# lb_method: dynamic-ratio-member|dynamic-ratio-node|fastest-app-response|fastest-node|least-connections-member|least-connections-node|least-sessions|observed-member|observed-node|predictive-member|predictive-node|ratio-least-connections-member|ratio-least-connections-node|ratio-member|ratio-node|ratio-session|round-robin|weighted-least-connections-member|weighted-least-connections-nod
		# quorum: # Monitor quorum value when C(monitor_type) is C(m_of_n).
		# description: # Specifies descriptive text that identifies the pool.
		# partition: Common
		# slow_ramp_time: # Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members.
		# service_down_action: none|reset|drop|reselect
		# reselect_tries: # Sets the number of times the system tries to contact a pool member after a passive failure.
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# metadata: # Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a pool to me managed by Ansible.
		# validate_certs: yes
		# monitor_type: and_list|m_of_n|single
$0
endsnippet

snippet bigip_profile_client_ssl "Manages client SSL profiles on a BIG-IP" b
- name: $1
	bigip_profile_client_ssl:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# Specifies the name of the profile.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# parent: /Common/clientssl
		# cert_key_chain: # One or more certificates and keys to associate with the SSL profile. This option is always a list. The keys in the list dictate the details of the client/key/chain combination. Note that BIG-IPs can only have one of each type of each certificate/key type. This means that you can only have one RSA, one DSA, and one ECDSA per profile. If you attempt to assign two RSA, DSA, or ECDSA certificate/key combo, the device will reject this.
		# ciphers: # Specifies the list of ciphers that the system supports. When creating a new profile, the default cipher list is C(DEFAULT).
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members" b
- name: $1
	bigip_pool_member:
		state: ${2:#present|absent}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		host: ${4:# Pool member IP.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		port: ${7:# Pool member port.}
		pool: ${8:# Pool name. This pool must exist.}
		# session_state: enabled|disabled
		# ratio: # Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.
		# description: # Pool member description.
		# monitor_state: enabled|disabled
		# partition: Common
		# connection_limit: # Pool member connection limit. Setting this to 0 disables the limit.
		# preserve_node: True|#False
		# server_port: 443
		# provider: # A dict object containing connection details.
		# rate_limit: # Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.
		# priority_group: # Specifies a number representing the priority group for the pool member.
		# validate_certs: yes
$0
endsnippet

snippet bigip_iapp_service "Manages TCL iApp services on a BIG-IP" b
- name: $1
	bigip_iapp_service:
		name: ${2:# The name of the iApp service that you want to deploy.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# force: no
		# parameters: # A hash of all the required template variables for the iApp template. If your parameters are stored in a file (the more common scenario) it is recommended you use either the `file` or `template` lookups to supply the expected parameters.
		# strict_updates: yes
		# partition: Common
		# server_port: 443
		# state: #present|absent
		# template: # The iApp template from which to instantiate a new service. This template must exist on your BIG-IP before you can successfully create a service. This parameter is required if the C(state) parameter is C(present).
		# provider: # A dict object containing connection details.
		# traffic_group: # The traffic group for the iApp service. When creating a new service, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
		# validate_certs: yes
$0
endsnippet

snippet bigip_policy "Manage general policy configuration on a BIG-IP" b
- name: $1
	bigip_policy:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${4:# The name of the policy to create.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# description: # The description to attach to the policy.
		# rules: # Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
		# partition: Common
		# strategy: first|all|best
		# state: present|absent|draft
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_device_group_member "Manages members in a device group" b
- name: $1
	bigip_device_group_member:
		name: ${2:# Specifies the name of the device that you want to add to the device group. Often this will be the hostname of the device. This member must be trusted by the device already. Trusting can be done with the C(bigip_device_trust) module and the C(peer_hostname) option to that module.}
		device_group: ${3:# The device group that you want to add the member to.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_gtm_pool "Manages F5 BIG-IP GTM pools" b
- name: $1
	bigip_gtm_pool:
		name: ${2:# Name of the GTM pool.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# alternate_lb_method: round-robin|return-to-dns|none|ratio|topology|static-persistence|global-availability|virtual-server-capacity|packet-rate|drop-packet|fallback-ip|virtual-server-score
		# validate_certs: yes
		# partition: Common
		# fallback_ip: # Specifies the IPv4, or IPv6 address of the server to which the system directs requests when it cannot use one of its pools to do so. Note that the system uses the fallback IP only if you select the C(fallback_ip) load balancing method.
		# state: present|absent|enabled|disabled
		# fallback_lb_method: round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score
		# server_port: 443
		# preferred_lb_method: round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score
		# type: a|aaaa|cname|mx|naptr|srv
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_snmp_trap "Manipulate SNMP trap information on a BIG-IP" b
- name: $1
	bigip_snmp_trap:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# Name of the SNMP configuration endpoint.}
		# snmp_version: 1|2c
		# destination: # Specifies the address for the trap destination. This can be either an IP address or a hostname.
		# network: other|management|default
		# partition: Common
		# community: # Specifies the community name for the trap destination.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# port: # Specifies the port for the trap destination.
$0
endsnippet

snippet bigip_software_update "Manage the software update settings of a BIG-IP" b
- name: $1
	bigip_software_update:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# auto_phone_home: # Specifies whether to automatically send phone home data to the F5 Networks PhoneHome server.
		# auto_check: # Specifies whether to automatically check for updates on the F5 Networks downloads server.
		# frequency: daily|monthly|weekly
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_qkview "Manage qkviews on the device" b
- name: $1
	bigip_qkview:
		dest: ${2:# Destination on your local filesystem when you want to save the qkview.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# max_file_size: 0
		# force: yes
		# server_port: 443
		# asm_request_log: no
		# filename: localhost.localdomain.qkview
		# exclude_core: no
		# complete_information: yes
		# provider: # A dict object containing connection details.
		# exclude: all|audit|secure|bash_history
		# validate_certs: yes
$0
endsnippet

snippet bigip_monitor_tcp_half_open "Manages F5 BIG-IP LTM tcp half-open monitors" b
- name: $1
	bigip_monitor_tcp_half_open:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/tcp_half_open
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
$0
endsnippet

snippet bigip_device_connectivity "Manages device IP configuration settings for HA on a BIG-IP" b
- name: $1
	bigip_device_connectivity:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# multicast_interface: # Interface over which the system sends multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(eth0) will be used.
		# validate_certs: yes
		# server_port: 443
		# mirror_primary_address: # Specifies the primary IP address for the system to use to mirror connections.
		# failover_multicast: True|False
		# config_sync_ip: # Local IP address that the system uses for ConfigSync operations.
		# provider: # A dict object containing connection details.
		# mirror_secondary_address: # Specifies the secondary IP address for the system to use to mirror connections.
		# multicast_address: # IP address for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(224.0.0.245) will be used.
		# unicast_failover: # Desired addresses to use for failover operations. Options C(address) and C(port) are supported with dictionary structure where C(address) is the local IP address that the system uses for failover operations. Port specifies the port that the system uses for failover operations. If C(port) is not specified, the default value C(1026) will be used.  If you are specifying the (recommended) management IP address, use 'management-ip' in the address field.
		# multicast_port: # Port for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(62960) will be used. This value must be between 0 and 65535.
$0
endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings" b
- name: $1
	bigip_device_dns:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# forwarders: # A list of BIND servers that the system can use to perform DNS lookups
		# name_servers: # A list of name servers that the system uses to validate DNS lookups
		# search: # A list of domains that the system searches for local domain lookups, to resolve local host names.
		# cache: enabled|disabled
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# ip_version: 4|6
		# validate_certs: yes
$0
endsnippet

snippet bigip_command "Run arbitrary command on F5 devices" b
- name: $1
	bigip_command:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		transport: ${3:#rest|cli}
		commands: ${4:# The commands to send to the remote BIG-IP device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries as expired.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${6:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails. See examples.
		# retries: 10
		# interval: 1
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# match: all
$0
endsnippet

snippet bigip_monitor_https "Manages F5 BIG-IP LTM https monitors" b
- name: $1
	bigip_monitor_https:
		name: ${2:# Monitor name.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# parent: /Common/https
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# partition: Common
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\\r\\n) will be used.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# server_port: 443
		# state: #present|absent
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# provider: # A dict object containing connection details.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# validate_certs: yes
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
$0
endsnippet

snippet bigip_device_trust "Manage the trust relationships between BIG-IPs" b
- name: $1
	bigip_device_trust:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		peer_server: ${3:# The peer address to connect to and trust for synchronizing configuration. This is typically the management address of the remote device, but may also be a Self IP.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${5:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# type: #peer|subordinate
		# peer_hostname: # The hostname that you want to associate with the device. This value will be used to easily distinguish this device in BIG-IP configuration. If not specified, the value of C(peer_server) will be used as a default.
		# peer_user: # The API username of the remote peer device that you are trusting. Note that the CLI user cannot be used unless it too has an API account. If this value is not specified, then the value of C(user), or the environment variable C(F5_USER) will be used.
		# peer_password: # The password of the API username of the remote peer device that you are trusting. If this value is not specified, then the value of C(password), or the environment variable C(F5_PASSWORD) will be used.
		# state: absent|#present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigiq_regkey_license "Manages licenses in a BIG-IQ registration key pool" b
- name: $1
	bigiq_regkey_license:
		regkey_pool: ${2:# The registration key pool that you want to place the license in.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		license_key: ${5:# The license key to put in the pool.}
		password: ${6:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# description: # Description of the license.
		# state: absent|#present
		# accept_eula: # A key that signifies that you accept the F5 EULA for this license.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_traffic_group "Manages traffic groups on BIG-IP" b
- name: $1
	bigip_traffic_group:
		name: ${2:# The name of the traffic group.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_snmp "Manipulate general SNMP settings on a BIG-IP" b
- name: $1
	bigip_snmp:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# agent_status_traps: enabled|disabled
		# agent_authentication_traps: enabled|disabled
		# device_warning_traps: enabled|disabled
		# contact: # Specifies the name of the person who administers the SNMP service for this system.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
		# location: # Specifies the description of this system's physical location.
$0
endsnippet

snippet bigip_config "Manage BIG-IP configuration sections" b
- name: $1
	bigip_config:
		password: ${2:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		# reset: no
		# merge_content: # Loads the specified configuration that you want to merge into the running configuration. This is equivalent to using the C(tmsh) command C(load sys config from-terminal merge). If you need to read configuration from a file or template, use Ansible's C(file) or C(template) lookup plugins respectively.
		# verify: no
		# server_port: 443
		# provider: # A dict object containing connection details.
		# save: no
		# validate_certs: yes
$0
endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP" b
- name: $1
	bigip_device_sshd:
		user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${3:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		server: ${4:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		# server_port: 443
		# banner_text: # Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.
		# inactivity_timeout: # Specifies the number of seconds before inactivity causes an SSH session to log out.
		# banner: enabled|disabled
		# port: # Port that you want the SSH daemon to run on.
		# log_level: debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose
		# allow: all|IP address, such as 172.27.1.10|IP range, such as 172.27.*.* or 172.27.0.0/255.255.0.0
		# provider: # A dict object containing connection details.
		# login: enabled|disabled
		# validate_certs: yes
$0
endsnippet

snippet bigip_device_group "Manage device groups on a BIG-IP" b
- name: $1
	bigip_device_group:
		name: ${2:# Specifies the name of the device group.}
		server: ${3:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${5:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# auto_sync: # Indicates whether configuration synchronization occurs manually or automatically. When creating a new device group, this option will default to C(false).
		# validate_certs: yes
		# max_incremental_sync_size: # Specifies the size of the changes cache for incremental sync. For example, using the default, if you make more than 1024 KB worth of incremental changes, the system performs a full synchronization operation. Using incremental synchronization operations can reduce the per-device sync/load time for configuration changes. This setting is relevant only when C(full_sync) is C(false).
		# server_port: 443
		# save_on_auto_sync: # When performing an auto-sync, specifies whether the configuration will be saved or not. If C(false), only the running configuration will be changed on the device(s) being synced to. When creating a new device group, this option will default to C(false).
		# state: present|absent
		# full_sync: # Specifies whether the system synchronizes the entire configuration during synchronization operations. When C(false), the system performs incremental synchronization operations, based on the cache size specified in C(max_incremental_sync_size). Incremental configuration synchronization is a mechanism for synchronizing a device-group's configuration among its members, without requiring a full configuration load for each configuration change. In order for this to work, all devices in the device-group must initially agree on the configuration. Typically this requires at least one full configuration load to each device. When creating a new device group, this option will default to C(false).
		# provider: # A dict object containing connection details.
		# type: sync-failover|sync-only
		# description: # Description of the device group.
$0
endsnippet

snippet bigip_partition "Manage BIG-IP partitions" b
- name: $1
	bigip_partition:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		name: ${5:# Name of the partition}
		# description: # The description to attach to the Partition.
		# state: #present|absent
		# route_domain: # The default Route Domain to assign to the Partition. If no route domain is specified, then the default route domain for the system (typically zero) will be used only when creating a new partition.
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings" b
- name: $1
	bigip_sys_global:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# security_banner: # Specifies whether the system displays an advisory message on the login screen.
		# net_reboot: # Specifies, when C(enabled), that the next time you reboot the system, the system boots to an ISO image on the network, rather than an internal media drive.
		# banner_text: # Specifies the text to present in the advisory banner.
		# console_timeout: # Specifies the number of seconds of inactivity before the system logs off a user that is logged on.
		# quiet_boot: # Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.
		# mgmt_dhcp: # Specifies whether or not to enable DHCP client on the management interface
		# state: #present
		# server_port: 443
		# provider: # A dict object containing connection details.
		# gui_setup: # C(enable) or C(disabled) the Setup utility in the browser-based Configuration utility.
		# validate_certs: yes
		# lcd_display: # Specifies, when C(enabled), that the system menu displays on the LCD screen on the front of the unit. This setting has no effect when used on the VE platform.
$0
endsnippet

snippet bigip_iapplx_package "Manages Javascript iApp packages on a BIG-IP" b
- name: $1
	bigip_iapplx_package:
		server: ${2:# The BIG-IP host. You can omit this option if the environment variable C(F5_SERVER) is set.}
		user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. You can omit this option if the environment variable C(F5_USER) is set.}
		password: ${4:# The password for the user account used to connect to the BIG-IP. You can omit this option if the environment variable C(F5_PASSWORD) is set.}
		# package: # The iAppLX package that you want to upload or remove. When C(state) is C(present), and you intend to use this module in a C(role), it is recommended that you use the C({{ role_path }}) variable. An example is provided in the C(EXAMPLES) section.
		# state: #present|absent
		# server_port: 443
		# provider: # A dict object containing connection details.
		# validate_certs: yes
$0
endsnippet

snippet nxos_l3_interface "Manage L3 interfaces on Cisco NXOS network devices" b
- name: $1
	nxos_l3_interface:
		# name: # Name of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# state: #present|absent
		# ipv4: # IPv4 of the L3 interface.
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet nxos_udld "Manages UDLD global configuration params." b
- name: $1
	nxos_udld:
		# reset: true
		# msg_time: # Message time in seconds for UDLD packets or keyword 'default'.
		# aggressive: enabled|disabled
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_igmp "Manages IGMP global configuration." b
- name: $1
	nxos_igmp:
		# state: #present|default
		# provider: # B(Deprecated)
		# enforce_rtr_alert: true|false
		# restart: true|false
		# flush_routes: true|false
$0
endsnippet

snippet nxos_overlay_global "Configures anycast gateway MAC of the switch." b
- name: $1
	nxos_overlay_global:
		anycast_gateway_mac: ${2:# Anycast gateway mac of the switch.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp_auth "Manages NTP authentication." b
- name: $1
	nxos_ntp_auth:
		# auth_type: #text|encrypt
		# state: #present|absent
		# provider: # B(Deprecated)
		# key_id: # Authentication key identifier (numeric).
		# trusted_key: true|false
		# authentication: on|off
		# md5string: # MD5 String.
$0
endsnippet

snippet nxos_install_os "Set boot options like boot, kickstart image and issu." b
- name: $1
	nxos_install_os:
		system_image_file: ${2:# Name of the system (or combined) image file on flash.}
		# issu: required|desired|yes|#no
		# kickstart_image_file: # Name of the kickstart image file on flash. (Not required on all Nexus platforms)
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_acl_interface "Manages applying ACLs to interfaces." b
- name: $1
	nxos_acl_interface:
		interface: ${2:# Full name of interface, e.g. I(Ethernet1/1).}
		direction: ${3:ingress|egress}
		name: ${4:# Case sensitive name of the access list (ACL).}
		# provider: # B(Deprecated)
		# state: #present|absent
$0
endsnippet

snippet nxos_igmp_snooping "Manages IGMP snooping global configuration." b
- name: $1
	nxos_igmp_snooping:
		# link_local_grp_supp: # Global link-local groups suppression.
		# report_supp: # Global IGMPv1/IGMPv2 Report Suppression.
		# snooping: # Enables/disables IGMP snooping on the switch.
		# provider: # B(Deprecated)
		# group_timeout: # Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).
		# v3_report_supp: # Global IGMPv3 Report Suppression and Proxy Reporting.
		# state: #present|default
$0
endsnippet

snippet nxos_igmp_interface "Manages IGMP interface configuration." b
- name: $1
	nxos_igmp_interface:
		interface: ${2:# The full interface name for IGMP configuration. e.g. I(Ethernet1/2).}
		# startup_query_interval: # Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31.
		# group_timeout: # Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds.
		# oif_routemap: # Configure a routemap for static outgoing interface (OIF).
		# oif_prefix: # Configure a prefix for static outgoing interface (OIF).
		# querier_timeout: # Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds.
		# last_member_query_count: # Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2.
		# restart: true|false
		# report_llg: true|false
		# last_member_qrt: # Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second.
		# robustness: # Sets the robustness variable. Values can range from 1 to 7. The default is 2.
		# startup_query_count: # Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2.
		# immediate_leave: true|false
		# state: #present|default
		# version: 2|3
		# provider: # B(Deprecated)
		# oif_source: # Configure a source for static outgoing interface (OIF).
		# query_interval: # Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. The default is 125 seconds.
		# query_mrt: # Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds.
$0
endsnippet

snippet nxos_acl "Manages access list entries for ACLs." b
- name: $1
	nxos_acl:
		name: ${2:# Case sensitive name of the access list (ACL).}
		# src_port_op: any|eq|gt|lt|neq|range
		# psh: enable
		# seq: # Sequence number of the entry (ACE).
		# src: # Source ip and mask using IP/MASK notation and supports keyword 'any'.
		# dest: # Destination ip and mask using IP/MASK notation and supports the keyword 'any'.
		# syn: enable
		# dscp: af11|af12|af13|af21|af22|af23|af31|af32|af33|af41|af42|af43|cs1|cs2|cs3|cs4|cs5|cs6|cs7|default|ef
		# time_range: # Name of time-range to apply.
		# dest_port_op: any|eq|gt|lt|neq|range
		# rst: enable
		# dest_port2: # Second (end) port when using range operand.
		# established: enable
		# remark: # If action is set to remark, this is the description.
		# urg: enable
		# log: enable
		# proto: # Port number or protocol (as supported by the switch).
		# ack: enable
		# src_port1: # Port/protocol and also first (lower) port when using range operand.
		# precedence: critical|flash|flash-override|immediate|internet|network|priority|routine
		# state: #present|absent|delete_acl
		# provider: # B(Deprecated)
		# action: permit|deny|remark
		# dest_port1: # Port/protocol and also first (lower) port when using range operand.
		# fragments: enable
		# fin: enable
		# src_port2: # Second (end) port when using range operand.
$0
endsnippet

snippet nxos_aaa_server_host "Manages AAA server host-specific configuration." b
- name: $1
	nxos_aaa_server_host:
		server_type: ${2:radius|tacacs}
		address: ${3:# Address or name of the radius or tacacs host.}
		# encrypt_type: 0|7
		# provider: # B(Deprecated)
		# auth_port: # Alternate UDP port for RADIUS authentication or keyword 'default'.
		# tacacs_port: # Alternate TCP port TACACS Server or keyword 'default'.
		# host_timeout: # Timeout period for specified host, in seconds or keyword 'default. Range is 1-60.
		# state: #present|absent
		# key: # Shared secret for the specified host or keyword 'default'.
		# acct_port: # Alternate UDP port for RADIUS accounting or keyword 'default'.
$0
endsnippet

snippet nxos_l2_interface "Manage Layer-2 interface on Cisco NXOS devices." b
- name: $1
	nxos_l2_interface:
		name: ${2:# Full name of the interface excluding any logical unit number, i.e. Ethernet1/1.}
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# trunk_vlans: # List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
		# state: #present|absent|unconfigured
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
		# mode: access|trunk
		# provider: # B(Deprecated)
		# aggregate: # List of Layer-2 interface definitions.
$0
endsnippet

snippet nxos_feature "Manage features in NX-OS switches." b
- name: $1
	nxos_feature:
		feature: ${2:# Name of feature.}
		# state: #enabled|disabled
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ospf_vrf "Manages a VRF for an OSPF router." b
- name: $1
	nxos_ospf_vrf:
		ospf: ${2:# Name of the OSPF instance.}
		# router_id: # Router Identifier (ID) of the OSPF router VRF instance.
		# timer_throttle_lsa_max: # Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_spf_max: # Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# auto_cost: # Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.
		# timer_throttle_lsa_hold: # Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# default_metric: # Specify the default Metric value. Valid values are an integer or the keyword 'default'.
		# provider: # B(Deprecated)
		# log_adjacency: log|detail|default
		# timer_throttle_lsa_start: # Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# state: #present|absent
		# vrf: default
		# passive_interface: true|false
		# timer_throttle_spf_start: # Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_spf_hold: # Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
$0
endsnippet

snippet nxos_vtp_password "Manages VTP password configuration." b
- name: $1
	nxos_vtp_password:
		# vtp_password: # VTP password
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_reboot "Reboot a network device." b
- name: $1
	nxos_reboot:
		# provider: # B(Deprecated)
		# confirm: no
$0
endsnippet

snippet nxos_bgp_neighbor "Manages BGP neighbors configurations." b
- name: $1
	nxos_bgp_neighbor:
		asn: ${2:# BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${3:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		# update_source: # Specify source interface of BGP session and updates.
		# maximum_peers: # Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit. Note that this parameter is accepted only on neighbors with address/prefix.
		# timers_holdtime: # Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.
		# local_as: # Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
		# pwd_type: 3des|cisco_type_7|default
		# timers_keepalive: # Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.
		# dynamic_capability: true|false
		# vrf: default
		# shutdown: true|false
		# low_memory_exempt: true|false
		# log_neighbor_changes: enable|disable|inherit
		# remove_private_as: enable|disable|all|replace-as
		# suppress_4_byte_as: true|false
		# connected_check: true|false
		# remote_as: # Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
		# ebgp_multihop: # Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.
		# description: # Description of the neighbor.
		# pwd: # Specify the password for neighbor. Valid value is string.
		# state: #present|absent
		# transport_passive_only: true|false
		# capability_negotiation: true|false
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_evpn_vni "Manages Cisco EVPN VXLAN Network Identifier (VNI)." b
- name: $1
	nxos_evpn_vni:
		route_distinguisher: ${2:# The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.}
		vni: ${3:# The EVPN VXLAN Network Identifier.}
		# state: #present|absent
		# route_target_import: # Sets the route-target 'import' extended communities.
		# provider: # B(Deprecated)
		# route_target_export: # Sets the route-target 'export' extended communities.
		# route_target_both: # Enables/Disables route-target settings for both import and export target communities using a single property.
$0
endsnippet

snippet nxos_user "Manage the collection of local users on Nexus devices" b
- name: $1
	nxos_user:
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the network device. The password needs to be provided in cleartext and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# name: # The username to be configured on the remote Cisco Nexus device.  This argument accepts a string value and is mutually exclusive with the C(aggregate) argument.
		# purge: no
		# state: #present|absent
		# role: # The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.
		# provider: # B(Deprecated)
		# aggregate: # The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.
		# sshkey: # The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.
$0
endsnippet

snippet nxos_gir "Trigger a graceful removal or insertion (GIR) of the switch." b
- name: $1
	nxos_gir:
		state: ${2:#present|absent}
		# system_mode_maintenance_on_reload_reset_reason: hw_error|svc_failure|kern_failure|wdog_timeout|fatal_error|lc_failure|match_any|manual_reload
		# system_mode_maintenance: true|false
		# system_mode_maintenance_dont_generate_profile: true|false
		# provider: # B(Deprecated)
		# system_mode_maintenance_shutdown: true|false
		# system_mode_maintenance_timeout: # Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.
$0
endsnippet

snippet nxos_logging "Manage logging on network devices" b
- name: $1
	nxos_logging:
		# aggregate: # L
		# facility_level: # Set logging serverity levels for facility based log messages.
		# name: # If value of C(dest) is I(logfile) it indicates file-name.
		# facility: # Facility name for logging.
		# dest: console|logfile|module|monitor
		# dest_level: # Set logging severity levels.
		# provider: # B(Deprecated)
		# state: #present|absent
$0
endsnippet

snippet nxos_interface_ospf "Manages configuration of an OSPF interface instance." b
- name: $1
	nxos_interface_ospf:
		area: ${2:# Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.}
		interface: ${3:# Name of this cisco_interface resource. Valid value is a string.}
		ospf: ${4:# Name of the ospf instance.}
		# hello_interval: # Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.
		# message_digest_algorithm_type: md5|default
		# message_digest_key_id: # Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.
		# provider: # B(Deprecated)
		# message_digest_encryption_type: cisco_type_7|3des|default
		# dead_interval: # Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.
		# state: #present|absent
		# cost: # The cost associated with this cisco_interface_ospf instance.
		# passive_interface: true|false
		# message_digest_password: # Specifies the message_digest password. Valid value is a string.
		# message_digest: true|false
$0
endsnippet

snippet nxos_aaa_server "Manages AAA server global configuration." b
- name: $1
	nxos_aaa_server:
		state: ${2:#present|default}
		server_type: ${3:radius|tacacs}
		# server_timeout: # Global AAA server timeout period, in seconds or keyword 'default. Range is 1-60. Device default is 5.
		# deadtime: # Duration for which a non-reachable AAA server is skipped, in minutes or keyword 'default. Range is 1-1440. Device default is 0.
		# directed_request: enabled|disabled
		# encrypt_type: 0|7
		# global_key: # Global AAA shared secret or keyword 'default'.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_rollback "Set a checkpoint or rollback to a checkpoint." b
- name: $1
	nxos_rollback:
		# checkpoint_file: # Name of checkpoint file to create. Mutually exclusive with rollback_to.
		# rollback_to: # Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_pim "Manages configuration of a PIM instance." b
- name: $1
	nxos_pim:
		ssm_range: ${2:# Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword C(none) or keyword C(default). C(none) removes all SSM group ranges. C(default) will set ssm_range to the default multicast address. If you set multicast address, please ensure that it is not the same as the C(default), otherwise use the C(default) option.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_interface "Manages physical attributes of interfaces." b
- name: $1
	nxos_interface:
		name: ${2:# Full name of interface, i.e. Ethernet1/1, port-channel10.}
		state: ${3:#present|absent|default}
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# description: # Interface description.
		# ip_forward: enable|disable
		# interface_type: loopback|portchannel|svi|nve
		# rx_rate: # Receiver rate in bits per second (bps).
		# admin_state: #up|down
		# aggregate: # L
		# speed: # Interface link speed. Applicable for ethernet interface only.
		# tx_rate: # Transmit rate in bits per second (bps).
		# fabric_forwarding_anycast_gateway: true|false
		# duplex: full|half|#auto
		# mtu: # MTU for a specific interface. Must be an even number between 576 and 9216. Applicable for ethernet interface only.
		# delay: 10
		# mode: layer2|layer3
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_file_copy "Copy a file to a remote NXOS device over SCP." b
- name: $1
	nxos_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist.}
		# provider: # B(Deprecated)
		# remote_file: # Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used.
		# file_system: # The remote file system of the device. If omitted, devices that support a I(file_system) parameter will use their default values.
		# connect_ssh_port: 22
$0
endsnippet

snippet nxos_gir_profile_management "Create a maintenance-mode or normal-mode profile for GIR." b
- name: $1
	nxos_gir_profile_management:
		mode: ${2:maintenance|normal}
		# commands: # List of commands to be included into the profile.
		# provider: # B(Deprecated)
		# state: #present|absent
$0
endsnippet

snippet nxos_static_route "Manages static route configuration" b
- name: $1
	nxos_static_route:
		prefix: ${2:# Destination prefix of static route.}
		next_hop: ${3:# Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.}
		# pref: # Preference or administrative difference of route (range 1-255) or keyword 'default'.
		# route_name: # Name of the route or keyword 'default'. Used with the name parameter on the CLI.
		# state: #present|absent
		# tag: # Route tag value (numeric) or keyword 'default'.
		# provider: # B(Deprecated)
		# aggregate: # L
		# vrf: default
$0
endsnippet

snippet nxos_vlan "Manages VLAN resources and attributes." b
- name: $1
	nxos_vlan:
		# purge: no
		# vlan_state: #active|suspend
		# name: null - Name of VLAN or keyword 'default'.
		# interfaces: # List of interfaces that should be associated to the VLAN or keyword 'default'.
		# mapped_vni: # The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'. Range 4096-16773119.
		# delay: 10
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# state: #present|absent
		# admin_state: #up|down
		# mode: #ce|fabricpath
		# provider: # B(Deprecated)
		# aggregate: # L
		# vlan_range: # Range of VLANs such as 2-10 or 2,5,10-15, etc.
		# vlan_id: # Single VLAN ID.
$0
endsnippet

snippet nxos_snmp_traps "Manages SNMP traps." b
- name: $1
	nxos_snmp_traps:
		group: ${2:aaa|bfd|bgp|bridge|callhome|cfs|config|eigrp|entity|feature-control|generic|hsrp|license|link|lldp|mmode|ospf|pim|rf|rmon|snmp|storm-control|stpx|switchfabric|syslog|sysmgr|system|upgrade|vtp|all}
		# state: #enabled|disabled
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_command "Run arbitrary command on Cisco NXOS devices" b
- name: $1
	nxos_command:
		commands: ${2:# The commands to send to the remote NXOS device.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# match: all
$0
endsnippet

snippet nxos_banner "Manage multiline banners on Cisco NXOS devices" b
- name: $1
	nxos_banner:
		banner: ${2:exec|motd}
		# text: # The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vpc "Manages global VPC configuration" b
- name: $1
	nxos_vpc:
		domain: ${2:# VPC domain}
		state: ${3:present|absent}
		# system_priority: # System priority device.  Remember they must match between peers.
		# role_priority: # Role priority for device. Remember lower is better.
		# auto_recovery: true|false
		# pkl_vrf: management
		# delay_restore: # manages delay restore command and config value in seconds
		# peer_gw: true|false
		# provider: # B(Deprecated)
		# pkl_dest: # Destination (remote) IP address used for peer keepalive link
		# pkl_src: # Source IP address used for peer keepalive link
$0
endsnippet

snippet nxos_vtp_domain "Manages VTP domain configuration." b
- name: $1
	nxos_vtp_domain:
		domain: ${2:# VTP domain name.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp_af "Manages BGP Address-family configuration." b
- name: $1
	nxos_bgp_af:
		afi: ${2:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${3:unicast|multicast|evpn}
		vrf: ${4:# Name of the VRF. The name 'default' is a valid VRF representing the global bgp.}
		asn: ${5:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		# dampening_max_suppress_time: # Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.
		# additional_paths_send: true|false
		# additional_paths_install: true|false
		# dampening_state: true|false
		# additional_paths_receive: true|false
		# suppress_inactive: true|false
		# dampening_routemap: # Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.
		# distance_ibgp: # Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.
		# distance_local: # Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.
		# advertise_l2vpn_evpn: true|false
		# default_information_originate: true|false
		# networks: # Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']].
		# state: #present|absent
		# next_hop_route_map: # Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.
		# provider: # B(Deprecated)
		# table_map_filter: true|false
		# default_metric: # Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'
		# client_to_client: true|false
		# dampen_igp_metric: # Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.
		# additional_paths_selection: # Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.
		# maximum_paths_ibgp: # Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
		# distance_ebgp: # Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.
		# redistribute: # A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].
		# dampening_reuse_time: # Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.
		# maximum_paths: # Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
		# inject_map: # An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].
		# dampening_suppress_time: # Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.
		# table_map: # Apply table-map to filter routes downloaded into URIB. Valid values are a string.
		# dampening_half_time: # Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.
$0
endsnippet

snippet nxos_system "Manage the system attributes on Cisco NXOS devices" b
- name: $1
	nxos_system:
		# domain_lookup: # Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.
		# state: #present|absent
		# provider: # B(Deprecated)
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.
		# domain_search: # Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# system_mtu: # Specifies the mtu, must be an integer.
		# domain_name: # Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name.  See examples.
$0
endsnippet

snippet nxos_vrf_af "Manages VRF AF." b
- name: $1
	nxos_vrf_af:
		afi: ${2:ipv4|ipv6}
		safi: ${3:unicast|multicast}
		vrf: ${4:# Name of the VRF.}
		# state: #present|absent
		# route_target_both_auto_evpn: true|false
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vxlan_vtep "Manages VXLAN Network Virtualization Endpoint (NVE)." b
- name: $1
	nxos_vxlan_vtep:
		interface: ${2:# Interface name for the VXLAN Network Virtualization Endpoint.}
		# state: #present|absent
		# description: # Description of the NVE interface.
		# shutdown: true|false
		# source_interface: # Specify the loopback interface whose IP address should be used for the NVE interface.
		# provider: # B(Deprecated)
		# host_reachability: true|false
		# source_interface_hold_down_time: # Suppresses advertisement of the NVE loopback address until the overlay has converged.
$0
endsnippet

snippet nxos_ospf "Manages configuration of an ospf instance." b
- name: $1
	nxos_ospf:
		ospf: ${2:# Name of the ospf instance.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_facts "Gets facts about NX-OS switches" b
- name: $1
	nxos_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp_neighbor_af "Manages BGP address-family's neighbors configuration." b
- name: $1
	nxos_bgp_neighbor_af:
		afi: ${2:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${3:unicast|multicast|evpn}
		asn: ${4:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${5:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		# default_originate: true|false
		# route_reflector_client: true|false
		# additional_paths_send: enable|disable|inherit
		# soo: # Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.
		# additional_paths_receive: enable|disable|inherit
		# suppress_inactive: true|false|default
		# unsuppress_map: # unsuppress-map. Valid values are a string defining a route-map name or 'default'.
		# prefix_list_out: # Valid values are a string defining a prefix-list name, or 'default'.
		# as_override: true|false
		# filter_list_out: # Valid values are a string defining a filter-list name, or 'default'.
		# allowas_in: # Activate allowas-in property
		# max_prefix_warning: true|false
		# max_prefix_threshold: # Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.
		# state: #present|absent
		# provider: # B(Deprecated)
		# advertise_map_non_exist: # Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.
		# default_originate_route_map: # Route-map for the default_originate property. Valid values are a string defining a route-map name, or 'default'. This is mutually exclusive with default_originate.
		# send_community: none|both|extended|standard|default
		# disable_peer_as_check: true|false
		# filter_list_in: # Valid values are a string defining a filter-list name, or 'default'.
		# weight: # Weight value. Valid values are an integer value or 'default'.
		# vrf: default
		# max_prefix_limit: # maximum-prefix limit value. Valid values are an integer value or 'default'.
		# route_map_in: # Valid values are a string defining a route-map name, or 'default'.
		# soft_reconfiguration_in: enable|always|inherit
		# max_prefix_interval: # Optional restart interval. Valid values are an integer. Requires max_prefix_limit. May not be combined with max_prefix_warning.
		# route_map_out: # Valid values are a string defining a route-map name, or 'default'.
		# next_hop_self: true|false
		# prefix_list_in: # Valid values are a string defining a prefix-list name, or 'default'.
		# next_hop_third_party: true|false
		# advertise_map_exist: # Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.
		# allowas_in_max: # Max-occurrences value for allowas_in. Valid values are an integer value or 'default'. This is mutually exclusive with allowas_in.
$0
endsnippet

snippet nxos_hsrp "Manages HSRP configuration on NX-OS switches." b
- name: $1
	nxos_hsrp:
		group: ${2:# HSRP group number.}
		interface: ${3:# Full name of interface that is being managed for HSRP.}
		# auth_type: text|md5
		# preempt: enabled|disabled
		# auth_string: # Authentication string. If this needs to be hidden(for md5 type), the string should be 7 followed by the key string. Otherwise, it can be 0 followed by key string or just key string (for backward compatibility). For text type, this should be just be a key string. if this is 'default', authentication is removed.
		# vip: # HSRP virtual IP address or keyword 'default'
		# priority: # HSRP priority or keyword 'default'.
		# state: #present|absent
		# version: 1|2
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_user "Manages SNMP users for monitoring." b
- name: $1
	nxos_snmp_user:
		user: ${2:# Name of the user.}
		# authentication: md5|sha
		# state: #present|absent
		# encrypt: # Enables AES-128 bit encryption when using privacy password.
		# privacy: # Privacy password for the user. This is not idempotent
		# group: # Group to which the user will belong to. If state = present, and the user is existing, the group is added to the user. If the user is not existing, user entry is created with this group argument. If state = absent, only the group is removed from the user entry. However, to maintain backward compatibility, if the existing user belongs to only one group, and if group argument is same as the existing user's group, then the user entry also is deleted.
		# provider: # B(Deprecated)
		# pwd: # Authentication password when using md5 or sha. This is not idempotent
$0
endsnippet

snippet nxos_vxlan_vtep_vni "Creates a Virtual Network Identifier member (VNI)" b
- name: $1
	nxos_vxlan_vtep_vni:
		vni: ${2:# ID of the Virtual Network Identifier.}
		interface: ${3:# Interface name for the VXLAN Network Virtualization Endpoint.}
		# assoc_vrf: true|false
		# multicast_group: # The multicast group (range) of the VNI. Valid values are string and keyword 'default'.
		# state: #present|absent
		# peer_list: # Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.
		# provider: # B(Deprecated)
		# ingress_replication: bgp|static|default
		# suppress_arp: true|false
$0
endsnippet

snippet nxos_smu "Perform SMUs on Cisco NX-OS devices." b
- name: $1
	nxos_smu:
		pkg: ${2:# Name of the remote package.}
		# provider: # B(Deprecated)
		# file_system: # The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
$0
endsnippet

snippet nxos_udld_interface "Manages UDLD interface configuration params." b
- name: $1
	nxos_udld_interface:
		interface: ${2:# FULL name of the interface, i.e. Ethernet1/1-}
		mode: ${3:enabled|disabled|aggressive}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_location "Manages SNMP location information." b
- name: $1
	nxos_snmp_location:
		location: ${2:# Location information.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ping "Tests reachability using ping from Nexus switch." b
- name: $1
	nxos_ping:
		dest: ${2:# IP address or hostname (resolvable by switch) of remote node.}
		# count: 5
		# source: # Source IP Address or hostname (resolvable by switch)
		# state: absent|#present
		# vrf: # Outgoing VRF.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_config "Manage Cisco NXOS configuration sections" b
- name: $1
	nxos_config:
		# force: no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# diff_against: #startup|intended|running
		# replace: #line|block|config
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
		# save: no
		# replace_src: # The I(replace_src) argument provides path to the configuration file to load into the remote system. This argument is used to replace the entire config with a flat-file. This is used with argument I(replace) with value I(config). This is mutually exclusive with the I(lines) and I(src) arguments. This argument is supported on Nexus 9K device. Use I(nxos_file_copy) module to copy the flat file to remote device and then use the path with this argument.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: no
		# provider: # B(Deprecated)
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# save_when: always|#never|modified
		# backup: no
		# match: #line|strict|exact|none
$0
endsnippet

snippet nxos_linkagg "Manage link aggregation groups on Cisco NXOS devices." b
- name: $1
	nxos_linkagg:
		group: ${2:# Channel-group number for the port-channel Link aggregation group.}
		# force: True|#False
		# provider: # B(Deprecated)
		# purge: no
		# state: #present|absent
		# mode: active|passive|on
		# members: # List of interfaces that will be managed in the link aggregation group.
		# min_links: # Minimum number of ports required up before bringing up the link aggregation group.
		# aggregate: # L
$0
endsnippet

snippet nxos_vrf "Manages global VRF configuration." b
- name: $1
	nxos_vrf:
		name: ${2:# Name of VRF to be managed.}
		# rd: # VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.
		# interfaces: # List of interfaces to check the VRF has been configured correctly or keyword 'default'.
		# vni: # Specify virtual network identifier. Valid values are Integer or keyword 'default'.
		# purge: no
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# state: #present|absent
		# delay: 10
		# admin_state: #up|down
		# provider: # B(Deprecated)
		# aggregate: # L
		# description: # Description of the VRF or keyword 'default'.
$0
endsnippet

snippet nxos_nxapi "Manage NXAPI configuration on an NXOS device." b
- name: $1
	nxos_nxapi:
		# state: #present|absent
		# http_port: 80
		# http: yes|no
		# https_port: 443
		# https: yes|no
		# provider: # B(Deprecated)
		# sandbox: yes|no
$0
endsnippet

snippet nxos_vrf_interface "Manages interface specific VRF configuration." b
- name: $1
	nxos_vrf_interface:
		interface: ${2:# Full name of interface to be managed, i.e. Ethernet1/1.}
		vrf: ${3:# Name of VRF to be managed.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp_options "Manages NTP options." b
- name: $1
	nxos_ntp_options:
		# master: true|false
		# state: #present|absent
		# provider: # B(Deprecated)
		# logging: true|false
		# stratum: # If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.
$0
endsnippet

snippet nxos_bgp "Manages BGP configuration." b
- name: $1
	nxos_bgp:
		asn: ${2:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		# neighbor_down_fib_accelerate: true|false
		# confederation_peers: # AS confederation parameters.
		# confederation_id: # Routing domain confederation AS.
		# event_history_cli: size_small|size_medium|size_large|size_disable|default
		# bestpath_always_compare_med: true|false
		# cluster_id: # Route Reflector Cluster-ID.
		# shutdown: true|false
		# log_neighbor_changes: true|false
		# bestpath_aspath_multipath_relax: true|false
		# graceful_restart_timers_stalepath_time: # Set maximum time that BGP keeps the stale routes from the restarting BGP peer.
		# maxas_limit: # Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.
		# bestpath_med_confed: true|false
		# isolate: true|false
		# timer_bgp_keepalive: # Set BGP keepalive timer.
		# bestpath_cost_community_ignore: true|false
		# fast_external_fallover: true|false
		# state: #present|absent
		# disable_policy_batching: true|false
		# suppress_fib_pending: true|false
		# bestpath_med_missing_as_worst: true|false
		# router_id: # Router Identifier (ID) of the BGP router VRF instance.
		# timer_bestpath_limit: # Specify timeout for the first best path after a restart, in seconds.
		# bestpath_compare_neighborid: true|false
		# provider: # B(Deprecated)
		# local_as: # Local AS number to be used within a VRF instance.
		# event_history_periodic: size_small|size_medium|size_large|size_disable|default
		# disable_policy_batching_ipv4_prefix_list: # Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
		# vrf: # Name of the VRF. The name 'default' is a valid VRF representing the global BGP.
		# graceful_restart_helper: true|false
		# timer_bgp_hold: # Set BGP hold timer.
		# event_history_events: size_small|size_medium|size_large|size_disable|default
		# disable_policy_batching_ipv6_prefix_list: # Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
		# event_history_detail: size_small|size_medium|size_large|size_disable|default
		# graceful_restart: true|false
		# flush_routes: true|false
		# enforce_first_as: true|false
		# bestpath_med_non_deterministic: true|false
		# reconnect_interval: # The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.
		# graceful_restart_timers_restart: # Set maximum time for a restart sent to the BGP peer.
		# bestpath_compare_routerid: true|false
$0
endsnippet

snippet nxos_pim_interface "Manages PIM interface configuration." b
- name: $1
	nxos_pim_interface:
		jp_policy_out: ${2:# Policy for join-prune messages (outbound).}
		interface: ${3:# Full name of the interface such as Ethernet1/33.}
		# hello_auth_key: # Authentication for hellos on this interface.
		# dr_prio: # Configures priority for PIM DR election on interface.
		# hello_interval: true|false
		# jp_type_in: prefix|routemap
		# neighbor_type: prefix|routemap
		# state: #present|default
		# neighbor_policy: # Configures a neighbor policy for filtering adjacencies.
		# sparse: true|false
		# provider: # B(Deprecated)
		# jp_policy_in: # Policy for join-prune messages (inbound).
		# border: true|false
		# jp_type_out: prefix|routemap
$0
endsnippet

snippet nxos_snmp_contact "Manages SNMP contact info." b
- name: $1
	nxos_snmp_contact:
		state: ${2:#present|absent}
		contact: ${3:# Contact information.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_lldp "Manage LLDP configuration on Cisco NXOS network devices." b
- name: $1
	nxos_lldp:
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_evpn_global "Handles the EVPN control plane for VXLAN." b
- name: $1
	nxos_evpn_global:
		nv_overlay_evpn: ${2:true|false}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp "Manages core NTP configuration." b
- name: $1
	nxos_ntp:
		# source_addr: # Local source address from which NTP messages are sent or keyword 'default'
		# prefer: enabled|disabled
		# server: # Network address of NTP server.
		# state: #present|absent
		# vrf_name: # Makes the device communicate with the given NTP server or peer over a specific VRF or keyword 'default'.
		# provider: # B(Deprecated)
		# peer: # Network address of NTP peer.
		# key_id: # Authentication key identifier to use with given NTP server or peer or keyword 'default'.
		# source_int: # Local source interface from which NTP messages are sent. Must be fully qualified interface name or keyword 'default'
$0
endsnippet

snippet nxos_snmp_host "Manages SNMP host configuration." b
- name: $1
	nxos_snmp_host:
		snmp_host: ${2:# IP address of hostname of target host.}
		# vrf_filter: # Name of VRF to filter. If state = absent, the vrf is removed from the filter.
		# udp: 162
		# src_intf: # Source interface. Must be fully qualified interface name. If state = absent, the interface is removed.
		# community: # Community string or v3 username.
		# state: #present|absent
		# version: v1|v2c|v3
		# v3: noauth|auth|priv
		# snmp_type: trap|inform
		# provider: # B(Deprecated)
		# vrf: # VRF to use to source traffic to source. If state = absent, the vrf is removed.
$0
endsnippet

snippet nxos_vrrp "Manages VRRP configuration on NX-OS switches." b
- name: $1
	nxos_vrrp:
		group: ${2:# VRRP group number.}
		interface: ${3:# Full name of interface that is being managed for VRRP.}
		# preempt: True|False
		# vip: # VRRP virtual IP address.
		# authentication: # Clear text authentication string.
		# priority: # VRRP priority.
		# state: #present|absent
		# admin_state: shutdown|#no shutdown
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_pim_rp_address "Manages configuration of an PIM static RP address instance." b
- name: $1
	nxos_pim_rp_address:
		state: ${2:#present|absent|default}
		rp_address: ${3:# Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.}
		# bidir: true|false
		# provider: # B(Deprecated)
		# route_map: # Route map policy for static RP. Valid values are route-map policy names.
		# prefix_list: # Prefix list policy for static RP. Valid values are prefix-list policy names.
		# group_list: # Group range for static RP. Valid values are multicast addresses.
$0
endsnippet

snippet nxos_vpc_interface "Manages interface VPC configuration" b
- name: $1
	nxos_vpc_interface:
		state: ${2:present|absent}
		portchannel: ${3:# Group number of the portchannel that will be configured.}
		# vpc: # VPC group/id that will be configured on associated portchannel.
		# peer_link: # Set to true/false for peer link config on associated portchannel.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vtp_version "Manages VTP version configuration." b
- name: $1
	nxos_vtp_version:
		version: ${2:1|2}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snapshot "Manage snapshots of the running states of selected features." b
- name: $1
	nxos_snapshot:
		action: ${2:create|add|compare|delete}
		# description: # Snapshot description to be used when C(action=create).
		# section: # Used to name the show command output, to be used when C(action=add).
		# snapshot1: # First snapshot to be used when C(action=compare).
		# comparison_results_file: # Name of the file where snapshots comparison will be stored when C(action=compare).
		# snapshot2: # Second snapshot to be used when C(action=compare).
		# element_key1: # Specify the tags used to distinguish among row entries, to be used when C(action=add).
		# element_key2: # Specify the tags used to distinguish among row entries, to be used when C(action=add).
		# snapshot_name: # Snapshot name, to be used when C(action=create) or C(action=delete).
		# save_snapshot_locally: true|false
		# provider: # B(Deprecated)
		# path: ./
		# row_id: # Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).
		# show_command: # Specify a new show command, to be used when C(action=add).
		# compare_option: summary|ipv4routes|ipv6routes
$0
endsnippet

snippet nxos_snmp_community "Manages SNMP community configs." b
- name: $1
	nxos_snmp_community:
		community: ${2:# Case-sensitive community string.}
		# group: # Group to which the community belongs.
		# acl: # ACL name to filter snmp requests or keyword 'default'.
		# access: ro|rw
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nuage_vspk "Manage Nuage VSP environments" b
- name: $1
	nuage_vspk:
		auth: ${2:# Dict with the authentication information required to connect to a Nuage VSP environment.}
		type: ${3:# The type of entity you want to work on (example Enterprise).}
		# parent_type: # The type of parent the ID is specified for (example Enterprise).
		# properties: # Properties are the key, value pairs of the different properties an entity has.
		# match_filter: # A filter used when looking (both in I(command) and I(state) for entities, in the format the Nuage VSP API expects.
		# parent_id: # The ID of the parent of the entity you want to work on.
		# state: present|absent
		# command: find|change_password|wait_for_job|get_csp_enterprise
		# id: # The ID of the entity you want to work on.
		# children: # Can be used to specify a set of child entities.
$0
endsnippet

snippet netact_cm_command "Manage network configuration data in Nokia Core and Radio networks" b
- name: $1
	netact_cm_command:
		operation: ${2:upload|provision|import|export|Provision_Mass_Modification}
		# DN: # S
		# planName: # Specifies a plan name.
		# verbose: # N
		# opsName: # user specified operation name
		# fileName: # Specifies a file name. Valid for Import and Export operations.
		# typeOption: plan|actual|reference|template|siteTemplate
		# WS: # S
		# MR: # S
		# extra_opts: # E
		# createBackupPlan: # Specifies if backup plan generation is enabled.
		# backupPlanName: # Specifies a backup plan name
		# fileFormat: RAML2|CSV|XLSX
		# inputFile: # S
$0
endsnippet

snippet nso_show "Displays data from Cisco NSO." b
- name: $1
	nso_show:
		url: ${2:# N}
		path: ${3:# P}
		username: ${4:# N}
		password: ${5:# N}
		# operational: no
$0
endsnippet

snippet nso_config "Manage Cisco NSO configuration and service synchronization." b
- name: $1
	nso_config:
		url: ${2:# N}
		username: ${3:# N}
		password: ${4:# N}
		data: ${5:# N}
$0
endsnippet

snippet nso_action "Executes Cisco NSO actions and verifies output." b
- name: $1
	nso_action:
		username: ${2:# N}
		url: ${3:# N}
		path: ${4:# P}
		password: ${5:# N}
		# output_invalid: # L
		# output_required: # R
		# input: # N
		# validate_strict: # I
$0
endsnippet

snippet nso_query "Query data from Cisco NSO." b
- name: $1
	nso_query:
		xpath: ${2:# X}
		fields: ${3:# L}
		username: ${4:# N}
		password: ${5:# N}
		url: ${6:# N}
$0
endsnippet

snippet nso_verify "Verifies Cisco NSO configuration." b
- name: $1
	nso_verify:
		url: ${2:# N}
		username: ${3:# N}
		password: ${4:# N}
		data: ${5:# N}
$0
endsnippet

snippet sros_config "Manage Nokia SR OS device configuration" b
- name: $1
	sros_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# force: true|false
		# backup: yes|no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.  The I(lines) argument only supports current context lines.  See EXAMPLES
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: yes|no
		# provider: # A dict object containing connection details.
		# save: yes|no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet sros_command "Run commands on remote devices running Nokia SR OS" b
- name: $1
	sros_command:
		commands: ${2:# List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet sros_rollback "Configure Nokia SR OS rollback" b
- name: $1
	sros_rollback:
		# remote_max_checkpoints: # The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50
		# local_max_checkpoints: # The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50
		# rollback_location: # The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS
		# state: #present|absent
		# rescue_location: # The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet net_lldp "Manage LLDP service configuration on network devices" b
- name: $1
	net_lldp:
		# state: #present|absent
$0
endsnippet

snippet aci_vlan_pool "Manage VLAN pools (fvns:VlanInstP)" b
- name: $1
	aci_vlan_pool:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# pool_allocation_mode: dynamic|static
		# description: # Description for the C(pool).
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# pool: # The name of the pool.
		# use_proxy: yes
$0
endsnippet

snippet aci_tenant_span_src_group_to_dst_group "Bind SPAN source groups to destination groups (span:SpanLbl)" b
- name: $1
	aci_tenant_span_src_group_to_dst_group:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for Span source group to destination group binding.
		# certificate_name: C(private_key) basename
		# src_group: # The name of the Span source group.
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# dst_group: # The Span destination group to associate with the source group.
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the Tenant.
		# use_proxy: yes
$0
endsnippet

snippet aci_domain_to_vlan_pool "Bind Domain to VLAN Pools (infra:RsVlanNs)" b
- name: $1
	aci_domain_to_vlan_pool:
		username: ${2:admin}
		pool_allocation_mode: ${3:dynamic|static}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		# domain: # Name of the domain being associated with the VLAN Pool.
		# certificate_name: C(private_key) basename
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# use_ssl: yes
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: 443 (for https) and 80 (for http)
		# pool: # The name of the pool.
		# use_proxy: yes
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_epg "Manage End Point Groups (EPG) objects (fv:AEPg)" b
- name: $1
	aci_epg:
		bd: ${2:# Name of the bridge domain being associated with the EPG.}
		username: ${3:admin}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		ap: ${5:# Name of an existing application network profile, that will contain the EPGs.}
		epg: ${6:# Name of the end point group.}
		password: ${7:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the EPG.
		# certificate_name: C(private_key) basename
		# fwd_control: #none|proxy-arp
		# port: 443 (for https) and 80 (for http)
		# priority: level1|level2|level3|#unspecified
		# state: absent|#present|query
		# preferred_group: no
		# output_level: debug|info|#normal
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# intra_epg_isolation: enforced|#unenforced
		# tenant: # Name of an existing tenant.
		# use_proxy: yes
$0
endsnippet

snippet aci_aep_to_domain "Bind AEPs to Physical or Virtual Domains (infra:RsDomP)" b
- name: $1
	aci_aep_to_domain:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# aep: # The name of the Attachable Access Entity Profile.
		# domain: # Name of the physical or virtual domain being associated with the AEP.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# state: absent|#present|query
		# output_level: debug|info|#normal
		# timeout: 30
		# use_ssl: yes
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
$0
endsnippet

snippet aci_aaa_user_certificate "Manage AAA user certificates (aaa:UserCert)" b
- name: $1
	aci_aaa_user_certificate:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# aaa_user: # The name of the user to add a certificate to.
		# use_proxy: yes
		# certificate: # The PEM format public key extracted from the X.509 certificate.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# aaa_user_type: #user|appuser
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
$0
endsnippet

snippet aci_filter "Manages top level filter objects (vz:Filter)" b
- name: $1
	aci_filter:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		filter: ${4:# The name of the filter.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# output_level: debug|info|#normal
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the filter.
		# certificate_name: C(private_key) basename
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_config_snapshot "Manage Config Snapshots (config:Snapshot, config:ExportP)" b
- name: $1
	aci_config_snapshot:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# include_secure: yes
		# description: # The description for the Config Export Policy.
		# format: #json|xml
		# certificate_name: C(private_key) basename
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# max_count: range between 1 and 10
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# export_policy: # The name of the Export Policy to use for Config Snapshots.
		# use_proxy: yes
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# snapshot: # The name of the snapshot to delete.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
- name: $1
	aci_interface_policy_lldp:
		username: ${2:admin}
		receive_state: ${3:disabled|#enabled}
		lldp_policy: ${4:# The LLDP interface policy name.}
		host: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${6:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the LLDP interface policy name.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# transmit_state: disabled|#enabled
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
- name: $1
	aci_interface_policy_port_security:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		port_security: ${4:# The name of the port security.}
		password: ${5:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# max_end_points: # Maximum number of end points (range 0-12000).
		# description: # The description for the contract.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_tenant_span_src_group "Manage SPAN source groups (span:SrcGrp)" b
- name: $1
	aci_tenant_span_src_group:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for Span source group.
		# certificate_name: C(private_key) basename
		# admin_state: #enabled|disabled
		# use_ssl: yes
		# dst_group: # The Span destination group to associate with the source group.
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the Tenant.
		# use_proxy: yes
		# src_group: # The name of the Span source group.
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_static_binding_to_epg "Bind static paths to EPGs (fv:RsPathAtt)" b
- name: $1
	aci_static_binding_to_epg:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# interface_type: fex|port_channel|#switch_port|vpc
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# leafs: # The switch ID(s) that the C(interface) belongs to.
		# use_ssl: yes
		# pod_id: # The pod number part of the tDn.
		# interface_mode: 802.1p|access|native|regular|tagged|#trunk|untagged
		# use_proxy: yes
		# port: 443 (for https) and 80 (for http)
		# state: absent|#present|query
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# certificate_name: C(private_key) basename
		# primary_encap_id: Valid encap IDs for specified encap|currently 1 to 4096
		# interface: # The C(interface) string value part of the tDn.
		# encap_id: Valid encap IDs for specified encap|currently 1 to 4096
		# tenant: # Name of an existing tenant.
		# deploy_immediacy: immediate|#lazy
		# output_level: debug|info|#normal
		# timeout: 30
		# epg: # The name of the end point group.
		# validate_certs: yes
		# extpaths: # The C(extpaths) integer value part of the tDn.
$0
endsnippet

snippet aci_contract_subject "Manage initial Contract Subjects (vz:Subj)" b
- name: $1
	aci_contract_subject:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# use_proxy: yes
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the contract subject.
		# consumer_match: all|#at_least_one|at_most_one|none
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|#unspecified
		# priority: level1|level2|level3|#unspecified
		# state: absent|#present|query
		# contract: # The name of the Contract.
		# timeout: 30
		# use_ssl: yes
		# reverse_filter: yes
		# provider_match: all|#at_least_one|at_most_one|none
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the tenant.
		# subject: # The contract subject name.
$0
endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
- name: $1
	aci_interface_policy_l2:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		l2_policy: ${5:# The name of the Layer 2 interface policy.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description of the Layer 2 interface policy.
		# certificate_name: C(private_key) basename
		# vepa: #disabled|enabled
		# use_ssl: yes
		# vlan_scope: #global|portlocal
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# qinq: core|#disabled|edge
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
- name: $1
	aci_interface_policy_l2:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		l2_policy: ${5:# The name of the Layer 2 interface policy.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description of the Layer 2 interface policy.
		# certificate_name: C(private_key) basename
		# vepa: #disabled|enabled
		# use_ssl: yes
		# vlan_scope: #global|portlocal
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# qinq: core|#disabled|edge
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_filter_entry "Manage filter entries (vz:Entry)" b
- name: $1
	aci_filter_entry:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# dst_port_end: Valid TCP/UDP Port Ranges
		# ether_type: arp|fcoe|ip|mac_security|mpls_ucast|trill|#unspecified
		# arp_flag: arp_reply|arp_request|#unspecified
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# ip_protocol: eigrp|egp|icmp|icmpv6|igmp|igp|l2tp|ospfigp|pim|tcp|udp|#unspecified
		# output_level: debug|info|#normal
		# use_proxy: yes
		# icmp_msg_type: dst_unreachable|echo|echo_reply|src_quench|time_exceeded|#unspecified
		# state: absent|#present|query
		# dst_port_start: Valid TCP/UDP Port Ranges
		# description: # Description for the Filter Entry.
		# icmp6_msg_type: dst_unreachable|echo_request|echo_reply|neighbor_advertisement|neighbor_solicitation|redirect|time_exceeded|#unspecified
		# certificate_name: C(private_key) basename
		# stateful: # Determines the statefulness of the filter entry.
		# tenant: # The name of the tenant.
		# filter: # T
		# dst_port: Valid TCP/UDP Port Ranges
		# timeout: 30
		# entry: # Then name of the Filter Entry.
		# validate_certs: yes
$0
endsnippet

snippet aci_vrf "Manage contexts or VRFs (fv:Ctx)" b
- name: $1
	aci_vrf:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the VRF.
		# certificate_name: C(private_key) basename
		# vrf: # The name of the VRF.
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the Tenant the VRF should belong to.
		# use_proxy: yes
		# policy_control_preference: enforced|unenforced
		# policy_control_direction: egress|ingress
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_leaf_profile "Manage fabric interface policy leaf profiles (infra:AccPortP)" b
- name: $1
	aci_interface_policy_leaf_profile:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		leaf_interface_profile: ${5:# The name of the Fabric access policy leaf interface profile.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# description: # Description for the Fabric access policy leaf interface profile.
$0
endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
- name: $1
	aci_interface_policy_fc:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		fc_policy: ${4:# The name of the Fiber Channel interface policy.}
		password: ${5:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description of the Fiber Channel interface policy.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# port_mode: #f|np
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
- name: $1
	aci_interface_policy_fc:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		fc_policy: ${4:# The name of the Fiber Channel interface policy.}
		password: ${5:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description of the Fiber Channel interface policy.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# port_mode: #f|np
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_switch_policy_vpc_protection_group "Manage switch policy explicit vPC protection groups (fabric:ExplicitGEp, fabric:NodePEp)." b
- name: $1
	aci_switch_policy_vpc_protection_group:
		username: ${2:admin}
		switch_2_id: ${3:# The ID of the Second Leaf Switch for the Explicit vPC Protection Group.}
		switch_1_id: ${4:# The ID of the first Leaf Switch for the Explicit vPC Protection Group.}
		host: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		protection_group: ${6:# The name of the Explicit vPC Protection Group.}
		password: ${7:# The password to use for authentication.}
		protection_group_id: ${8:# The Explicit vPC Protection Group ID.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# certificate_name: C(private_key) basename
		# vpc_domain_policy: # The vPC domain policy to be associated with the Explicit vPC Protection Group.
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# validate_certs: yes
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
$0
endsnippet

snippet aci_tenant_action_rule_profile "Manage action rule profiles (rtctrl:AttrP)" b
- name: $1
	aci_tenant_action_rule_profile:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# output_level: debug|info|#normal
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the action rule profile.
		# certificate_name: C(private_key) basename
		# action_rule: # The name of the action rule profile.
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the tenant.
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
- name: $1
	aci_interface_policy_mcp:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		mcp: ${5:# The name of the MCP interface.}
		# use_proxy: yes
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the MCP interface.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# admin_state: disable|#enable
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
$0
endsnippet

snippet aci_ap "Manage top level Application Profile (AP) objects (fv:Ap)" b
- name: $1
	aci_ap:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		ap: ${4:# The name of the application network profile.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of an existing tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the AP.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_tenant_span_dst_group "Manage SPAN destination groups (span:DestGrp)" b
- name: $1
	aci_tenant_span_dst_group:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		dst_group: ${5:# The name of the SPAN destination group.}
		tenant: ${6:# The name of the tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description of the SPAN destination group.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
- name: $1
	aci_interface_policy_port_security:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		port_security: ${4:# The name of the port security.}
		password: ${5:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# max_end_points: # Maximum number of end points (range 0-12000).
		# description: # The description for the contract.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_taboo_contract "Manage taboo contracts (vz:BrCP)" b
- name: $1
	aci_taboo_contract:
		username: ${2:admin}
		taboo_contract: ${3:# The name of the Taboo Contract.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# description: # The description for the Taboo Contract.
		# certificate_name: C(private_key) basename
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# scope: application-profile|#context|global|tenant
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_contract "Manage contract resources (vz:BrCP)" b
- name: $1
	aci_contract:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		tenant: ${5:# The name of the tenant.}
		contract: ${6:# The name of the contract.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the contract.
		# certificate_name: C(private_key) basename
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|#unspecified
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# output_level: debug|info|#normal
		# use_proxy: yes
		# priority: level1|level2|level3|#unspecified
		# state: absent|#present|query
		# timeout: 30
		# scope: application-profile|#context|global|tenant
		# validate_certs: yes
$0
endsnippet

snippet aci_fabric_node "Manage Fabric Node Members (fabric:NodeIdentP)" b
- name: $1
	aci_fabric_node:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the new Fabric Node Member.
		# certificate_name: C(private_key) basename
		# node_id: # Node ID Number for the new Fabric Node Member.
		# use_ssl: yes
		# serial: # Serial Number for the new Fabric Node Member.
		# pod_id: # The pod id of the new Fabric Node Member.
		# use_proxy: yes
		# switch: # Switch Name for the new Fabric Node Member.
		# port: 443 (for https) and 80 (for http)
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# role: leaf|spine|unspecified
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_epg_to_contract "Bind EPGs to Contracts (fv:RsCons, fv:RsProv)" b
- name: $1
	aci_epg_to_contract:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		contract_type: ${5:consumer|proivder}
		# output_level: debug|info|#normal
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# contract: # The name of the contract.
		# priority: level1|level2|level3|#unspecified
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# epg: # The name of the end point group.
		# provider_match: all|#at_least_one|at_most_one|none
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# tenant: # Name of an existing tenant.
$0
endsnippet

snippet aci_encap_pool_range "Manage encap ranges assigned to pools (fvns:EncapBlk, fvns:VsanEncapBlk)" b
- name: $1
	aci_encap_pool_range:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		pool_type: ${4:vlan|vxlan|vsan}
		password: ${5:# The password to use for authentication.}
		# range_end: # The end of encap range.
		# range_start: # The start of the encap range.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# pool_allocation_mode: dynamic|static
		# description: # Description for the pool range.
		# certificate_name: C(private_key) basename
		# validate_certs: yes
		# state: absent|#present|query
		# output_level: debug|info|#normal
		# timeout: 30
		# use_ssl: yes
		# allocation_mode: dynamic|inherit|static
		# use_proxy: yes
		# port: 443 (for https) and 80 (for http)
		# pool: # The name of the pool that the range should be assigned to.
		# range_name: # The name to give to the encap range.
$0
endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
- name: $1
	aci_interface_policy_port_channel:
		port_channel: ${2:# Name of the port channel.}
		username: ${3:admin}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		# min_links: Ranges from 1 to 16
		# use_ssl: yes
		# fast_select: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# load_defer: no
		# state: absent|#present|query
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the port channel.
		# certificate_name: C(private_key) basename
		# graceful_convergence: yes
		# symmetric_hash: no
		# suspend_individual: yes
		# output_level: debug|info|#normal
		# mode: active|mac-pin|mac-pin-nicload|#off|passive
		# timeout: 30
		# validate_certs: yes
		# max_links: Ranges from 1 to 16
$0
endsnippet

snippet aci_switch_policy_leaf_profile "Manage switch policy leaf profiles (infra:NodeP)" b
- name: $1
	aci_switch_policy_leaf_profile:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# leaf_profile: # The name of the Leaf Profile.
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# description: # Description for the Leaf Profile.
$0
endsnippet

snippet aci_vlan_pool_encap_block "Manage encap blocks assigned to VLAN pools (fvns:EncapBlk)" b
- name: $1
	aci_vlan_pool_encap_block:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# pool_allocation_mode: dynamic|static
		# block_end: # The end of encap block.
		# description: # Description for the pool encap block.
		# certificate_name: C(private_key) basename
		# block_start: # The start of the encap block.
		# output_level: debug|info|#normal
		# block_name: # The name to give to the encap block.
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# allocation_mode: dynamic|inherit|static
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# pool: # The name of the pool that the encap block should be assigned to.
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_selector_to_switch_policy_leaf_profile "Bind interface selector profiles to switch policy leaf profiles (infra:RsAccPortP)" b
- name: $1
	aci_interface_selector_to_switch_policy_leaf_profile:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# leaf_profile: # Name of the Leaf Profile to which we add a Selector.
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# interface_selector: # Name of Interface Profile Selector to be added and associated with the Leaf Profile.
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
$0
endsnippet

snippet aci_bd_subnet "Manage Subnets (fv:Subnet)" b
- name: $1
	aci_bd_subnet:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_ssl: yes
		# gateway: # The IPv4 or IPv6 gateway address for the Subnet.
		# use_proxy: yes
		# port: 443 (for https) and 80 (for http)
		# state: absent|#present|query
		# subnet_name: # The name of the Subnet.
		# scope: #private|public|shared|[u'private', u'shared']|[u'public', u'shared']
		# bd: # The name of the Bridge Domain.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the Subnet.
		# certificate_name: C(private_key) basename
		# nd_prefix_policy: # The IPv6 Neighbor Discovery Prefix Policy to associate with the Subnet.
		# enable_vip: no
		# preferred: no
		# route_profile_l3_out: # The L3 Out that contains the assocated Route Profile.
		# tenant: # The name of the Tenant.
		# mask: Any 0 to 32 for IPv4 Addresses|0-128 for IPv6 Addresses
		# subnet_control: #nd_ra|no_gw|querier_ip|unspecified
		# output_level: debug|info|#normal
		# route_profile: # The Route Profile to the associate with the Subnet.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_encap_pool "Manage encap pools (fvns:VlanInstP, fvns:VxlanInstP, fvns:VsanInstP)" b
- name: $1
	aci_encap_pool:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		pool_type: ${4:vlan|vxlan|vsan}
		password: ${5:# The password to use for authentication.}
		# output_level: debug|info|#normal
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# pool_allocation_mode: dynamic|static
		# description: # Description for the C(pool).
		# certificate_name: C(private_key) basename
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# pool: # The name of the pool.
		# use_proxy: yes
$0
endsnippet

snippet aci_contract_subject_to_filter "Bind Contract Subjects to Filters (vz:RsSubjFiltAtt)" b
- name: $1
	aci_contract_subject_to_filter:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		tenant: ${5:# The name of the tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# certificate_name: C(private_key) basename
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# output_level: debug|info|#normal
		# log: log|none
		# contract: # The name of the contract.
		# filter: # The name of the Filter to bind to the Subject.
		# state: absent|#present|query
		# timeout: 30
		# subject: # The name of the Contract Subject.
		# validate_certs: yes
$0
endsnippet

snippet aci_domain "Manage physical, virtual, bridged, routed or FC domain profiles (phys:DomP, vmm:DomP, l2ext:DomP, l3ext:DomP, fc:DomP)" b
- name: $1
	aci_domain:
		username: ${2:admin}
		password: ${3:# The password to use for authentication.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# output_level: debug|info|#normal
		# domain: # Name of the physical, virtual, bridged routed or FC domain profile.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|#unspecified
		# port: 443 (for https) and 80 (for http)
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# state: absent|#present|query
		# timeout: 30
		# encap_mode: unknown|vlan|vxlan
		# vswitch: avs|#default|dvs|unknown
		# multicast_address: # The muticast IP address to use for the virtual switch.
		# use_ssl: yes
		# validate_certs: yes
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
$0
endsnippet

snippet aci_access_port_to_interface_policy_leaf_profile "Manage Fabric interface policy leaf profile interface selectors (infra:HPortS, infra:RsAccBaseGrp, infra:PortBlk)" b
- name: $1
	aci_access_port_to_interface_policy_leaf_profile:
		username: ${2:admin}
		from: ${3:# The beggining (from range) of the port range block for the leaf access port block.}
		access_port_selector: ${4:# The name of the Fabric access policy leaf interface profile access port selector.}
		leaf_port_blk: ${5:# The name of the Fabric access policy leaf interface profile access port block.}
		host: ${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
		to: ${7:# The end (to range) of the port range block for the leaf access port block.}
		password: ${8:# The password to use for authentication.}
		leaf_interface_profile: ${9:# The name of the Fabric access policy leaf interface profile.}
		# output_level: debug|info|#normal
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description to assign to the C(access_port_selector)
		# validate_certs: yes
		# certificate_name: C(private_key) basename
		# policy_group: # The name of the fabric access policy group to be associated with the leaf interface profile interface selector.
		# leaf_port_blk_description: # The description to assign to the C(leaf_port_blk)
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_config_rollback "Provides rollback and rollback preview functionality (config:ImportP)" b
- name: $1
	aci_config_rollback:
		username: ${2:admin}
		export_policy: ${3:# The export policy that the C(snapshot) is associated to.}
		password: ${4:# The password to use for authentication.}
		snapshot: ${5:# The name of the snapshot to rollback to, or the base snapshot to use for comparison.}
		host: ${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
		# use_proxy: yes
		# import_mode: #atomic|best-effort
		# description: # The description for the Import Policy.
		# fail_on_decrypt: yes
		# compare_export_policy: # The export policy that the C(compare_snapshot) is associated to.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: preview|#rollback
		# timeout: 30
		# certificate_name: C(private_key) basename
		# import_type: merge|#replace
		# use_ssl: yes
		# compare_snapshot: # The name of the snapshot to compare with C(snapshot).
		# port: 443 (for https) and 80 (for http)
		# import_policy: # The name of the Import Policy to use for config rollback.
$0
endsnippet

snippet aci_tenant_ep_retention_policy "Manage End Point (EP) retention protocol policies (fv:EpRetPol)" b
- name: $1
	aci_tenant_ep_retention_policy:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the End point rentention policy.
		# certificate_name: C(private_key) basename
		# hold_interval: 300
		# epr_policy: # The name of the end point retention policy.
		# bounce_trigger: coop
		# output_level: debug|info|#normal
		# validate_certs: yes
		# state: absent|#present|query
		# timeout: 30
		# local_ep_interval: 900
		# bounce_age: 630
		# move_frequency: 256
		# use_ssl: yes
		# remote_ep_interval: 300
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of an existing tenant.
		# use_proxy: yes
$0
endsnippet

snippet aci_bd_to_l3out "Bind Bridge Domain to L3 Out (fv:RsBDToOut)" b
- name: $1
	aci_bd_to_l3out:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# bd: # The name of the Bridge Domain.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# l3out: # The name of the l3out to associate with th Bridge Domain.
		# state: absent|#present|query
		# output_level: debug|info|#normal
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the Tenant.
$0
endsnippet

snippet aci_rest "Direct access to the Cisco APIC REST API" b
- name: $1
	aci_rest:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		path: ${4:# URI being used to execute API calls.}
		password: ${5:# The password to use for authentication.}
		# src: # Name of the absolute path of the filname that includes the body of the http request being sent to the ACI fabric.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# port: 443 (for https) and 80 (for http)
		# content: # When used instead of C(src), sets the payload of the API request directly.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# method: delete|#get|post
$0
endsnippet

snippet aci_tenant "Manage tenants (fv:Tenant)" b
- name: $1
	aci_tenant:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		tenant: ${5:# The name of the tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# use_proxy: yes
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# description: # Description for the tenant.
$0
endsnippet

snippet aci_interface_policy_leaf_policy_group "Manage fabric interface policy leaf policy groups (infra:AccBndlGrp, infra:AccPortGrp)" b
- name: $1
	aci_interface_policy_leaf_policy_group:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# stp_interface_policy: # Choice of stp_interface_policy to be used as part of the leaf policy group to be created.
		# description: # Description for the leaf policy group to be created.
		# egress_data_plane_policing_policy: # Choice of egress_data_plane_policing_policy to be used as part of the leaf policy group to be created.
		# certificate_name: C(private_key) basename
		# cdp_policy: # Choice of cdp_policy to be used as part of the leaf policy group to be created.
		# storm_control_interface_policy: # Choice of storm_control_interface_policy to be used as part of the leaf policy group to be created.
		# port_channel_policy: # Choice of port_channel_policy to be used as part of the leaf policy group to be created.
		# mcp_policy: # Choice of mcp_policy to be used as part of the leaf policy group to be created.
		# lag_type: leaf|link|node
		# use_ssl: yes
		# monitoring_policy: # Choice of monitoring_policy to be used as part of the leaf policy group to be created.
		# port: 443 (for https) and 80 (for http)
		# aep: # Choice of attached_entity_profile (AEP) to be used as part of the leaf policy group to be created.
		# use_proxy: yes
		# priority_flow_control_policy: # Choice of priority_flow_control_policy to be used as part of the leaf policy group to be created.
		# fibre_channel_interface_policy: # Choice of fibre_channel_interface_policy to be used as part of the leaf policy group to be created.
		# l2_interface_policy: # Choice of l2_interface_policy to be used as part of the leaf policy group to be created.
		# policy_group: # Name of the leaf policy group to be added/deleted.
		# port_security_policy: # Choice of port_security_policy to be used as part of the leaf policy group to be created.
		# output_level: debug|info|#normal
		# link_level_policy: # Choice of link_level_policy to be used as part of the leaf policy group to be created.
		# state: absent|#present|query
		# ingress_data_plane_policing_policy: # Choice of ingress_data_plane_policing_policy to be used as part of the leaf policy group to be created.
		# timeout: 30
		# slow_drain_policy: # Choice of slow_drain_policy to be used as part of the leaf policy group to be created.
		# validate_certs: yes
		# lldp_policy: # Choice of lldp_policy to be used as part of the leaf policy group to be created.
$0
endsnippet

snippet aci_aaa_user "Manage AAA users (aaa:User)" b
- name: $1
	aci_aaa_user:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# last_name: # The last name of the locally-authenticated user.
		# use_ssl: yes
		# aaa_password: # The password of the locally-authenticated user.
		# first_name: # The first name of the locally-authenticated user.
		# use_proxy: yes
		# port: 443 (for https) and 80 (for http)
		# state: absent|#present|query
		# email: # The email address of the locally-authenticated user.
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# aaa_user: # The name of the locally-authenticated user user to add.
		# description: # Description for the AAA user.
		# certificate_name: C(private_key) basename
		# expires: # Whether to enable an expiration date for the locally-authenticated user account.
		# phone: # The phone number of the locally-authenticated user.
		# aaa_password_lifetime: # The lifetime of the locally-authenticated user password.
		# enabled: # The status of the locally-authenticated user account.
		# output_level: debug|info|#normal
		# aaa_password_update_required: # Whether this account needs password update.
		# clear_password_history: # Whether to clear the password history of a locally-authenticated user.
		# expiration: # The expiration date of the locally-authenticated user account.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet aci_aep "Manage attachable Access Entity Profile (AEP) objects (infra:AttEntityP, infra:ProvAcc)" b
- name: $1
	aci_aep:
		username: ${2:admin}
		aep: ${3:# The name of the Attachable Access Entity Profile.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the AEP.
		# certificate_name: C(private_key) basename
		# infra_vlan: no
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_epg_monitoring_policy "Manage monitoring policies (mon:EPGPol)" b
- name: $1
	aci_epg_monitoring_policy:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		monitoring_policy: ${4:# The name of the monitoring policy.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # Description for the monitoring policy.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
- name: $1
	aci_interface_policy_port_channel:
		port_channel: ${2:# Name of the port channel.}
		username: ${3:admin}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		# min_links: Ranges from 1 to 16
		# use_ssl: yes
		# fast_select: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# load_defer: no
		# state: absent|#present|query
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the port channel.
		# certificate_name: C(private_key) basename
		# graceful_convergence: yes
		# symmetric_hash: no
		# suspend_individual: yes
		# output_level: debug|info|#normal
		# mode: active|mac-pin|mac-pin-nicload|#off|passive
		# timeout: 30
		# validate_certs: yes
		# max_links: Ranges from 1 to 16
$0
endsnippet

snippet aci_l3out_route_tag_policy "Manage route tag policies (l3ext:RouteTagPol)" b
- name: $1
	aci_l3out_route_tag_policy:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		rtp: ${4:# The name of the route tag policy.}
		password: ${5:# The password to use for authentication.}
		tenant: ${6:# The name of the tenant.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the route tag policy.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# tag: 4294967295
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_epg_to_domain "Bind EPGs to Domains (fv:RsDomAtt)" b
- name: $1
	aci_epg_to_domain:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# domain: # Name of the physical or virtual domain being associated with the EPG.
		# allow_useg: #encap|useg
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# use_ssl: yes
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
		# primary_encap: range from 1 to 4096
		# state: absent|#present|query
		# encap: range from 1 to 4096
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# certificate_name: C(private_key) basename
		# domain_type: phys|vmm
		# encap_mode: #auto|vlan|vxlan
		# netflow: no
		# resolution_immediacy: immediate|#lazy|pre-provision
		# tenant: # Name of an existing tenant.
		# deploy_immediacy: immediate|#lazy
		# output_level: debug|info|#normal
		# timeout: 30
		# epg: # Name of the end point group.
		# validate_certs: yes
$0
endsnippet

snippet aci_bd "Manage Bridge Domains (BD) objects (fv:BD)" b
- name: $1
	aci_bd:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# bd: # The name of the Bridge Domain.
		# arp_flooding: no
		# igmp_snoop_policy: # The name of the IGMP Snooping Policy the Bridge Domain should use when overriding the default IGMP Snooping Policy.
		# endpoint_retention_action: inherit|#resolve
		# description: # Description for the Bridge Domain.
		# certificate_name: C(private_key) basename
		# l3_unknown_multicast: #flood|opt-flood
		# enable_routing: yes
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# vrf: # The name of the VRF.
		# bd_type: #ethernet|fc
		# use_ssl: yes
		# ip_learning: # Determines if the Bridge Domain should learn End Point IPs.
		# port: 443 (for https) and 80 (for http)
		# tenant: # The name of the Tenant.
		# l2_unknown_unicast: #proxy|flood
		# endpoint_retention_policy: # The name of the End Point Retention Policy the Bridge Domain should use when overriding the default End Point Retention Policy.
		# use_proxy: yes
		# multi_dest: #bd-flood|drop|encap-flood
		# endpoint_clear: no
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# ipv6_nd_policy: # The name of the IPv6 Neighbor Discovery Policy the Bridge Domain should use when overridding the default IPV6 ND Policy.
		# timeout: 30
		# mac_address: 00:22:BD:F8:19:FF
		# endpoint_move_detect: default|#garp
		# enable_multicast: no
		# validate_certs: yes
		# limit_ip_learn: yes
$0
endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
- name: $1
	aci_interface_policy_lldp:
		username: ${2:admin}
		receive_state: ${3:disabled|#enabled}
		lldp_policy: ${4:# The LLDP interface policy name.}
		host: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${6:# The password to use for authentication.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the LLDP interface policy name.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# transmit_state: disabled|#enabled
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# use_proxy: yes
$0
endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
- name: $1
	aci_interface_policy_mcp:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		mcp: ${5:# The name of the MCP interface.}
		# use_proxy: yes
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# description: # The description for the MCP interface.
		# certificate_name: C(private_key) basename
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# admin_state: disable|#enable
		# timeout: 30
		# use_ssl: yes
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
$0
endsnippet

snippet aci_firmware_source "Manage firmware image sources (firmware:OSource)" b
- name: $1
	aci_firmware_source:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		source: ${5:# The identifying name for the outside source of images, such as an HTTP or SCP server.}
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# timeout: 30
		# certificate_name: C(private_key) basename
		# use_ssl: yes
		# port: 443 (for https) and 80 (for http)
		# url_password: # T
		# url_protocol: http|local|#scp|usbkey
		# use_proxy: yes
		# url: # T
		# output_level: debug|info|#normal
		# state: absent|#present|query
		# url_username: # T
		# polling_interval: # Polling interval in minutes.
		# validate_certs: yes
$0
endsnippet

snippet aci_switch_leaf_selector "Bind leaf selectors to switch policy leaf profiles (infra:LeafS, infra:NodeBlk, infra:RsAccNodePGrep)" b
- name: $1
	aci_switch_leaf_selector:
		username: ${2:admin}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		# use_proxy: yes
		# private_key: # PEM formatted file that contains your private key to be used for signature-based authentication.
		# from: # Start of Node Block Range
		# description: # The description to assign to the C(leaf)
		# certificate_name: C(private_key) basename
		# leaf_profile: # Name of the Leaf Profile to which we add a Selector.
		# output_level: debug|info|#normal
		# to: # Start of Node Block Range
		# state: absent|#present|query
		# leaf_node_blk_description: # The description to assign to the C(leaf_node_blk)
		# timeout: 30
		# use_ssl: yes
		# leaf: # Name of Leaf Selector.
		# validate_certs: yes
		# port: 443 (for https) and 80 (for http)
		# leaf_node_blk: # Name of Node Block range to be added to Leaf Selector of given Leaf Profile
		# policy_group: # Name of the Policy Group to be added to Leaf Selector of given Leaf Profile
$0
endsnippet

snippet ios_system "Manage the system attributes on Cisco IOS devices" b
- name: $1
	ios_system:
		# authorize: yes|no
		# state: #present|absent
		# auth_pass: none
		# provider: # B(Deprecated)
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# lookup_enabled: # Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
$0
endsnippet

snippet ios_logging "Manage logging on network devices" b
- name: $1
	ios_logging:
		# authorize: yes|no
		# aggregate: # L
		# state: #present|absent
		# auth_pass: none
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# level: # Set logging severity levels.
		# dest: on|host|console|monitor|buffered
		# facility: # Set logging facility.
		# provider: # B(Deprecated)
		# size: 4096
$0
endsnippet

snippet ios_l2_interface "Manage Layer-2 interface on Cisco IOS devices." b
- name: $1
	ios_l2_interface:
		name: ${2:# Full name of the interface excluding any logical unit number, i.e. GigabitEthernet0/1.}
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# auth_pass: none
		# trunk_vlans: # List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
		# authorize: yes|no
		# state: #present|absent|unconfigured
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
		# mode: #access|trunk
		# provider: # B(Deprecated)
		# aggregate: # List of Layer-2 interface definitions.
$0
endsnippet

snippet ios_command "Run commands on remote devices running Cisco IOS" b
- name: $1
	ios_command:
		commands: ${2:# List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# authorize: yes|no
		# retries: 10
		# auth_pass: none
		# interval: 1
		# provider: # B(Deprecated)
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet ios_vrf "Manage the collection of VRF definitions on Cisco IOS devices" b
- name: $1
	ios_vrf:
		# authorize: yes|no
		# rd: # The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
		# description: # Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
		# route_export: # Adds an export list of extended route target communities to the VRF.
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.
		# auth_pass: none
		# name: # The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument
		# delay: 10
		# purge: no
		# state: #present|absent
		# vrfs: # The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
		# route_both: # Adds an export and import list of extended route target communities to the VRF.
		# provider: # B(Deprecated)
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# route_import: # Adds an import list of extended route target communities to the VRF.
$0
endsnippet

snippet ios_ping "Tests reachability using ping from Cisco IOS network devices" b
- name: $1
	ios_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# count: 5
		# authorize: yes|no
		# auth_pass: none
		# source: # The source IP Address.
		# state: absent|#present
		# vrf: default
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_config "Manage Cisco IOS configuration sections" b
- name: $1
	ios_config:
		# multiline_delimiter: @
		# authorize: yes|no
		# force: no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# diff_against: running|startup|intended
		# replace: #line|block
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# save: no
		# auth_pass: none
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: no
		# provider: # B(Deprecated)
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# save_when: always|#never|modified|changed
		# backup: no
		# match: #line|strict|exact|none
$0
endsnippet

snippet ios_l3_interface "Manage L3 interfaces on Cisco IOS network devices." b
- name: $1
	ios_l3_interface:
		# authorize: yes|no
		# name: # Name of the L3 interface to be configured eg. GigabitEthernet0/2
		# auth_pass: none
		# provider: # B(Deprecated)
		# state: #present|absent
		# ipv4: # IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
		# ipv6: # IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
		# aggregate: # List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
$0
endsnippet

snippet ios_static_route "Manage static IP routes on Cisco IOS network devices" b
- name: $1
	ios_static_route:
		# authorize: yes|no
		# state: #present|absent
		# next_hop: # Next hop IP of the static route.
		# provider: # B(Deprecated)
		# aggregate: # L
		# auth_pass: none
		# mask: # Network prefix mask of the static route.
		# prefix: # Network prefix of the static route.
		# admin_distance: # Admin distance of the static route.
$0
endsnippet

snippet ios_lldp "Manage LLDP configuration on Cisco IOS network devices." b
- name: $1
	ios_lldp:
		# authorize: yes|no
		# state: #present|absent
		# auth_pass: none
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_user "Manage the aggregate of local users on Cisco IOS device" b
- name: $1
	ios_user:
		# authorize: yes|no
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the Cisco IOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# aggregate: # The set of username objects to be configured on the remote Cisco IOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the Cisco IOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# auth_pass: none
		# purge: no
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.
		# state: #present|absent
		# provider: # B(Deprecated)
		# nopassword: # Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.
		# view: # Configures the view for the username in the device running configuration. The argument accepts a string value defining the view name. This argument does not check if the view has been configured on the device.
$0
endsnippet

snippet ios_facts "Collect facts from remote devices running Cisco IOS" b
- name: $1
	ios_facts:
		# authorize: yes|no
		# auth_pass: none
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_linkagg "Manage link aggregation groups on Cisco IOS network devices" b
- name: $1
	ios_linkagg:
		# purge: no
		# authorize: yes|no
		# state: #present|absent
		# group: # Channel-group number for the port-channel Link aggregation group. Range 1-255.
		# mode: active|on|passive|auto|desirable
		# members: # List of members of the link aggregation group.
		# provider: # B(Deprecated)
		# aggregate: # L
		# auth_pass: none
$0
endsnippet

snippet ios_interface "Manage Interface on Cisco IOS network devices" b
- name: $1
	ios_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: # Check the operational state of given interface C(name) for CDP/LLDP neighbor.
		# rx_rate: # Receiver rate in bits per second (bps).
		# duplex: full|half|#auto
		# auth_pass: none
		# enabled: # Interface link status.
		# authorize: yes|no
		# mtu: # Maximum size of transmit packet.
		# delay: 10
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
		# aggregate: # L
		# speed: # Interface link speed.
		# tx_rate: # Transmit rate in bits per second (bps).
		# description: # Description of Interface.
$0
endsnippet

snippet ios_vlan "Manage VLANs on IOS network devices" b
- name: $1
	ios_vlan:
		interfaces: ${2:# List of interfaces that should be associated to the VLAN.}
		vlan_id: ${3:# ID of the VLAN. Range 1-4094.}
		# authorize: yes|no
		# delay: 10
		# name: # Name of the VLAN.
		# auth_pass: none
		# purge: no
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# state: #present|absent|active|suspend
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet ios_banner "Manage multiline banners on Cisco IOS devices" b
- name: $1
	ios_banner:
		banner: ${2:login|motd|exec|incoming|slip-ppp}
		# authorize: yes|no
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# auth_pass: none
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet cv_server_provision "Provision server port by applying or removing template configuration to an Arista CloudVision Portal configlet that is applied to a switch." b
- name: $1
	cv_server_provision:
		username: ${2:# The user that will be used to connect to CVP for making API calls.}
		switch_port: ${3:# The physical port number on the switch that the new server is connected to.}
		server_name: ${4:# The hostname or identifier for the server that is having it's switch port provisioned.}
		host: ${5:# The hostname or IP address of the CVP node being connected to.}
		template: ${6:# A path to a Jinja formatted template file that contains the configuration block that will be applied to the specified switch port. This template will have variable fields replaced by the module before being applied to the switch configuration.}
		password: ${7:# The password of the user that will be used to connect to CVP for API calls.}
		switch_name: ${8:# The hostname of the switch is being configured for the server being provisioned.}
		# port_vlan: # The vlan that should be applied to the port for this server. This parameter is dependent on a proper template that supports single vlan provisioning with it. If a port vlan is specified by the template specified does not support this the module will exit out with no changes. If a template is specified that requires a port vlan but no port vlan is specified the module will exit out with no changes.
		# protocol: #https|http
		# port: # The port number to use when making API calls to the CVP node. This will default to the default port for the specified protocol. Port 80 for http and port 443 for https.
		# auto_run: no
		# action: #show|add|remove
$0
endsnippet

snippet vdirect_commit "Commits pending configuration changes on Radware devices" b
- name: $1
	vdirect_commit:
		vdirect_user: ${2:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
		vdirect_ip: ${3:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
		devices: ${4:# List of Radware Alteon device names for commit operations.}
		vdirect_password: ${5:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
		# vdirect_wait: yes
		# vdirect_https_port: 2189
		# vdirect_validate_certs: yes
		# vdirect_timeout: 60
		# vdirect_http_port: 2188
		# sync: yes
		# apply: yes
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
		# save: yes
		# vdirect_use_ssl: yes
$0
endsnippet

snippet vdirect_file "Uploads a new or updates an existing runnable file into Radware vDirect server" b
- name: $1
	vdirect_file:
		vdirect_user: ${2:# vDirect server username, may be set as VDIRECT_USER environment variable.}
		file_name: ${3:# vDirect runnable file name to be uploaded.}
		vdirect_ip: ${4:# Primary vDirect server IP address, may be set as VDIRECT_IP environment variable.}
		vdirect_password: ${5:# vDirect server password, may be set as VDIRECT_PASSWORD environment variable.}
		# vdirect_wait: yes
		# vdirect_https_port: 2189
		# vdirect_validate_certs: yes
		# vdirect_timeout: 60
		# vdirect_http_port: 2188
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as VDIRECT_SECONDARY_IP environment variable.
		# vdirect_use_ssl: yes
$0
endsnippet

snippet vdirect_runnable "Runs templates and workflow actions in Radware vDirect server" b
- name: $1
	vdirect_runnable:
		vdirect_user: ${2:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
		runnable_name: ${3:# vDirect runnable name to run.}
		vdirect_ip: ${4:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
		runnable_type: ${5:# vDirect runnable type.}
		vdirect_password: ${6:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
		# vdirect_wait: yes
		# parameters: # Action parameters dictionary. In case of ConfigurationTemplate runnable type,
		# vdirect_https_port: 2189
		# vdirect_validate_certs: yes
		# vdirect_timeout: 60
		# vdirect_http_port: 2188
		# action_name: # Workflow action name to run.
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
		# vdirect_use_ssl: yes
$0
endsnippet

snippet onyx_l2_interface "Manage Layer-2 interface on Mellanox ONYX network devices" b
- name: $1
	onyx_l2_interface:
		# access_vlan: # Configure given VLAN in access port.
		# state: #present|absent
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port.
		# name: # Name of the interface.
		# aggregate: # List of Layer-2 interface definitions.
		# mode: #access|trunk|hybrid
$0
endsnippet

snippet onyx_mlag_vip "Configures MLAG VIP on Mellanox ONYX network devices" b
- name: $1
	onyx_mlag_vip:
		# delay: 12
		# state: present|absent
		# group_name: # MLAG group name. Required if I(state=present).
		# ipaddress: # Virtual IP address of the MLAG. Required if I(state=present).
		# mac_address: # MLAG system MAC address. Required if I(state=present).
$0
endsnippet

snippet onyx_ospf "Manage OSPF protocol on Mellanox ONYX network devices" b
- name: $1
	onyx_ospf:
		ospf: ${2:# OSPF instance number 1-65535}
		# router_id: # OSPF router ID. Required if I(state=present).
		# interfaces: # List of interfaces and areas. Required if I(state=present).
		# state: #present|absent
$0
endsnippet

snippet onyx_linkagg "Manage link aggregation groups on Mellanox ONYX network devices" b
- name: $1
	onyx_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# purge: no
		# state: #present|absent|up|down
		# aggregate: # L
		# mode: on|active|passive
$0
endsnippet

snippet onyx_l3_interface "Manage L3 interfaces on Mellanox ONYX network devices" b
- name: $1
	onyx_l3_interface:
		# purge: no
		# state: #present|absent
		# name: # Name of the L3 interface.
		# ipv6: # IPv6 of the L3 interface (not supported for now).
		# aggregate: # L
		# ipv4: # IPv4 of the L3 interface.
$0
endsnippet

snippet onyx_magp "Manage MAGP protocol on Mellanox ONYX network devices" b
- name: $1
	onyx_magp:
		interface: ${2:# VLAN Interface name.}
		magp_id: ${3:# MAGP instance number 1-255}
		# router_mac: # MAGP router MAC address.
		# state: #present|absent|enabled|disabled
		# router_ip: # MAGP router IP address.
$0
endsnippet

snippet onyx_protocol "Enables/Disables protocols on Mellanox ONYX network devices" b
- name: $1
	onyx_protocol:
		# spanning_tree: enabled|disabled
		# lldp: enabled|disabled
		# mlag: enabled|disabled
		# magp: enabled|disabled
		# ip_routing: enabled|disabled
		# lacp: enabled|disabled
		# ip_l3: enabled|disabled
		# igmp_snooping: enabled|disabled
		# dcb_pfc: enabled|disabled
		# ospf: enabled|disabled
		# bgp: enabled|disabled
$0
endsnippet

snippet onyx_lldp "Manage LLDP configuration on Mellanox ONYX network devices" b
- name: $1
	onyx_lldp:
		# state: #present|absent
$0
endsnippet

snippet onyx_bgp "Configures BGP on Mellanox ONYX network devices" b
- name: $1
	onyx_bgp:
		as_number: ${2:# Local AS number.}
		# router_id: # Router IP address. Required if I(state=present).
		# state: #present|absent
		# networks: # List of advertised networks.
		# neighbors: # List of neighbors. Required if I(state=present).
$0
endsnippet

snippet onyx_config "Manage Mellanox ONYX configuration sections" b
- name: $1
	onyx_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# backup: yes|no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# save: yes|no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet onyx_mlag_ipl "Manage IPL (inter-peer link) on Mellanox ONYX network devices" b
- name: $1
	onyx_mlag_ipl:
		name: ${2:# Name of the interface (port-channel) IPL should be configured on.}
		# vlan_interface: # Name of the IPL vlan interface.
		# state: #present|absent
		# peer_address: # IPL peer IP address.
$0
endsnippet

snippet onyx_pfc_interface "Manage priority flow control on ONYX network devices" b
- name: $1
	onyx_pfc_interface:
		# aggregate: # L
		# purge: no
		# state: #enabled|disabled
		# name: # Name of the interface PFC should be configured on.
$0
endsnippet

snippet onyx_lldp_interface "Manage LLDP interfaces configuration on Mellanox ONYX network devices" b
- name: $1
	onyx_lldp_interface:
		# aggregate: # L
		# purge: no
		# state: #present|absent|enabled|disabled
		# name: # Name of the interface LLDP should be configured on.
$0
endsnippet

snippet onyx_facts "Collect facts from Mellanox ONYX network devices" b
- name: $1
	onyx_facts:
		# gather_subset: version
$0
endsnippet

snippet onyx_command "Run commands on remote devices running Mellanox ONYX" b
- name: $1
	onyx_command:
		commands: ${2:# List of commands to send to the remote Mellanox ONYX network device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet onyx_interface "Manage Interfaces on Mellanox ONYX network devices" b
- name: $1
	onyx_interface:
		name: ${2:# Name of the Interface.}
		# rx_rate: # Receiver rate in bits per second (bps).
		# duplex: full|half|#auto
		# enabled: # Interface link status.
		# mtu: # Maximum size of transmit packet.
		# delay: 10
		# purge: no
		# state: #present|absent|up|down
		# aggregate: # L
		# speed: 1G|10G|25G|40G|50G|56G|100G
		# tx_rate: # Transmit rate in bits per second (bps).
		# description: # Description of Interface.
$0
endsnippet

snippet onyx_vlan "Manage VLANs on Mellanox ONYX network devices" b
- name: $1
	onyx_vlan:
		# aggregate: # L
		# purge: no
		# state: #present|absent
		# name: # Name of the VLAN.
		# vlan_id: # ID of the VLAN.
$0
endsnippet

snippet net_banner "Manage multiline banners on network devices" b
- name: $1
	net_banner:
		banner: ${2:login|motd}
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
$0
endsnippet

snippet net_logging "Manage logging on network devices" b
- name: $1
	net_logging:
		# purge: no
		# aggregate: # L
		# state: #present|absent
		# name: # If value of C(dest) is I(host) it indicates file-name the host name to be notified.
		# level: # Set logging severity levels.
		# dest: console|host
		# facility: # Set logging facility.
$0
endsnippet

snippet net_user "Manage the aggregate of local users on network device" b
- name: $1
	net_user:
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the remote network device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# aggregate: # The set of username objects to be configured on the remote network device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the remote network device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# purge: no
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.
		# state: #present|absent
		# role: # Configures the role for the username in the device running configuration. The argument accepts a string value defining the role name. This argument does not check if the role has been configured on the device.
		# nopassword: # Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.
		# sshkey: # Specifies the SSH public key to configure for the given username. This argument accepts a valid SSH key value.
$0
endsnippet

snippet net_ping "Tests reachability using ping from a network device" b
- name: $1
	net_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# count: 5
		# state: absent|#present
		# vrf: default
		# source: # The source IP Address.
$0
endsnippet

snippet net_system "Manage the system attributes on network devices" b
- name: $1
	net_system:
		# state: #present|absent
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
$0
endsnippet

snippet vyos_command "Run one or more commands on VyOS devices" b
- name: $1
	vyos_command:
		commands: ${2:# The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.}
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet vyos_config "Manage VyOS configuration on remote device" b
- name: $1
	vyos_config:
		# comment: configured by vyos_config
		# src: # The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.
		# provider: # B(Deprecated)
		# config: # The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
		# lines: # The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
		# save: yes|no
		# backup: no
		# match: #line|none
$0
endsnippet

snippet vyos_system "Run `set system` commands on VyOS devices" b
- name: $1
	vyos_system:
		# domain_search: # A list of domain names to search. Mutually exclusive with I(name_server)
		# domain_name: # The new domain name to apply to the device.
		# state: #present|absent
		# host_name: # Configure the device hostname parameter. This option takes an ASCII string value.
		# provider: # B(Deprecated)
		# name_servers: # A list of name servers to use with the device. Mutually exclusive with I(domain_search)
$0
endsnippet

snippet vyos_logging "Manage logging on network devices" b
- name: $1
	vyos_logging:
		# aggregate: # L
		# state: #present|absent
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# level: # Set logging severity levels.
		# dest: console|file|global|host|user
		# facility: # Set logging facility.
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_lldp_interface "Manage LLDP interfaces configuration on VyOS network devices" b
- name: $1
	vyos_lldp_interface:
		# aggregate: # L
		# state: #present|absent|enabled|disabled
		# name: # Name of the interface LLDP should be configured on.
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_lldp "Manage LLDP configuration on VyOS network devices" b
- name: $1
	vyos_lldp:
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_static_route "Manage static IP routes on Vyatta VyOS network devices" b
- name: $1
	vyos_static_route:
		# state: #present|absent
		# next_hop: # Next hop IP of the static route.
		# provider: # B(Deprecated)
		# aggregate: # L
		# mask: # Network prefix mask of the static route.
		# prefix: # Network prefix of the static route. C(mask) param should be ignored if C(prefix) is provided with C(mask) value C(prefix/mask).
		# admin_distance: # Admin distance of the static route.
$0
endsnippet

snippet vyos_interface "Manage Interface on VyOS network devices" b
- name: $1
	vyos_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# duplex: full|half|#auto
		# enabled: # Interface link status.
		# mtu: # Maximum size of transmit packet.
		# delay: 10
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
		# aggregate: # L
		# speed: # Interface link speed.
		# description: # Description of Interface.
$0
endsnippet

snippet vyos_user "Manage the collection of local users on VyOS device" b
- name: $1
	vyos_user:
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the VyOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# name: # The username to be configured on the VyOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# level: # The C(level) argument configures the level of the user when logged into the system. This argument accepts string values admin or operator.
		# purge: no
		# state: #present|absent
		# full_name: # The C(full_name) argument provides the full name of the user account to be created on the remote device. This argument accepts any text string value.
		# provider: # B(Deprecated)
		# aggregate: # The set of username objects to be configured on the remote VyOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
$0
endsnippet

snippet vyos_facts "Collect facts from remote devices running VyOS" b
- name: $1
	vyos_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_linkagg "Manage link aggregation groups on VyOS network devices" b
- name: $1
	vyos_linkagg:
		name: ${2:# Name of the link aggregation group.}
		# state: #present|absent|up|down
		# mode: 802.3ad|active-backup|broadcast|round-robin|transmit-load-balance|adaptive-load-balance|xor-hash|on
		# members: # List of members of the link aggregation group.
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet vyos_banner "Manage multiline banners on VyOS devices" b
- name: $1
	vyos_banner:
		banner: ${2:pre-login|post-login}
		# text: # The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_vlan "Manage VLANs on VyOS network devices" b
- name: $1
	vyos_vlan:
		interfaces: ${2:# List of interfaces that should be associated to the VLAN.}
		vlan_id: ${3:# ID of the VLAN. Range 0-4094.}
		# delay: 10
		# name: # Name of the VLAN.
		# provider: # B(Deprecated)
		# purge: no
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan on device it will result in failure.
		# state: #present|absent
		# address: # Configure Virtual interface address.
		# aggregate: # L
$0
endsnippet

snippet vyos_l3_interface "Manage L3 interfaces on VyOS network devices" b
- name: $1
	vyos_l3_interface:
		# name: # Name of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# state: #present|absent
		# ipv4: # IPv4 of the L3 interface.
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet net_vlan "Manage VLANs on network devices" b
- name: $1
	net_vlan:
		# purge: no
		# state: #present|absent|active|suspend
		# name: # Name of the VLAN.
		# aggregate: # L
		# interfaces: # List of interfaces the VLAN should be configured on.
		# vlan_id: # ID of the VLAN.
$0
endsnippet

snippet net_l2_interface "Manage Layer-2 interface on network devices" b
- name: $1
	net_l2_interface:
		# native_vlan: # Native VLAN to be configured in trunk port.
		# access_vlan: # Configure given VLAN in access port.
		# name: # Name of the interface excluding any logical unit number.
		# trunk_vlans: # List of VLANs to be configured in trunk port.
		# state: #present|absent
		# trunk_allowed_vlans: # List of allowed VLAN's in a given trunk port.
		# mode: #access|trunk
		# aggregate: # List of Layer-2 interface definitions.
$0
endsnippet

snippet panos_loadcfg "load configuration on PAN-OS device" b
- name: $1
	panos_loadcfg:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# commit: yes
		# file: # configuration file to load
$0
endsnippet

snippet panos_restart "restart a device" b
- name: $1
	panos_restart:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
$0
endsnippet

snippet panos_commit "commit firewall's candidate configuration" b
- name: $1
	panos_commit:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# timeout: # timeout for commit job
		# interval: 0.5
		# sync: yes
$0
endsnippet

snippet panos_pg "create a security profiles group" b
- name: $1
	panos_pg:
		pg_name: ${2:# name of the security profile group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# wildfire: # name of the wildfire analysis profile
		# data_filtering: # name of the data filtering profile
		# file_blocking: # name of the file blocking profile
		# vulnerability: # name of the vulnerability profile
		# spyware: # name of the spyware profile
		# url_filtering: # name of the url filtering profile
		# virus: # name of the anti-virus profile
		# commit: yes
$0
endsnippet

snippet panos_security_rule "Create security rule policy on PAN-OS devices or Panorama management console." b
- name: $1
	panos_security_rule:
		password: ${2:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device being configured.}
		rule_name: ${4:# Name of the security rule.}
		# wildfire_analysis: # Name of the already defined wildfire_analysis profile.
		# username: admin
		# destination_ip: any
		# source_zone: any
		# devicegroup: # -
		# data_filtering: # Name of the already defined data_filtering profile.
		# spyware: # Name of the already defined spyware profile.
		# hip_profiles: any
		# file_blocking: # Name of the already defined file_blocking profile.
		# antivirus: # Name of the already defined antivirus profile.
		# log_start: no
		# operation: add
		# description: # Description for the security rule.
		# rule_type: universal
		# log_end: yes
		# service: application-default
		# application: any
		# vulnerability: # Name of the already defined vulnerability profile.
		# source_ip: any
		# source_user: any
		# url_filtering: # Name of the already defined url_filtering profile.
		# tag_name: # Administrative tags that can be added to the rule. Note, tags must be already defined.
		# destination_zone: any
		# group_profile: # -
		# action: allow
		# commit: yes
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
$0
endsnippet

snippet panos_interface "configure data-port network interface for DHCP" b
- name: $1
	panos_interface:
		zone_name: ${2:# N}
		password: ${3:# Password credentials to use for auth.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		if_name: ${5:# Name of the interface to configure.}
		# username: admin
		# create_default_route: false
		# commit: yes
$0
endsnippet

snippet panos_sag "Create a static address group." b
- name: $1
	panos_sag:
		static_match_filter: ${2:# Static filter user by the address group}
		sag_name: ${3:# name of the dynamic address group}
		operation: ${4:# The operation to perform Supported values are I(add)/I(list)/I(delete).}
		password: ${5:# password for authentication}
		ip_address: ${6:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# devicegroup: # -
		# description: # The purpose / objective of the static Address Group
		# tags: # Tags to be associated with the address group
		# commit: yes
$0
endsnippet

snippet panos_admin "Add or modify PAN-OS user accounts password." b
- name: $1
	panos_admin:
		admin_password: ${2:# password for admin user}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# role: # role for admin user
		# commit: yes
		# admin_username: admin
$0
endsnippet

snippet panos_cert_gen_ssh "generates a self-signed certificate using SSH protocol with SSH key" b
- name: $1
	panos_cert_gen_ssh:
		password: ${2:# Password credentials to use for auth. Either I(key_filename) or I(password) is required.}
		cert_cn: ${3:# Certificate CN (common name) embedded in the certificate signature.}
		cert_friendly_name: ${4:# Human friendly certificate name (not CN but just a friendly name).}
		key_filename: ${5:# Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.}
		ip_address: ${6:# IP address (or hostname) of PAN-OS device being configured.}
		signed_by: ${7:# Undersigning authority (CA) that MUST already be presents on the device.}
		# rsa_nbits: 2048
$0
endsnippet

snippet panos_object "create/read/update/delete object in PAN-OS or Panorama" b
- name: $1
	panos_object:
		password: ${2:# Password credentials to use for authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device or Panorama management console being configured.}
		operation: ${4:# The operation to be performed.  Supported values are I(add)/I(delete)/I(find).}
		# username: admin
		# static_value: # A group of address objects to be used in an addressgroup definition.
		# description: # The description of the object.
		# color: # -
		# address: # The IP address of the host or network in CIDR notation.
		# services: # The group of service objects used in a servicegroup definition.
		# devicegroup: # -
		# destination_port: # The destination port to be used in a service object definition.
		# servicegroup: # A group of service objects.
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# protocol: # The IP protocol to be used in a service object definition.  Valid values are I(tcp) or I(udp).
		# addressobject: # The name of the address object.
		# tag_name: # The name of an object or rule tag.
		# serviceobject: # The name of the service object.
		# source_port: # The source port to be used in a service object definition.
		# address_type: # The type of address object definition.  Valid types are I(ip-netmask) and I(ip-range).
		# dynamic_value: # The filter match criteria to be used in a dynamic addressgroup definition.
		# addressgroup: # A static group of address objects or dynamic address group.
$0
endsnippet

snippet panos_import "import file on PAN-OS devices" b
- name: $1
	panos_import:
		password: ${2:# Password for device authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		# username: admin
		# category: software
		# file: # Location of the file to import into device.
		# url: # URL of the file that will be imported to device.
$0
endsnippet

snippet panos_admpwd "change admin password of PAN-OS device using SSH with SSH key" b
- name: $1
	panos_admpwd:
		newpassword: ${2:# password to configure for admin on the PAN-OS device}
		key_filename: ${3:# filename of the SSH Key to use for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		# username: admin
$0
endsnippet

snippet panos_check "check if PAN-OS device is ready for configuration" b
- name: $1
	panos_check:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# timeout: 0
		# interval: 0
$0
endsnippet

snippet panos_dag_tags "Create tags for DAG's on PAN-OS devices." b
- name: $1
	panos_dag_tags:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# devicegroup: # -
		# description: # The purpose / objective of the static Address Group
		# tag_names: # The list of the tags that will be added or removed from the IP address.
		# commit: yes
		# operation: # The action to be taken. Supported values are I(add)/I(update)/I(find)/I(delete).
		# ip_to_register: # IP that will be registered with the given tag names.
$0
endsnippet

snippet panos_query_rules "PANOS module that allows search for security rules in PANW NGFW devices." b
- name: $1
	panos_query_rules:
		password: ${2:# Password credentials to use for authentication.}
		ip_address: ${3:# IP address (or hostname) of PAN-OS firewall or Panorama management console being queried.}
		# username: admin
		# destination_ip: # The destination IP address to be queried.
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# protocol: # The protocol used to be queried.  Must be either I(tcp) or I(udp).
		# source_zone: # Name of the source security zone to be queried.
		# source_ip: # The source IP address to be queried.
		# application: # Name of the application or application group to be queried.
		# tag_name: # Name of the rule tag to be queried.
		# destination_zone: # Name of the destination security zone to be queried.
		# source_port: # The source port to be queried.
		# devicegroup: # The Panorama device group in which to conduct the query.
		# destination_port: # The destination port to be queried.
$0
endsnippet

snippet panos_op "execute arbitrary OP commands on PANW devices (e.g. show interface all)" b
- name: $1
	panos_op:
		cmd: ${2:# The OP command to be performed.}
		password: ${3:# Password credentials to use for authentication.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device or Panorama management console being configured.}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
$0
endsnippet

snippet panos_lic "apply authcode to a device/instance" b
- name: $1
	panos_lic:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device}
		password: ${3:# password for authentication}
		auth_code: ${4:# authcode to be applied}
		# username: admin
		# force: false
$0
endsnippet

snippet panos_nat_rule "create a policy NAT rule" b
- name: $1
	panos_nat_rule:
		rule_name: ${2:# name of the SNAT rule}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		source_zone: ${5:# list of source zones}
		destination_zone: ${6:# destination zone}
		# username: admin
		# destination_ip: [u'any']
		# dnat_port: # dnat translated port
		# snat_bidirectional: false
		# snat_interface_address: # snat interface address
		# snat_address_type: translated-address
		# operation: # The action to be taken.  Supported values are I(add)/I(update)/I(find)/I(delete).
		# dnat_address: # dnat translated address
		# service: any
		# snat_type: # type of source translation
		# snat_static_address: # Source NAT translated address. Used with Static-IP translation.
		# source_ip: [u'any']
		# snat_dynamic_address: # Source NAT translated address. Used with Dynamic-IP and Dynamic-IP-and-Port.
		# commit: yes
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# snat_interface: # snat interface
$0
endsnippet

snippet panos_dag "create a dynamic address group" b
- name: $1
	panos_dag:
		dag_name: ${2:# name of the dynamic address group}
		password: ${3:# password for authentication}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device}
		dag_filter: ${5:# dynamic filter user by the dynamic address group}
		# username: admin
		# commit: yes
$0
endsnippet

snippet panos_match_rule "Test for match against a security rule on PAN-OS devices or Panorama management console." b
- name: $1
	panos_match_rule:
		vsys_id: ${2:vsys1}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device being configured.}
		source_ip: ${5:# The source IP address.}
		# username: admin
		# category: # URL category
		# destination_ip: # The destination IP address.
		# protocol: # The IP protocol number from 1 to 255.
		# destination_port: # The destination port.
		# to_interface: # The inbound interface in a NAT rule.
		# rule_type: security
		# source_zone: # The source zone.
		# source_user: # The source user or group.
		# application: # The application.
		# destination_zone: # The destination zone.
		# source_port: # The source port.
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
$0
endsnippet

snippet panos_mgtconfig "configure management settings of device" b
- name: $1
	panos_mgtconfig:
		password: ${2:# password for authentication}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device}
		# username: admin
		# panorama_primary: # address of primary Panorama server
		# dns_server_secondary: # address of secondary DNS server
		# dns_server_primary: # address of primary DNS server
		# panorama_secondary: # address of secondary Panorama server
		# commit: yes
$0
endsnippet

snippet ordnance_config "Manage Ordnance configuration sections" b
- name: $1
	ordnance_config:
		# multiline_delimiter: @
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# backup: yes|no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: yes|no
		# save: yes|no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet ordnance_facts "Collect facts from Ordnance Virtual Routers over SSH" b
- name: $1
	ordnance_facts:
		# gather_subset: !config
$0
endsnippet

snippet net_l3_interface "Manage L3 interfaces on network devices" b
- name: $1
	net_l3_interface:
		# purge: no
		# state: #present|absent
		# name: # Name of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# aggregate: # L
		# ipv4: # IPv4 of the L3 interface.
$0
endsnippet

snippet net_vrf "Manage VRFs on network devices" b
- name: $1
	net_vrf:
		# aggregate: # L
		# purge: no
		# interfaces: # List of interfaces the VRF should be configured on.
		# name: # Name of the VRF.
		# state: #present|absent
$0
endsnippet

snippet asa_acl "Manage access-lists on a Cisco ASA" b
- name: $1
	asa_acl:
		lines: ${2:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# authorize: yes|no
		# force: yes|no
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# provider: # B(Deprecated)
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuruation to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact
		# replace: #line|block
$0
endsnippet

snippet asa_command "Run arbitrary commands on Cisco ASA devices" b
- name: $1
	asa_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# authorize: yes|no
		# retries: 10
		# interval: 1
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# provider: # B(Deprecated)
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet asa_config "Manage configuration sections on Cisco ASA devices" b
- name: $1
	asa_config:
		# authorize: yes|no
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# passwords: yes|no
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# backup: yes|no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: yes|no
		# provider: # B(Deprecated)
		# save: yes|no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet fortios_config "Manage config on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_config:
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# src: # The I(src) argument provides a path to the configuration template to load into the remote device.
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# file_mode: no
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# filter: 
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
		# timeout: 60
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# backup: yes|no
		# vdom: # Specifies on which vdom to apply configuration
$0
endsnippet

snippet fortios_address "Manage fortios firewall address objects" b
- name: $1
	fortios_address:
		name: ${2:# Name of the address to add or delete.}
		state: ${3:present|absent}
		# comment: # free text to describe address.
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# backup: yes|no
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# country: # 2 letter country code (like FR).
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# value: # Address value, based on type. If type=fqdn, somthing like www.google.com. If type=ipmask, you can use simple ip (192.168.0.1), ip+mask (192.168.0.1 255.255.255.0) or CIDR (192.168.0.1/32).
		# start_ip: # First ip in range (used only with type=iprange).
		# end_ip: # Last ip in range (used only with type=iprange).
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
		# timeout: 60
		# interface: any
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# type: iprange|fqdn|ipmask|geography
		# vdom: # Specifies on which vdom to apply configuration
		# file_mode: no
$0
endsnippet

snippet fortios_ipv4_policy "Manage IPv4 policy objects on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_ipv4_policy:
		id: ${2:# Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns}
		# comment: # free text to describe policy.
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# file_mode: no
		# schedule: always
		# application_list: # Specifies Application Control name.
		# src_intf: any
		# service_negate: true|false
		# av_profile: # Specifies Antivirus profile name.
		# dst_addr_negate: true|false
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
		# logtraffic_start: true|false
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# fixedport: true|false
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# timeout: 60
		# webfilter_profile: # Specifies Webfilter profile name.
		# src_addr: # Specifies source address (or group) object name(s). Required when I(state=present).
		# service: # Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).
		# poolname: # Specifies NAT pool name.
		# policy_action: accept|deny
		# dst_intf: any
		# ips_sensor: # Specifies IPS Sensor profile name.
		# state: #present|absent
		# vdom: # Specifies on which vdom to apply configuration
		# nat: true|false
		# src_addr_negate: true|false
		# backup: yes|no
		# dst_addr: # Specifies destination address (or group) object name(s). Required when I(state=present).
		# logtraffic: disable|#utm|all
$0
endsnippet

snippet net_static_route "Manage static IP routes on network appliances (routers, switches et. al.)" b
- name: $1
	net_static_route:
		next_hop: ${2:# Next hop IP of the static route.}
		mask: ${3:# Network prefix mask of the static route.}
		prefix: ${4:# Network prefix of the static route.}
		# purge: no
		# state: #present|absent
		# aggregate: # L
		# admin_distance: # Admin distance of the static route.
$0
endsnippet

snippet nclu "Configure network interfaces using NCLU" b
- name: $1
	nclu:
		# commands: # A list of strings containing the net commands to run. Mutually exclusive with I(template).
		# abort: no
		# description: Ansible-originated commit
		# template: # A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).
		# commit: no
		# atomic: no
$0
endsnippet

snippet edgeos_facts "Collect facts from remote devices running EdgeOS" b
- name: $1
	edgeos_facts:
		# gather_subset: !config
$0
endsnippet

snippet edgeos_command "Run one or more commands on EdgeOS devices" b
- name: $1
	edgeos_command:
		commands: ${2:# The commands or ordered set of commands that should be run against the remote device. The output of the command is returned to the playbook. If the C(wait_for) argument is provided, the module is not returned until the condition is met or the number of retries is exceeded.}
		# retries: 10
		# wait_for: # Causes the task to wait for a specific condition to be met before moving forward. If the condition is not met before the specified number of retries is exceeded, the task will fail.
		# match: any|#all
		# interval: 1
$0
endsnippet

snippet edgeos_config "Manage EdgeOS configuration on remote device" b
- name: $1
	edgeos_config:
		# comment: configured by edgeos_config
		# src: # The C(src) argument specifies the path to the source config file to load. The source config file can either be in bracket format or set format. The source file can include Jinja2 template variables.
		# config: # The C(config) argument specifies the base configuration to use to compare against the desired configuration. If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
		# lines: # The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
		# save: yes|no
		# backup: yes|no
		# match: #line|none
$0
endsnippet

snippet junos_vlan "Manage VLANs on Juniper JUNOS network devices" b
- name: $1
	junos_vlan:
		name: ${2:# Name of the VLAN.}
		vlan_id: ${3:# ID of the VLAN.}
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
		# active: #True|False
		# interfaces: # List of interfaces to check the VLAN has been configured correctly.
		# description: # Text description of VLANs.
$0
endsnippet

snippet junos_interface "Manage Interface on Juniper JUNOS network devices" b
- name: $1
	junos_interface:
		name: ${2:# Name of the Interface.}
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# rx_rate: # Receiver rate in bits per second (bps).
		# duplex: full|half|#auto
		# enabled: # Configure interface link status.
		# mtu: # Maximum size of transmit packet.
		# delay: 10
		# aggregate: # L
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
		# active: #True|False
		# speed: # Interface link speed.
		# tx_rate: # Transmit rate in bits per second (bps).
		# description: # Description of Interface.
$0
endsnippet

snippet junos_user "Manage local user accounts on Juniper JUNOS devices" b
- name: $1
	junos_user:
		# name: # The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(aggregate) argument.
		# purge: no
		# aggregate: # The C(aggregate) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument.
		# state: #present|absent
		# role: operator|read-only|super-user|unauthorized
		# full_name: # The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value.
		# provider: # B(Deprecated)
		# active: #True|False
		# sshkey: # The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key
$0
endsnippet

snippet junos_banner "Manage multiline banners on Juniper JUNOS devices" b
- name: $1
	junos_banner:
		banner: ${2:login|motd}
		# active: #True|False
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_linkagg "Manage link aggregation groups on Juniper JUNOS network devices" b
- name: $1
	junos_linkagg:
		members: ${2:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		name: ${3:# Name of the link aggregation group.}
		# description: # Description of Interface.
		# provider: # B(Deprecated)
		# device_count: # Number of aggregated ethernet devices that can be configured. Acceptable integer value is between 1 and 128.
		# aggregate: # L
		# state: #present|absent|up|down
		# mode: on|off|active|passive
		# min_links: # Minimum members that should be up before bringing up the link aggregation group.
		# active: #True|False
$0
endsnippet

snippet junos_vrf "Manage the VRF definitions on Juniper JUNOS devices" b
- name: $1
	junos_vrf:
		# target: # It configures VRF target community configuration. The target value takes the form of C(target:A:B) where C(A) and C(B) are both numeric values.
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF.
		# name: # The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(aggregate) argument
		# rd: # The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
		# table_label: # Causes JUNOS to allocate a VPN label per VRF rather than per VPN FEC. This allows for forwarding of traffic to directly connected subnets, COS Egress filtering etc.
		# state: #present|absent
		# provider: # B(Deprecated)
		# aggregate: # The set of VRF definition objects to be configured on the remote JUNOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
		# active: #True|False
		# description: # Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
$0
endsnippet

snippet junos_l3_interface "Manage L3 interfaces on Juniper JUNOS network devices" b
- name: $1
	junos_l3_interface:
		# aggregate: # L
		# state: #present|absent
		# name: # Name of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# active: #True|False
		# provider: # B(Deprecated)
		# unit: 0
		# ipv4: # IPv4 of the L3 interface.
$0
endsnippet

snippet junos_config "Manage configuration on devices running Juniper JUNOS" b
- name: $1
	junos_config:
		# comment: configured by junos_config
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system. The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.
		# rollback: # The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.
		# confirm: 0
		# lines: # This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.
		# update: #merge|override|replace
		# replace: yes|no
		# confirm_commit: yes|no
		# zeroize: # The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.
		# src_format: xml|set|text|json
		# provider: # B(Deprecated)
		# backup: no
$0
endsnippet

snippet junos_scp "Transfer files from or to remote devices running Junos" b
- name: $1
	junos_scp:
		src: ${2:# The C(src) argument takes a single path, or a list of paths to be transfered. The argument C(recursive) must be C(true) to transfer directories.}
		# dest: .
		# provider: # B(Deprecated)
		# recursive: true|false
		# remote_src: true|false
$0
endsnippet

snippet junos_lldp_interface "Manage LLDP interfaces configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp_interface:
		# active: #True|False
		# state: #present|absent|enabled|disabled
		# name: # Name of the interface LLDP should be configured on.
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_command "Run arbitrary commands on an Juniper JUNOS device" b
- name: $1
	junos_command:
		# retries: 10
		# commands: # The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# rpcs: # The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.
		# provider: # B(Deprecated)
		# interval: 1
		# display: text|json|xml|set
		# match: any|#all
$0
endsnippet

snippet junos_facts "Collect facts from remote devices running Juniper Junos" b
- name: $1
	junos_facts:
		# config_format: xml|set|#text|json
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_l2_interface "Manage Layer-2 interface on Juniper JUNOS network devices" b
- name: $1
	junos_l2_interface:
		# native_vlan: # Native VLAN to be configured in trunk port. The value of C(native_vlan) should be vlan id.
		# access_vlan: # Configure given VLAN in access port. The value of C(access_vlan) should be vlan name.
		# name: # Name of the interface excluding any logical unit number.
		# trunk_vlans: # List of VLAN names to be configured in trunk port. The value of C(trunk_vlans) should be list of vlan names.
		# aggregate: # List of Layer-2 interface definitions.
		# state: #present|absent
		# mode: access|trunk
		# provider: # B(Deprecated)
		# active: #True|False
		# unit: 0
		# description: # Description of Interface.
$0
endsnippet

snippet junos_package "Installs packages on remote devices running Junos" b
- name: $1
	junos_package:
		src: ${2:# The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install.}
		force: ${3:true|false}
		reboot: ${4:true|false}
		# version: # The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename.
		# provider: # B(Deprecated)
		# no_copy: true|false
		# validate: true|false
$0
endsnippet

snippet junos_lldp "Manage LLDP configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp:
		# interval: # Frequency at which LLDP advertisements are sent (in seconds).
		# state: #present|absent|enabled|disabled
		# provider: # B(Deprecated)
		# active: #True|False
		# hold_multiplier: # Specify the number of seconds that LLDP information is held before it is discarded. The multiplier value is used in combination with the C(interval) value.
		# transmit_delay: # Specify the number of seconds the device waits before sending advertisements to neighbors after a change is made in local system.
$0
endsnippet

snippet junos_system "Manage the system attributes on Juniper JUNOS devices" b
- name: $1
	junos_system:
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# state: #present|absent
		# provider: # B(Deprecated)
		# active: #True|False
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
$0
endsnippet

snippet junos_logging "Manage logging on network devices" b
- name: $1
	junos_logging:
		# files: # Number of files to be archived, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 1 to 1000.
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# level: # Set logging severity levels.
		# dest: console|host|file|user
		# facility: # Set logging facility.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
		# active: #True|False
		# rotate_frequency: # Rotate log frequency in minutes, this is applicable if value of I(dest) is C(file). The acceptable value is in range of 1 to 59. This controls the frequency after which log file is rotated.
		# size: # Size of the file in archive, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 65536 to 1073741824 bytes.
$0
endsnippet

snippet junos_netconf "Configures the Junos Netconf system service" b
- name: $1
	junos_netconf:
		# state: #present|absent
		# provider: # B(Deprecated)
		# netconf_port: 830
$0
endsnippet

snippet junos_static_route "Manage static IP routes on Juniper JUNOS network devices" b
- name: $1
	junos_static_route:
		next_hop: ${2:# Next hop IP of the static route.}
		address: ${3:# Network address with prefix of the static route.}
		# provider: # B(Deprecated)
		# qualified_next_hop: # Qualified next hop IP of the static route. Qualified next hops allow to associate preference with a particular next-hop address.
		# aggregate: # L
		# state: #present|absent
		# preference: # Global admin preference of the static route.
		# qualified_preference: # Assign preference for qualified next hop.
		# active: #True|False
$0
endsnippet

snippet junos_rpc "Runs an arbitrary RPC over NetConf on an Juniper JUNOS device" b
- name: $1
	junos_rpc:
		rpc: ${2:# The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.}
		# output: xml
		# args: # The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.
		# attrs: # The C(attrs) arguments defines a list of attributes and their values to set for the RPC call. This accepts a dictionary of key-values.
		# provider: # B(Deprecated)
$0
endsnippet

snippet cnos_vlag "Manage VLAG resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlag:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		vlagArg1: ${4:enable|auto-recovery|config-consistency|isl|mac-address-table|peer-gateway|priority|startup-delay|tier-id|vrrp|instance|hlthchk}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# vlagArg2: Interval in seconds|disable or strict|Port Aggregation Number|VLAG priority|Delay time in seconds|VLAG tier-id value|VLAG instance number|keepalive-attempts|keepalive-interval|retry-interval|peer-ip
		# vlagArg3: enable or port-aggregation|Number of keepalive attempts|Interval in seconds|Interval in seconds|VLAG health check peer IP4 address
		# vlagArg4: Port Aggregation Number|default or management
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_rollback "Roll back the running or startup configuration from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_rollback:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		protocol: ${3:SFTP|SCP|FTP|TFTP}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${6:# This specifies the IP Address of the remote server from where the backup configuration will be downloaded.}
		serverpassword: ${7:# Specify the password for the server relating to the protocol used.}
		outputfile: ${8:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		configType: ${9:running-config|startup-config}
		deviceType: ${10:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${11:# Specify the username for the server relating to the protocol used.}
		rcpath: ${12:# This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_facts "Collect facts on devices running Lenovo CNOS" b
- name: $1
	cnos_facts:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_interface "Manage interface configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_interface:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${3:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		interfaceOption: ${5:None|ethernet|loopback|mgmt|port-aggregation|vlan}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		interfaceRange: ${8:# This specifies the interface range in which the port aggregation is envisaged}
		interfaceArg1: ${9:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		# interfaceArg4: key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface
		# interfaceArg5: name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32
		# interfaceArg6: Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent
		# interfaceArg7: Authentication key string|admin-down
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
		# interfaceArg2: aggregation-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port
		# interfaceArg3: active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6
$0
endsnippet

snippet cnos_bgp "Manage BGP resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_bgp:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		asNum: ${4:# AS number}
		bgpArg1: ${5:address-family|bestpath|bgp|cluster-id|confederation|enforce-first-as|fast-external-failover|graceful-restart|graceful-restart-helper|log-neighbor-changes|maxas-limit|neighbor|router-id|shutdown|synchronization|timers|vrf}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# bgpArg8: Un-reachability Half-life time for the penalty(minutes)|backdoor
		# bgpArg4: Aggregate prefix|Reachability Half-life time|route-map|Distance for routes external|ebgp or ibgp|IP prefix <network>|IP prefix <network>/<length>|synchronization|Delay value|direct|ospf|static|memory
		# bgpArg5: as-set|summary-only|Value to start reusing a route|Distance for routes internal|Supported multipath numbers|backdoor|map|route-map
		# bgpArg6: summary-only|as-set|route-map name|Value to start suppressing a route|Distance for local routes|Network mask|Pointer to route-map entries
		# bgpArg7: Maximum duration to suppress a stable route(minutes)|backdoor|route-map|Name of the route map
		# bgpArg2: ipv4 or ipv6|always-compare-med|compare-confed-aspath|compare-routerid|dont-compare-originator-id|tie-break-on-age|as-path|med|identifier|peers
		# bgpArg3: aggregate-address|client-to-client|dampening|distance|maximum-paths|network|nexthop|redistribute|save|synchronization|ignore or multipath-relax|confed or missing-as-worst or non-deterministic or remove-recv-med or remove-send-med
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_showrun "Collect the current running configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_showrun:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_conditional_command "Execute a single command based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		clicommand: ${4:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		flag: ${6:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		condition: ${9:# If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_save "Save the running configuration as the startup configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_save:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_command "Execute a single command on devices running Lenovo CNOS" b
- name: $1
	cnos_command:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		clicommand: ${4:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_vlan "Manage VLAN resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlan:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		vlanArg1: ${5:access-map|dot1q|filter|<1-3999> VLAN ID 1-3999 or range}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# vlanArg5: access-list name|Slot/chassis number|Port Aggregation Number
		# vlanArg4: drop or forward or redirect|ip or mac|Interval in seconds|ethernet|port-aggregation|Querier IP address|Querier Timeout in seconds|Query Interval in seconds|Query Max Response Time in seconds|Robustness Variable value|Number of queries sent at startup|Query Interval at startup
		# vlanArg3: action|match|statistics|enter VLAN id or range of vlan|ascii name for the VLAN|ipv4 or ipv6|active or suspend|fast-leave|last-member-query-interval|mrouter|querier|querier-timeout|query-interval|query-max-response-time|report-suppression|robustness-variable|startup-query-count|startup-query-interval|static-group
		# vlanArg2: VLAN Access Map name|egress-only|name|flood|state|ip
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_conditional_template "Manage switch configuration using templates based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		flag: ${5:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		condition: ${7:# If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		commandfile: ${9:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_LP21_commands.txt}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_factory "Reset the switch's startup configuration to default (factory) on devices running Lenovo CNOS" b
- name: $1
	cnos_factory:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_reload "Perform switch restart on devices running Lenovo CNOS" b
- name: $1
	cnos_reload:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_image "Perform firmware upgrade/download from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_image:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		protocol: ${3:SFTP|SCP|FTP|TFTP}
		serverip: ${4:# This specifies the IP Address of the remote server from where the software image will be downloaded.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${7:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		imgpath: ${8:# This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		deviceType: ${9:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${10:# Specify the username for the server relating to the protocol used.}
		imgtype: ${11:all|boot|os|onie}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
		# serverpassword: # Specify the password for the server relating to the protocol used.
$0
endsnippet

snippet cnos_portchannel "Manage portchannel (port aggregation) configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_portchannel:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${3:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		interfaceRange: ${7:# This specifies the interface range in which the port aggregation is envisaged}
		interfaceArg1: ${8:aggregation-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-aggregation}
		# interfaceArg4: key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface
		# interfaceArg5: name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32
		# interfaceArg6: Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent
		# interfaceArg7: Authentication key string|admin-down
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
		# interfaceArg2: aggregation-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port
		# interfaceArg3: active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6
$0
endsnippet

snippet cnos_backup "Backup the current running or startup configuration to a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_backup:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		protocol: ${3:SFTP|SCP|FTP|TFTP}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		rcserverip: ${6:# -}
		serverpassword: ${7:# Specify the password for the server relating to the protocol used.}
		outputfile: ${8:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		configType: ${9:running-config|startup-config}
		deviceType: ${10:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		serverusername: ${11:# Specify the username for the server relating to the protocol used.}
		rcpath: ${12:# This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_template "Manage switch configuration using templates on devices running Lenovo CNOS" b
- name: $1
	cnos_template:
		username: ${2:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		deviceType: ${5:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		commandfile: ${7:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet pn_vrouterbgp "CLI command to add/remove/modify vrouter-bgp." b
- name: $1
	pn_vrouterbgp:
		pn_vrouter_name: ${2:# Specify a name for the vRouter service.}
		state: ${3:present|absent|update}
		# pn_max_prefix: # Specify the maximum number of prefixes.
		# pn_route_mapout: # Specify outbound route map for neighbor.
		# pn_neighbor: # Specify a neighbor IP address to use for BGP.
		# pn_override_capability: # Specify if you want to override capability.
		# pn_route_mapin: # Specify inbound route map for neighbor.
		# pn_soft_reconfig: # Specify if you want a soft reconfiguration of inbound traffic.
		# pn_ebgp: # Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.
		# pn_prefix_listin: # Specify the prefix list to filter traffic inbound.
		# pn_bfd: # Specify if you want BFD protocol support for fault detection.
		# pn_password: # Specify a password, if desired.
		# pn_route_reflector: # Specify if a route reflector client is used.
		# pn_keepalive: # Specify BGP neighbor keepalive interval in seconds.
		# pn_max_prefix_warn: # Specify if you want a warning message when the maximum number of prefixes is exceeded.
		# pn_multiprotocol: ipv4-unicast|ipv6-unicast
		# pn_clipassword: # Provide login password if user is not root.
		# pn_default_originate: # Specify if you want announce default routes to the neighbor or not.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_weight: # Specify a default weight value between 0 and 65535 for the neighbor routes.
		# pn_prefix_listout: # Specify the prefix list to filter traffic outbound.
		# pn_remote_as: # Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_holdtime: # Specify BGP neighbor holdtime in seconds.
		# pn_next_hop_self: # Specify if the next-hop is the same router or not.
$0
endsnippet

snippet pn_cluster "CLI command to create/delete a cluster." b
- name: $1
	pn_cluster:
		pn_name: ${2:# Specify the name of the cluster.}
		state: ${3:present|absent}
		# pn_cluster_node1: # Specify the name of the first switch in the cluster.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_validate: validate|no-validate
		# pn_cliswitch: # Target switch to run the cli on.
		# pn_cluster_node2: # Specify the name of the second switch in the cluster.
$0
endsnippet

snippet pn_ospf "CLI command to add/remove ospf protocol to a vRouter." b
- name: $1
	pn_ospf:
		state: ${2:#present|absent}
		pn_vrouter_name: ${3:# Specify the name of the vRouter.}
		pn_network_ip: ${4:# Specify the network IP (IPv4 or IPv6) address.}
		# pn_clipassword: # Provide login password if user is not root.
		# pn_ospf_area: # Stub area number for the configuration. Required for vrouter-ospf-add.
		# pn_cliswitch: # Target switch to run the CLI on.
		# pn_cliusername: # Provide login username if user is not root.
$0
endsnippet

snippet pn_vrouter "CLI command to create/delete/modify a vrouter." b
- name: $1
	pn_vrouter:
		pn_name: ${2:# Specify the name of the vRouter.}
		state: ${3:present|absent|update}
		# pn_rip_redistribute: static|connected|ospf|bgp
		# pn_bgp_options: # Specify other BGP options as a whitespaces separated string within single quotes ''.
		# pn_router_id: # Specify the vRouter IP address.
		# pn_ospf_options: # Specify other OSPF options as a whitespaces separated string within single quotes ''.
		# pn_bgp_as: # Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).
		# pn_ospf_redistribute: static|connected|bgp|rip
		# pn_clipassword: # Provide login password if user is not root.
		# pn_bgp_redistribute: static|connected|rip|ospf
		# pn_router_type: hardware|software
		# pn_hw_vrrp_id: # Specifies the VRRP ID for a hardware vrouter.
		# pn_vnet: # Specify the name of the VNET.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_service_state: enable|disable
		# pn_service_type: dedicated|shared
		# pn_cliswitch: # Target switch(es) to run the CLI on.
		# pn_bgp_max_paths: # Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.
$0
endsnippet

snippet pn_vlag "CLI command to create/delete/modify vlag." b
- name: $1
	pn_vlag:
		pn_name: ${2:# The C(pn_name) takes a valid name for vlag configuration.}
		state: ${3:present|absent|update}
		# pn_lacp_fallback: bundle|individual
		# pn_lacp_fallback_timeout: # Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_lacp_timeout: slow|fast
		# pn_cliusername: # Provide login username if user is not root.
		# pn_lacp_mode: off|passive|active
		# pn_failover_action: move|ignore
		# pn_peer_port: # Specify the peer VLAG port.
		# pn_peer_switch: # Specify the fabric-name of the peer switch.
		# pn_port: # Specify the local VLAG port.
		# pn_cliswitch: # Target switch(es) to run this command on.
		# pn_mode: active-active|active-standby
$0
endsnippet

snippet pn_ospfarea "CLI command to add/remove ospf area to/from a vrouter." b
- name: $1
	pn_ospfarea:
		pn_ospf_area: ${2:# Specify the OSPF area number.}
		pn_clipassword: ${3:# Login password.}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		pn_cliusername: ${5:# Login username.}
		state: ${6:present|absent|update}
		# pn_prefix_listin: # OSPF prefix list for filtering incoming packets.
		# pn_prefix_listout: # OSPF prefix list for filtering outgoing packets.
		# pn_stub_type: none|stub|stub-no-summary|nssa|nssa-no-summary
		# pn_cliswitch: # Target switch(es) to run the CLI on.
		# pn_quiet: yes
$0
endsnippet

snippet pn_vrouterif "CLI command to add/remove/modify vrouter-interface." b
- name: $1
	pn_vrouterif:
		pn_vrouter_name: ${2:# Specify the name of the vRouter interface.}
		state: ${3:present|absent|update}
		# pn_nic_enable: # Specify if the NIC is enabled or not
		# pn_vrrp_adv_int: # Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.
		# pn_vrrp_priority: # Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).
		# pn_alias: # Specify an alias for the interface.
		# pn_secondary_macs: # Specify a secondary MAC address for the interface.
		# pn_interface_ip: # Specify the IP address of the interface in x.x.x.x/n format.
		# pn_vlan: # Specify the VLAN identifier. This is a value between 1 and 4092.
		# pn_vxlan: # Specify the VXLAN identifier. This is a value between 1 and 16777215.
		# pn_exclusive: # Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.
		# pn_nic_str: # Specify the type of NIC. Used for vrouter-interface remove/modify.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_vrrp_id: # Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_interface: mgmt|data|span
		# pn_l3port: # Specify a Layer 3 port for the interface.
		# pn_cliswitch: # Target switch to run the cli on.
		# pn_assignment: none|dhcp|dhcpv6|autov6
$0
endsnippet

snippet pn_vrouterlbif "CLI command to add/remove vrouter-loopback-interface." b
- name: $1
	pn_vrouterlbif:
		pn_interface_ip: ${2:# Specify the IP address.}
		state: ${3:present|absent}
		pn_vrouter_name: ${4:# Specify the name of the vRouter.}
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_index: # Specify the interface index from 1 to 255.
$0
endsnippet

snippet pn_show "Run show commands on nvOS device." b
- name: $1
	pn_show:
		pn_command: ${2:# The C(pn_command) takes a CLI show command as value.}
		# pn_parameters: # Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.
		# pn_options: # Specify formatting options.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_cliusername: # Provide login username if user is not root.
$0
endsnippet

snippet pn_vlan "CLI command to create/delete a VLAN." b
- name: $1
	pn_vlan:
		pn_vlanid: ${2:# Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.}
		state: ${3:present|absent}
		# pn_scope: fabric|local
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_ports: # Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.
		# pn_untagged_ports: # Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_stats: # Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.
		# pn_description: # Specify a description for the VLAN.
$0
endsnippet

snippet pn_trunk "CLI command to create/delete/modify a trunk." b
- name: $1
	pn_trunk:
		pn_name: ${2:# Specify the name for the trunk configuration.}
		state: ${3:present|absent|update}
		# pn_unknown_mcast_level: # Specify an unknown multicast level in percent. The default value is 100%.
		# pn_jumbo: # Specify if the port can receive jumbo frames.
		# pn_lacp_fallback_timeout: # Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
		# pn_unknown_ucast_level: # Specify an unknown unicast level in percent. The default value is 100%.
		# pn_lacp_timeout: slow|fast
		# pn_loopback: # Specify loopback if you want to use loopback.
		# pn_speed: disable|10m|100m|1g|2.5g|10g|40g
		# pn_edge_switch: # Specify if the switch is an edge switch.
		# pn_host: # Host facing port control setting.
		# pn_port_macaddr: # Specify the MAC address of the port.
		# pn_lacp_fallback: bundle|individual
		# pn_routing: # Specify if the port participates in routing on the network.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_mirror_receive: # Specify if the configuration receives mirrored traffic.
		# pn_egress_rate_limit: # Specify an egress port data rate limit for the configuration.
		# pn_cliusername: # Provide login username if user is not root.
		# pn_lacp_mode: off|passive|active
		# pn_ports: # Specify the port number(s) for the link(s) to aggregate into the trunk.
		# pn_lacp_priority: # Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.
		# pn_broadcast_level: # Specify a broadcast level in percent. The default value is 100%.
		# pn_pause: # Specify if pause frames are sent.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_loopvlans: # Specify a list of looping vlans.
		# pn_description: # Specify a description for the trunk configuration.
$0
endsnippet

snippet dellos9_command "Run commands on remote devices running Dell OS9" b
- name: $1
	dellos9_command:
		commands: ${2:# List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet dellos9_config "Manage Dell EMC Networking OS9 configuration sections" b
- name: $1
	dellos9_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# update: #merge|check
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# save: yes|no
		# backup: no
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet dellos9_facts "Collect facts from remote devices running Dell EMC Networking OS9" b
- name: $1
	dellos9_facts:
		# gather_subset: !config
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet eos_lldp "Manage LLDP configuration on Arista EOS network devices" b
- name: $1
	eos_lldp:
		# authorize: yes|no
		# state: #present|absent
		# auth_pass: none
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_config "Manage Arista EOS configuration sections" b
- name: $1
	eos_config:
		# authorize: yes|no
		# force: no
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# diff_against: startup|running|intended|#session
		# replace: #line|block|config
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for this module.
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments. It can be a Jinja2 template as well. src file must have same indentation as a live switch config. Arista EOS device config has 3 spaces indentation.
		# save: no
		# auth_pass: none
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# defaults: no
		# provider: # B(Deprecated)
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# save_when: always|#never|modified|changed
		# backup: no
		# match: #line|strict|exact|none
$0
endsnippet

snippet eos_system "Manage the system attributes on Arista EOS devices" b
- name: $1
	eos_system:
		# authorize: yes|no
		# state: #present|absent
		# auth_pass: none
		# provider: # B(Deprecated)
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
$0
endsnippet

snippet eos_vrf "Manage VRFs on Arista EOS network devices" b
- name: $1
	eos_vrf:
		name: ${2:# Name of the VRF.}
		# authorize: yes|no
		# rd: # Route distinguisher of the VRF
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF. The name of interface should be in expanded format and not abbreviated.
		# auth_pass: none
		# purge: no
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# state: #present|absent
		# delay: 10
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet eos_logging "Manage logging on network devices" b
- name: $1
	eos_logging:
		# authorize: yes|no
		# aggregate: # L
		# state: #present|absent
		# auth_pass: none
		# name: # If value of C(dest) is I(host) C(name) should be specified, which indicates hostname or IP address.
		# level: emergencies|alerts|critical|errors|warnings|notifications|informational|debugging
		# dest: on|host|console'|monitor|buffered
		# facility: # Set logging facility.
		# provider: # B(Deprecated)
		# size: # Size of buffer. The acceptable value is in range from 10 to 2147483647 bytes.
$0
endsnippet

snippet eos_facts "Collect facts from remote devices running Arista EOS" b
- name: $1
	eos_facts:
		# authorize: yes|no
		# auth_pass: none
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_command "Run arbitrary commands on an Arista EOS device" b
- name: $1
	eos_command:
		commands: ${2:# The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# authorize: yes|no
		# retries: 10
		# auth_pass: none
		# interval: 1
		# provider: # B(Deprecated)
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails. Note - With I(wait_for) the value in C(result['stdout']) can be accessed using C(result), that is to access C(result['stdout'][0]) use C(result[0]) See examples.
		# match: any|#all
$0
endsnippet

snippet eos_eapi "Manage and configure Arista EOS eAPI." b
- name: $1
	eos_eapi:
		# authorize: yes|no
		# local_http_port: 8080
		# http_port: 80
		# http: yes|no
		# https_port: 443
		# auth_pass: none
		# state: #started|stopped
		# vrf: default
		# https: yes|no
		# provider: # B(Deprecated)
		# config: nul
		# local_http: yes|no
		# socket: yes|no
$0
endsnippet

snippet eos_user "Manage the collection of local users on EOS devices" b
- name: $1
	eos_user:
		# authorize: yes|no
		# update_password: on_create|#always
		# configured_password: # The password to be configured on the remote Arista EOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# aggregate: # The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument.
		# name: # The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# auth_pass: none
		# purge: no
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.
		# state: #present|absent
		# role: # Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.
		# provider: # B(Deprecated)
		# nopassword: # Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.
		# sshkey: # Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.
$0
endsnippet

snippet eos_static_route "Manage static IP routes on Arista EOS network devices" b
- name: $1
	eos_static_route:
		next_hop: ${2:# Next hop IP of the static route.}
		address: ${3:# Network address with prefix of the static route.}
		# authorize: yes|no
		# auth_pass: none
		# provider: # B(Deprecated)
		# admin_distance: 1
		# state: #present|absent
		# aggregate: # L
$0
endsnippet

snippet eos_linkagg "Manage link aggregation groups on Arista EOS network devices" b
- name: $1
	eos_linkagg:
		# purge: no
		# authorize: yes|no
		# state: #present|absent
		# group: # Channel-group number for the port-channel Link aggregation group. Range 1-2000.
		# mode: active|on|passive
		# members: # List of members of the link aggregation group.
		# min_links: # Minimum number of ports required up before bringing up the link aggregation group.
		# aggregate: # L
		# auth_pass: none
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_interface "Manage Interface on Arista EOS network devices" b
- name: $1
	eos_interface:
		name: ${2:# Name of the Interface to be configured on remote device. The name of interface should be in expanded format and not abbreviated.}
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# rx_rate: # Receiver rate in bits per second (bps) for the interface given in C(name) option.
		# auth_pass: none
		# enabled: yes
		# authorize: yes|no
		# mtu: # Set maximum transmission unit size in bytes of transmit packet for the interface given in C(name) option.
		# delay: 10
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
		# aggregate: # List of Interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and other options as required.
		# speed: # This option configures autoneg and speed/duplex/flowcontrol for the interface given in C(name) option.
		# tx_rate: # Transmit rate in bits per second (bps) for the interface given in C(name) option.
		# description: # Description of Interface upto 240 characters.
$0
endsnippet

snippet eos_vlan "Manage VLANs on Arista EOS network devices" b
- name: $1
	eos_vlan:
		vlan_id: ${2:# ID of the VLAN.}
		# authorize: yes|no
		# delay: 10
		# name: # Name of the VLAN.
		# interfaces: # List of interfaces that should be associated to the VLAN. The name of interface is case sensitive and should be in expanded format and not abbreviated.
		# auth_pass: none
		# purge: no
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. The name of interface is case sensitive and should be in expanded format and not abbreviated. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# state: #present|absent|active|suspend
		# provider: # B(Deprecated)
		# aggregate: # L
$0
endsnippet

snippet eos_banner "Manage multiline banners on Arista EOS devices" b
- name: $1
	eos_banner:
		banner: ${2:login|motd}
		# authorize: yes|no
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).
		# auth_pass: none
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_l3_interface "Manage L3 interfaces on Arista EOS network devices." b
- name: $1
	eos_l3_interface:
		# authorize: yes|no
		# name: # Name of the L3 interface to be configured eg. ethernet1
		# auth_pass: none
		# provider: # B(Deprecated)
		# state: #present|absent
		# ipv4: # IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
		# ipv6: # IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
		# aggregate: # List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
$0
endsnippet

snippet eos_l2_interface "Manage L2 interfaces on Arista EOS network devices." b
- name: $1
	eos_l2_interface:
		name: ${2:# Name of the interface}
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# state: #present|absent|unconfigured
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the ONLY VLANs that will be configured on the trunk, i.e. C(2-10,15).
		# provider: # B(Deprecated)
		# aggregate: # List of Layer-2 interface definitions.
		# auth_pass: none
		# authorize: yes|no
		# mode: access|trunk
$0
endsnippet

snippet dellos6_config "Manage Dell EMC Networking OS6 configuration sections" b
- name: $1
	dellos6_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# update: #merge|check
		# replace: #line|block
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# save: yes|no
		# backup: no
		# match: #line|strict|exact|none
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
$0
endsnippet

snippet dellos6_command "Run commands on remote devices running Dell OS6" b
- name: $1
	dellos6_command:
		commands: ${2:# List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet dellos6_facts "Collect facts from remote devices running Dell EMC Networking OS6" b
- name: $1
	dellos6_facts:
		# gather_subset: !config
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet aruba_command "Run commands on remote devices running Aruba Mobility Controller" b
- name: $1
	aruba_command:
		commands: ${2:# List of commands to send to the remote aruba device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
$0
endsnippet

snippet aruba_config "Manage Aruba configuration sections" b
- name: $1
	aruba_config:
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# save_when: always|#never|modified|changed
		# encrypt: yes
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# diff_against: startup|intended|running
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# provider: # A dict object containing connection details.
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# replace: #line|block
		# backup: no
		# match: #line|strict|exact|none
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
$0
endsnippet

snippet etcd3 "Set or delete key value pairs from an etcd3 cluster" b
- name: $1
	etcd3:
		key: ${2:# the key where the information is stored in the cluster}
		state: ${3:# the state of the value for the key.}
		value: ${4:# the information stored}
		# host: localhost
		# port: 2379
$0
endsnippet

snippet consul_acl "Manipulate Consul ACL keys and rules" b
- name: $1
	consul_acl:
		# name: # the name that should be associated with the acl key, this is opaque to Consul
		# rules: # a list of the rules that should be associated with a given token
		# state: #present|absent
		# token_type: #client|management
		# token: # the token key indentifying an ACL rule set. If generated by consul this will be a UUID
		# mgmt_token: # a management token is required to manipulate the acl lists
		# host: localhost
		# scheme: http
		# validate_certs: yes
		# port: 8500
$0
endsnippet

snippet consul_session "Manipulate consul sessions" b
- name: $1
	consul_session:
		# node: # The name of the node that with which the session will be associated. by default this is the name of the agent.
		# datacenter: # The name of the datacenter in which the session exists or should be created.
		# name: # The name that should be associated with the session. This is opaque to Consul and not required.
		# state: absent|info|list|node|#present
		# checks: # A list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.
		# delay: 15
		# host: localhost
		# behavior: delete|#release
		# scheme: http
		# validate_certs: yes
		# port: 8500
$0
endsnippet

snippet consul "Add, modify & delete services within a consul cluster." b
- name: $1
	consul:
		state: ${2:present|absent}
		# service_address: # the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.
		# http: # checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.
		# tags: # a list of tags that will be attached to the service registration.
		# check_name: # a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.
		# service_name: # Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check
		# host: localhost
		# ttl: # checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m
		# port: 8500
		# script: # the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa
		# check_id: # an ID for the service check, defaults to the check name, ignored if part of a service definition.
		# service_port: # the port on which the service is listening. Can optionally be supplied for registration of a service, i.e. if service_name or service_id is set
		# notes: # Notes to attach to check when registering it.
		# interval: # the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.
		# token: # the token key indentifying an ACL rule set. May be required to register services.
		# timeout: # A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.
		# service_id: service_name if supplied
		# scheme: http
		# validate_certs: yes
$0
endsnippet

snippet znode "Create, delete, retrieve, and update znodes using ZooKeeper" b
- name: $1
	znode:
		hosts: ${2:# A list of ZooKeeper servers (format '[server]:[port]').}
		name: ${3:# The path of the znode.}
		# state: # The state to enforce. Mutually exclusive with op.
		# timeout: 300
		# op: # An operation to perform. Mutually exclusive with state.
		# value: # The value assigned to the znode.
		# recursive: no
$0
endsnippet

snippet pacemaker_cluster "Manage pacemaker clusters" b
- name: $1
	pacemaker_cluster:
		state: ${2:cleanup|offline|online|restart}
		# node: # Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.
		# force: yes
		# timeout: 300
$0
endsnippet

snippet consul_kv "Manipulate entries in the key/value store of a consul cluster" b
- name: $1
	consul_kv:
		value: ${2:# The value should be associated with the given key, required if C(state) is C(present).}
		key: ${3:# The key at which the value should be stored.}
		# cas: # Used when acquiring a lock with a session. If the C(cas) is C(0), then Consul will only put the key if it does not already exist. If the C(cas) value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.
		# recurse: no
		# token: # The token key indentifying an ACL rule set that controls access to the key value pair
		# state: absent|acquire|#present|release
		# session: # The session that should be used to acquire or release a lock associated with a key/value pair.
		# flags: # Opaque integer value that can be passed when setting a value.
		# host: localhost
		# scheme: http
		# validate_certs: yes
		# port: 8500
$0
endsnippet

snippet k8s_raw "Manage Kubernetes (K8s) objects" b
- name: $1
	k8s_raw:
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# src: # Provide a path to a file containing a valid YAML definition of an object to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# force: no
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# resource_definition: # Provide a valid YAML definition for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# state: #present|absent
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# api_version: v1
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
$0
endsnippet

snippet k8s_scale "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job." b
- name: $1
	k8s_scale:
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# src: # Provide a path to a file containing a valid YAML definition of an object to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# replicas: # The desired number of replicas.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# wait_timeout: 20
		# current_replicas: # For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# resource_version: # Only attempt to scale, if the current object version matches.
		# resource_definition: # Provide a valid YAML definition for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# api_version: v1
		# wait: yes
$0
endsnippet

snippet openshift_raw "Manage OpenShift objects" b
- name: $1
	openshift_raw:
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# src: # Provide a path to a file containing a valid YAML definition of an object to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# force: no
		# description: # Use only when creating a project, otherwise ignored. Adds a description to the project metadata.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# resource_definition: # Provide a valid YAML definition for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# state: #present|absent
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# display_name: # Use only when creating a project, otherwise ignored. Adds a display name to the project metadata.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# api_version: v1
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
$0
endsnippet

snippet openshift_scale "Set a new size for a Deployment Config, Deployment, Replica Set, Replication Controller, or Job." b
- name: $1
	openshift_scale:
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# src: # Provide a path to a file containing a valid YAML definition of an object to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# replicas: # The desired number of replicas.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# wait_timeout: 20
		# current_replicas: # For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# resource_version: # Only attempt to scale, if the current object version matches.
		# resource_definition: # Provide a valid YAML definition for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# api_version: v1
		# wait: yes
$0
endsnippet

snippet netapp_e_facts "Get facts about NetApp E-Series arrays" b
- name: $1
	netapp_e_facts:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${3:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${4:# The ID of the array to manage. This value must be unique for each array.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# validate_certs: yes
$0
endsnippet

snippet sf_snapshot_schedule_manager "Manage SolidFire snapshot schedules" b
- name: $1
	sf_snapshot_schedule_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# Name for the snapshot schedule.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# time_interval_days: 1
		# time_interval_minutes: 0
		# time_interval_hours: 0
		# paused: # Pause / Resume a schedule.
		# schedule_id: # The schedule ID for the schedule that you want to update or delete.
		# snapshot_name: # Name for the created snapshots.
		# volumes: # Volume IDs that you want to set the snapshot schedule for.
		# starting_date: # Starting date for the schedule.
		# recurring: # Should the schedule recur?
		# retention: # Retention period for the snapshot.
$0
endsnippet

snippet na_cdot_svm "Manage NetApp cDOT svm" b
- name: $1
	na_cdot_svm:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the SVM to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# root_volume_aggregate: # The aggregate on which the root volume will be created.
		# root_volume_security_style: unix|ntfs|mixed|unified
		# root_volume: # Root volume of the SVM. Required when C(state=present).
$0
endsnippet

snippet na_cdot_volume "Manage NetApp cDOT volumes" b
- name: $1
	na_cdot_volume:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		password: ${3:# Password for the specified user.}
		name: ${4:# The name of the volume to manage.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		vserver: ${6:# Name of the vserver to use.}
		state: ${7:present|absent}
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# online: #True|False
		# infinite: True|#False
		# aggregate_name: # The name of the aggregate the flexvol should exist on. Required when C(state=present).
		# size: # The size of the volume in (size_unit). Required when C(state=present).
$0
endsnippet

snippet netapp_e_amg_sync "Conduct synchronization actions on asynchronous mirror groups." b
- name: $1
	netapp_e_amg_sync:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${3:running|suspended}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${6:# The name of the async mirror group you wish to target}
		# ssid: # The ID of the storage array containing the AMG you wish to target
		# delete_recovery_point: True|#False
		# validate_certs: yes
$0
endsnippet

snippet na_cdot_user "useradmin configuration and management" b
- name: $1
	na_cdot_user:
		vserver: ${2:# The name of the vserver to use.}
		application: ${3:console|http|ontapi|rsh|snmp|sp|ssh|telnet}
		state: ${4:present|absent}
		name: ${5:# The name of the user to manage.}
		authentication_method: ${6:community|password|publickey|domain|nsswitch|usm}
		username: ${7:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		password: ${8:# Password for the specified user.}
		hostname: ${9:# The hostname or IP address of the ONTAP instance.}
		# role_name: # The name of the role. Required when C(state=present)
		# set_password: # Password for the user account.
$0
endsnippet

snippet netapp_e_flashcache "Manage NetApp SSD caches" b
- name: $1
	netapp_e_flashcache:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:#present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${7:# The name of the SSD cache to manage}
		# cache_size_min: # The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.
		# io_type: #filesystem|database|media
		# disk_count: # The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# validate_certs: yes
$0
endsnippet

snippet na_cdot_license "Manage NetApp cDOT protocol and feature licenses" b
- name: $1
	na_cdot_license:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		password: ${4:# Password for the specified user.}
		# remove_unused: true|false
		# licenses: # List of licenses to add or remove.
		# remove_expired: true|false
		# serial_number: # Serial number of the node associated with the license.
$0
endsnippet

snippet netapp_e_volume "Manage storage volumes (standard and thin)" b
- name: $1
	netapp_e_volume:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		name: ${3:# The name of the volume to manage}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		storage_pool_name: ${6:# Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.}
		api_username: ${7:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${8:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		thin_volume_repo_size: ${9:# Initial size of the thin volume repository volume (in size_unit)}
		size: ${10:# Required only when state = 'present'.  The size of the volume in (size_unit).}
		# segment_size_kb: 512
		# ssd_cache_enabled: yes|no|true|false
		# data_assurance_enabled: no
		# thin_provision: yes|no|true|false
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# thin_volume_max_repo_size: same as size (in size_unit)
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_amg_role "Update the role of a storage array within an Asynchronous Mirror Group (AMG)." b
- name: $1
	netapp_e_amg_role:
		ssid: ${2:# The ID of the primary storage array for the async mirror action}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		role: ${4:primary|secondary}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# force: no
		# validate_certs: yes
		# noSync: True|#False
$0
endsnippet

snippet netapp_e_lun_mapping "Create or Remove LUN Mappings" b
- name: $1
	netapp_e_lun_mapping:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		volume_name: ${5:# The name of the volume you wish to include in the mapping.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${7:# The ID of the array to manage. This value must be unique for each array.}
		# target: # The name of host or hostgroup you wish to assign to the mapping
		# target_type: host|group
		# validate_certs: yes
		# lun: 0
$0
endsnippet

snippet sf_check_connections "Check connectivity to MVIP and SVIP." b
- name: $1
	sf_check_connections:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		password: ${4:# Password for the specified user.}
		# skip: svip|mvip
		# svip: # Optionally, use to test connection of a different SVIP.
		# mvip: # Optionally, use to test connection of a different MVIP.
$0
endsnippet

snippet na_cdot_user_role "useradmin configuration and management" b
- name: $1
	na_cdot_user_role:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the role to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		command_directory_name: ${8:# The command or command directory to which the role has an access.}
		# access_level: none|readonly|#all
$0
endsnippet

snippet na_cdot_aggregate "Manage NetApp cDOT aggregates." b
- name: $1
	na_cdot_aggregate:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the aggregate to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		state: ${5:present|absent}
		password: ${6:# Password for the specified user.}
		# disk_count: # Number of disks to place into the aggregate, including parity disks.
$0
endsnippet

snippet sf_account_manager "Manage SolidFire accounts" b
- name: $1
	sf_account_manager:
		password: ${2:# Password for the specified user.}
		name: ${3:# Unique username for this account. (May be 1 to 64 characters in length).}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		username: ${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		state: ${6:present|absent}
		# new_name: # New name for the user account.
		# status: # Status of the account.
		# initiator_secret: # CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.
		# attributes: # L
		# target_secret: # CHAP secret to use for the target (mutual CHAP authentication).
		# account_id: # The ID of the account to manage or update.
$0
endsnippet

snippet netapp_e_auth "Sets or updates the password for a storage array." b
- name: $1
	netapp_e_auth:
		new_password: ${2:# The password you would like to set. Cannot be more than 30 characters.}
		# ssid: # the identifier of the storage array in the Web Services Proxy.
		# name: # The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.
		# api_password: # The password used to authenticate against the API
		# current_password: # The current admin password. This is not required if the password hasn't been set before.
		# api_username: # The username used to authenticate against the API
		# validate_certs: yes
		# set_admin: no
		# api_url: # The full API url.
$0
endsnippet

snippet netapp_e_storage_system "Add/remove arrays from the Web Services Proxy" b
- name: $1
	netapp_e_storage_system:
		ssid: ${2:# The ID of the array to manage. This value must be unique for each array.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		controller_addresses: ${7:# The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.}
		# meta_tags: # Optional meta tags to associate to this storage system
		# array_wwn: # The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.
		# array_password: # The management password of the array to manage, if set.
		# enable_trace: no
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_amg "Create, Remove, and Update Asynchronous Mirror Groups" b
- name: $1
	netapp_e_amg:
		name: ${2:# The name of the async array you wish to target, or create.}
		secondaryArrayId: ${3:# The ID of the secondary array to be used in mirroing process}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:# A C(state) of present will either create or update the async mirror group.}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${7:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${8:# The ID of the array to manage. This value must be unique for each array.}
		# syncIntervalMinutes: 10
		# recoveryWarnThresholdMinutes: 20
		# repoUtilizationWarnThreshold: 80
		# interfaceType: iscsi|fibre
		# manualSync: no
		# syncWarnThresholdMinutes: 10
		# validate_certs: yes
$0
endsnippet

snippet na_cdot_lun "Manage  NetApp cDOT luns" b
- name: $1
	na_cdot_lun:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the lun to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		# force_remove: no
		# flexvol_name: # The name of the FlexVol the lun should exist on.
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# force_resize: no
		# force_remove_fenced: no
		# size: # The size of the lun in C(size_unit).
$0
endsnippet

snippet sf_volume_access_group_manager "Manage SolidFire Volume Access Groups" b
- name: $1
	sf_volume_access_group_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		password: ${3:# Password for the specified user.}
		name: ${4:# Name of the volume access group. It is not required to be unique, but recommended.}
		hostname: ${5:# The hostname or IP address of the SolidFire cluster.}
		state: ${6:present|absent}
		# virtual_network_id: # The ID of the SolidFire Virtual Network ID to associate the volume access group with.
		# volumes: # List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.
		# initiators: # List of initiators to include in the volume access group. If unspecified, the access group will start out without configured initiators.
		# attributes: # L
		# virtual_network_tags: # The ID of the VLAN Virtual Network Tag to associate the volume access group with.
		# volume_access_group_id: # The ID of the volume access group to modify or delete.
$0
endsnippet

snippet netapp_e_snapshot_volume "Manage E/EF-Series snapshot volumes." b
- name: $1
	netapp_e_snapshot_volume:
		snapshot_image_id: ${2:# The identifier of the snapshot image used to create the new snapshot volume.}
		ssid: ${3:# storage array ID}
		api_password: ${4:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		view_mode: ${5:modeUnknown|readWrite|readOnly|__UNDEFINED}
		state: ${6:absent|present}
		storage_pool_name: ${7:# Name of the storage pool on which to allocate the repository volume.}
		api_username: ${8:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${9:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${10:# The name you wish to give the snapshot volume}
		# repo_percentage: 20
		# full_threshold: 85
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_snapshot_group "Manage snapshot groups" b
- name: $1
	netapp_e_snapshot_group:
		api_password: ${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		name: ${3:# The name to give the snapshot group}
		state: ${4:present|absent}
		storage_pool_name: ${5:# The name of the storage pool on which to allocate the repository volume.}
		api_username: ${6:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		base_volume_name: ${7:# The name of the base volume or thin volume to use as the base for the new snapshot group.}
		api_url: ${8:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# repo_pct: 20
		# warning_threshold: 80
		# rollback_priority: highest|high|#medium|low|lowest|__UNDEFINED
		# delete_limit: 30
		# full_policy: #purgepit|unknown|failbasewrites|__UNDEFINED
		# validate_certs: yes
$0
endsnippet

snippet sf_volume_manager "Manage SolidFire volumes" b
- name: $1
	sf_volume_manager:
		username: ${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://goo.gl/ddJa4Q).}
		name: ${3:# The name of the volume to manage.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		account_id: ${5:# Account ID for the owner of this volume.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		# qos: # I
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# access: readOnly|readWrite|locked|replicationTarget
		# volume_id: # The ID of the volume to manage or update.
		# 512emulation: # Should the volume provide 512-byte sector emulation?
		# attributes: # A
		# size: # The size of the volume in (size_unit).
$0
endsnippet

snippet netapp_e_host "manage eseries hosts" b
- name: $1
	netapp_e_host:
		name: ${2:# If the host doesn't yet exist, the label to assign at creation time.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_username: ${4:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		host_type_index: ${6:# The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.}
		ssid: ${7:# The ID of the array to manage. This value must be unique for each array.}
		# group: # the group you want the host to be a member of
		# validate_certs: yes
		# ports: # a list of of dictionaries of host ports you wish to associate with the newly created host
$0
endsnippet

snippet netapp_e_snapshot_images "Create and delete snapshot images" b
- name: $1
	netapp_e_snapshot_images:
		state: ${2:create|remove}
		api_url: ${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		snapshot_group: ${4:# The name of the snapshot group in which you want to create a snapshot image.}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${6:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_hostgroup "Manage NetApp Storage Array Host Groups" b
- name: $1
	netapp_e_hostgroup:
		ssid: ${2:# The ID of the array to manage (as configured on the web services proxy).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${6:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		# new_name: # specify this when you need to update the name of a host group
		# hosts: # a list of host names/labels to add to the group
		# validate_certs: yes
		# id: # The id number of the host group to manage. Either this or C(name) must be supplied.
		# name: # The name of the host group to manage. Either this or C(id_num) must be supplied.
$0
endsnippet

snippet na_cdot_qtree "Manage qtrees" b
- name: $1
	na_cdot_qtree:
		username: ${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://goo.gl/BRu78Z).}
		name: ${3:# The name of the Qtree to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		vserver: ${5:# The name of the vserver to use.}
		state: ${6:present|absent}
		password: ${7:# Password for the specified user.}
		# flexvol_name: # The name of the FlexVol the Qtree should exist on. Required when C(state=present).
$0
endsnippet

snippet netapp_e_storagepool "Manage disk groups and disk pools" b
- name: $1
	netapp_e_storagepool:
		name: ${2:# The name of the storage pool to manage}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		raid_level: ${4:raidAll|raid0|raid1|raid3|raid5|raid6|raidDiskPool}
		api_url: ${5:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		state: ${6:present|absent}
		api_username: ${7:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${8:# The ID of the array to manage. This value must be unique for each array.}
		# criteria_size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# criteria_drive_require_fde: # Whether full disk encryption ability is required for drives to be added to the storage pool
		# criteria_min_usable_capacity: # The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.
		# erase_secured_drives: true|false
		# secure_pool: true|false
		# criteria_drive_min_size: # The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.
		# remove_volumes: no
		# criteria_drive_type: hdd|ssd
		# criteria_drive_count: # The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place
		# criteria_drive_interface_type: sas|sas4k|fibre|fibre520b|scsi|sata|pata
		# validate_certs: yes
		# reserve_drive_count: # Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.
$0
endsnippet

snippet netapp_e_volume_copy "Create volume copy pairs" b
- name: $1
	netapp_e_volume_copy:
		api_url: ${2:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		state: ${4:present|absent}
		api_username: ${5:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${6:# The ID of the array to manage. This value must be unique for each array.}
		# create_copy_pair_if_does_not_exist: #True|False
		# search_volume_id: # Searches for all valid potential target and source volumes that could be used in a copy_pair
		# source_volume_id: # The id of the volume copy source.
		# destination_volume_id: # The id of the volume copy destination.
		# volume_copy_pair_id: # The id of a given volume copy pair
		# start_stop_copy: # starts a re-copy or stops a copy in progress
		# validate_certs: yes
$0
endsnippet

snippet purefa_host "Manage hosts on Pure Storage FlashArrays" b
- name: $1
	purefa_host:
		api_token: ${2:# FlashArray API token for admin privilaged user.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		host: ${4:# The name of the host.}
		# volume: # Volume name to map to the host.
		# state: absent|#present
		# iqn: # List of IQNs of the host if protocol is iscsi.
		# protocol: fc|#iscsi
		# wwns: # List of wwns of the host if protocol is fc.
$0
endsnippet

snippet purefa_snap "Manage volume snapshots on Pure Storage FlashArrays" b
- name: $1
	purefa_snap:
		api_token: ${2:# FlashArray API token for admin privilaged user.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		name: ${4:# The name of the source volume.}
		# state: absent|copy|#present
		# suffix: # Suffix of snapshot name.
		# target: # Name of target volume if creating from snapshot.
		# eradicate: no
		# overwrite: no
$0
endsnippet

snippet purefa_hg "Manage hostgroups on Pure Storage FlashArrays" b
- name: $1
	purefa_hg:
		hostgroup: ${2:# The name of the hostgroup.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# host: # List of existing hosts to add to hostgroup.
		# volume: # List of existing volumes to add to hostgroup.
		# state: absent|#present
$0
endsnippet

snippet purefa_volume "Manage volumes on Pure Storage FlashArrays" b
- name: $1
	purefa_volume:
		name: ${2:# The name of the volume.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# size: # Volume size in M, G, T or P units.
		# state: absent|#present
		# eradicate: no
		# overwrite: no
		# target: # The name of the target volume, if copying.
$0
endsnippet

snippet purefa_pg "Manage protection groups on Pure Storage FlashArrays" b
- name: $1
	purefa_pg:
		api_token: ${2:# FlashArray API token for admin privilaged user.}
		pgroup: ${3:# The name of the protection group.}
		fa_url: ${4:# FlashArray management IPv4 address or Hostname.}
		# volume: # List of existing volumes to add to protection group.
		# host: # List of existing hosts to add to protection group.
		# enabled: yes
		# state: absent|#present
		# hostgroup: # List of existing hostgroups to add to protection group.
		# eradicate: no
$0
endsnippet

snippet zfs_facts "Gather facts about ZFS datasets." b
- name: $1
	zfs_facts:
		name: ${2:# ZFS dataset name.}
		# parsable: no
		# depth: # Specifiies recurion depth.
		# type: #all|filesystem|volume|snapshot|bookmark
		# recurse: no
		# properties: all
$0
endsnippet

snippet zfs "Manage zfs" b
- name: $1
	zfs:
		state: ${2:absent|present}
		name: ${3:# File system, snapshot or volume name e.g. C(rpool/myfs).}
		# origin: # Snapshot from which to create a clone.
		# extra_zfs_properties: # A dictionary of zfs properties to be set.
		# key_value: # (**DEPRECATED**) This will be removed in Ansible-2.9.  Set these values in the
$0
endsnippet

snippet zpool_facts "Gather facts about ZFS pools." b
- name: $1
	zpool_facts:
		# parsable: no
		# name: # ZFS pool name.
		# properties: all
$0
endsnippet

snippet infini_export "Create, Delete or Modify NFS Exports on Infinibox" b
- name: $1
	infini_export:
		name: ${2:# Export name. Should always start with C(/). (ex. name=/data)}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		filesystem: ${4:# Name of exported file system.}
		# inner_path: /
		# client_list: All Hosts(*), RW, no_root_squash: True
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_host "Create, Delete and Modify Hosts on Infinibox" b
- name: $1
	infini_host:
		name: ${2:# Host Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		# volume: # Volume name to map to the host
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
		# wwns: # List of wwns of the host
$0
endsnippet

snippet infini_pool "Create, Delete and Modify Pools on Infinibox" b
- name: $1
	infini_pool:
		name: ${2:# Pool Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		# ssd_cache: yes|no
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
		# vsize: # Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.
		# size: # Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.
$0
endsnippet

snippet infini_fs "Create, Delete or Modify filesystems on Infinibox" b
- name: $1
	infini_fs:
		name: ${2:# File system name.}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		pool: ${4:# Pool that will host file system.}
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
		# size: # File system size in MB, GB or TB units. See examples.
$0
endsnippet

snippet infini_export_client "Create, Delete or Modify NFS Client(s) for existing exports on Infinibox" b
- name: $1
	infini_export_client:
		system: ${2:# Infinibox Hostname or IPv4 Address.}
		client: ${3:# Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.}
		export: ${4:# Name of the export.}
		# no_root_squash: yes|no
		# access_mode: #RW|RO
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_vol "Create, Delete or Modify volumes on Infinibox" b
- name: $1
	infini_vol:
		name: ${2:# Volume Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		pool: ${4:# Pool that volume will reside on}
		# state: #present|absent
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
		# size: # Volume size in MB, GB or TB units. See examples.
$0
endsnippet

snippet async_status "Obtain status of asynchronous task" b
- name: $1
	async_status:
		jid: ${2:# Job or task identifier}
		# mode: #status|cleanup
$0
endsnippet

snippet include_role "Load and execute a role" b
- name: $1
	include_role:
		name: ${2:# The name of the role to be executed.}
		# allow_duplicates: yes
		# tasks_from: main
		# vars_from: main
		# defaults_from: main
		# private: # If C(True) the variables from C(defaults/) and C(vars/) in a role will not be made available to the rest of the play.
$0
endsnippet

snippet wait_for "Waits for a condition before continuing" b
- name: $1
	wait_for:
		# active_connection_states: [u'ESTABLISHED', u'FIN_WAIT1', u'FIN_WAIT2', u'SYN_RECV', u'SYN_SENT', u'TIME_WAIT']
		# host: 127.0.0.1
		# connect_timeout: 5
		# delay: 0
		# search_regex: # Can be used to match a string in either a file or a socket connection.
		# state: absent|drained|present|#started|stopped
		# sleep: 1
		# timeout: 300
		# exclude_hosts: # List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.
		# msg: # This overrides the normal error message from a failure to meet the required conditions.
		# path: # Path to a file on the filesystem that must exist before continuing.
		# port: # Port number to poll.
$0
endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable" b
- name: $1
	wait_for_connection:
		# delay: 0
		# sleep: 1
		# connect_timeout: 5
		# timeout: 600
$0
endsnippet

snippet include_tasks "Dynamically include a task list" b
- name: $1
	include_tasks:
		# free-form: # The name of the imported file is specified directly without any other option.
$0
endsnippet

snippet import_tasks "Import a task list" b
- name: $1
	import_tasks:
		# free-form: # The name of the imported file is specified directly without any other option.
$0
endsnippet

snippet assert "Asserts given expressions are true" b
- name: $1
	assert:
		that: ${2:# A string expression of the same form that can be passed to the 'when' statement}
		# msg: # The customized message used for a failing assertion
$0
endsnippet

snippet include_vars "Load variables from files, dynamically within a task" b
- name: $1
	include_vars:
		# ignore_files: # List of file names to ignore.
		# free-form: # This module allows you to specify the 'file' option directly without any other options. There is no 'free-form' option, this is just an indicator, see example below.
		# files_matching: # Limit the files that are loaded within any directory to this regular expression.
		# depth: 0
		# extensions: [u'yaml', u'yml', u'json']
		# file: # The file name from which variables should be loaded.
		# dir: # The directory name from which the variables should be loaded.
		# name: # The name of a variable into which assign the included vars. If omitted (null) they will be made top level vars.
$0
endsnippet

snippet fail "Fail with custom message" b
- name: $1
	fail:
		# msg: 'Failed as requested from task'
$0
endsnippet

snippet set_fact "Set host facts from a task" b
- name: $1
	set_fact:
		key_value: ${2:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}
		# cacheable: no
$0
endsnippet

snippet pause "Pause playbook execution" b
- name: $1
	pause:
		# seconds: # A positive number of seconds to pause for.
		# minutes: # A positive number of minutes to pause for.
		# prompt: # Optional text to use for the prompt message.
		# echo: #yes|no
$0
endsnippet

snippet import_playbook "Import a playbook" b
- name: $1
	import_playbook:
		# free-form: # The name of the imported playbook is specified directly without any other option.
$0
endsnippet

snippet debug "Print statements during execution" b
- name: $1
	debug:
		# msg: Hello world!
		# var: # A variable name to debug.  Mutually exclusive with the 'msg' option.
		# verbosity: 0
$0
endsnippet

snippet import_role "Import a role into a play" b
- name: $1
	import_role:
		name: ${2:# The name of the role to be executed.}
		# allow_duplicates: yes
		# tasks_from: main
		# vars_from: main
		# defaults_from: main
		# private: # If C(True) the variables from C(defaults/) and C(vars/) in a role will not be made available to the rest of the play.
$0
endsnippet

snippet include "Include a play or task list" b
- name: $1
	include:
		# free-form: # This module allows you to specify the name of the file directly without any other options.
$0
endsnippet

snippet set_stats "Set stats for the current ansible run" b
- name: $1
	set_stats:
		data: ${2:# A dictionary of which each key represents a stat (or variable) you want to keep track of}
		# aggregate: yes
		# per_host: no
$0
endsnippet

snippet meta "Execute Ansible 'actions'" b
- name: $1
	meta: $2
	args:
$0
endsnippet

snippet cronvar "Manage variables in crontabs" b
- name: $1
	cronvar:
		name: ${2:# Name of the crontab variable.}
		# insertbefore: # Used with C(state=present). If specified, the variable will be inserted just before the variable specified.
		# cron_file: # If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.
		# value: # The value to set this variable to.
		# state: absent|#present
		# user: root
		# insertafter: # If specified, the variable will be inserted after the variable specified.
		# backup: no
$0
endsnippet

snippet osx_defaults "osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible" b
- name: $1
	osx_defaults:
		key: ${2:# The key of the user preference}
		# domain: NSGlobalDomain
		# array_add: true|false
		# host: # The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.
		# type: array|bool|boolean|date|float|int|integer|#string
		# state: #present|absent
		# value: # The value to write. Only required when state = present.
$0
endsnippet

snippet service "Manage services" b
- name: $1
	service:
		name: ${2:# Name of the service.}
		# use: auto
		# pattern: # If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# state: reloaded|restarted|running|started|stopped
		# sleep: # If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
		# arguments: # Additional arguments provided on the command line
		# runlevel: default
$0
endsnippet

snippet user "Manage user accounts" b
- name: $1
	user:
		name: ${2:# Name of the user to create, remove or modify.}
		# comment: # Optionally sets the description (aka I(GECOS)) of user account.
		# ssh_key_bits: default set by ssh-keygen
		# update_password: #always|on_create
		# non_unique: no
		# force: no
		# ssh_key_type: rsa
		# expires: # An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux, FreeBSD, and DragonFlyBSD.
		# create_home: yes
		# ssh_key_passphrase: # Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.
		# groups: # Puts the user in  list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.
		# home: # Optionally set the user's home directory.
		# move_home: no
		# password: # Optionally set the user's password to this crypted value.
		# skeleton: # Optionally set a home skeleton directory. Requires create_home option!
		# generate_ssh_key: no
		# append: no
		# uid: # Optionally sets the I(UID) of the user.
		# ssh_key_comment: ansible-generated on $HOSTNAME
		# group: # Optionally sets the user's primary group (takes a group name).
		# seuser: # Optionally sets the seuser type (user_u) on selinux enabled systems.
		# system: no
		# remove: no
		# state: absent|#present
		# ssh_key_file: .ssh/id_rsa
		# login_class: # Optionally sets the user's login class for FreeBSD, DragonFlyBSD, OpenBSD and NetBSD systems.
		# shell: # Optionally set the user's shell.
		# local: no
$0
endsnippet

snippet sefcontext "Manages SELinux file context mapping definitions" b
- name: $1
	sefcontext:
		setype: ${2:# SELinux type for the specified target.}
		target: ${3:# Target path (expression).}
		# reload: yes
		# ftype: a
		# selevel: # SELinux range for the specified target.
		# seuser: # SELinux user for the specified target.
		# state: absent|#present
$0
endsnippet

snippet gluster_volume "Manage GlusterFS volumes" b
- name: $1
	gluster_volume:
		name: ${2:# The volume name.}
		state: ${3:absent|present|started|stopped}
		# arbiters: # Arbiter count for volume.
		# force: # If brick is being created in the root partition, module will fail. Set force to true to override this behaviour.
		# replicas: # Replica count for volume.
		# bricks: # Brick paths on servers. Multiple brick paths can be separated by commas.
		# quota: # Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list).
		# stripes: # Stripe count for volume.
		# cluster: # List of hosts to use for probing and brick setup.
		# host: # Override local hostname (for peer probing purposes).
		# start_on_create: yes
		# redundancies: # Redundancy count for volume.
		# transport: rdma|#tcp|#tcp|rdma
		# disperses: # Disperse count for volume.
		# directory: # Directory for limit-usage.
		# rebalance: no
		# options: # A dictionary/hash with options/settings for the volume.
$0
endsnippet

snippet selinux "Change policy and state of SELinux" b
- name: $1
	selinux:
		state: ${2:enforcing|permissive|disabled}
		# policy: # name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)
		# conf: /etc/selinux/config
$0
endsnippet

snippet crypttab "Encrypted Linux block devices" b
- name: $1
	crypttab:
		state: ${2:absent|opts_absent|opts_present|present}
		name: ${3:# Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).}
		# backing_device: # Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=).
		# path: /etc/crypttab
		# password: none
		# opts: # A comma-delimited list of options. See C(crypttab(5) ) for details.
$0
endsnippet

snippet gconftool2 "Edit GNOME Configurations" b
- name: $1
	gconftool2:
		state: ${2:absent|get|present}
		key: ${3:# A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)}
		# value_type: bool|float|int|string
		# direct: no
		# value: # Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)
		# config_source: # Specify a configuration source to use rather than the default path. See man gconftool-2(1)
$0
endsnippet

snippet open_iscsi "Manage iscsi targets with open-iscsi" b
- name: $1
	open_iscsi:
		# auto_node_startup: True|False
		# target: # the iscsi target name
		# show_nodes: True|False
		# node_auth: CHAP
		# node_pass: # discovery.sendtargets.auth.password
		# discover: True|False
		# portal: # the ip address of the iscsi target
		# login: True|False
		# node_user: # discovery.sendtargets.auth.username
		# port: 3260
$0
endsnippet

snippet aix_inittab "Manages the inittab on AIX" b
- name: $1
	aix_inittab:
		action: ${2:boot|bootwait|hold|initdefault|False|once|ondemand|powerfail|powerwait|respawn|sysinit|wait}
		command: ${3:# What command has to run.}
		name: ${4:# Name of the inittab entry.}
		runlevel: ${5:# Runlevel of the entry.}
		# state: absent|#present
		# insertafter: # After which inittabline should the new entry inserted.
$0
endsnippet

snippet ohai "Returns inventory data from I(Ohai)" b
- name: $1
	ohai:
$0
endsnippet

snippet debconf "Configure a .deb package" b
- name: $1
	debconf:
		name: ${2:# Name of package to configure.}
		# value: # Value to set the configuration to.
		# vtype: boolean|error|multiselect|note|password|seen|select|string|text|title|text
		# question: # A debconf configuration setting.
		# unseen: no
$0
endsnippet

snippet systemd "Manage services" b
- name: $1
	systemd:
		# masked: # Whether the unit should be masked or not, a masked unit is impossible to start.
		# state: reloaded|restarted|started|stopped
		# no_block: no
		# name: # Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service).
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# daemon_reload: no
		# user: no
$0
endsnippet

snippet cron "Manage cron.d and crontab entries" b
- name: $1
	cron:
		# cron_file: # If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens. To use the C(cron_file) parameter you must specify the C(user) as well.
		# month: *
		# disabled: no
		# job: # The command to execute or, if env is set, the value of environment variable. The command should not contain line breaks. Required if state=present.
		# special_time: reboot|yearly|annually|monthly|weekly|daily|hourly
		# user: root
		# insertafter: # Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable.
		# insertbefore: # Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable.
		# day: *
		# minute: *
		# name: # Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.
		# hour: *
		# reboot: no
		# state: absent|#present
		# weekday: *
		# env: no
		# backup: no
$0
endsnippet

snippet getent "A wrapper to the unix getent utility" b
- name: $1
	getent:
		database: ${2:# The name of a getent database supported by the target system (passwd, group, hosts, etc).}
		# fail_key: yes
		# split: # Character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database.
		# key: 
$0
endsnippet

snippet modprobe "Load or unload kernel modules" b
- name: $1
	modprobe:
		name: ${2:# Name of kernel module to manage.}
		# state: absent|#present
		# params: 
$0
endsnippet

snippet filesystem "Makes a filesystem" b
- name: $1
	filesystem:
		dev: ${2:# Target path to device or image file.}
		fstype: ${3:btrfs|ext2|ext3|ext4|ext4dev|lvm|reiserfs|xfs|vfat}
		# resizefs: no
		# force: no
		# opts: # List of options to be passed to mkfs command.
$0
endsnippet

snippet facter "Runs the discovery program I(facter) on the remote system" b
- name: $1
$0
endsnippet

snippet dconf "Modify and read dconf database" b
- name: $1
	dconf:
		key: ${2:# A dconf key to modify or read from the dconf database.}
		# state: read|#present|absent
		# value: # Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present).
$0
endsnippet

snippet beadm "Manage ZFS boot environments on FreeBSD/Solaris/illumos systems." b
- name: $1
	beadm:
		name: ${2:# ZFS boot environment name.}
		# state: #present|absent|activated|mounted|unmounted
		# force: true|false
		# mountpoint: no
		# snapshot: no
		# options: no
		# description: no
$0
endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld" b
- name: $1
	firewalld:
		state: ${2:enabled|disabled|present|absent}
		# zone: work|drop|internal|external|trusted|home|dmz|public|block
		# service: # Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.
		# masquerade: # The masquerade setting you would like to enable/disable to/from zones within firewalld
		# immediate: no
		# source: # The source/network you would like to add/remove to/from firewalld
		# permanent: # Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9). (NOTE: If this is false, immediate is assumed true.)

		# timeout: 0
		# interface: # The interface you would like to add/remove to/from a zone in firewalld
		# port: # Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.
		# rich_rule: # Rich rule to add/remove to/from firewalld.
$0
endsnippet

snippet at "Schedule the execution of a command or script file via the at command" b
- name: $1
	at:
		count: ${2:# The count of units in the future to execute the command or script file.}
		units: ${3:minutes|hours|days|weeks}
		# state: absent|#present
		# command: # A command to be executed in the future.
		# unique: no
		# script_file: # An existing script file to be executed in the future.
$0
endsnippet

snippet mksysb "Generates AIX mksysb rootvg backups." b
- name: $1
	mksysb:
		name: ${2:# Backup name}
		storage_path: ${3:# Storage path where the mksysb will stored.}
		# exclude_files: yes|#no
		# software_packing: yes|#no
		# use_snapshot: yes|#no
		# create_map_files: yes|#no
		# extended_attrs: #yes|no
		# backup_crypt_files: #yes|no
		# new_image_data: #yes|no
		# exclude_wpar_files: yes|#no
		# backup_dmapi_fs: #yes|no
$0
endsnippet

snippet ufw "Manage firewall with UFW" b
- name: $1
	ufw:
		# comment: # Add a comment to the rule. Requires UFW version >=0.35.
		# direction: in|incoming|out|outgoing|routed
		# from_port: # Source port.
		# to_ip: any
		# to_port: # Destination port.
		# from_ip: any
		# interface: # Specify interface for rule.
		# name: # Use profile located in C(/etc/ufw/applications.d).
		# insert: # Insert the corresponding rule as rule number NUM
		# logging: True|False|low|medium|high|full
		# log: # Log new connections matched to this rule
		# proto: any|tcp|udp|ipv6|esp|ah
		# route: # Apply the rule to routed/forwarded packets.
		# rule: allow|deny|limit|reject
		# state: disabled|enabled|reloaded|reset
		# policy: allow|deny|reject
		# delete: # Delete rule.
$0
endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file" b
- name: $1
	known_hosts:
		name: ${2:# The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.}
		# path: (homedir)+/.ssh/known_hosts
		# state: #present|absent
		# hash_host: no
		# key: # The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(8), section "SSH_KNOWN_HOSTS FILE FORMAT")
$0
endsnippet

snippet solaris_zone "Manage Solaris zones" b
- name: $1
	solaris_zone:
		name: ${2:# Zone name.}
		state: ${3:absent|attached|configured|detached|installed|#present|running|started|stopped}
		# install_options: empty string
		# sparse: no
		# create_options: empty string
		# root_password: # The password hash for the root account. If not specified, the zone's root account will not have a password.
		# timeout: 600
		# path: # The path where the zone will be created. This is required when the zone is created, but not used otherwise.
		# config: empty string
		# attach_options: empty string
$0
endsnippet

snippet nosh "Manage services with nosh" b
- name: $1
	nosh:
		name: ${2:# Name of the service to manage.}
		# state: started|stopped|reset|restarted|reloaded
		# preset: yes|no
		# enabled: yes|no
		# user: yes|#no
$0
endsnippet

snippet authorized_key "Adds or removes an SSH authorized key" b
- name: $1
	authorized_key:
		user: ${2:# The username on the remote host whose authorized_keys file will be modified}
		key: ${3:# The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)}
		# comment: # Change the comment on the public key. Rewriting the comment is useful in cases such as fetching it from GitHub or GitLab.
		# exclusive: yes|#no
		# key_options: # A string of ssh key options to be prepended to the key in the authorized_keys file
		# state: #present|absent
		# path: (homedir)+/.ssh/authorized_keys
		# validate_certs: #yes|no
		# manage_dir: #yes|no
$0
endsnippet

snippet pamd "Manage PAM Modules" b
- name: $1
	pamd:
		control: ${2:# The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.}
		name: ${3:# The name generally refers to the PAM service file to change, for example system-auth.}
		module_path: ${4:# The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		type: ${5:# The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		# new_module_path: # The new module path to be assigned to the new rule.
		# new_type: # The new type to assign to the new rule.
		# state: #updated|before|after|args_present|args_absent|absent
		# new_control: # The new control to assign to the new rule.
		# path: /etc/pam.d/
		# module_arguments: # When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.  Note that module_arguments is a list.  Please see the examples for usage.
$0
endsnippet

snippet aix_lvol "Configure AIX LVM logical volumes" b
- name: $1
	aix_lvol:
		vg: ${2:# The volume group this logical volume is part of.}
		lv: ${3:# The name of the logical volume.}
		# pvs: # Comma separated list of physical volumes e.g. C(hdisk1,hdisk2).
		# lv_type: jfs2
		# copies: 1
		# state: absent|#present
		# policy: #maximum|minimum
		# opts: # Free-form options to be passed to the mklv command.
		# size: # The size of the logical volume with one of the [MGT] units.
$0
endsnippet

snippet svc "Manage daemontools services" b
- name: $1
	svc:
		name: ${2:# Name of the service to manage.}
		# service_dir: /service
		# downed: no
		# enabled: # Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).
		# state: killed|once|reloaded|restarted|started|stopped
		# service_src: # directory where services are defined, the source of symlinks to service_dir.
$0
endsnippet

snippet setup "Gathers facts about remote hosts" b
- name: $1
	setup:
		# filter: *
		# gather_subset: all
		# fact_path: /etc/ansible/facts.d
		# gather_timeout: 10
$0
endsnippet

snippet service_facts "Return service state information as fact data" b
- name: $1
$0
endsnippet

snippet vdo "Module to control VDO" b
- name: $1
	vdo:
		name: ${2:# The name of the VDO volume.}
		state: ${3:present|absent}
		# readcachesize: # Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# ackthreads: # Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# biothreads: # Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# activated: yes|no
		# running: yes|no
		# emulate512: # Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# indexmem: # Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# device: # The full path of the device to use for VDO storage. This is required if "state" is "present".
		# logicalthreads: # Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# blockmapcachesize: # The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# writepolicy: auto|sync|async
		# compression: enabled|disabled
		# deduplication: enabled|disabled
		# physicalthreads: # Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# readcache: enabled|disabled
		# logicalsize: # The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed.
		# growphysical: no
		# indexmode: # Specifies the index mode of the Albireo index.  The default is 'dense', which has a deduplication window of 1 GB of index memory per 1 TB of incoming data, requiring 10 GB of index data on persistent storage. The 'sparse' mode has a deduplication window of 1 GB of index memory per 10 TB of incoming data, but requires 100 GB of index data on persistent storage.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# slabsize: # The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# cputhreads: # Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
$0
endsnippet

snippet openwrt_init "Manage services on OpenWrt." b
- name: $1
	openwrt_init:
		name: ${2:# Name of the service.}
		# pattern: # If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.
		# state: started|stopped|restarted|reloaded
		# enabled: yes|no
$0
endsnippet

snippet capabilities "Manage Linux capabilities" b
- name: $1
	capabilities:
		capability: ${2:# Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))}
		path: ${3:# Specifies the path to the file to be managed.}
		# state: absent|#present
$0
endsnippet

snippet puppet "Runs puppet" b
- name: $1
	puppet:
		# logdest: #stdout|syslog
		# execute: # Execute a specific piece of Puppet code.
		# facter_basename: ansible
		# tags: # A comma-separated list of puppet tags to be used.
		# puppetmaster: # The hostname of the puppetmaster to contact.
		# certname: # The name to use when handling certificates.
		# manifest: # Path to the manifest file to run puppet apply on.
		# environment: # Puppet environment to be used.
		# timeout: 30m
		# facts: # A dict of values to pass in as persistent external facter facts.
		# modulepath: # Path to an alternate location for puppet modules.
$0
endsnippet

snippet runit "Manage runit services" b
- name: $1
	runit:
		name: ${2:# Name of the service to manage.}
		# state: killed|once|reloaded|restarted|started|stopped
		# enabled: # Wheater the service is enabled or not, if disabled it also implies stopped.
		# service_dir: /var/service
		# service_src: /etc/sv
$0
endsnippet

snippet pam_limits "Modify Linux PAM limits" b
- name: $1
	pam_limits:
		domain: ${2:# A username, @groupname, wildcard, uid/gid range.}
		value: ${3:# The value of the limit.}
		limit_item: ${4:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
		limit_type: ${5:hard|soft|-}
		# comment: 
		# use_max: yes|#no
		# dest: /etc/security/limits.conf
		# use_min: yes|#no
		# backup: yes|#no
$0
endsnippet

snippet awall "Manage awall policies" b
- name: $1
	awall:
		# state: #enabled|disabled
		# activate: no
		# name: # A policy name, like C(foo), or multiple policies, like C(foo, bar).
$0
endsnippet

snippet kernel_blacklist "Blacklist kernel modules" b
- name: $1
	kernel_blacklist:
		name: ${2:# Name of kernel module to black- or whitelist.}
		# blacklist_file: # If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).
		# state: absent|#present
$0
endsnippet

snippet parted "Configure block device partitions" b
- name: $1
	parted:
		device: ${2:# T}
		# part_start: 0%
		# part_end: 100%
		# name: # Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).
		# align: none|cylinder|minimal|#optimal
		# number: # The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.
		# label: aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun
		# state: present|absent|#info
		# part_type: #primary|extended|logical
		# flags: # A
		# unit: s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact
$0
endsnippet

snippet lvol "Configure LVM logical volumes" b
- name: $1
	lvol:
		# pvs: # Comma separated list of physical volumes (e.g. /dev/sda,/dev/sdb).
		# force: no
		# vg: # The volume group this logical volume is part of.
		# lv: # The name of the logical volume.
		# resizefs: yes
		# state: absent|#present
		# thinpool: # The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name.
		# snapshot: # The name of the snapshot volume
		# active: yes
		# shrink: yes
		# opts: # Free-form options to be passed to the lvcreate command.
		# size: # The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.
$0
endsnippet

snippet group "Add or remove groups" b
- name: $1
	group:
		name: ${2:# Name of the group to manage.}
		# state: absent|#present
		# gid: # Optional I(GID) to set for the group.
		# system: no
$0
endsnippet

snippet make "Run targets in a Makefile" b
- name: $1
	make:
		chdir: ${2:# cd into this directory before running make}
		# params: none
		# target: none
		# file: none
$0
endsnippet

snippet mount "Control active and configured mount points" b
- name: $1
	mount:
		state: ${2:absent|mounted|present|unmounted}
		path: ${3:# Path to the mount point (e.g. C(/mnt/files)).}
		# src: # Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted).
		# dump: 0
		# passno: 0
		# fstab: /etc/fstab (/etc/vfstab on Solaris)
		# boot: yes
		# fstype: # Filesystem type. Required when I(state) is C(present) or C(mounted).
		# backup: yes|#no
		# opts: # Mount options (see fstab(5), or vfstab(4) on Solaris).
$0
endsnippet

snippet iptables "Modify the systems iptables" b
- name: $1
	iptables:
		# tcp_flags: {}
		# comment: # This specifies a comment that will be added to the rule.
		# log_prefix: # Specifies a log text for the rule. Only make sense with a LOG jump.
		# protocol: # The protocol of the rule or of the packet to check.
		# chain: # Chain to operate on.
		# out_interface: # Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
		# limit_burst: # Specifies the maximum burst before the above limit kicks in.
		# ctstate: [DNAT, ESTABLISHED, INVALID, NEW, RELATED, SNAT, UNTRACKED
		# jump: # This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
		# to_ports: # This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
		# flush: # Flushes the specified table and chain of all rules.
		# table: #filter|nat|mangle|raw|security
		# icmp_type: # This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'
		# to_destination: # This specifies a destination address to use with DNAT.
		# uid_owner: # Specifies the UID or username to use in match by owner rule.
		# set_dscp_mark_class: # This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.
		# destination: # Destination specification.
		# state: absent|#present
		# source: # Source specification.
		# set_dscp_mark: # This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.
		# policy: ACCEPT|DROP|QUEUE|RETURN
		# set_counters: # This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).
		# match: []
		# goto: # This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.
		# fragment: # This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.
		# to_source: # This specifies a source address to use with SNAT.
		# syn: #ignore|match|negate
		# in_interface: # Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
		# source_port: # Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
		# rule_num: # Insert the rule as the given rule number. This works only with action = 'insert'.
		# destination_port: # Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
		# reject_with: # Specifies the error packet type to return while rejecting. It implies "jump: REJECT"
		# limit: # Specifies the maximum average number of matches to allow per second.
		# action: #append|insert
		# ip_version: #ipv4|ipv6
$0
endsnippet

snippet java_cert "Uses keytool to import/remove key from java keystore(cacerts)" b
- name: $1
	java_cert:
		keystore_pass: ${2:# Keystore password.}
		# keystore_create: # Create keystore if it doesn't exist
		# cert_alias: # Imported certificate alias.
		# executable: keytool
		# pkcs12_password: 
		# cert_port: 443
		# pkcs12_alias: 1
		# state: absent|#present
		# pkcs12_path: # Local path to load PKCS12 keystore from.
		# cert_url: # Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate.
		# cert_path: # Local path to load certificate from. One of cert_url or cert_path is required to load certificate.
		# keystore_path: # Path to keystore.
$0
endsnippet

snippet sysctl "Manage entries in sysctl.conf." b
- name: $1
	sysctl:
		name: ${2:# The dot-separated path (aka I(key)) specifying the sysctl variable.}
		# reload: #yes|no
		# state: #present|absent
		# sysctl_set: yes|no
		# ignoreerrors: yes|no
		# sysctl_file: /etc/sysctl.conf
		# value: # Desired value of the sysctl key.
$0
endsnippet

snippet lvg "Configure LVM volume groups" b
- name: $1
	lvg:
		vg: ${2:# The name of the volume group.}
		# vg_options: # Additional options to pass to C(vgcreate) when creating the volume group.
		# pvs: # List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.
		# force: no
		# pesize: 4
		# pv_options: # Additional options to pass to C(pvcreate) when creating the volume group.
		# state: absent|#present
$0
endsnippet

snippet locale_gen "Creates or removes locales" b
- name: $1
	locale_gen:
		name: ${2:# Name and encoding of the locale, such as "en_GB.UTF-8".}
		# state: absent|#present
$0
endsnippet

snippet timezone "Configure timezone setting" b
- name: $1
	timezone:
		# hwclock: # Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS. B(At least one of name and hwclock are required.) I(Only used on Linux.)
		# name: # Name of the timezone for the system clock. Default is to keep current setting. B(At least one of name and hwclock are required.)
$0
endsnippet

snippet seport "Manages SELinux network port type definitions" b
- name: $1
	seport:
		setype: ${2:# SELinux type for the specified port.}
		proto: ${3:tcp|udp}
		state: ${4:absent|#present}
		ports: ${5:# Ports or port ranges, separated by a comma.}
		# reload: yes
$0
endsnippet

snippet alternatives "Manages alternative programs for common commands" b
- name: $1
	alternatives:
		path: ${2:# The path to the real executable that the link should point to.}
		name: ${3:# The generic name of the link.}
		# priority: 50
		# link: # The path to the symbolic link that should point to the real executable.
$0
endsnippet

snippet hostname "Manage hostname" b
- name: $1
	hostname:
		name: ${2:# Name of the host}
$0
endsnippet

snippet seboolean "Toggles SELinux booleans" b
- name: $1
	seboolean:
		state: ${2:# Desired boolean value}
		name: ${3:# Name of the boolean to configure.}
		# persistent: no
$0
endsnippet

snippet ping "Try to connect to host, verify a usable python and return C(pong) on success" b
- name: $1
	ping:
		# data: pong
$0
endsnippet

snippet interfaces_file "Tweak settings in /etc/network/interfaces files" b
- name: $1
	interfaces_file:
		# option: # Name of the option, required for value changes or option remove
		# dest: /etc/network/interfaces
		# selevel: s0
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# iface: # Name of the interface, required for value changes or option remove
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# value: # If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# backup: yes|#no
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy" b
- name: $1
	selinux_permissive:
		domain: ${2:# the domain that will be added or removed from the list of permissive domains}
		permissive: ${3:True|False}
		# no_reload: True|False
		# store: # name of the SELinux policy store to use
$0
endsnippet

snippet add_host "add a host (and alternatively a group) to the ansible-playbook in-memory inventory" b
- name: $1
	add_host:
		name: ${2:# The hostname/ip of the host to add to the inventory, can include a colon and a port number.}
		# groups: # The groups to add the hostname to, comma separated.
$0
endsnippet

snippet group_by "Create Ansible groups based on facts" b
- name: $1
	group_by:
		key: ${2:# The variables whose values will be used as groups}
		# parents: all
$0
endsnippet

snippet webfaction_site "Add or remove a website on a Webfaction host" b
- name: $1
	webfaction_site:
		name: ${2:# The name of the website}
		host: ${3:# The webfaction host on which the site should be created.}
		login_password: ${4:# The webfaction password to use}
		login_name: ${5:# The webfaction account to use}
		# subdomains: # A list of subdomains associated with this site.
		# state: #present|absent
		# https: false
		# site_apps: # A mapping of URLs to apps
$0
endsnippet

snippet webfaction_domain "Add or remove domains and subdomains on Webfaction" b
- name: $1
	webfaction_domain:
		login_name: ${2:# The webfaction account to use}
		name: ${3:# The name of the domain}
		login_password: ${4:# The webfaction password to use}
		# state: #present|absent
		# subdomains: # Any subdomains to create.
$0
endsnippet

snippet webfaction_db "Add or remove a database on Webfaction" b
- name: $1
	webfaction_db:
		name: ${2:# The name of the database}
		login_password: ${3:# The webfaction password to use}
		type: ${4:mysql|postgresql}
		login_name: ${5:# The webfaction account to use}
		# machine: # The machine name to use (optional for accounts with only one machine)
		# state: #present|absent
		# password: # The password for the new database user.
$0
endsnippet

snippet webfaction_mailbox "Add or remove mailboxes on Webfaction" b
- name: $1
	webfaction_mailbox:
		mailbox_password: ${2:# The password for the mailbox}
		login_name: ${3:# The webfaction account to use}
		mailbox_name: ${4:# The name of the mailbox}
		login_password: ${5:# The webfaction password to use}
		# state: #present|absent
$0
endsnippet

snippet webfaction_app "Add or remove applications on a Webfaction host" b
- name: $1
	webfaction_app:
		name: ${2:# The name of the application}
		login_password: ${3:# The webfaction password to use}
		type: ${4:# The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list.}
		login_name: ${5:# The webfaction account to use}
		# port_open: no
		# machine: # The machine name to use (optional for accounts with only one machine)
		# state: #present|absent
		# autostart: no
		# extra_info: # Any extra parameters required by the app
$0
endsnippet

snippet serverless "Manages a Serverless Framework project" b
- name: $1
	serverless:
		service_path: ${2:# The path to the root of the Serverless Service to be operated on.}
		# functions: []
		# deploy: yes
		# serverless_bin_path: # The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless
		# region: us-east-1
		# stage: # The name of the serverless framework project stage to deploy to. This uses the serverless framework default "dev".
		# state: #present|absent
$0
endsnippet

snippet rhevm "RHEV/oVirt automation" b
- name: $1
	rhevm:
		# vmhost: # The host you wish your VM to run on.
		# vmmem: 1
		# cd_drive: # The CD you wish to have mounted on the VM when I(state = 'CD').
		# image: # The template to use for the VM.
		# cpu_share: 0
		# insecure_api: no
		# cluster: # The rhev/ovirt cluster in which you want you VM to start.
		# user: admin@internal
		# port: 443
		# vm_ha: yes
		# disks: # This option uses complex arguments and is a list of disks with the options name, size and domain.
		# datacenter: Default
		# name: # The name of the VM.
		# ifaces: # This option uses complex arguments and is a list of interfaces with the options name and vlan.
		# server: 127.0.0.1
		# state: ping|#present|absent|up|down|restarted|cd|info
		# osver: rhel_6x64
		# mempol: 1
		# timeout: # The timeout you wish to define for power actions.
		# del_prot: yes
		# boot_order: [u'network', u'hd']
		# type: #server|desktop|host
		# vmcpu: 2
$0
endsnippet

snippet terraform "Manages a Terraform deployment (and plans)" b
- name: $1
	terraform:
		project_path: ${2:# The path to the root of the Terraform directory with the vars.tf/main.tf/etc to use.}
		# variables_file: # The path to a variables file for Terraform to fill into the TF configurations.
		# lock_timeout: # How long to maintain the lock on the statefile, if you use a service that accepts locks (such as S3+DynamoDB).
		# lock: # Enable statefile locking, if you use a service that accepts locks (such as S3+DynamoDB) to store your statefile.
		# variables: # A group of key-values to override template variables or those in variables files.
		# state: planned|#present|absent
		# plan_file: # The path to an existing Terraform plan file to apply. If this is not specified, Ansible will build a new TF plan and execute it.
		# state_file: # The path to an existing Terraform state file to use when building plan. If this is not specified, the default `terraform.tfstate` will be used.
		# force_init: no
		# binary_path: # The path of a terraform binary to use, relative to the 'service_path' unless you supply an absolute path.
		# targets: # A list of specific resources to target in this plan/application. The resources selected here will also auto-include any dependencies.
$0
endsnippet

snippet virt "Manages virtual machines supported by libvirt" b
- name: $1
	virt:
		name: ${2:# name of the guest VM being managed. Note that VM must be previously defined with xml.}
		# xml: # XML document used with the define command.
		# state: destroyed|paused|running|shutdown
		# command: create|define|destroy|freemem|get_xml|info|list_vms|nodeinfo|pause|shutdown|start|status|stop|undefine|unpause|virttype
		# autostart: # start VM at host startup.
		# uri: qemu:///system
$0
endsnippet

snippet ovirt "oVirt/RHEV platform management" b
- name: $1
	ovirt:
		user: ${2:# The user to authenticate with.}
		password: ${3:# Password of the user to authenticate with.}
		url: ${4:# The url of the oVirt instance.}
		instance_name: ${5:# The name of the instance to use.}
		# instance_mem: # The instance's amount of memory in MB.
		# instance_cores: 1
		# instance_cpus: 1
		# image: # The template to use for the instance.
		# instance_hostname: # Define the instance's Hostname.
		# instance_disksize: # Size of the instance's disk in GB.
		# instance_nic: # The name of the network interface in oVirt/RHEV.
		# instance_network: rhevm
		# instance_type: desktop|#server|high_performance
		# sdomain: # The Storage Domain where you want to create the instance's disk on.
		# instance_os: # Type of Operating System.
		# instance_ip: # Define the instance's IP.
		# zone: # Deploy the image to this oVirt cluster.
		# disk_alloc: preallocated|#thin
		# region: # The oVirt/RHEV datacenter where you want to deploy to.
		# instance_dns: # Define the instance's Primary DNS server.
		# instance_netmask: # Define the instance's Netmask.
		# state: absent|#present|restarted|shutdown|started
		# instance_key: # Define the instance's Authorized key.
		# instance_domain: # Define the instance's Domain.
		# instance_rootpw: # Define the instance's Root password.
		# resource_type: new|template
		# disk_int: ide|#virtio
$0
endsnippet

snippet proxmox "management of instances in Proxmox VE cluster" b
- name: $1
	proxmox:
		api_host: ${2:# the host of the Proxmox VE cluster}
		api_user: ${3:# the user to authenticate with}
		# node: # Proxmox VE node, when new VM will be created
		# force: no
		# cpuunits: 1000
		# vmid: # the instance id
		# api_password: # the password to authenticate with
		# cpus: 1
		# ostemplate: # the template for VM creating
		# unprivileged: no
		# disk: 3
		# ip_address: # specifies the address the container will be assigned
		# pool: # Proxmox VE resource pool
		# password: # the instance root password
		# searchdomain: # sets DNS search domain for a container
		# netif: # specifies network interfaces for the container. As a hash/dictionary defining interfaces.
		# validate_certs: no
		# hostname: # the instance hostname
		# storage: local
		# state: #present|started|absent|stopped|restarted
		# swap: 0
		# timeout: 30
		# memory: 512
		# mounts: # specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points
		# cores: 1
		# nameserver: # sets DNS server IP address for a container
		# pubkey: # Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions
		# onboot: no
$0
endsnippet

snippet proxmox_template "management of OS templates in Proxmox VE cluster" b
- name: $1
	proxmox_template:
		node: ${2:# Proxmox VE node, when you will operate with template}
		api_host: ${3:# the host of the Proxmox VE cluster}
		api_user: ${4:# the user to authenticate with}
		# src: # path to uploaded file
		# force: no
		# api_password: # the password to authenticate with
		# storage: local
		# state: #present|absent
		# content_type: #vztmpl|iso
		# timeout: 30
		# validate_certs: no
		# template: # the template name
$0
endsnippet

snippet virt_net "Manage libvirt network configuration" b
- name: $1
	virt_net:
		name: ${2:# name of the network being managed. Note that network must be previously defined with xml.}
		# xml: # XML document used with the define command.
		# state: active|inactive|present|absent
		# command: define|create|start|stop|destroy|undefine|get_xml|list_nets|facts|info|status|modify
		# autostart: yes|no
		# uri: qemu:///system
$0
endsnippet

snippet xenserver_facts "get facts reported on xenserver" b
- name: $1
	xenserver_facts:
$0
endsnippet

snippet helm "Manages Kubernetes packages with the Helm package manager" b
- name: $1
	helm:
		# disable_hooks: no
		# name: # Release name to manage
		# namespace: default
		# chart: {}
		# state: absent|purged|present
		# values: {}
		# host: localhost
		# port: 44134
$0
endsnippet

snippet virt_pool "Manage libvirt storage pools" b
- name: $1
	virt_pool:
		# xml: # XML document used with the define command.
		# state: active|inactive|present|absent|undefined|deleted
		# command: define|build|create|start|stop|destroy|delete|undefine|get_xml|list_pools|facts|info|status
		# name: # name of the storage pool being managed. Note that pool must be previously defined with xml.
		# autostart: yes|no
		# uri: qemu:///system
		# mode: new|repair|resize|no_overwrite|overwrite|normal|zeroed
$0
endsnippet

snippet proxmox_kvm "Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster." b
- name: $1
	proxmox_kvm:
		api_host: ${2:# Specify the target host of the Proxmox VE cluster.}
		api_user: ${3:# Specify the user to authenticate with.}
		# revert: # Revert a pending change.
		# boot: cnd
		# migrate_speed: # Sets maximum speed (in MB/s) for migrations.
		# vga: #std|cirrus|vmware|qxl|serial0|serial1|serial2|serial3|qxl2|qxl3|qxl4
		# keyboard: # Sets the keyboard layout for VNC server.
		# watchdog: # Creates a virtual hardware watchdog device.
		# sockets: 1
		# digest: # Specify if to prevent changes if current configuration file has different SHA1 digest.
		# tablet: yes|#no
		# bios: seabios|ovmf
		# hostpci: # Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').
		# autostart: yes|#no
		# memory: 512
		# migrate_downtime: # Sets maximum tolerated downtime (in seconds) for migrations.
		# localtime: yes|no
		# virtio: # A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').
		# format: cloop|cow|qcow|#qcow2|qed|raw|vmdk
		# snapname: # The name of the snapshot. Used only with clone.
		# hotplug: # Selectively enable hotplug features.
		# name: # Specifies the VM name. Only used on the configuration web interface.
		# target: # Target node. Only allowed if the original VM is on shared storage.
		# vmid: # Specifies the VM ID. Instead use I(name) parameter.
		# bootdisk: # Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)
		# vcpus: # Sets number of hotplugged vcpus.
		# newid: # VMID for the clone. Used only with clone.
		# timeout: 30
		# skiplock: # Ignore locks
		# validate_certs: yes|#no
		# onboot: #yes|no
		# delete: # Specify a list of settings you want to delete.
		# force: yes|no
		# lock: migrate|backup|snapshot|rollback
		# startup: # Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).
		# agent: yes|no
		# freeze: yes|no
		# serial: # A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').
		# startdate: # Sets the initial date of the real time clock.
		# balloon: 0
		# cpuunits: 1000
		# storage: # Target storage for full clone.
		# reboot: yes|no
		# shares: # Rets amount of memory shares for auto-ballooning. (0 - 50000).
		# machine: # Specifies the Qemu machine type.
		# sata: # A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').
		# state: #present|started|absent|stopped|restarted|current
		# template: yes|#no
		# net: # A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').
		# acpi: #yes|no
		# node: # Proxmox VE node, where the new VM will be created.
		# full: yes|no
		# description: # Specify the description for the VM. Only used on the configuration web interface.
		# scsihw: lsi|lsi53c810|virtio-scsi-pci|virtio-scsi-single|megasas|pvscsi
		# clone: # Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone.
		# args: -serial unix:/var/run/qemu-server/VMID.serial,server,nowait
		# api_password: # Specify the password to authenticate with.
		# tdf: yes|no
		# update: yes|#no
		# kvm: #yes|no
		# ostype: other|wxp|w2k|w2k3|w2k8|wvista|win7|win8|l24|#l26|solaris
		# protection: yes|no
		# numa: # A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').
		# parallel: # A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').
		# pool: # Add the new VM to the specified pool.
		# cpulimit: # Specify if CPU usage will be limited. Value 0 indicates no CPU limit.
		# hugepages: any|2|1024
		# smbios: # Specifies SMBIOS type 1 fields.
		# cores: 1
		# scsi: # A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').
		# ide: # A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').
		# cpu: kvm64
$0
endsnippet

snippet os_client_config "Get OpenStack Client config" b
- name: $1
	os_client_config:
		# clouds: []
$0
endsnippet

snippet os_nova_flavor "Manage OpenStack compute flavors" b
- name: $1
	os_nova_flavor:
		name: ${2:# Flavor name.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# ram: # Amount of memory, in MB.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# disk: # Size of local disk, in GB.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# flavorid: auto
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# ephemeral: 0
		# vcpus: # Number of virtual CPUs.
		# state: #present|absent
		# swap: 0
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# extra_specs: # Metadata dictionary
		# key: # A path to a client key to use as part of the SSL transaction.
		# rxtx_factor: 1.0
		# interface: #public|internal|admin
		# is_public: yes
		# wait: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
$0
endsnippet

snippet os_security_group_rule "Add/Delete rule from an existing security group" b
- name: $1
	os_security_group_rule:
		security_group: ${2:# Name or ID of the security group}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# protocol: tcp|udp|icmp|112|#None
		# availability_zone: # Ignored. Present for backwards compatibility
		# interface: #public|internal|admin
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# state: #present|absent
		# port_range_min: # Starting port
		# direction: egress|#ingress
		# region_name: # Name of the region.
		# port_range_max: # Ending port
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# remote_ip_prefix: # Source IP address(es) in CIDR notation (exclusive with remote_group)
		# remote_group: # Name or ID of the Security group to link (exclusive with remote_ip_prefix)
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# ethertype: #IPv4|IPv6
$0
endsnippet

snippet os_stack "Add/Remove Heat Stack" b
- name: $1
	os_stack:
		name: ${2:# Name of the stack that should be created, name could be char and digit, no space}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# key: # A path to a client key to use as part of the SSL transaction.
		# rollback: no
		# parameters: # Dictionary of parameters for the stack creation
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# environment: # List of environment files that should be used for the stack creation
		# interface: #public|internal|admin
		# state: #present|absent
		# tag: # Tag for the stack that should be created, name could be char and digit, no space
		# region_name: # Name of the region.
		# timeout: 3600
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# template: # Path of the template file to use for the stack creation
$0
endsnippet

snippet os_subnets_facts "Retrieve facts about one or more OpenStack subnets." b
- name: $1
	os_subnets_facts:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# subnet: # Name or ID of the subnet
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_group "Manage OpenStack Identity Groups" b
- name: $1
	os_group:
		name: ${2:# Group name}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# description: # Group description
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# domain_id: # Domain id to create the group in if the cloud supports domains.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_router "Create or delete routers from OpenStack" b
- name: $1
	os_router:
		name: ${2:# Name to be give to the router}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# key: # A path to a client key to use as part of the SSL transaction.
		# enable_snat: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# network: # Unique name or ID of the external gateway network.
		# region_name: # Name of the region.
		# admin_state_up: yes
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# interfaces: # List of subnets to attach to the router internal interface. Default gateway associated with the subnet will be automatically attached with the router's internal interface. In order to provide an ip address different from the default gateway,parameters are passed as dictionary with keys as network name or ID(net), subnet name or ID (subnet) and the IP of port (portip) from the network. User defined portip is often required when a multiple router need to be connected to a single subnet for which the default gateway has been already used.
		# availability_zone: # Ignored. Present for backwards compatibility
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# project: # Unique name or ID of the project.
		# interface: #public|internal|admin
		# state: #present|absent
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# external_fixed_ips: # The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.
$0
endsnippet

snippet os_project_access "Manage OpenStack compute flavors acceess" b
- name: $1
	os_project_access:
		target_project_id: ${2:# Project id.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# resource_name: # The resource name (eg. tiny).
		# region_name: # Name of the region.
		# availability_zone: # The availability zone of the resource.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# resource_type: # The resource type (eg. nova_flavor, cinder_volume_type).
		# wait: yes
$0
endsnippet

snippet os_image_facts "Retrieve facts about an image within OpenStack." b
- name: $1
	os_image_facts:
		image: ${2:# Name or ID of the image}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# image: # Image the server should be rebuilt with
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# action: stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild
$0
endsnippet

snippet os_project_facts "Retrieve facts about one or more OpenStack projects" b
- name: $1
	os_project_facts:
		name: ${2:# Name or ID of the project}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# domain: # Name or ID of the domain containing the project if the cloud supports domains
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_server_facts "Retrieve facts about one or more compute instances" b
- name: $1
	os_server_facts:
		# detailed: no
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# server: # restrict results to servers with names or UUID matching this glob expression (e.g., C<web*>).
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_server_volume "Attach/Detach Volumes from OpenStack VM's" b
- name: $1
	os_server_volume:
		server: ${2:# Name or ID of server you want to attach a volume to}
		volume: ${3:# Name or id of volume you want to attach to a server}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# key: # A path to a client key to use as part of the SSL transaction.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# state: #present|absent
		# timeout: 180
		# device: # Device you want to attach. Defaults to auto finding a device name.
		# interface: #public|internal|admin
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_port_facts "Retrieve facts about ports within OpenStack." b
- name: $1
	os_port_facts:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# port: # Unique name or ID of a port.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_image "Add/Delete images from OpenStack Cloud" b
- name: $1
	os_image:
		name: ${2:# Name that has to be given to the image}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# kernel: # The name of an existing kernel image that will be associated with this image
		# availability_zone: # Ignored. Present for backwards compatibility
		# container_format: bare
		# min_ram: # The minimum ram (in MB) required to boot this image
		# min_disk: # The minimum disk space (in GB) required to boot this image
		# owner: # The owner of the image
		# id: # The Id of the image
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# disk_format: qcow2
		# filename: # The path to the file which has to be uploaded
		# state: #present|absent
		# ramdisk: # The name of an existing ramdisk image that will be associated with this image
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# is_public: yes
		# properties: {}
		# wait: yes
		# checksum: # The checksum of the image
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# interface: #public|internal|admin
$0
endsnippet

snippet os_user_group "Associate OpenStack Identity users and groups" b
- name: $1
	os_user_group:
		group: ${2:# Name or id for the group.}
		user: ${3:# Name or id for the user}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_nova_host_aggregate "Manage OpenStack host aggregates" b
- name: $1
	os_nova_host_aggregate:
		name: ${2:# N}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # A
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# hosts: # L
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# metadata: # M
$0
endsnippet

snippet os_volume "Create/Delete Cinder Volumes" b
- name: $1
	os_volume:
		display_name: ${2:# Name of volume}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# image: # Image name or id for boot from volume
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# snapshot_id: # Volume snapshot id to create from
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# size: # Size of volume in GB. This parameter is required when the I(state) parameter is 'present'.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# display_description: # String describing the volume
		# state: #present|absent
		# scheduler_hints: # Scheduler hints passed to volume API in form of dict
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# volume: # Volume name or id to create from
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# wait: yes
		# volume_type: # Volume type for volume
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
$0
endsnippet

snippet os_zone "Manage OpenStack DNS zones" b
- name: $1
	os_zone:
		name: ${2:# Zone name}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# masters: # Master nameservers (only applies if zone_type is secondary)
		# description: # Zone description
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# state: #present|absent
		# timeout: 180
		# ttl: # TTL (Time To Live) value in seconds
		# zone_type: primary|secondary
		# wait: yes
		# interface: #public|internal|admin
		# email: # Email of the zone owner (only applies if zone_type is primary)
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_keystone_service "Manage OpenStack Identity services" b
- name: $1
	os_keystone_service:
		name: ${2:# Name of the service}
		service_type: ${3:# The type of service}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# description: # Description of the service
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# enabled: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# state: #present|absent
		# timeout: 180
		# wait: yes
$0
endsnippet

snippet os_keystone_endpoint "Manage OpenStack Identity service endpoints" b
- name: $1
	os_keystone_endpoint:
		interface: ${2:admin|#public|internal}
		service: ${3:# Name or id of the service.}
		url: ${4:# URL of the service.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# region: # Region that the service belongs to. Note that I(region_name) is used for authentication.
		# enabled: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# state: #present|absent
		# timeout: 180
$0
endsnippet

snippet os_networks_facts "Retrieve facts about one or more OpenStack networks." b
- name: $1
	os_networks_facts:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# name: # Name or ID of the Network
$0
endsnippet

snippet os_project "Manage OpenStack Projects" b
- name: $1
	os_project:
		name: ${2:# Name for the project}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# domain_id: # Domain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# description: # Description for the project
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# enabled: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# state: #present|absent
		# timeout: 180
		# wait: yes
$0
endsnippet

snippet os_recordset "Manage OpenStack DNS recordsets" b
- name: $1
	os_recordset:
		name: ${2:# Name of the recordset}
		zone: ${3:# Zone managing the recordset}
		records: ${4:# List of recordset definitions}
		recordset_type: ${5:# Recordset type}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# state: #present|absent
		# region_name: # Name of the region.
		# timeout: 180
		# ttl: # TTL (Time To Live) value in seconds
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# interface: #public|internal|admin
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# description: # Description of the recordset
$0
endsnippet

snippet os_flavor_facts "Retrieve facts about one or more flavors" b
- name: $1
	os_flavor_facts:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# ram: no
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# name: # A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# ephemeral: no
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# vcpus: no
		# limit: # Limits the number of flavors returned. All matching flavors are returned by default.
		# timeout: 180
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# image: # Image the server should be rebuilt with
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# action: stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild
$0
endsnippet

snippet os_ironic "Create/Delete Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic:
		nics: ${2:# A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"}
		driver: ${3:# The name of the Ironic Driver to use with this node.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# uuid: # globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
		# state: #present|absent
		# chassis_uuid: # Associate the node with a pre-defined chassis.
		# skip_update_of_driver_password: no
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# properties: # Definition of the physical characteristics of this server, used for scheduling purposes
		# wait: yes
		# name: # unique name identifier to be given to the resource.
		# driver_info: # Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
$0
endsnippet

snippet os_ironic_node "Activate/Deactivate Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic_node:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# maintenance_reason: # A string expression regarding the reason a node is in a maintenance mode.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# uuid: # globally unique identifier (UUID) to be given to the resource.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
		# state: #present|absent
		# maintenance: no
		# config_drive: # A configdrive file or HTTP(S) URL that will be passed along to the node.
		# region_name: # Name of the region.
		# power: #present|absent
		# deploy: true|false
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# wait: no
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# instance_info: # Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.
$0
endsnippet

snippet os_security_group "Add/Delete security groups from an OpenStack cloud." b
- name: $1
	os_security_group:
		name: ${2:# Name that has to be given to the security group. This module requires that security group names be unique.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# description: # Long description of the purpose of the security group
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_keystone_role "Manage OpenStack Identity Roles" b
- name: $1
	os_keystone_role:
		name: ${2:# Role Name}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# region_name: # Name of the region.
$0
endsnippet

snippet os_floating_ip "Add/Remove floating IP from an instance" b
- name: $1
	os_floating_ip:
		server: ${2:# The name or ID of the instance to which the IP address should be assigned.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# key: # A path to a client key to use as part of the SSL transaction.
		# fixed_address: # To which fixed IP of server the floating IP address should be attached to.
		# network: # The name or ID of a neutron external network or a nova pool name.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# reuse: no
		# nat_destination: # The name or id of a neutron private network that the fixed IP to attach floating IP is on
		# purge: no
		# interface: #public|internal|admin
		# state: #present|absent
		# floating_ip_address: # A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# timeout: 60
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: no
$0
endsnippet

snippet os_user "Manage OpenStack Identity Users" b
- name: $1
	os_user:
		name: ${2:# Username for the user}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# update_password: #always|on_create
		# availability_zone: # Ignored. Present for backwards compatibility
		# domain: # Domain to create the user in if the cloud supports domains
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# region_name: # Name of the region.
		# default_project: # Project name or ID that the user should be associated with by default
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# state: #present|absent
		# email: # Email address for the user
		# description: # Description about the user
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# password: # Password for the user
		# wait: yes
		# enabled: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
$0
endsnippet

snippet os_user_role "Associate OpenStack Identity users and roles" b
- name: $1
	os_user_role:
		role: ${2:# Name or ID for the role.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# domain: # ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# user: # Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# group: # Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# project: # Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.
		# state: #present|absent
		# timeout: 180
$0
endsnippet

snippet os_keystone_domain "Manage OpenStack Identity Domains" b
- name: $1
	os_keystone_domain:
		name: ${2:# Name that has to be given to the instance}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# description: # Description of the domain
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# enabled: yes
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_object "Create or Delete objects and containers from OpenStack" b
- name: $1
	os_object:
		container: ${2:# The name of the container in which to create the object}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
		# name: # Name to be give to the object. If omitted, operations will be on the entire container
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filename: # Path to local file to be uploaded.
		# state: #present|absent
		# timeout: 180
		# container_access: #private|public
$0
endsnippet

snippet os_user_facts "Retrieve facts about one or more OpenStack users" b
- name: $1
	os_user_facts:
		name: ${2:# Name or ID of the user}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# domain: # Name or ID of the domain containing the user if the cloud supports domains
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet os_keystone_domain_facts "Retrieve facts about one or more OpenStack domains" b
- name: $1
	os_keystone_domain_facts:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# name: # Name or ID of the domain
$0
endsnippet

snippet os_network "Creates/removes networks from OpenStack" b
- name: $1
	os_network:
		name: ${2:# Name to be assigned to the network.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# availability_zone: # Ignored. Present for backwards compatibility
		# provider_physical_network: # The physical network where this network object is implemented.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# state: #present|absent
		# shared: no
		# region_name: # Name of the region.
		# provider_network_type: # The type of physical network that maps to this network resource.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# external: no
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# wait: yes
		# admin_state_up: yes
		# project: # Project name or ID containing the network (name admin-only)
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# provider_segmentation_id: # An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.
		# timeout: 180
$0
endsnippet

snippet os_port "Add/Update/Delete ports from an OpenStack cloud." b
- name: $1
	os_port:
		network: ${2:# Network ID or name this port belongs to.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# allowed_address_pairs: # Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...
		# availability_zone: # Ignored. Present for backwards compatibility
		# extra_dhcp_opts: # Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...
		# interface: #public|internal|admin
		# device_owner: # The ID of the entity that uses this port.
		# fixed_ips: # Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.
		# security_groups: # Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# state: #present|absent
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# mac_address: # MAC address of this port.
		# wait: yes
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# device_id: # Device ID of device using this port.
		# name: # Name that has to be given to the port.
		# admin_state_up: # Sets admin state.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# no_security_groups: no
		# timeout: 180
$0
endsnippet

snippet os_quota "Manage OpenStack Quotas" b
- name: $1
	os_quota:
		name: ${2:# Name of the OpenStack Project to manage.}
		# snapshots_lvm: # N
		# server_groups: # N
		# availability_zone: # Ignored. Present for backwards compatibility
		# ram: # M
		# snapshots: # N
		# instances: # M
		# backups: # M
		# fixed_ips: # N
		# port: # N
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# subnet: # N
		# per_volume_gigabytes: # M
		# network: # N
		# floatingip: # N
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# volumes_lvm: # N
		# floating_ips: # N
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# properties: # N
		# security_group_rule: # N
		# state: present
		# injected_files: # N
		# gigabytes_lvm: # M
		# wait: yes
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# injected_path_size: # M
		# region_name: # Name of the region.
		# gigabytes: # M
		# backup_gigabytes: # M
		# subnetpool: # N
		# key_pairs: # N
		# interface: #public|internal|admin
		# injected_file_size: # M
		# key: # A path to a client key to use as part of the SSL transaction.
		# cores: # M
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# rbac_policy: # N
		# pool: # N
		# server_group_members: # N
		# timeout: 180
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# volumes: # N
		# security_group: # N
		# router: # N
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# loadbalancer: # N
$0
endsnippet

snippet os_auth "Retrieve an auth token" b
- name: $1
	os_auth:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# wait: yes
$0
endsnippet

snippet os_ironic_inspect "Explicitly triggers baremetal node introspection in ironic." b
- name: $1
	os_ironic_inspect:
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# interface: #public|internal|admin
		# mac: # unique mac address that is used to attempt to identify the host.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# name: # unique name identifier to identify the host in Ironic.
		# uuid: # globally unique identifier (UUID) to identify the host.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.
		# timeout: 1200
		# wait: yes
$0
endsnippet

snippet os_subnet "Add/Remove subnet to an OpenStack network" b
- name: $1
	os_subnet:
		name: ${2:# The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# no_gateway_ip: no
		# use_default_subnetpool: no
		# availability_zone: # Ignored. Present for backwards compatibility
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# ipv6_ra_mode: dhcpv6-stateful|dhcpv6-stateless|slaac
		# host_routes: # A list of host route dictionaries for the subnet.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# ipv6_address_mode: dhcpv6-stateful|dhcpv6-stateless|slaac
		# cidr: # The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.
		# network_name: # Name of the network to which the subnet should be attached
		# allocation_pool_end: # From the subnet pool the last IP that should be assigned to the virtual machines.
		# region_name: # Name of the region.
		# enable_dhcp: yes
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# dns_nameservers: # List of DNS nameservers for this subnet.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# project: # Project name or ID containing the subnet (name admin-only)
		# state: #present|absent
		# allocation_pool_start: # From the subnet pool the starting address from which the IP should be allocated.
		# gateway_ip: # The ip that would be assigned to the gateway for this subnet
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# timeout: 180
		# ip_version: 4
		# wait: yes
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server "Create/Delete Compute Instances from OpenStack" b
- name: $1
	os_server:
		name: ${2:# Name that has to be given to the instance}
		image: ${3:# The name or id of the base image to boot.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# volumes: []
		# availability_zone: # Availability zone in which to create the server.
		# key_name: # The key pair name to be used when creating a instance
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# image_exclude: # Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"
		# boot_volume: # Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.
		# flavor_include: # Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.
		# interface: #public|internal|admin
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# meta: # A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# terminate_volume: no
		# flavor: 1
		# delete_fip: no
		# security_groups: # Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.
		# scheduler_hints: # Arbitrary key/value pairs to the scheduler for custom use
		# boot_from_volume: no
		# userdata: # Opaque blob of data which is made available to the instance
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# network: # Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.
		# region_name: # Name of the region.
		# nics: # A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.
		# floating_ips: # list of valid floating IPs that pre-exist to assign to this node
		# flavor_ram: 1
		# volume_size: # The size of the volume to create in GB if booting from volume based on an image.
		# state: #present|absent
		# auto_ip: yes
		# config_drive: no
		# timeout: 180
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# wait: yes
		# reuse_ips: yes
		# floating_ip_pools: # Name of floating IP pool from which to choose a floating IP
$0
endsnippet

snippet os_keypair "Add/Delete a keypair from OpenStack" b
- name: $1
	os_keypair:
		name: ${2:# Name that has to be given to the key pair}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# public_key: # The public key that would be uploaded to nova and injected into VMs upon creation.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# timeout: 180
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# public_key_file: # Path to local file containing ssh public key. Mutually exclusive with public_key.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# region_name: # Name of the region.
$0
endsnippet

snippet os_server_group "Manage OpenStack server groups" b
- name: $1
	os_server_group:
		name: ${2:# Server group name.}
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# region_name: # Name of the region.
		# availability_zone: # Ignored. Present for backwards compatibility
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# timeout: 180
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
		# state: #present|absent
		# policies: # A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# wait: yes
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
$0
endsnippet

snippet docker_service "Manage docker services and containers." b
- name: $1
	docker_service:
		# files: # List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.
		# project_name: # Provide a project name. If not provided, the project name is taken from the basename of C(project_src).
		# project_src: # Path to a directory containing a docker-compose.yml or docker-compose.yaml file.
		# hostname_check: no
		# recreate: always|never|#smart
		# tls_hostname: localhost
		# docker_host: unix://var/run/docker.sock
		# dependencies: yes
		# remove_images: # Use with state I(absent) to remove the all images or only local images.
		# services: # When C(state) is I(present) run I(docker-compose up) on a subset of services.
		# cert_path: # Path to the client's TLS certificate file.
		# pull: no
		# tls: no
		# definition: # Provide docker-compose yaml describing one or more services, networks and volumes.
		# scale: # When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.
		# nocache: no
		# restarted: no
		# ssl_version: 1.0
		# state: absent|#present
		# api_version: default provided by docker-py
		# remove_volumes: no
		# tls_verify: no
		# stopped: no
		# build: no
		# timeout: 60
		# debug: no
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# key_path: # Path to the client's TLS key file.
$0
endsnippet

snippet docker_image_facts "Inspect docker images" b
- name: $1
	docker_image_facts:
		name: ${2:# An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.}
		# tls: no
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# ssl_version: 1.0
		# tls_hostname: localhost
		# docker_host: unix://var/run/docker.sock
		# tls_verify: no
		# key_path: # Path to the client's TLS key file.
		# timeout: 60
		# cert_path: # Path to the client's TLS certificate file.
		# api_version: default provided by docker-py
$0
endsnippet

snippet docker_image "Manage docker images." b
- name: $1
	docker_image:
		name: ${2:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}
		# archive_path: # Use with state C(present) to archive an image to a .tar file.
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# force: no
		# timeout: 60
		# repository: # Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).
		# tls_hostname: localhost
		# docker_host: unix://var/run/docker.sock
		# tag: latest
		# cert_path: # Path to the client's TLS certificate file.
		# path: # Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.
		# tls: no
		# pull: yes
		# nocache: no
		# container_limits: # A dictionary of limits applied to each container created by the build process.
		# http_timeout: # Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.
		# ssl_version: 1.0
		# load_path: # Use with state C(present) to load an image from a .tar file.
		# use_tls: #False|encrypt|verify
		# state: absent|#present|build
		# tls_verify: no
		# key_path: # Path to the client's TLS key file.
		# buildargs: # Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.
		# push: no
		# rm: yes
		# dockerfile: Dockerfile
		# api_version: default provided by docker-py
$0
endsnippet

snippet docker_secret "Manage docker secrets." b
- name: $1
	docker_secret:
		name: ${2:# The name of the secret.}
		# tls: no
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# force: no
		# labels: # A map of key:value meta data, where both the I(key) and I(value) are expected to be a string.
		# ssl_version: 1.0
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# state: absent|#present
		# tls_verify: no
		# key_path: # Path to the client's TLS key file.
		# timeout: 60
		# cert_path: # Path to the client's TLS certificate file.
		# data: # String. The value of the secret. Required when state is C(present).
		# api_version: default provided by docker-py
$0
endsnippet

snippet docker_login "Log into a Docker registry." b
- name: $1
	docker_login:
		username: ${2:# The username for the registry account}
		password: ${3:# The plaintext password for the registry account}
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# tls_hostname: localhost
		# docker_host: unix://var/run/docker.sock
		# tls_verify: no
		# cert_path: # Path to the client's TLS certificate file.
		# tls: no
		# config_path: ~/.docker/config.json
		# ssl_version: 1.0
		# state: #present|absent
		# key_path: # Path to the client's TLS key file.
		# timeout: 60
		# registry_url: https://index.docker.io/v1/
		# email: # The email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it.
		# api_version: default provided by docker-py
		# reauthorize: yes|no
$0
endsnippet

snippet docker_volume "Manage Docker volumes" b
- name: $1
	docker_volume:
		name: ${2:# Name of the volume to operate on.}
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# force: no
		# labels: # List of labels to set for the volume
		# driver: local
		# tls_hostname: localhost
		# docker_host: unix://var/run/docker.sock
		# driver_options: # Dictionary of volume settings. Consult docker docs for valid options and values: U(https://docs.docker.com/engine/reference/commandline/volume_create/#driver-specific-options)
		# cert_path: # Path to the client's TLS certificate file.
		# tls: no
		# ssl_version: 1.0
		# state: absent|#present
		# tls_verify: no
		# key_path: # Path to the client's TLS key file.
		# timeout: 60
		# api_version: default provided by docker-py
$0
endsnippet

snippet docker_network "Manage Docker networks" b
- name: $1
	docker_network:
		name: ${2:# Name of the network to operate on.}
		# tls: no
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# force: no
		# tls_verify: no
		# ssl_version: 1.0
		# driver: bridge
		# docker_host: unix://var/run/docker.sock
		# ipam_options: # Dictionary of IPAM options.
		# tls_hostname: localhost
		# state: absent|#present
		# driver_options: # Dictionary of network settings. Consult docker docs for valid options and values.
		# connected: # List of container names or container IDs to connect to a network.
		# key_path: # Path to the client's TLS key file.
		# timeout: 60
		# cert_path: # Path to the client's TLS certificate file.
		# ipam_driver: # Specify an IPAM driver.
		# appends: no
		# api_version: default provided by docker-py
$0
endsnippet

snippet docker_container "manage docker containers" b
- name: $1
	docker_container:
		name: ${2:# Assign a name to a new container or match an existing container.}
		# tty: no
		# dns_servers: # List of custom DNS servers.
		# image: # Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.
		# labels: # Dictionary of key value pairs.
		# docker_host: unix://var/run/docker.sock
		# cpuset_cpus: # CPUs in which to allow execution C(1,3) or C(1-3).
		# force_kill: no
		# pid_mode: # Set the PID namespace mode for the container. Currently only supports 'host'.
		# networks: # List of networks the container belongs to.
		# cpu_period: 0
		# detach: yes
		# oom_score_adj: 0
		# state: absent|present|stopped|#started
		# capabilities: # List of capabilities to add to the container.
		# memory_swap: 0
		# mac_address: # Container MAC address (e.g. 92:d0:c6:0a:29:33)
		# volumes_from: # List of container names or Ids to get volumes from.
		# log_options: # Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details.
		# cert_path: # Path to the client's TLS certificate file.
		# recreate: no
		# memory: 0
		# memory_swappiness: 0
		# network_mode: bridge|container:<name|id>|host|none
		# tmpfs: # Mount a tmpfs directory
		# published_ports: # List of ports to publish from the container to the host.
		# restart: no
		# pull: no
		# stop_signal: # Override default signal used to stop the container.
		# devices: # List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>
		# uts: # Set the UTS namespace mode for the container.
		# tls_verify: no
		# blkio_weight: # Block IO (relative weight), between 10 and 1000.
		# timeout: 60
		# stop_timeout: # Number of seconds to wait for the container to stop before sending SIGKILL.
		# ulimits: # List of ulimit options. A ulimit is specified as C(nofile:262144:262144)
		# interactive: no
		# links: # List of name aliases for linked containers in the format C(container_name:alias)
		# domainname: # Container domainname.
		# ssl_version: 1.0
		# command: # Command to execute when the container starts. A command may be either a string or a list. Prior to version 2.4, strings were split on commas.
		# paused: no
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# dns_search_domains: # List of custom DNS search domains.
		# security_opts: # List of security options in the form of C("label:user:User")
		# env_file: # Path to a file containing environment variables I(FOO=BAR).
		# cpu_quota: 0
		# read_only: no
		# cpuset_mems: # Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)
		# hostname: # Container hostname.
		# working_dir: # Path to the working directory.
		# cleanup: no
		# entrypoint: # Command that overwrites the default ENTRYPOINT of the image.
		# key_path: # Path to the client's TLS key file.
		# env: # Dictionary of key,value pairs.
		# keep_volumes: yes
		# ipc_mode: # Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.
		# privileged: no
		# api_version: default provided by docker-py
		# exposed_ports: # List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.
		# trust_image_content: no
		# auto_remove: no
		# log_driver: none|json-file|syslog|journald|gelf|fluentd|awslogs|splunk
		# oom_killer: no
		# shm_size: # Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes).
		# kill_signal: # Override default signal used to kill a running container.
		# tls_hostname: localhost
		# volume_driver: none
		# user: # Sets the username or UID used and optionally the groupname or GID for the specified command.
		# groups: # List of additional group names and/or IDs that the container process will run as.
		# userns_mode: # User namespace to use
		# purge_networks: no
		# tls: no
		# ignore_image: no
		# restart_policy: always|False|#on-failure|unless-stopped
		# kernel_memory: 0
		# etc_hosts: # Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.
		# sysctls: # Dictionary of key,value pairs.
		# memory_reservation: 0
		# volumes: # List of volumes to mount within the container.
		# cpu_shares: # CPU shares (relative weight).
		# restart_retries: 0
$0
endsnippet

snippet ovh_ip_loadbalancing_backend "Manage OVH IP LoadBalancing backends" b
- name: $1
	ovh_ip_loadbalancing_backend:
		endpoint: ${2:# The endpoint to use ( for instance ovh-eu)}
		name: ${3:# Name of the LoadBalancing internal name (ip-X.X.X.X)}
		application_key: ${4:# The applicationKey to use}
		application_secret: ${5:# The application secret to use}
		consumer_key: ${6:# The consumer key to use}
		backend: ${7:# The IP address of the backend to update / modify / delete}
		# weight: 8
		# probe: #none|http|icmp|oco
		# state: #present|absent
		# timeout: 120
$0
endsnippet

snippet sl_vm "create or cancel a virtual instance in SoftLayer" b
- name: $1
	sl_vm:
		disks: ${2:[25]}
		cpus: ${3:# Count of cpus to be assigned to new virtual instance.}
		memory: ${4:# Amount of memory to be assigned to new virtual instance.}
		# domain: # Domain name to be provided to a virtual instance.
		# tags: # Tag or list of tags to be provided to a virtual instance.
		# instance_id: # Instance Id of the virtual instance to perform action option.
		# dedicated: no
		# private: no
		# image_id: # Image Template to be used for new virtual instance.
		# nic_speed: 10
		# private_vlan: # VLAN by its Id to be assigned to the private NIC.
		# datacenter: # Datacenter for the virtual instance to be deployed.
		# public_vlan: # VLAN by its Id to be assigned to the public NIC.
		# wait: yes
		# hourly: yes
		# ssh_keys: # List of ssh keys by their Id to be assigned to a virtual instance.
		# hostname: # Hostname to be provided to a virtual instance.
		# os_code: # OS Code to be used for new virtual instance.
		# wait_time: 600
		# local_disk: yes
		# state: absent|#present
		# post_uri: # URL of a post provisioning script to be loaded and executed on virtual instance.
$0
endsnippet

snippet ec2_ami "create or destroy an image in ec2" b
- name: $1
	ec2_ami:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# image_location: # The s3 location of an image to use for the AMI.
		# description: # Human-readable string describing the contents and purpose of the AMI.
		# tags: # A dictionary of tags to add to the new image; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# enhanced_networking: # A boolean representing whether enhanced networking with ENA is enabled or not.
		# purge_tags: no
		# launch_permissions: # Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, "all" is the only acceptable value currently.
		# ramdisk_id: # The ID of the RAM disk.
		# image_id: # Image ID to be deregistered.
		# no_reboot: yes|no
		# wait_timeout: 900
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# wait: yes|#no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of the new AMI.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# delete_snapshot: yes|#no
		# billing_products: # A list of valid billing codes. To be used with valid accounts by aws marketplace vendors.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# instance_id: # Instance ID to create the AMI from.
		# kernel_id: # The target kernel id of the image to register.
		# state: absent|#present
		# architecture: # The target architecture of the image to register
		# device_mapping: # List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters).
		# validate_certs: yes
		# virtualization_type: # The virtualization type of the image to register.
		# sriov_net_support: # Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.
		# root_device_name: # The root device name of the image to register.
$0
endsnippet

snippet cloudtrail "manage CloudTrail create, delete, update" b
- name: $1
	cloudtrail:
		name: ${2:# Name for the CloudTrail.}
		state: ${3:present|absent|enabled|disabled}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# enable_log_file_validation: # Specifies whether log file integrity validation is enabled.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# include_global_events: yes
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# is_multi_region_trail: no
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# kms_key_id: # Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. This also has the effect of enabling log file encryption.
		# cloudwatch_logs_log_group_arn: # A full ARN specifying a valid CloudWatch log group to which CloudTrail logs will be delivered. The log group should already exist.
		# s3_bucket_name: # An existing S3 bucket where CloudTrail will deliver log files.
		# cloudwatch_logs_role_arn: # Specifies a full ARN for an IAM role that assigns the proper permissions for CloudTrail to create and write to the log group.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# sns_topic_name: # SNS Topic name to send notifications to when a log file is delivered
		# s3_key_prefix: # S3 Key prefix for delivered log files. A trailing slash is not necessary and will be removed.
		# enable_logging: yes
		# tags: {}
$0
endsnippet

snippet redshift "create, delete, or modify an Amazon Redshift instance" b
- name: $1
	redshift:
		command: ${2:create|facts|delete|modify}
		identifier: ${3:# Redshift cluster identifier.}
		# cluster_parameter_group_name: # name of the cluster parameter group
		# username: # Master database username. Used only when command=create.
		# new_cluster_identifier: # Only used when command=modify.
		# number_of_nodes: # Number of nodes. Only used when cluster_type=multi-node.
		# availability_zone: # availability zone in which to launch cluster
		# encrypted: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# node_type: ds1.xlarge|ds1.8xlarge|ds2.xlarge|ds2.8xlarge|dc1.large|dc1.8xlarge|dc2.large|dc2.8xlarge|dw1.xlarge|dw1.8xlarge|dw2.large|dw2.8xlarge
		# db_name: # Name of the database.
		# publicly_accessible: no
		# skip_final_cluster_snapshot: no
		# password: # Master database password. Used only when command=create.
		# port: # which port the cluster is listining
		# wait: yes|#no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# allow_version_upgrade: yes
		# cluster_type: multi-node|#single-node
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# elastic_ip: # if the cluster has an elastic IP or not
		# cluster_subnet_group_name: # which subnet to place the cluster
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# validate_certs: yes
		# wait_timeout: 300
		# cluster_security_groups: # in which security group the cluster belongs
		# automated_snapshot_retention_period: # period when the snapshot take place
		# cluster_version: 1.0
		# final_cluster_snapshot_identifier: # identifier of the final snapshot to be created before deleting the cluster. If this parameter is provided, final_cluster_snapshot_identifier must be false. Used only when command=delete.
		# preferred_maintenance_window: # maintenance window
		# vpc_security_group_ids: # VPC security group
$0
endsnippet

snippet elasticache_facts "Retrieve facts for AWS Elasticache clusters" b
- name: $1
	elasticache_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of an Elasticache cluster
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_ssm_parameter_store "Manage key-value pairs in aws parameter store." b
- name: $1
	aws_ssm_parameter_store:
		name: ${2:# parameter key name.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# decryption: yes
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # region.
		# string_type: #String|StringList|SecureString
		# value: # Parameter value.
		# state: #present|absent
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# key_id: aws/ssm (this key is automatically generated at the first parameter created).
		# validate_certs: yes
		# overwrite: yes
		# description: # parameter key desciption.
$0
endsnippet

snippet ec2_ami_facts "Gather facts about ec2 AMIs" b
- name: $1
	ec2_ami_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# owners: # Filter the images by the owner. Valid options are an AWS account ID, self,
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# executable_users: # Filter images by users with explicit launch permissions. Valid options are an AWS account ID, self, or all (public AMIs).
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# image_ids: # O
		# describe_image_attributes: yes|no
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet elb_target_group_facts "Gather facts about ELB target groups in AWS" b
- name: $1
	elb_target_group_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# load_balancer_arn: # The Amazon Resource Name (ARN) of the load balancer.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# target_group_arns: # The Amazon Resource Names (ARN) of the target groups.
		# names: # The names of the target groups.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet cloudfront_distribution "create, update and delete aws cloudfront distributions." b
- name: $1
	cloudfront_distribution:
		# comment: # A comment that describes the cloudfront distribution. If not specified, it defaults to a generic message that it has been created with Ansible, and a datetime stamp.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# purge_custom_error_responses: no
		# e_tag: # A unique identifier of a modified or existing distribution. Used in conjunction with I(distribution_id). Is determined automatically if not specified.
		# tags: # Should be input as a dict() of key-value pairs. Note that numeric keys or values must be wrapped in quotes. e.g. "Priority:" '1'
		# purge_tags: yes|#no
		# caller_reference: # A unique identifier for creating and updating cloudfront distributions. Each caller reference must be unique across all distributions. e.g. a caller reference used in a web distribution cannot be reused in a streaming distribution. This parameter can be used instead of I(distribution_id) to reference an existing distribution. If not specified, this defaults to a datetime stamp of the format 'YYYY-MM-DDTHH:MM:SS.ffffff'.
		# default_root_object: # A config element that specifies the path to request when the user requests the origin. e.g. if specified as 'index.html', this maps to www.example.com/index.html when www.example.com is called by the user. This prevents the entire distribution origin from being exposed at the root.
		# alias: # The name of an alias (CNAME) that is used in a distribution. This is used to effectively reference a distribution by its alias as an alias can only be used by one distribution per AWS account. This variable avoids having to provide the I(distribution_id) as well as the I(e_tag), or I(caller_reference) of an existing distribution.
		# wait_timeout: 1800
		# purge_aliases: yes|#no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# default_origin_domain_name: # The domain name to use for an origin if no I(origins) have been specified. Should only be used on a first run of generating a distribution and not on subsequent runs. Should not be used in conjunction with I(distribution_id), I(caller_reference) or I(alias).
		# ipv6_enabled: yes|#no
		# purge_cache_behaviors: no
		# aliases: # A I(list[]) of domain name aliases (CNAMEs) as strings to be used for the distribution. Each alias must be unique across all distribution for the AWS account.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# restrictions: # A config element that is a complex object that describes how a distribution should restrict it's content. The restriction object comprises the following attributes I(geo_restriction) I(restriction_type) I(items[])
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# logging: # A config element that is a complex object that defines logging for the distribution. The logging object comprises the attributes I(enabled) I(include_cookies) I(bucket) I(prefix)
		# http_version: http1.1|http2
		# origins: # A config element that is a I(list[]) of complex origin objects to be specified for the distribution. Used for creating and updating distributions. Each origin item comprises the attributes I(id) I(domain_name) (defaults to default_origin_domain_name if not specified) I(origin_path) (defaults to default_origin_path if not specified) I(custom_headers[]) I(header_name) I(header_value) I(s3_origin_access_identity_enabled) I(custom_origin_config) I(http_port) I(https_port) I(origin_protocol_policy) I(origin_ssl_protocols[]) I(origin_read_timeout) I(origin_keepalive_timeout)
		# web_acl_id: # The id of a Web Application Firewall (WAF) Access Control List (ACL).
		# viewer_certificate: # A config element that is a complex object that specifies the encryption details of the distribution. Comprises the following attributes I(cloudfront_default_certificate) I(iam_certificate_id) I(acm_certificate_arn) I(ssl_support_method) I(minimum_protocol_version) I(certificate) I(certificate_source)
		# price_class: PriceClass_100|PriceClass_200|PriceClass_All
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# purge_origins: no
		# default_cache_behavior: # A config element that is a complex object specifying the default cache behavior of the distribution. If not specified, the I(target_origin_id) is defined as the I(target_origin_id) of the first valid I(cache_behavior) in I(cache_behaviors) with defaults. The default cache behavior comprises the attributes I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[]) I(lambda_function_arn) I(event_type)
		# distribution_id: # The id of the cloudfront distribution. This parameter can be exchanged with I(alias) or I(caller_reference) and is used in conjunction with I(e_tag).
		# state: #present|absent
		# cache_behaviors: # A config element that is a I(list[]) of complex cache behavior objects to be specified for the distribution. The order of the list is preserved across runs unless C(purge_cache_behavior) is enabled. Each cache behavior comprises the attributes I(path_pattern) I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[])
		# custom_error_responses: # A config element that is a I(list[]) of complex custom error responses to be specified for the distribution. This attribute configures custom http error messages returned to the user. Each custom error response object comprises the attributes I(error_code) I(reponse_page_path) I(response_code) I(error_caching_min_ttl)
		# default_origin_path: # The default origin path to specify for an origin if no I(origins) have been specified. Defaults to empty if not specified.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# wait: yes|#no
		# validate_certs: yes
		# enabled: #yes|no
$0
endsnippet

snippet s3_logging "Manage logging facility of an s3 bucket in AWS" b
- name: $1
	s3_logging:
		name: ${2:# Name of the s3 bucket.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# target_prefix: 
		# target_bucket: # The bucket to log to. Required when state=present.
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet elb_application_lb "Manage an Application load balancer" b
- name: $1
	elb_application_lb:
		state: ${2:present|absent}
		name: ${3:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# subnets: # A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# access_logs_enabled: yes|no
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# access_logs_s3_bucket: # The name of the S3 bucket for the access logs. This attribute is required if access logs in Amazon S3 are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permission to write to the bucket.
		# purge_tags: yes|no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# tags: # A dictionary of one or more tags to assign to the load balancer.
		# idle_timeout: 60
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# deletion_protection: yes|no
		# purge_listeners: yes|no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# access_logs_s3_prefix: # The prefix for the location in the S3 bucket. If you don't specify a prefix, the access logs are stored in the root of the bucket.
		# scheme: #internet-facing|internal
		# validate_certs: yes
		# listeners: # A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.
		# security_groups: []
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# dhcp_options_ids: # Get details of specific DHCP Option ID
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_application_scaling_policy "Manage Application Auto Scaling Scaling Policies" b
- name: $1
	aws_application_scaling_policy:
		resource_id: ${2:# T}
		policy_name: ${3:# T}
		scalable_dimension: ${4:ecs:service:DesiredCount|ec2:spot-fleet-request:TargetCapacity|elasticmapreduce:instancegroup:InstanceCount|appstream:fleet:DesiredCapacity|dynamodb:table:ReadCapacityUnits|dynamodb:table:WriteCapacityUnits|dynamodb:index:ReadCapacityUnits|dynamodb:index:WriteCapacityUnits}
		service_namespace: ${5:ecs|elasticmapreduce|ec2|appstream|dynamodb}
		policy_type: ${6:StepScaling|TargetTrackingScaling}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# step_scaling_policy_configuration: # A
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# target_tracking_scaling_policy_configuration: # A
		# validate_certs: yes
$0
endsnippet

snippet ec2_key "create or delete an ec2 key pair" b
- name: $1
	ec2_key:
		name: ${2:# Name of the key pair.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# force: yes
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# wait: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# key_material: # Public key material.
		# state: #present|absent
		# validate_certs: yes
$0
endsnippet

snippet rds "create, delete, or modify an Amazon rds instance" b
- name: $1
	rds:
		command: ${2:create|replicate|delete|facts|modify|promote|snapshot|reboot|restore}
		region: ${3:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# db_engine: mariadb|MySQL|oracle-se1|oracle-se2|oracle-se|oracle-ee|sqlserver-ee|sqlserver-se|sqlserver-ex|sqlserver-web|postgres|aurora
		# iops: # Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000.
		# backup_window: # Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# backup_retention: # Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.

		# port: 3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.
		# security_groups: # Comma separated list of one or more security groups.  Used only when command=create or command=modify.
		# size: # Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# subnet: # VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.
		# vpc_security_groups: # Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.
		# upgrade: yes|no
		# zone: # availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.
		# instance_type: # The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.
		# source_instance: # Name of the database to replicate. Used only when command=replicate.
		# parameter_group: # Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.
		# multi_zone: yes|no
		# new_instance_name: # Name to rename an instance to. Used only when command=modify.
		# username: # Master database username. Used only when command=create.
		# tags: # tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0
		# db_name: # Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.
		# license_model: license-included|bring-your-own-license|general-public-license|postgresql-license
		# password: # Password for the master database username. Used only when command=create or command=modify.
		# apply_immediately: yes|no
		# wait: yes|#no
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# character_set_name: # Associate the DB instance with a specified character set. Used with command=create.
		# validate_certs: yes
		# option_group: # The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.
		# engine_version: # Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used
		# instance_name: # Database instance identifier. Required except when using command=facts or command=delete on just a snapshot
		# force_failover: yes|#no
		# wait_timeout: 300
		# snapshot: # Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.
		# publicly_accessible: # explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0
		# maint_window: # Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.

$0
endsnippet

snippet route53_health_check "add or delete health-checks in Amazons Route53 DNS service" b
- name: $1
	route53_health_check:
		request_interval: ${2:10|#30}
		type: ${3:HTTP|HTTPS|HTTP_STR_MATCH|HTTPS_STR_MATCH|TCP}
		state: ${4:present|absent}
		failure_threshold: ${5:1|2|#3|4|5|6|7|8|9|10}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# fqdn: # Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.
		# port: # The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.
		# validate_certs: yes
		# resource_path: # The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.
		# ip_address: # IP address of the end-point to check. Either this or `fqdn` has to be provided.
		# string_match: # If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.
$0
endsnippet

snippet ec2_vpc_igw "Manage an AWS VPC Internet gateway" b
- name: $1
	ec2_vpc_igw:
		vpc_id: ${2:# The VPC ID for the VPC in which to manage the Internet Gateway.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A dict of tags to apply to the internet gateway. Any tags currently applied to the internet gateway and not present here will be removed.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_lc "Create or delete AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc:
		name: ${2:# Unique name for configuration}
		instance_type: ${3:# Instance type to use for the instance}
		state: ${4:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# kernel_id: # Kernel id for the EC2 instance
		# key_name: # The SSH key name to be used for access to managed instances
		# ramdisk_id: # A RAM disk id for the instances.
		# user_data: # Opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path).
		# image_id: # The AMI unique identifier to be used for the group
		# assign_public_ip: # Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.
		# instance_monitoring: no
		# classic_link_vpc_id: # Id of ClassicLink enabled VPC
		# security_groups: # A list of security groups to apply to the instances. Since version 2.4 you can specify either security group names or IDs or a mix.  Previous to 2.4, for VPC instances, specify security group IDs and for EC2-Classic, specify either security group names or IDs.
		# classic_link_vpc_security_groups: # A list of security group IDs with which to associate the ClassicLink VPC instances.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# spot_price: # The spot price you are bidding. Only applies for an autoscaling group with spot instances.
		# instance_profile_name: # The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.
		# user_data_path: # Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data).
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ebs_optimized: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# instance_id: # The Id of a running instance to use as a basis for a launch configuration. Can be used in place of image_id and instance_type.
		# volumes: # A list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.
		# vpc_id: # VPC ID, used when resolving security group names to IDs.
		# validate_certs: yes
		# placement_tenancy: default
$0
endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
- name: $1
	ec2_metadata_facts:
		# url_password: # The password for use in HTTP basic authentication.
		# force: no
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force_basic_auth: no
		# http_agent: ansible-httpget
		# url_username: # The username for use in HTTP basic authentication.
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet iam_role "Manage AWS IAM roles" b
- name: $1
	iam_role:
		name: ${2:# The name of the role to create.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# managed_policy: # A list of managed policy ARNs or, since Ansible 2.4, a list of either managed policy ARNs or friendly names. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.
		# purge_policies: yes
		# assume_role_policy_document: # The trust relationship policy document that grants an entity permission to assume the role.
		# state: #present|absent
		# create_instance_profile: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# path: /
		# validate_certs: yes
		# description: # Provide a description of the new role
$0
endsnippet

snippet elasticache "Manage cache clusters in Amazon Elasticache." b
- name: $1
	elasticache:
		name: ${2:# The cache cluster identifier}
		state: ${3:present|absent|rebooted}
		# engine: redis|#memcached
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# cache_port: # The port number on which each of the cache nodes will accept connections
		# cache_parameter_group: # The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.
		# cache_engine_version: # The version number of the cache engine
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# node_type: cache.m1.small
		# num_nodes: # The initial number of cache nodes that the cache cluster will have. Required when state=present.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# zone: # The EC2 Availability Zone in which the cache cluster will be created
		# cache_security_groups: # A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc
		# cache_subnet_group: # The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc
		# hard_modify: yes|no
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# security_group_ids: # A list of vpc security group names to associate with this cache cluster. Only use if inside a vpc
		# validate_certs: yes
		# wait: yes|no
$0
endsnippet

snippet ec2_asg_lifecycle_hook "Create, delete or update AWS ASG Lifecycle Hooks." b
- name: $1
	ec2_asg_lifecycle_hook:
		lifecycle_hook_name: ${2:# The name of the lifecycle hook.}
		autoscaling_group_name: ${3:# The name of the Auto Scaling group to which you want to assign the lifecycle hook.}
		transition: ${4:autoscaling:EC2_INSTANCE_TERMINATING|autoscaling:EC2_INSTANCE_LAUNCHING}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# role_arn: # The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# heartbeat_timeout: 3600 (1 hour)
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# notification_target_arn: # The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an SQS queue or an SNS topic. If you specify an empty string, this overrides the current ARN.
		# default_result: #ABANDON|CONTINUE
		# notification_meta_data: # Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.
$0
endsnippet

snippet ec2_vpc_nacl "create and delete Network ACLs." b
- name: $1
	ec2_vpc_nacl:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# subnets: # The list of subnets that should be associated with the network ACL.
		# ingress: # List of rules for incoming traffic.
		# name: # Tagged name identifying a network ACL.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # Dictionary of tags to look for and apply when creating a network ACL.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# state: #present|absent
		# egress: # A list of rules for outgoing traffic.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# vpc_id: # VPC id of the requesting VPC.
		# validate_certs: yes
		# nacl_id: # NACL id identifying a network ACL.
$0
endsnippet

snippet ec2_placement_group "Create or delete an EC2 Placement Group" b
- name: $1
	ec2_placement_group:
		name: ${2:# The name for the placement group.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# strategy: #cluster|spread
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_nat_gateway "Manage AWS VPC NAT Gateways." b
- name: $1
	ec2_vpc_nat_gateway:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# release_eip: yes
		# nat_gateway_id: # The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# allocation_id: # The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.
		# subnet_id: # The id of the subnet to create the NAT Gateway in. This is required with the present option.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# if_exist_do_not_create: no
		# eip_address: # The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.
		# state: #present|absent
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# client_token: # Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.
		# validate_certs: yes
		# wait: no
$0
endsnippet

snippet aws_waf_condition "create and delete WAF Conditions" b
- name: $1
	aws_waf_condition:
		name: ${2:# N}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# purge_filters: # W
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
		# state: #present|absent
		# filters: # A list of the filters against which to match
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# type: byte|geo|ip|regex|size|sql|xss
$0
endsnippet

snippet ec2_vpc_net_facts "Gather facts about ec2 VPCs in AWS" b
- name: $1
	ec2_vpc_net_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# vpc_ids: # A list of VPC IDs that exist in your account.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_snapshot "creates a snapshot from an existing volume" b
- name: $1
	ec2_snapshot:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# description: # description to be applied to the snapshot
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# snapshot_tags: # a hash/dictionary of tags to add to the snapshot
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# volume_id: # volume from which to take the snapshot
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# device_name: # device name of a mounted volume to be snapshotted
		# instance_id: # instance that has the required volume to snapshot mounted
		# state: absent|#present
		# wait_timeout: 0
		# snapshot_id: # snapshot id to remove
		# last_snapshot_min_age: 0
		# validate_certs: yes
		# wait: yes|no
$0
endsnippet

snippet redshift_facts "Gather facts about Redshift cluster(s)" b
- name: $1
	redshift_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# cluster_identifier: # The prefix of cluster identifier of the Redshift cluster you are searching for.
		# tags: # A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the security group(s) you are searching for.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet data_pipeline "Create and manage AWS Datapipelines" b
- name: $1
	data_pipeline:
		name: ${2:# The name of the Datapipeline to create/modify/delete.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# parameters: # A list of parameter objects (dicts) in the pipeline definition.
		# tags: # A dict of key:value pair(s) to add to the pipeline.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent|active|inactive
		# objects: # A list of pipeline object definitions, each of which is a dict that takes the keys C(id), C(name) and C(fields).
		# values: # A list of parameter values (dicts) in the pipeline definition. Each dict takes the keys C(id) and C(stringValue) both of which are strings.
		# timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# description: 
$0
endsnippet

snippet aws_ses_identity "Manages SES email and domain identity" b
- name: $1
	aws_ses_identity:
		identity: ${2:# This is the email address or domain to verify / delete.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# bounce_notifications: # Setup the SNS topic used to report bounce notifications.
		# feedback_forwarding: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# complaint_notifications: # Setup the SNS topic used to report complaint notifications.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# delivery_notifications: # Setup the SNS topic used to report delivery notifications.
		# validate_certs: yes
$0
endsnippet

snippet s3_bucket "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3" b
- name: $1
	s3_bucket:
		name: ${2:# Name of the s3 bucket}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# force: yes|no
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # tags dict to apply to bucket
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ceph: # Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# policy: # The JSON policy as a string.
		# s3_url: # S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS
		# validate_certs: yes
		# requester_pays: yes|no
		# versioning: yes|no
$0
endsnippet

snippet cloudfront_invalidation "create invalidations for aws cloudfront distributions" b
- name: $1
	cloudfront_invalidation:
		target_paths: ${2:# A list of paths on the distribution to invalidate. Each path should begin with '/'. Wildcards are allowed. eg. '/foo/bar/*'}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# alias: # The alias of the cloudfront distribution to invalidate paths for. Can be specified instead of distribution_id.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# distribution_id: # The id of the cloudfront distribution to invalidate paths for. Can be specified insted of the alias.
		# caller_reference: current datetime stamp
		# validate_certs: yes
$0
endsnippet

snippet aws_az_facts "Gather facts about availability zones in AWS." b
- name: $1
	aws_az_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet iam "Manage IAM users, groups, roles and keys" b
- name: $1
	iam:
		name: ${2:# Name of IAM resource to create or identify}
		iam_type: ${3:user|group|role}
		state: ${4:present|absent|update}
		# new_name: # When state is update, will replace name with new_name on IAM resource
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# update_password: #always|on_create
		# new_path: # When state is update, will replace the path with new_path on the IAM resource
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# access_key_state: create|remove|active|inactive
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# key_count: 1
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# validate_certs: yes
		# access_key_ids: # A list of the keys that you want impacted by the access_key_state parameter.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# groups: # A list of groups the user should belong to. When update, will gracefully remove groups not listed.
		# trust_policy: # The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath).
		# path: /
		# password: # When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.
		# trust_policy_filepath: # The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy).
$0
endsnippet

snippet ecs_service_facts "list or describe services in ecs" b
- name: $1
	ecs_service_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# service: # The service to get details for (required if details is true)
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# cluster: default
		# details: true|#false
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_customer_gateway_facts "Gather facts about customer gateways in AWS" b
- name: $1
	ec2_customer_gateway_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# customer_gateway_ids: # Get details of a specific customer gateways using customer gateway ID/IDs. This value should be provided as a list.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCustomerGateways.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_peer "create, delete, accept, and reject VPC peering connections between two VPCs." b
- name: $1
	ec2_vpc_peer:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# peering_id: # Peering connection id.
		# tags: # Dictionary of tags to look for and apply when creating a Peering Connection.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# peer_vpc_id: # VPC id of the accepting VPC.
		# peer_region: # Region of the accepting VPC.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# peer_owner_id: # The AWS account number for cross account peering.
		# state: #present|absent|accept|reject
		# vpc_id: # VPC id of the requesting VPC.
		# validate_certs: yes
$0
endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
- name: $1
	ec2_metadata_facts:
		# url_password: # The password for use in HTTP basic authentication.
		# force: no
		# use_proxy: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force_basic_auth: no
		# http_agent: ansible-httpget
		# url_username: # The username for use in HTTP basic authentication.
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet ec2_vpc_route_table_facts "Gather facts about ec2 VPC route tables in AWS" b
- name: $1
	ec2_vpc_route_table_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_peering_facts "Retrieves AWS VPC Peering details using AWS methods." b
- name: $1
	ec2_vpc_peering_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# peer_connection_ids: # Get details of specific vpc peer IDs
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet cloudformation "Create or delete an AWS CloudFormation stack" b
- name: $1
	cloudformation:
		stack_name: ${2:# name of the cloudformation stack}
		# template_body: # Template body. Use this to pass in the actual body of the Cloudformation template.
		# template_format: #json|yaml
		# termination_protection: # enable or disable termination protection on the stack. Only works with botocore >= 1.7.18.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# role_arn: # The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)
		# stack_policy: # the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. (for instance, [allow all updates](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)
		# template_parameters: {}
		# state: #present|absent
		# template: # The local path of the cloudformation template.
		# create_changeset: no
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# disable_rollback: true|#false
		# notification_arns: # The Simple Notification Service (SNS) topic ARNs to publish stack related events.
		# tags: # Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.
		# template_url: # Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# changeset_name: # Name given to the changeset when creating a changeset, only used when create_changeset is true. By default a name prefixed with Ansible-STACKNAME is generated based on input parameters. See the AWS Change Sets docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html)
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
$0
endsnippet

snippet lambda "Manage AWS Lambda functions" b
- name: $1
	lambda:
		name: ${2:# The name you want to assign to the function you are uploading. Cannot be changed.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# description: # A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.
		# tags: # tag dict to apply to the function (requires botocore 1.5.40 or above)
		# s3_key: # The Amazon S3 object (the deployment package) key name you want to upload
		# zip_file: # A .zip file containing your deployment package
		# s3_object_version: # The Amazon S3 object (the deployment package) version you want to upload.
		# memory_size: 128
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# dead_letter_arn: # The parent object that contains the target Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# s3_bucket: # Amazon S3 bucket name where the .zip file containing your deployment package is stored
		# state: #present|absent
		# handler: # The function within your code that Lambda calls to begin execution
		# role: # The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.
		# timeout: 3
		# environment_variables: # A dictionary of environment variables the Lambda function is given.
		# runtime: # The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# vpc_subnet_ids: # List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.
		# vpc_security_group_ids: # List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.
$0
endsnippet

snippet dynamodb_table "Create, update or delete AWS Dynamo DB tables." b
- name: $1
	dynamodb_table:
		name: ${2:# Name of the table.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# read_capacity: 1
		# hash_key_name: # Name of the hash key.
		# range_key_type: #STRING|NUMBER|BINARY
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# write_capacity: 1
		# indexes: []
		# range_key_name: # Name of the range key.
		# state: #present|absent
		# wait_for_active_timeout: 60
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# validate_certs: yes
		# hash_key_type: #STRING|NUMBER|BINARY
$0
endsnippet

snippet ec2_elb_lb "Creates or destroys Amazon ELB." b
- name: $1
	ec2_elb_lb:
		name: ${2:# The name of the ELB}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# subnets: # A list of VPC subnets to use when creating ELB. Zones should be empty if using this.
		# health_check: # An associative array of health check configuration settings (see example)
		# tags: # An associative array of tags. To delete all tags, supply an empty dict.
		# purge_subnets: no
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# instance_ids: no
		# zones: # List of availability zones to enable on this ELB
		# idle_timeout: # ELB connections from clients and to servers are timed out after this amount of time
		# wait_timeout: 60
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# cross_az_load_balancing: yes|#no
		# security_group_ids: # A list of security groups to apply to the elb
		# purge_zones: no
		# wait: yes|no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# purge_instance_ids: no
		# connection_draining_timeout: # Wait a specified timeout allowing connections to drain before terminating an instance
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# listeners: # List of ports/protocols for this ELB to listen on (see example)
		# access_logs: # An associative array of access logs configuration settings (see example)
		# security_group_names: # A list of security group names to apply to the elb
		# purge_listeners: yes
		# scheme: internal|#internet-facing
		# validate_certs: #yes|no
		# stickiness: # An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )
$0
endsnippet

snippet ecs_ecr "Manage Elastic Container Registry repositories" b
- name: $1
	ecs_ecr:
		name: ${2:# the name of the repository}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# delete_policy: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# force_set_policy: no
		# state: #present|absent
		# policy: # JSON or dict that represents the new policy
		# registry_id: # AWS account id associated with the registry.
$0
endsnippet

snippet ec2_vpc_subnet "Manage subnets in AWS virtual private clouds" b
- name: $1
	ec2_vpc_subnet:
		vpc_id: ${2:# VPC ID of the VPC in which to create or delete the subnet.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# az: # The availability zone for the subnet.
		# ipv6_cidr: # The IPv6 CIDR block for the subnet. The VPC must have a /56 block assigned and this value must be a valid IPv6 /64 that falls in the VPC range.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.
		# purge_tags: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# map_public: no
		# cidr: # The CIDR block for the subnet. E.g. 192.0.2.0/24.
		# assign_instances_ipv6: no
		# validate_certs: yes
		# wait: yes
$0
endsnippet

snippet sts_session_token "Obtain a session token from the AWS Security Token Service" b
- name: $1
	sts_session_token:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# duration_seconds: # The duration, in seconds, of the session token. See http://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters for acceptable and default values.
		# mfa_serial_number: # The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.
		# mfa_token: # The value provided by the MFA device, if the trust policy of the user requires MFA.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_eni_facts "Gather facts about ec2 ENI interfaces in AWS" b
- name: $1
	ec2_eni_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ecs_taskdefinition "register a task definition in ecs" b
- name: $1
	ecs_taskdefinition:
		state: ${2:present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# family: # A Name that would be given to the task definition
		# task_role_arn: # The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# force_create: # Always create new task definition
		# network_mode: #bridge|host|none
		# containers: # A list of containers definitions
		# volumes: # A list of names of volumes to be attached
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# arn: # The arn of the task description to delete
		# revision: # A revision number for the task definition
$0
endsnippet

snippet ec2_vpc_vgw "Create and delete AWS VPN Virtual Gateways." b
- name: $1
	ec2_vpc_vgw:
		# state: #present|absent
		# wait_timeout: 320
		# name: # name of the vgw to be created or deleted
		# tags: # dictionary of resource tags
		# vpc_id: # the vpc-id of a vpc to attach or detach
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# vpn_gateway_id: # vpn gateway id of an existing virtual gateway
		# type: ipsec.1
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# dns_servers: # A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)
		# ntp_servers: # List of hosts to advertise as NTP servers for the VPC.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# domain_name: # The domain name to set in the DHCP option sets
		# delete_old: yes
		# state: absent|#present
		# netbios_node_type: # NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# vpc_id: # VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.
		# inherit_existing: no
		# validate_certs: yes
		# dhcp_options_id: # The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)
		# netbios_name_servers: # List of hosts to advertise as NetBIOS servers.
$0
endsnippet

snippet lightsail "Create or delete a virtual machine instance in AWS Lightsail" b
- name: $1
	lightsail:
		name: ${2:# Name of the instance}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# zone: # AWS availability zone in which to launch the instance. Required when state='present'
		# blueprint_id: # ID of the instance blueprint image. Required when state='present'
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# user_data: # Launch script that can configure the instance with additional data
		# key_pair_name: # Name of the key pair to use with the instance
		# state: #present|absent|running|restarted|stopped
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# bundle_id: # Bundle of specification info for the instance. Required when state='present'
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# wait: #yes|no
$0
endsnippet

snippet ec2_group_facts "Gather facts about ec2 security groups in AWS." b
- name: $1
	ec2_group_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_scaling_policy "Create or delete AWS scaling policies for Autoscaling groups" b
- name: $1
	ec2_scaling_policy:
		name: ${2:# Unique name for the scaling policy}
		asg_name: ${3:# Name of the associated autoscaling group}
		state: ${4:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# adjustment_type: ChangeInCapacity|ExactCapacity|PercentChangeInCapacity
		# min_adjustment_step: # Minimum amount of adjustment when policy is triggered
		# scaling_adjustment: # The amount by which the autoscaling group is adjusted by the policy
		# cooldown: # The minimum period of time between which autoscaling actions can take place
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
$0
endsnippet

snippet iam_managed_policy "Manage User Managed IAM policies" b
- name: $1
	iam_managed_policy:
		policy_name: ${2:# The name of the managed policy.}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# make_default: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# only_version: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# policy_description: 
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# policy: # A properly json formatted policy
		# validate_certs: yes
$0
endsnippet

snippet aws_waf_rule "create and delete WAF Rules" b
- name: $1
	aws_waf_rule:
		name: ${2:# N}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# purge_conditions: # Whether or not to remove conditions that are not passed when updating `conditions`. Defaults to false.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# conditions: # l
		# metric_name: # A friendly name or description for the metrics for the rule
$0
endsnippet

snippet ecs_attribute "manage ecs attributes" b
- name: $1
	ecs_attribute:
		cluster: ${2:# The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to apply attributes.}
		ec2_instance_id: ${3:# EC2 instance ID of ECS cluster container instance.}
		attributes: ${4:# List of attributes.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_igw_facts "Gather facts about internet gateways in AWS" b
- name: $1
	ec2_vpc_igw_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# internet_gateway_ids: # Get details of specific Internet Gateway ID. Provide this value as a list.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_batch_job_definition "Manage AWS Batch Job Definitions" b
- name: $1
	aws_batch_job_definition:
		state: ${2:#present|absent}
		job_definition_name: ${3:# The name for the job definition}
		type: ${4:# The type of job definition}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# readonly_root_filesystem: # When this parameter is true, the container is given read-only access to its root file system. This parameter maps to ReadonlyRootfs in the Create a container section of the Docker Remote API and the --read-only option to docker run.
		# mount_points: # The mount points for data volumes in your container. This parameter maps to Volumes in the Create a container section of the Docker Remote API and the --volume option to docker run. List of dictionaries.
		# image: # The image used to start a container. This string is passed directly to the Docker daemon. Images in the Docker Hub registry are available by default. Other repositories are specified with `` repository-url /image <colon>tag ``. Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed. This parameter maps to Image in the Create a container section of the Docker Remote API and the IMAGE parameter of docker run.
		# job_role_arn: # The Amazon Resource Name (ARN) of the IAM role that the container can assume for AWS permissions.
		# attempts: # Retry strategy - The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If attempts is greater than one, the job is retried if it fails until it has moved to RUNNABLE that many times.
		# user: # The user name to use inside the container. This parameter maps to User in the Create a container section of the Docker Remote API and the --user option to docker run.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# job_definition_arn: # The arn for the job definition
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# parameters: # Default parameter substitution placeholders to set in the job definition. Parameters are specified as a key-value pair mapping. Parameters in a SubmitJob request override any corresponding parameter defaults from the job definition.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# environment: # The environment variables to pass to a container. This parameter maps to Env in the Create a container section of the Docker Remote API and the --env option to docker run. List of dictionaries.
		# vcpus: # The number of vCPUs reserved for the container. This parameter maps to CpuShares in the Create a container section of the Docker Remote API and the --cpu-shares option to docker run. Each vCPU is equivalent to 1,024 CPU shares.
		# command: # The command that is passed to the container. This parameter maps to Cmd in the Create a container section of the Docker Remote API and the COMMAND parameter to docker run. For more information, see https://docs.docker.com/engine/reference/builder/#cmd.
		# volumes: # A list of data volumes used in a job. List of dictionaries.
		# memory: # The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed. This parameter maps to Memory in the Create a container section of the Docker Remote API and the --memory option to docker run.
		# privileged: # When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). This parameter maps to Privileged in the Create a container section of the Docker Remote API and the --privileged option to docker run.
		# ulimits: # A list of ulimits to set in the container. This parameter maps to Ulimits in the Create a container section of the Docker Remote API and the --ulimit option to docker run. List of dictionaries.
$0
endsnippet

snippet ec2_placement_group_facts "List EC2 Placement Group(s) details" b
- name: $1
	ec2_placement_group_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# names: []
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ecs_service "create, terminate, start or stop a service in ecs" b
- name: $1
	ecs_service:
		name: ${2:# The name of the service}
		state: ${3:present|absent|deleting}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# repeat: 10
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# desired_count: # The count of how many instances of the service. This parameter is required when state=present
		# placement_constraints: # The placement constraints for the tasks in the service
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# delay: 10
		# cluster: # The name of the cluster in which the service exists
		# task_definition: # The task definition the service will run. This parameter is required when state=present
		# role: # The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service.
		# deployment_configuration: # Optional parameters that control the deployment_configuration; format is '{"maximum_percent":<integer>, "minimum_healthy_percent":<integer>}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# load_balancers: # The list of ELBs defined for this service
		# client_token: # Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.
		# validate_certs: yes
		# placement_strategy: # The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service
$0
endsnippet

snippet ec2_vpc_nacl_facts "Gather facts about Network ACLs in an AWS VPC" b
- name: $1
	ec2_vpc_nacl_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# nacl_ids: []
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet sqs_queue "Creates or deletes AWS SQS queues." b
- name: $1
	sqs_queue:
		name: ${2:# Name of the queue.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# message_retention_period: # The message retention period in seconds.
		# delivery_delay: # The delivery delay in seconds.
		# default_visibility_timeout: # The default visibility timeout in seconds.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# state: #present|absent
		# maximum_message_size: # The maximum message size in bytes.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# policy: # The json dict policy to attach to queue
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# redrive_policy: # json dict with the redrive_policy (see example)
		# receive_message_wait_time: # The receive message wait time in seconds.
$0
endsnippet

snippet ec2_vpc_vpn "Create, modify, and delete EC2 VPN connections." b
- name: $1
	ec2_vpc_vpn:
		# connection_type: #ipsec.1
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# customer_gateway_id: # The ID of the customer gateway.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # Tags to attach to the VPN connection.
		# purge_tags: no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# tunnel_options: # An optional list object containing no more than two dict members, each of which may contain 'TunnelInsideCidr' and/or 'PreSharedKey' keys with appropriate string values.  AWS defaults will apply in absence of either of the aforementioned keys.
		# state: #present|absent
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# validate_certs: yes
		# purge_routes: # Whether or not to delete VPN connections routes that are not specified in the task.
		# vpn_connection_id: # The ID of the VPN connection. Required to modify or delete a connection if the filters option does not provide a unique match.
		# filters: # An alternative to using vpn_connection_id. If multiple matches are found, vpn_connection_id is required. If one of the following suboptions is a list of items to filter by, only one item needs to match to find the VPN that correlates. e.g. if the filter 'cidr' is ['194.168.2.0/24', '192.168.2.0/24'] and the VPN route only has the destination cidr block of '192.168.2.0/24' it will be found with this filter (assuming there are not multiple VPNs that are matched). Another example, if the filter 'vpn' is equal to ['vpn-ccf7e7ad', 'vpn-cb0ae2a2'] and one of of the VPNs has the state deleted (exists but is unmodifiable) and the other exists and is not deleted, it will be found via this filter. See examples.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# routes: # Routes to add to the connection.
		# vpn_gateway_id: # The ID of the virtual private gateway.
		# static_only: no
$0
endsnippet

snippet route53_facts "Retrieves route53 details using AWS methods" b
- name: $1
	route53_facts:
		query: ${2:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# start_record_name: # The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# resource_id: # The ID/s of the specified resource/s
		# hosted_zone_method: details|#list|list_by_name|count|tags
		# dns_name: # The first name in the lexicographic ordering of domain names that you want the list_command to start listing from
		# health_check_method: #list|details|status|failure_reason|count|tags
		# delegation_set_id: # The DNS Zone delegation set ID
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# max_items: # Maximum number of items to return for various get/list requests
		# hosted_zone_id: # The Hosted Zone ID of the DNS zone
		# validate_certs: yes
		# health_check_id: # The ID of the health check
		# change_id: # The ID of the change batch request. The value that you specify here is the value that ChangeResourceRecordSets returned in the Id element when you submitted the request.
		# next_marker: # Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100 or the number specified by max_items. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results
		# type: A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudfront_facts "Obtain facts about an AWS CloudFront distribution" b
- name: $1
	cloudfront_facts:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# list_streaming_distributions: no
		# origin_access_identity_config: no
		# invalidation: no
		# domain_name_alias: # Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.
		# list_invalidations: no
		# origin_access_identity_id: # The id of the cloudfront origin access identity to get information about.
		# list_distributions_by_web_acl_id: no
		# origin_access_identity: no
		# streaming_distribution_config: no
		# all_lists: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# list_distributions: no
		# summary: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# web_acl_id: # Used with I(list_distributions_by_web_acl_id).
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# streaming_distribution: no
		# distribution_id: # The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).
		# distribution_config: no
		# invalidation_id: # The id of the invalidation to get information about. Used with I(invalidation).
		# distribution: no
		# validate_certs: yes
		# list_origin_access_identities: no
$0
endsnippet

snippet aws_direct_connect_connection "Creates, deletes, modifies a DirectConnect connection" b
- name: $1
	aws_direct_connect_connection:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# connection_id: # The ID of the Direct Connect connection. I(name) or I(connection_id) is required to recreate or delete a connection. Modifying attributes of a connection with I(forced_update) will result in a new Direct Connect connection ID.
		# bandwidth: 1Gbps|10Gbps
		# link_aggregation_group: # The ID of the link aggregation group you want to associate with the connection. This is optional in case a stand-alone connection is desired.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# forced_update: # To modify bandwidth or location the connection will need to be deleted and recreated. By default this will not happen - this option must be set to True.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of the Direct Connect connection. This is required to create a new connection. To recreate or delete a connection I(name) or I(connection_id) is required.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: present|absent
		# location: # Where the Direct Connect connection is located. Required when I(state=present).
		# validate_certs: yes
$0
endsnippet

snippet aws_acm_facts "Retrieve certificate facts from AWS Certificate Manager service" b
- name: $1
	aws_acm_facts:
		# status: PENDING_VALIDATION|ISSUED|INACTIVE|EXPIRED|VALIDATION_TIMED_OUT
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of an ACM certificate
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet elasticache_parameter_group "Manage cache security groups in Amazon Elasticache." b
- name: $1
	elasticache_parameter_group:
		name: ${2:# A user-specified name for the cache parameter group.}
		state: ${3:present|absent|reset}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# group_family: memcached1.4|redis2.6|redis2.8|redis3.2
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# values: # A user-specified dictionary of parameters to reset or modify for the cache parameter group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# description: # A user-specified description for the cache parameter group.
$0
endsnippet

snippet aws_batch_job_queue "Manage AWS Batch Job Queues" b
- name: $1
	aws_batch_job_queue:
		compute_environment_order: ${2:# The set of compute environments mapped to a job queue and their order relative to each other. The job scheduler uses this parameter to determine which compute environment should execute a given job. Compute environments must be in the VALID state before you can associate them with a job queue. You can associate up to 3 compute environments with a job queue.}
		job_queue_name: ${3:# The name for the job queue}
		priority: ${4:# The priority of the job queue. Job queues with a higher priority (or a lower integer value for the priority parameter) are evaluated first when associated with same compute environment. Priority is determined in ascending order, for example, a job queue with a priority value of 1 is given scheduling preference over a job queue with a priority value of 10.}
		state: ${5:#present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# job_queue_state: #ENABLED|DISABLED
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_lc_facts "Gather facts about AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_facts:
		# sort: launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# sort_end: # Which result to end with (when sorting).
		# name: []
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# sort_start: # Which result to start with (when sorting).
		# sort_order: #ascending|descending
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet iam_user "Manage AWS IAM users" b
- name: $1
	iam_user:
		name: ${2:# The name of the user to create.}
		state: ${3:present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# purge_policy: no
		# managed_policy: # A list of managed policy ARNs or friendly names to attach to the user. To embed an inline policy, use M(iam_policy).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_direct_connect_virtual_interface "Manage Direct Connect virtual interfaces." b
- name: $1
	aws_direct_connect_virtual_interface:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# vlan: 100
		# name: # The name of the virtual interface.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# virtual_interface_id: # The virtual interface ID.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# id_to_associate: # The ID of the link aggrecation group or connection to associate with the virtual interface.
		# customer_address: # The customer address CIDR with which to create the virtual interface.
		# state: present|absent
		# amazon_address: # The amazon address CIDR with which to create the virtual interface.
		# authentication_key: # The authentication key for BGP configuration.
		# bgp_asn: 65000
		# cidr: # A list of route filter prefix CIDRs with which to create the public virtual interface.
		# address_type: # The type of IP address for the BGP peer.
		# virtual_gateway_id: # The virtual gateway ID required for creating a private virtual interface.
		# public: # The type of virtual interface.
$0
endsnippet

snippet aws_s3_bucket_facts "Lists S3 buckets in AWS" b
- name: $1
	aws_s3_bucket_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
$0
endsnippet

snippet cloudwatchlogs_log_group_facts "get facts about log_group in CloudWatchLogs" b
- name: $1
	cloudwatchlogs_log_group_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# log_group_name: # The name or prefix of the log group to filter by.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet cloudfront_origin_access_identity "create, update and delete origin access identities for a cloudfront distribution." b
- name: $1
	cloudfront_origin_access_identity:
		# comment: # A comment to describe the cloudfront origin access identity.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# origin_access_identity_id: # The origin_access_identity_id of the cloudfront distribution.
		# state: present|absent
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# caller_reference: # A unique identifier to reference the origin access identity by.
		# validate_certs: yes
$0
endsnippet

snippet aws_s3 "manage objects in S3." b
- name: $1
	aws_s3:
		bucket: ${2:# Bucket name.}
		mode: ${3:get|put|delete|create|geturl|getstr|delobj|list}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# permission: private
		# dest: # The destination file path when downloading an object/key with a GET operation.
		# object: # Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.
		# prefix: 
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# marker: # Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.
		# ignore_nonexistent_bucket: # Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.
		# overwrite: always
		# headers: # Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# src: # The source file path when performing a PUT operation.
		# aws_access_key: # AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# encrypt: yes
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# rgw: no
		# region: # AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.
		# retries: 0
		# max_keys: 1000
		# version: # Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.
		# expiration: 600
		# s3_url: # S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS
		# metadata: # Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# validate_certs: yes
$0
endsnippet

snippet elb_classic_lb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	elb_classic_lb_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# names: # List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_net "Configure AWS virtual private clouds" b
- name: $1
	ec2_vpc_net:
		name: ${2:# The name to give your VPC. This is used in combination with C(cidr_block) to determine if a VPC already exists.}
		cidr_block: ${3:# The primary CIDR of the VPC. After 2.5 a list of CIDRs can be provided. The first in the list will be used as the primary CIDR and is used in conjunction with the C(name) to ensure idempotence.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# purge_cidrs: yes|no
		# dns_support: yes|no
		# tags: # The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# multi_ok: no
		# state: #present|absent
		# tenancy: #default|dedicated
		# dns_hostnames: yes|no
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# dhcp_opts_id: # the id of the DHCP options to use for this vpc
$0
endsnippet

snippet aws_batch_compute_environment "Manage AWS Batch Compute Environments" b
- name: $1
	aws_batch_compute_environment:
		subnets: ${2:# The VPC subnets into which the compute resources are launched.}
		instance_types: ${3:# The instance types that may be launched.}
		maxv_cpus: ${4:# The maximum number of EC2 vCPUs that an environment can reach.}
		security_group_ids: ${5:# The EC2 security groups that are associated with instances launched in the compute environment.}
		instance_role: ${6:# The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment.}
		minv_cpus: ${7:# The minimum number of EC2 vCPUs that an environment should maintain.}
		compute_resource_type: ${8:EC2|SPOT}
		state: ${9:#present|absent}
		service_role: ${10:# The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf.}
		compute_environment_name: ${11:# The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed.}
		type: ${12:MANAGED|UNMANAGED}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# tags: # Key-value pair tags to be applied to resources that are launched in the compute environment.
		# bid_percentage: # The minimum percentage that a Spot Instance price must be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20%, then the Spot price must be below 20% of the current On-Demand price for that EC2 instance.
		# image_id: # The Amazon Machine Image (AMI) ID used for instances launched in the compute environment.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# desiredv_cpus: # The desired number of EC2 vCPUS in the compute environment.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# compute_environment_state: #ENABLED|DISABLED
		# spot_iam_fleet_role: # The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment.
		# ec2_key_pair: # The EC2 key pair that is used for instances launched in the compute environment.
$0
endsnippet

snippet ec2_eni "Create and optionally attach an Elastic Network Interface (ENI) to an instance" b
- name: $1
	ec2_eni:
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_groups: # List of security groups associated with the interface. Only used when state=present. Since version 2.2, you can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# secondary_private_ip_addresses: # A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count
		# subnet_id: # ID of subnet in which to create the ENI.
		# device_index: 0
		# state: #present|absent
		# source_dest_check: # By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.
		# eni_id: # The ID of the ENI (to modify); if null and state is present, a new eni will be created.
		# delete_on_termination: # Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# description: # Optional description of the ENI.
		# purge_secondary_private_ip_addresses: no
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# attached: yes
		# force_detach: no
		# instance_id: # Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.
		# private_ip_address: # Private IP address.
		# secondary_private_ip_address_count: # The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses
		# validate_certs: yes
$0
endsnippet

snippet ec2_asg "Create or delete AWS Autoscaling Groups" b
- name: $1
	ec2_asg:
		launch_config_name: ${2:# Name of the Launch configuration to use for the group. See the ec2_lc module for managing these. If unspecified then the current group value will be used.}
		name: ${3:# Unique name for group to be created or deleted}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# target_group_arns: # List of target group ARNs to use for the group. Use for application load balancers.
		# default_cooldown: 300 seconds
		# tags: # A list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# min_size: # Minimum number of instances in group, if unspecified then the current group value will be used.
		# wait_timeout: 300
		# health_check_period: 500 seconds
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# load_balancers: # List of ELB names to use for the group. Use for classic load balancers.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# lc_check: yes
		# availability_zones: # List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.
		# replace_batch_size: 1
		# vpc_zone_identifier: # List of VPC subnets to use
		# replace_all_instances: no
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# suspend_processes: [Launch, Terminate, HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions, AddToLoadBalancer
		# termination_policies: OldestInstance|NewestInstance|OldestLaunchConfiguration|ClosestToNextInstanceHour|#Default
		# replace_instances: # List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.
		# desired_capacity: # Desired number of instances in group, if unspecified then the current group value will be used.
		# state: #present|absent
		# health_check_type: #EC2|ELB
		# max_size: # Maximum number of instances in group, if unspecified then the current group value will be used.
		# placement_group: # Physical location of your cluster placement group created in Amazon EC2.
		# notification_topic: # A SNS topic ARN to send auto scaling notifications to.
		# notification_types: [u'autoscaling:EC2_INSTANCE_LAUNCH', u'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', u'autoscaling:EC2_INSTANCE_TERMINATE', u'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']
		# wait_for_instances: yes
$0
endsnippet

snippet iam_group "Manage AWS IAM groups" b
- name: $1
	iam_group:
		name: ${2:# The name of the group to create.}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# users: # A list of existing users to add as members of the group.
		# purge_users: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# purge_policy: no
		# managed_policy: # A list of managed policy ARNs or friendly names to attach to the role. To embed an inline policy, use M(iam_policy).
		# validate_certs: yes
$0
endsnippet

snippet ec2_metric_alarm "Create/update or delete AWS Cloudwatch 'metric alarms'" b
- name: $1
	ec2_metric_alarm:
		state: ${2:present|absent}
		name: ${3:# Unique name for the alarm}
		# metric: # Name of the monitored metric (e.g. CPUUtilization)
		# statistic: SampleCount|Average|Sum|Minimum|Maximum
		# period: # The time (in seconds) between metric evaluations
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# threshold: # Sets the min/max bound for triggering the alarm
		# unit: Seconds|Microseconds|Milliseconds|Bytes|Kilobytes|Megabytes|Gigabytes|Terabytes|Bits|Kilobits|Megabits|Gigabits|Terabits|Percent|Count|Bytes/Second|Kilobytes/Second|Megabytes/Second|Gigabytes/Second|Terabytes/Second|Bits/Second|Kilobits/Second|Megabits/Second|Gigabits/Second|Terabits/Second|Count/Second|None
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# dimensions: # Describes to what the alarm is applied
		# namespace: # Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch
		# insufficient_data_actions: # A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ok_actions: # A list of the names of action(s) to take when the alarm is in the 'ok' status
		# description: # A longer description of the alarm
		# evaluation_periods: # The number of times in which the metric is evaluated before final calculation
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# comparison: <=|<|>|>=
		# alarm_actions: # A list of the names action(s) taken when the alarm is in the 'alarm' status
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
$0
endsnippet

snippet aws_region_facts "Gather facts about AWS regions." b
- name: $1
	aws_region_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_ami_copy "copies AMI between AWS regions, return new image id" b
- name: $1
	ec2_ami_copy:
		source_image_id: ${2:# The ID of the AMI in source region that should be copied.}
		source_region: ${3:# The source region the AMI should be copied from.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: default
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A hash/dictionary of tags to add to the new copied AMI; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# encrypted: # Whether or not the destination snapshots of the copied AMI should be encrypted.
		# description: # An optional human-readable string describing the contents and purpose of the new AMI.
		# kms_key_id: # KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.
		# wait_timeout: 1200
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# wait: yes|#no
$0
endsnippet

snippet ec2_eip "manages EC2 elastic IP (EIP) addresses." b
- name: $1
	ec2_eip:
		# release_on_disassociation: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# reuse_existing_ip_allowed: no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# allow_reassociation: no
		# public_ip: # The IP address of a previously allocated EIP.
		# state: #present|absent
		# in_vpc: no
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# private_ip_address: # The primary or secondary private IP address to associate with the Elastic IP address.
		# validate_certs: yes
		# device_id: # The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.
$0
endsnippet

snippet cloudwatchevent_rule "Manage CloudWatch Event rules and targets" b
- name: $1
	cloudwatchevent_rule:
		name: ${2:# The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\.\-_A-Za-z0-9]+))}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# description: # A description of the rule
		# event_pattern: # A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered
		# schedule_expression: # A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# targets: # A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], role_arn: [string], input: [valid JSON string], input_path: [valid JSONPath string], ecs_parameters: {task_definition_arn: [string], task_count: [int]}}). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(role_arn) (optional) is The Amazon Resource Name of the IAM role to be used for this target when the rule is triggered. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form. I(task_definition_arn) [optional] is ecs task definition arn. I(task_count) [optional] is ecs task count.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# role_arn: # The Amazon Resource Name (ARN) of the IAM role associated with the rule
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|disabled|absent
		# validate_certs: yes
$0
endsnippet

snippet iam_mfa_device_facts "List the MFA (Multi-Factor Authentication) devices registered for a user" b
- name: $1
	iam_mfa_device_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# user_name: # The name of the user whose MFA devices will be listed
$0
endsnippet

snippet ec2_vpc_subnet_facts "Gather facts about ec2 VPC subnets in AWS" b
- name: $1
	ec2_vpc_subnet_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# subnet_ids: # A list of subnet IDs to gather facts for.
		# validate_certs: yes
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_instance_facts "Gather facts about ec2 instances in AWS" b
- name: $1
	ec2_instance_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# instance_ids: # If you specify one or more instance IDs, only instances that have the specified IDs are returned.
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet cloudformation_facts "Obtain facts about an AWS CloudFormation stack" b
- name: $1
	cloudformation_facts:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# all_facts: no
		# stack_events: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# stack_resources: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# stack_template: no
		# stack_policy: no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# stack_name: # The name or id of the CloudFormation stack. Gathers facts for all stacks by default.
		# validate_certs: yes
$0
endsnippet

snippet aws_direct_connect_gateway "Manage AWS Direct Connect Gateway." b
- name: $1
	aws_direct_connect_gateway:
		amazon_asn: ${2:# amazon side asn}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # name of the dxgw to be created or deleted
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# virtual_gateway_id: # vpn gateway id of an existing virtual gateway
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# direct_connect_gateway_id: # id of an existing direct connect gateway
$0
endsnippet

snippet route53 "add or delete entries in Amazons Route53 DNS service" b
- name: $1
	route53:
		zone: ${2:# The DNS zone to modify}
		record: ${3:# The full DNS record to create or delete}
		state: ${4:present|absent|get|create|delete}
		type: ${5:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS|SOA}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# health_check: # Health check to associate with this record
		# weight: # Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# hosted_zone_id: # The Hosted Zone ID of the DNS zone to modify
		# wait_timeout: 300
		# ttl: 3600 (one hour)
		# overwrite: # Whether an existing record should be overwritten on create if values do not match
		# wait: no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# alias_hosted_zone_id: # The hosted zone identifier.
		# validate_certs: yes
		# region: # Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing
		# retry_interval: 500
		# value: # The new value when creating a DNS record.  YAML lists or multiple comma-spaced values are allowed for non-alias records.
		# alias: True|False
		# private_zone: no
		# alias_evaluate_target_health: no
		# vpc_id: # When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.
		# identifier: # Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.
		# failover: # Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY
$0
endsnippet

snippet rds_param_group "manage RDS parameter groups" b
- name: $1
	rds_param_group:
		name: ${2:# Database parameter group identifier.}
		state: ${3:#present|absent}
		# engine: aurora5.6|mariadb10.0|mariadb10.1|mysql5.1|mysql5.5|mysql5.6|mysql5.7|oracle-ee-11.2|oracle-ee-12.1|oracle-se-11.2|oracle-se-12.1|oracle-se1-11.2|oracle-se1-12.1|postgres9.3|postgres9.4|postgres9.5|postgres9.6|sqlserver-ee-10.5|sqlserver-ee-11.0|sqlserver-ex-10.5|sqlserver-ex-11.0|sqlserver-ex-12.0|sqlserver-se-10.5|sqlserver-se-11.0|sqlserver-se-12.0|sqlserver-web-10.5|sqlserver-web-11.0|sqlserver-web-12.0
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # Dictionary of tags to attach to the parameter group
		# purge_tags: # Whether or not to remove tags that do not appear in the I(tags) list. Defaults to false.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# immediate: # Whether to apply the changes immediately, or after the next reboot of any associated instances.
		# params: # Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# validate_certs: yes
		# description: # Database parameter group description. Only set when a new group is added.
$0
endsnippet

snippet ec2 "create, terminate, start or stop an instance in ec2" b
- name: $1
	ec2:
		image: ${2:# I(ami) ID to use for the instance}
		instance_type: ${3:# instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)}
		# kernel: # kernel I(eki) to use for the instance
		# monitoring: yes|no
		# user_data: # opaque blob of data which is made available to the ec2 instance
		# termination_protection: yes|no
		# private_ip: # the private ip address to assign the instance (from the vpc subnet)
		# spot_type: #one-time|persistent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# id: # identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances. This identifier is valid for at least 24 hours after the termination of the instance, and should not be reused for another call later on. For details, see the description of client token at U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
		# source_dest_check: yes|no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# spot_wait_timeout: 600
		# group: # security group (or list of groups) to use with the instance
		# zone: # AWS availability zone in which to launch the instance
		# exact_count: # An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.
		# ebs_optimized: false
		# state: #present|absent|running|restarted|stopped
		# placement_group: # placement group for the instance when using EC2 Clustered Compute
		# key_name: # key pair to use on the instance
		# ramdisk: # ramdisk I(eri) to use for the instance
		# count_tag: # Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running. This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with "class=webserver". The specified tag must already exist or be passed in as the 'instance_tags' option.
		# spot_launch_group: # Launch group for spot request, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group)
		# vpc_subnet_id: # the subnet ID in which to launch the instance (VPC)
		# instance_ids: # list of instance ids, currently used for states: absent, running, stopped
		# tenancy: #default|dedicated
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# assign_public_ip: yes|no
		# spot_price: # Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started.
		# wait: yes|#no
		# count: 1
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# instance_profile_name: # Name of the IAM instance profile to use. Boto library must be 2.5.0+
		# region: # The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# network_interfaces: # A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)
		# instance_initiated_shutdown_behavior: #stop|terminate
		# wait_timeout: 300
		# volumes: # a list of hash/dictionaries of volumes to add to the new instance; '[{"key":"value", "key":"value"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), iops (int) - device_type is deprecated use volume_type, iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.
		# instance_tags: # a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# group_id: # security group id (or list of ids) to use with the instance
		# validate_certs: yes
$0
endsnippet

snippet elasticache_snapshot "Manage cache snapshots in Amazon Elasticache." b
- name: $1
	elasticache_snapshot:
		name: ${2:# The name of the snapshot we want to create, copy, delete}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# cluster_id: # The name of an existing cache cluster in the replication group to make the snapshot.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# target: # The name of a snapshot copy
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# replication_id: # The name of the existing replication group to make the snapshot.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# bucket: # The s3 bucket to which the snapshot is exported
		# state: present|absent|copy
		# validate_certs: yes
$0
endsnippet

snippet rds_subnet_group "manage RDS database subnet groups" b
- name: $1
	rds_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# subnets: # List of subnet IDs that make up the database subnet group.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# description: # Database subnet group description. Only set when a new group is added.
$0
endsnippet

snippet aws_kms "Perform various KMS management tasks." b
- name: $1
	aws_kms:
		mode: ${2:#grant|deny}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# role_name: # Role to allow/deny access. One of C(role_name) or C(role_arn) are required.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# key_alias: # Alias label to the key. One of C(key_alias) or C(key_arn) are required.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# role_arn: # ARN of role to allow/deny access. One of C(role_name) or C(role_arn) are required.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# grant_types: # List of grants to give to user/role. Likely "role,role grant" or "role,role grant,admin". Required when C(mode=grant).
		# key_arn: # Full ARN to the key. One of C(key_alias) or C(key_arn) are required.
		# clean_invalid_entries: yes
		# validate_certs: yes
$0
endsnippet

snippet ec2_tag "create and remove tag(s) to ec2 resources." b
- name: $1
	ec2_tag:
		resource: ${2:# The EC2 resource id.}
		tags: ${3:# a hash/dictionary of tags to add to the resource; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent|list
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet elb_target_group "Manage a target group for an Application or Network load balancer" b
- name: $1
	elb_target_group:
		name: ${2:# The name of the target group.}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# protocol: http|https|tcp
		# tags: # A dictionary of one or more tags to assign to the target group.
		# purge_tags: yes|no
		# health_check_port: The port on which each target receives traffic from the load balancer.
		# successful_response_codes: # The HTTP codes to use when checking for a successful response from a target. You can specify multiple values (for example, "200,202") or a range of values (for example, "200-299").
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# health_check_interval: # The approximate amount of time, in seconds, between health checks of an individual target.
		# modify_targets: yes
		# healthy_threshold_count: # The number of consecutive health checks successes required before considering an unhealthy target healthy.
		# targets: # A list of targets to assign to the target group. This parameter defaults to an empty list. Unless you set the 'modify_targets' parameter then all existing targets will be removed from the group. The list should be an Id and a Port parameter. See the Examples for detail.
		# health_check_path: # The ping path that is the destination on the targets for health checks. The path must be defined in order to set a health check.
		# health_check_protocol: http|https|tcp
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# unhealthy_threshold_count: # The number of consecutive health check failures required before considering a target unhealthy.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# stickiness_type: lb_cookie
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# target_type: #instance|ip
		# port: # The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. Required if I(state) is C(present).
		# stickiness_lb_cookie_duration: # The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds).
		# stickiness_enabled: yes|no
		# vpc_id: # The identifier of the virtual private cloud (VPC). Required when I(state) is C(present).
		# deregistration_delay_timeout: # The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds.
		# validate_certs: yes
		# health_check_timeout: # The amount of time, in seconds, during which no response from a target means a failed health check.
$0
endsnippet

snippet elb_classic_lb "Creates or destroys Amazon ELB." b
- name: $1
	elb_classic_lb:
		name: ${2:# The name of the ELB}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# subnets: # A list of VPC subnets to use when creating ELB. Zones should be empty if using this.
		# health_check: # An associative array of health check configuration settings (see example)
		# tags: # An associative array of tags. To delete all tags, supply an empty dict.
		# purge_subnets: no
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# instance_ids: no
		# zones: # List of availability zones to enable on this ELB
		# idle_timeout: # ELB connections from clients and to servers are timed out after this amount of time
		# wait_timeout: 60
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# cross_az_load_balancing: yes|#no
		# security_group_ids: # A list of security groups to apply to the elb
		# purge_zones: no
		# wait: yes|no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# purge_instance_ids: no
		# connection_draining_timeout: # Wait a specified timeout allowing connections to drain before terminating an instance
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# listeners: # List of ports/protocols for this ELB to listen on (see example)
		# access_logs: # An associative array of access logs configuration settings (see example)
		# security_group_names: # A list of security group names to apply to the elb
		# purge_listeners: yes
		# scheme: internal|#internet-facing
		# validate_certs: #yes|no
		# stickiness: # An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )
$0
endsnippet

snippet sns_topic "Manages AWS SNS topics and subscriptions" b
- name: $1
	sns_topic:
		name: ${2:# The name or ARN of the SNS topic to converge}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# subscriptions: []
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# purge_subscriptions: yes
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# display_name: # Display name of the topic
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# delivery_policy: # Delivery policy to apply to the SNS topic
		# state: absent|#present
		# policy: # Policy to apply to the SNS topic
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sts_assume_role "Assume a role using AWS Security Token Service and obtain temporary credentials" b
- name: $1
	sts_assume_role:
		role_arn: ${2:# The Amazon Resource Name (ARN) of the role that the caller is assuming (http://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs)}
		role_session_name: ${3:# Name of the role's session - will be used by CloudTrail}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# mfa_serial_number: # The identification number of the MFA device that is associated with the user who is making the AssumeRole call.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# duration_seconds: # The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# mfa_token: # The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.
		# policy: # Supplemental policy to use in addition to assumed role's policies.
		# external_id: # A unique identifier that is used by third parties to assume a role in their customers' accounts.
$0
endsnippet

snippet s3_sync "Efficiently upload multiple files to S3" b
- name: $1
	s3_sync:
		file_root: ${2:# File/directory path for synchronization. This is a local path.}
		bucket: ${3:# Bucket name.}
		mode: ${4:#push}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# file_change_strategy: force|checksum|#date_size
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# permission: |private|public-read|public-read-write|authenticated-read|aws-exec-read|bucket-owner-read|bucket-owner-full-control
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# mime_map: # Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({".txt": "application/text", ".yml": "application/text"})

		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# exclude: .*
		# include: *
		# validate_certs: yes
		# cache_control: # This is a string.
		# key_prefix: # In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary.
		# delete: no
$0
endsnippet

snippet aws_direct_connect_link_aggregation_group "Manage Direct Connect LAG bundles." b
- name: $1
	aws_direct_connect_link_aggregation_group:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of the Direct Connect link aggregation group.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# state: present|absent
		# delete_with_disassociation: # To be used with I(state=absent) to delete connections after disassociating them with the LAG.
		# force_delete: # This allows the minimum number of links to be set to 0, any hosted connections disassociated, and any virtual interfaces associated to the LAG deleted.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# num_connections: # The number of connections with which to intialize the link aggregation group.
		# connection_id: # A connection ID to link with the link aggregation group upon creation.
		# validate_certs: yes
		# bandwidth: # The bandwidth of the link aggregation group.
		# wait_timeout: 120
		# location: # The location of the link aggregation group.
		# min_links: # The minimum number of physical connections that must be operational for the LAG itself to be operational.
		# link_aggregation_group_id: # The ID of the Direct Connect link aggregation group.
		# wait: # Whether or not to wait for the operation to complete. May be useful when waiting for virtual interfaces to be deleted. May modify the time of waiting with C(wait_timeout).
$0
endsnippet

snippet ec2_group "maintain an ec2 VPC security group." b
- name: $1
	ec2_group:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# rules_egress: # List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled. Rule Egress sources list support was added in version 2.4. In version 2.5 support for rule descriptions was added.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # Name of the security group.
		# purge_rules: true
		# tags: # A dictionary of one or more tags to assign to the security group.
		# rules: # List of firewall inbound rules to enforce in this group (see example). If none are supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to access itself). Rule sources list support was added in version 2.4. This allows to define multiple sources per source type as well as multiple source types per rule. Prior to 2.4 an individual source is allowed. In version 2.5 support for rule descriptions was added.
		# purge_tags: yes|no
		# description: # Description of the security group. Required when C(state) is C(present).
		# state: #present|absent
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# vpc_id: # ID of the VPC to create the group in.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# group_id: # Id of group to delete (works only with absent).
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# purge_rules_egress: true
$0
endsnippet

snippet aws_waf_web_acl "create and delete WAF Web ACLs" b
- name: $1
	aws_waf_web_acl:
		name: ${2:# N}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# purge_rules: # W
		# rules: # A list of rules that the Web ACL will enforce.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# metric_name: # A friendly name or description for the metrics for this WebACL
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# default_action: block|allow|count
		# validate_certs: yes
$0
endsnippet

snippet iam_policy "Manage IAM policies for users, groups, and roles" b
- name: $1
	iam_policy:
		iam_name: ${2:# Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.}
		policy_name: ${3:# The name label for the policy to create or remove.}
		iam_type: ${4:user|group|role}
		state: ${5:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# policy_document: # The path to the properly json formatted policy file (mutually exclusive with C(policy_json))
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# policy_json: # A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)
		# skip_duplicates: /
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_endpoint_facts "Retrieves AWS VPC endpoints details using AWS methods." b
- name: $1
	ec2_vpc_endpoint_facts:
		query: ${2:services|endpoints}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# vpc_endpoint_ids: # Get details of specific endpoint IDs
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_route_table "Manage route tables for AWS virtual private clouds" b
- name: $1
	ec2_vpc_route_table:
		vpc_id: ${2:# V}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# subnets: # A
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A
		# purge_tags: false
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# purge_subnets: true
		# purge_routes: true
		# route_table_id: # T
		# state: #present|absent
		# lookup: #tag|id
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# routes: # L
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# validate_certs: yes
		# propagating_vgw_ids: # E
$0
endsnippet

snippet ec2_snapshot_facts "Gather facts about ec2 volume snapshots in AWS" b
- name: $1
	ec2_snapshot_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# snapshot_ids: []
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# restorable_by_user_ids: []
		# validate_certs: yes
		# owner_ids: []
$0
endsnippet

snippet aws_s3 "manage objects in S3." b
- name: $1
	aws_s3:
		bucket: ${2:# Bucket name.}
		mode: ${3:get|put|delete|create|geturl|getstr|delobj|list}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# permission: private
		# dest: # The destination file path when downloading an object/key with a GET operation.
		# object: # Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.
		# prefix: 
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# marker: # Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.
		# ignore_nonexistent_bucket: # Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.
		# overwrite: always
		# headers: # Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# src: # The source file path when performing a PUT operation.
		# aws_access_key: # AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# encrypt: yes
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# rgw: no
		# region: # AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.
		# retries: 0
		# max_keys: 1000
		# version: # Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.
		# expiration: 600
		# s3_url: # S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS
		# metadata: # Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# validate_certs: yes
$0
endsnippet

snippet aws_api_gateway "Manage AWS API Gateway APIs" b
- name: $1
	aws_api_gateway:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# swagger_file: # JSON or YAML file containing swagger definitions for API. Exactly one of swagger_file, swagger_text or swagger_dict must be present.
		# api_id: # The ID of the API you want to manage.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# stage: # The name of the stage the API should be deployed to.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# swagger_dict: # Swagger definitions API ansible dictionary which will be converted to JSON and uploaded.
		# deploy_desc: Automatic deployment by Ansible.
		# state: #present|absent
		# swagger_text: # Swagger definitions for API in JSON or YAML as a string direct from playbook.
		# validate_certs: yes
$0
endsnippet

snippet aws_waf_facts "Retrieve facts for WAF ACLs, Rule , Conditions and Filters." b
- name: $1
	aws_waf_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of a Web Application Firewall
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# dhcp_options_ids: # Get details of specific DHCP Option ID
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_nat_gateway_facts "Retrieves AWS VPC Managed Nat Gateway details using AWS methods." b
- name: $1
	ec2_vpc_nat_gateway_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# nat_gateway_ids: # Get details of specific nat gateway IDs
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet efs "create and maintain EFS file systems" b
- name: $1
	efs:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# encrypt: yes|no
		# name: # Creation Token of Amazon EFS file system. Required for create and update. Either name or ID required for delete.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.
		# purge_tags: yes|no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# kms_key_id: # The id of the AWS KMS CMK that will be used to protect the encrypted file system. This parameter is only required if you want to use a non-default CMK. If this parameter is not specified, the default CMK for Amazon EFS is used. The key id can be Key ID, Key ID ARN, Key Alias or Key Alias ARN.
		# id: # ID of Amazon EFS. Either name or ID required for delete.
		# validate_certs: yes
		# state: #present|absent
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# performance_mode: #general_purpose|max_io
		# targets: # List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in. - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet. - security_groups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.
		# wait: yes|#no
$0
endsnippet

snippet lambda_policy "Creates, updates or deletes AWS Lambda policy statements." b
- name: $1
	lambda_policy:
		statement_id: ${2:# A unique statement identifier.}
		state: ${3:#present|absent}
		action: ${4:# The AWS Lambda action you want to allow in this statement. Each Lambda action is a string starting with lambda: followed by the API name (see Operations ). For example, lambda:CreateFunction . You can use wildcard (lambda:* ) to grant permission for all AWS Lambda actions.}
		function_name: ${5:# Name of the Lambda function whose resource policy you are updating by adding a new permission.}
		principal: ${6:# The principal who is getting this permission. It can be Amazon S3 service Principal (s3.amazonaws.com ) if you want Amazon S3 to invoke the function, an AWS account ID if you are granting cross-account permission, or any valid AWS service principal such as sns.amazonaws.com . For example, you might want to allow a custom application in another AWS account to push events to AWS Lambda by invoking your function.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# event_source_token: # Token string representing source ARN or account. Mutually exclusive with C(source_arn) or C(source_account).
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# alias: # Name of the function alias. Mutually exclusive with C(version).
		# version: # Version of the Lambda function. Mutually exclusive with C(alias).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# source_arn: # This is optional; however, when granting Amazon S3 permission to invoke your function, you should specify this field with the bucket Amazon Resource Name (ARN) as its value. This ensures that only events generated from the specified bucket can invoke the function.
		# source_account: # The AWS account ID (without a hyphen) of the source owner. For example, if the SourceArn identifies a bucket, then this is the bucket owner's account ID. You can use this additional condition to ensure the bucket you specify is owned by a specific account (it is possible the bucket owner deleted the bucket and some other AWS account created the bucket). You can also use this condition to specify all sources (that is, you don't specify the SourceArn ) owned by a specific account.
$0
endsnippet

snippet execute_lambda "Execute an AWS Lambda function" b
- name: $1
	execute_lambda:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tail_log: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# payload: {}
		# wait: yes
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN.
		# dry_run: no
		# function_arn: # The name of the function to be invoked
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# version_qualifier: LATEST
		# validate_certs: yes
$0
endsnippet

snippet elb_target "Manage a target in a target group" b
- name: $1
	elb_target:
		target_id: ${2:# The ID of the target.}
		state: ${3:present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# target_status_timeout: 60
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# target_group_name: # The name of the target group. Mutually exclusive of I(target_group_arn).
		# target_group_arn: # The Amazon Resource Name (ARN) of the target group. Mutually exclusive of I(target_group_name).
		# target_port: The default port for a target is the port for the target group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# target_status: initial|healthy|unhealthy|unused|draining|unavailable
		# deregister_unused: yes|no
		# validate_certs: yes
		# target_az: # An Availability Zone or all. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer. This parameter is not supported if the target type of the target group is instance.
$0
endsnippet

snippet elb_application_lb_facts "Gather facts about application ELBs in AWS" b
- name: $1
	elb_application_lb_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# names: # The names of the load balancers.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# load_balancer_arns: # The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load balancers in a single call.
$0
endsnippet

snippet kinesis_stream "Manage a Kinesis Stream." b
- name: $1
	kinesis_stream:
		name: ${2:# The name of the Kinesis Stream you are managing.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.
		# encryption_type: KMS
		# retention_period: # The default retention period is 24 hours and can not be less than 24 hours.
		# shards: # The number of shards you want to have with this stream.
		# encryption_state: enabled|disabled
		# state: #present|absent
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# key_id: # The GUID or alias for the KMS key.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# wait: yes
$0
endsnippet

snippet ec2_vpc_vgw_facts "Gather facts about virtual gateways in AWS" b
- name: $1
	ec2_vpc_vgw_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# vpn_gateway_ids: # Get details of a specific Virtual Gateway ID. This value should be provided as a list.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_elb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	ec2_elb_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# names: # List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet route53_zone "add or delete Route53 zones" b
- name: $1
	route53_zone:
		zone: ${2:# The DNS zone record (eg: foo.com.)}
		# comment: 
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# vpc_region: # The VPC Region the zone should be a part of (if this is going to be a private zone)
		# hosted_zone_id: # The unique zone identifier you want to delete or "all" if there are many zones with the same domain name. Required if there are multiple zones identified with the above options
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# vpc_id: # The VPC ID the zone should be a part of (if this is going to be a private zone)
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# dns_servers: # A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)
		# ntp_servers: # List of hosts to advertise as NTP servers for the VPC.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# domain_name: # The domain name to set in the DHCP option sets
		# delete_old: yes
		# state: absent|#present
		# netbios_node_type: # NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# vpc_id: # VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.
		# inherit_existing: no
		# validate_certs: yes
		# dhcp_options_id: # The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)
		# netbios_name_servers: # List of hosts to advertise as NetBIOS servers.
$0
endsnippet

snippet efs_facts "Get information about Amazon EFS file systems" b
- name: $1
	efs_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # Creation Token of Amazon EFS file system.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # List of tags of Amazon EFS. Should be defined as dictionary
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# targets: # list of targets on which to filter the returned results
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# id: # ID of Amazon EFS.
$0
endsnippet

snippet dynamodb_ttl "set TTL for a given DynamoDB table." b
- name: $1
	dynamodb_ttl:
		attribute_name: ${2:# the name of the Time to Live attribute used to store the expiration time for items in the table}
		table_name: ${3:# name of the DynamoDB table to work on}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #enable|disable
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet lambda_facts "Gathers AWS Lambda function details as Ansible facts" b
- name: $1
	lambda_facts:
		query: ${2:aliases|#all|config|mappings|policy|versions}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# event_source_arn: # For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# function_name: # The name of the lambda function for which facts are requested.
$0
endsnippet

snippet s3_website "Configure an s3 bucket as a website" b
- name: $1
	s3_website:
		name: ${2:# Name of the s3 bucket}
		# redirect_all_requests: # Describes the redirect behavior for every request to this s3 bucket website endpoint
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# suffix: index.html
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.

		# error_key: # The object key name to use when a 4XX class error occurs. To remove an error key, set to None.
		# state: #present|absent
		# validate_certs: yes
$0
endsnippet

snippet s3_lifecycle "Manage s3 bucket lifecycle rules in AWS" b
- name: $1
	s3_lifecycle:
		name: ${2:# Name of the s3 bucket}
		# status: #enabled|disabled
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# transition_days: # Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# expiration_date: # Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.

		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# prefix: # Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket.
		# state: #present|absent
		# storage_class: #glacier|standard_ia
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# expiration_days: # Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# validate_certs: yes
		# rule_id: # Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.
		# transition_date: # Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required."

$0
endsnippet

snippet iam_role_facts "Gather information on IAM roles" b
- name: $1
	iam_role_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # Name of a role to search for
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# path_prefix: # Prefix of role I(path) to restrict IAM role search for
		# validate_certs: yes
$0
endsnippet

snippet redshift_subnet_group "manage Redshift cluster subnet groups" b
- name: $1
	redshift_subnet_group:
		group_name: ${2:# Cluster subnet group name.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# state: #present|absent
		# group_subnets: # List of subnet IDs that make up the cluster subnet group.
		# group_description: # Database subnet group description.
		# validate_certs: yes
$0
endsnippet

snippet ec2_instance "Create & manage EC2 instances" b
- name: $1
	ec2_instance:
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# availability_zone: # Specify an availability zone to use the default subnet it. Useful if not specifying the I(vpc_subnet_id) parameter.
		# purge_tags: no
		# image: # An image to use for the instance. The ec2_ami_facts module may be used to retrieve images. One of I(image) or I(image_id) are required when instance is not already present.
		# vpc_subnet_id: # The subnet ID in which to launch the instance (VPC) If none is provided, ec2_instance will chose the default zone of the default VPC
		# user_data: # Opaque blob of data which is made available to the ec2 instance
		# instance_ids: # If you specify one or more instance IDs, only instances that have the specified IDs are returned.
		# tower_callback: # Preconfigured user-data to enable an instance to perform a Tower callback.
		# image_id: # I(ami) ID to use for the instance. One of I(image) or I(image_id) are required when instance is not already present.
		# termination_protection: # Whether to enable termination protection. This module will not terminate an instance with termination protection active, it must be turned off first.
		# tenancy: dedicated|default
		# launch_template: # The EC2 launch template to base instance configuration on.
		# filters: {u'subnet-id': u'<provided-or-default subnet>', u'tag:Name': u'<provided-Name-attribute>'}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_groups: # A list of security group IDs or names (strings). Mutually exclusive with I(security_group).
		# wait: yes
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# instance_role: # The ARN or name of an EC2-enabled instance role to be used. If a name is not provided in arn format then the ListInstanceProfiles permission must also be granted. U(https://docs.aws.amazon.com/IAM/latest/APIReference/API_ListInstanceProfiles.html) If no full ARN is provided, the role with a matching name will be used from the active AWS account.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# network: # Either a dictionary containing the key 'interfaces' corresponding to a list of network interface IDs or containing specifications for a single network interface.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# wait_timeout: 600
		# ebs_optimized: # Whether instance is should use optimized EBS volumes, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html)
		# cpu_credit_specification: unlimited|standard
		# instance_initiated_shutdown_behavior: stop|terminate
		# name: # The Name tag for the instance.
		# instance_type: t2.micro
		# state: #present|terminated|running|started|stopped|restarted|rebooted|absent
		# tags: # A hash/dictionary of tags to add to the new instance or to add/remove from an existing one.
		# volumes: # A list of block device mappings, by default this will always use the AMI root device so the volumes option is primarily for adding more storage.
		# key_name: # Name of the SSH access key to assign to the instance - must exist in the region the instance is created.
		# security_group: # A security group ID or name. Mutually exclusive with I(security_groups).
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# detailed_monitoring: # Whether to allow detailed cloudwatch metrics to be collected, enabling more detailed alerting.
$0
endsnippet

snippet lambda_event "Creates, updates or deletes AWS Lambda function event mappings." b
- name: $1
	lambda_event:
		source_params: ${2:# Sub-parameters required for event source.}
		lambda_function_arn: ${3:# The name or ARN of the lambda function.}
		alias: ${4:# Name of the function alias. Mutually exclusive with C(version).}
		state: ${5:#present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# event_source: #stream
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# version: # Version of the Lambda function. Mutually exclusive with C(alias).
		# validate_certs: yes
$0
endsnippet

snippet aws_elasticbeanstalk_app "create, update, and delete an elastic beanstalk application" b
- name: $1
	aws_elasticbeanstalk_app:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# description: # the description of the application
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: absent|#present
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# terminate_by_force: no
		# app_name: # name of the beanstalk application you wish to manage
$0
endsnippet

snippet ec2_snapshot_copy "copies an EC2 snapshot and returns the new Snapshot ID." b
- name: $1
	ec2_snapshot_copy:
		source_snapshot_id: ${2:# The ID of the Snapshot in source region that should be copied.}
		source_region: ${3:# The source region the Snapshot should be copied from.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# description: # An optional human-readable string describing purpose of the new Snapshot.
		# tags: # A hash/dictionary of tags to add to the new Snapshot; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# encrypted: no
		# kms_key_id: # KMS key id used to encrypt snapshot. If not specified, defaults to EBS Customer Master Key (CMK) for that account.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# wait: yes|#no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# validate_certs: yes
$0
endsnippet

snippet ec2_vol_facts "Gather facts about ec2 volumes in AWS" b
- name: $1
	ec2_vol_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet lambda_alias "Creates, updates or deletes AWS Lambda function aliases." b
- name: $1
	lambda_alias:
		name: ${2:# Name of the function alias.}
		state: ${3:#present|absent}
		function_name: ${4:# The name of the function alias.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# description: # A short, user-defined function alias description.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# version: # Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_elb "De-registers or registers instances from EC2 ELBs" b
- name: $1
	ec2_elb:
		instance_id: ${2:# EC2 Instance ID}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# wait: yes|no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_elbs: # List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.
		# validate_certs: #yes|no
		# enable_availability_zone: yes|no
$0
endsnippet

snippet elb_instance "De-registers or registers instances from EC2 ELBs" b
- name: $1
	elb_instance:
		instance_id: ${2:# EC2 Instance ID}
		state: ${3:present|absent}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# wait: yes|no
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_elbs: # List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.
		# validate_certs: #yes|no
		# enable_availability_zone: yes|no
$0
endsnippet

snippet ecs_cluster "create or terminate ecs clusters" b
- name: $1
	ecs_cluster:
		name: ${2:# The cluster name}
		state: ${3:present|absent|has_instances}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# repeat: # The number of times to wait for the cluster to have an instance
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# delay: # Number of seconds to wait
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_win_password "gets the default administrator password for ec2 windows instances" b
- name: $1
	ec2_win_password:
		instance_id: ${2:# The instance id to get the password data from.}
		key_file: ${3:# Path to the file containing the key pair used on the instance.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# key_passphrase: # The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) C(openssl rsa -in current_key -out new_key -des3).
		# wait_timeout: 120
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# wait: yes|#no
$0
endsnippet

snippet elasticache_subnet_group "manage Elasticache subnet groups" b
- name: $1
	elasticache_subnet_group:
		name: ${2:# Database subnet group identifier.}
		state: ${3:#present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# subnets: # List of subnet IDs that make up the Elasticache subnet group.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# description: # Elasticache subnet group description. Only set when a new group is added.
$0
endsnippet

snippet cloudwatchlogs_log_group "create or delete log_group in CloudWatchLogs" b
- name: $1
	cloudwatchlogs_log_group:
		log_group_name: ${2:# The name of the log group.}
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# tags: # The key-value pairs to use for the tags.
		# kms_key_id: # The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# overwrite: no
		# retention: # The number of days to retain the log events in the specified log group. Valid values are: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# validate_certs: yes
$0
endsnippet

snippet ecs_task "run, start or stop a task in ecs" b
- name: $1
	ecs_task:
		operation: ${2:run|start|stop}
		# count: # How many new instances to start
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# task: # The task to stop
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# overrides: # A dictionary of values to pass to the new instances
		# started_by: # A value showing who or what started the task (for informational purposes)
		# cluster: # The name of the cluster to run the task on
		# task_definition: # The task definition to start or run
		# container_instances: # The list of container instances on which to deploy the task
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_cert "Manage server certificates for use on ELBs and CloudFront" b
- name: $1
	iam_cert:
		name: ${2:# Name of certificate to add, update or remove.}
		state: ${3:present|absent}
		# new_name: # When state is present, this will update the name of the cert.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# dup_ok: no
		# new_path: # When state is present, this will update the path of the cert.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# cert: # The path to, or content of the certificate body in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# key: # The path to, or content of the private key in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# path: /
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# validate_certs: yes
		# cert_chain: # The path to, or content of the CA certificate chain in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
$0
endsnippet

snippet ec2_customer_gateway "Manage an AWS customer gateway" b
- name: $1
	ec2_customer_gateway:
		name: ${2:# Name of the customer gateway.}
		ip_address: ${3:# Internet-routable IP address for customers gateway, must be a static address.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# state: #present|absent
		# routing: static|#dynamic
		# bgp_asn: # Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.
$0
endsnippet

snippet sns "Send Amazon Simple Notification Service (SNS) messages" b
- name: $1
	sns:
		topic: ${2:# The topic you want to publish to.}
		msg: ${3:# Default message to send.}
		message_structure: ${4:#json|string}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# http: # Message to send to HTTP-only subscription
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# sqs: # Message to send to SQS-only subscription
		# region: # The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.
		# sms: # Message to send to SMS-only subscription
		# https: # Message to send to HTTPS-only subscription
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# message_attributes: # Dictionary of message attributes. These are optional structured data entries to be sent along to the endpoint.
		# validate_certs: yes
		# email: # Message to send to email-only subscription
		# subject: # Subject line for email delivery.
$0
endsnippet

snippet ec2_vpc_endpoint "Create and delete AWS VPC Endpoints." b
- name: $1
	ec2_vpc_endpoint:
		# policy_file: # The path to the properly json formatted policy file, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813) on how to use it properly. Cannot be used with I(policy).
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# service: # An AWS supported vpc endpoint service. Use the ec2_vpc_endpoint_facts module to describe the supported endpoint services.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# vpc_endpoint_id: # One or more vpc endpoint ids to remove from the AWS account
		# wait_timeout: 320
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# policy: # A properly formatted json policy as string, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813). Cannot be used with I(policy_file).
		# vpc_id: # Required when creating a VPC endpoint.
		# client_token: # Optional client token to ensure idempotency
		# validate_certs: yes
		# route_table_ids: # List of one or more route table ids to attach to the endpoint. A route is added to the route table with the destination of the endpoint if provided.
		# wait: yes|no
$0
endsnippet

snippet ec2_asg_facts "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS" b
- name: $1
	ec2_asg_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # The prefix or name of the auto scaling group(s) you are searching for.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# tags: # A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.

		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vpc_egress_igw "Manage an AWS VPC Egress Only Internet gateway" b
- name: $1
	ec2_vpc_egress_igw:
		vpc_id: ${2:# The VPC ID for the VPC that this Egress Only Internet Gateway should be attached.}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_s3_cors "Manage CORS for S3 buckets in AWS" b
- name: $1
	aws_s3_cors:
		name: ${2:# Name of the s3 bucket}
		state: ${3:present|absent}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# rules: # Cors rules to put on the s3 bucket
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_lc_find "Find AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_find:
		region: ${2:# The AWS region to use.}
		name_regex: ${3:# A Launch Configuration to match}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# sort_order: #ascending|descending
		# limit: # How many results to show.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet aws_kms_facts "Gather facts about AWS KMS keys" b
- name: $1
	aws_kms_facts:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. The filters aren't natively supported by boto3, but are supported to provide similar functionality to other modules. Standard tag filters (C(tag-key), C(tag-value) and C(tag:tagName)) are available, as are C(key-id) and C(alias)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# pending_deletion: no
		# validate_certs: yes
$0
endsnippet

snippet ecs_taskdefinition_facts "describe a task definition in ecs" b
- name: $1
	ecs_taskdefinition_facts:
		task_definition: ${2:# The name of the task definition to get details for}
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# validate_certs: yes
$0
endsnippet

snippet ec2_vol "create and attach a volume, return volume id and device map" b
- name: $1
	ec2_vol:
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# name: # volume Name tag if you wish to attach an existing volume (requires instance)
		# zone: # zone in which to create the volume, if unset uses the zone the instance is in (if set)
		# instance: # instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.
		# encrypted: no
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# kms_key_id: # Specify the id of the KMS key to use.
		# volume_type: standard
		# device_name: # device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.
		# volume_size: # size of volume (in GB) to create.
		# state: absent|#present|list
		# iops: 100
		# snapshot: # snapshot ID on which to base the volume
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# id: # volume id if you wish to attach an existing volume (requires instance) or remove an existing volume
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: #yes|no
		# delete_on_termination: yes|#no
		# tags: {}
$0
endsnippet

snippet profitbricks_datacenter "Create or destroy a ProfitBricks Virtual Datacenter." b
- name: $1
	profitbricks_datacenter:
		name: ${2:# The name of the virtual datacenter.}
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# state: #present|absent
		# wait_timeout: 600
		# location: #us/las|de/fra|de/fkb
		# wait: #yes|no
		# description: # The description of the virtual datacenter.
$0
endsnippet

snippet profitbricks_nic "Create or Remove a NIC." b
- name: $1
	profitbricks_nic:
		datacenter: ${2:# The datacenter in which to operate.}
		lan: ${3:# The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.}
		name: ${4:# The name or ID of the NIC. This is only required on deletes, but not on create.}
		server: ${5:# The server name or ID.}
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# state: #present|absent
		# wait_timeout: 600
		# wait: #yes|no
$0
endsnippet

snippet profitbricks "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine." b
- name: $1
	profitbricks:
		image: ${2:# The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.}
		name: ${3:# The name of the virtual machine.}
		# lan: 1
		# image_password: # Password set for the administrative user.
		# bus: IDE|#VIRTIO
		# ram: 2048
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait_timeout: 600
		# assign_public_ip: no
		# wait: #yes|no
		# count: 1
		# datacenter: # The datacenter to provision this virtual machine.
		# remove_boot_volume: #yes|no
		# ssh_keys: # Public SSH keys allowing access to the virtual machine.
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# cpu_family: #AMD_OPTERON|INTEL_XEON
		# volume_size: 10
		# state: running|stopped|absent|#present
		# location: #us/las|de/fra|de/fkb
		# auto_increment: yes|no
		# cores: 2
$0
endsnippet

snippet profitbricks_volume_attachments "Attach or detach a volume." b
- name: $1
	profitbricks_volume_attachments:
		datacenter: ${2:# The datacenter in which to operate.}
		server: ${3:# The name of the server you wish to detach or attach the volume.}
		volume: ${4:# The volume name or ID.}
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# state: #present|absent
		# wait_timeout: 600
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: #yes|no
$0
endsnippet

snippet profitbricks_volume "Create or destroy a volume." b
- name: $1
	profitbricks_volume:
		image: ${2:# The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.}
		datacenter: ${3:# The datacenter in which to create the volumes.}
		name: ${4:# The name of the volumes. You can enumerate the names using auto_increment.}
		# image_password: # Password set for the administrative user.
		# licence_type: LINUX|WINDOWS|#UNKNOWN|OTHER
		# bus: IDE|#VIRTIO
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait_timeout: 600
		# disk_type: #HDD|SSD
		# wait: #yes|no
		# count: 1
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# state: #present|absent
		# auto_increment: yes|no
		# size: 10
		# ssh_keys: # Public SSH keys allowing access to the virtual machine.
$0
endsnippet

snippet azure_rm_resourcegroup_facts "Get resource group facts." b
- name: $1
	azure_rm_resourcegroup_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Limit results to a specific resource group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_dnsrecordset_facts "Get DNS Record Set facts." b
- name: $1
	azure_rm_dnsrecordset_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# resource_group: # Limit results by resource group. Required when filtering by name or type.
		# cloud_environment: AzureCloud
		# top: 100
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cert_validation_mode: validate|ignore
		# relative_name: # Only show results for a Record Set.
		# record_type: # Limit record sets by record type.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# zone_name: # Limit results by zones. Required when filtering by name or type.
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_loadbalancer_facts "Get load balancer facts." b
- name: $1
	azure_rm_loadbalancer_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Limit results to a specific resource group.
		# resource_group: # The resource group to search for the desired load balancer
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_storageaccount "Manage Azure storage accounts." b
- name: $1
	azure_rm_storageaccount:
		resource_group: ${2:# Name of the resource group to use.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# kind: #Storage|BlobStorage
		# account_type: Premium_LRS|Standard_GRS|Standard_LRS|Standard_RAGRS|Standard_ZRS
		# custom_domain: # User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# cloud_environment: AzureCloud
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# state: absent|#present
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# location: resource_group location
		# access_tier: Hot|Cool
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# name: # Name of the storage account to update or create.
$0
endsnippet

snippet azure_rm_containerregistry "Manage an Azure Container Registry." b
- name: $1
	azure_rm_containerregistry:
		resource_group: ${2:# Name of a resource group where the Container Registry exists or will be created.}
		name: ${3:# Name of the Container Registry.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# admin_user_enabled: no
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# sku: Basic|#Standard|Premium
		# append_tags: yes
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# state: absent|#present
		# location: resource_group location
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_dnszone "Manage Azure DNS zones." b
- name: $1
	azure_rm_dnszone:
		name: ${2:# name of the DNS Zone.}
		resource_group: ${3:# name of resource group.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# append_tags: yes
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# state: absent|#present
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_sqlserver "Manage SQL Server instance" b
- name: $1
	azure_rm_sqlserver:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the server.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# identity: # The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resour ce. Possible values include: 'SystemAssigned'
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# append_tags: yes
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# admin_username: # Administrator username for the server. Once created it cannot be changed.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# version: # The version of the server. For example '12.0'.
		# location: # Resource location.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# admin_password: # The administrator login password (required for server creation).
$0
endsnippet

snippet azure_rm_virtualmachine_extension "Managed Azure Virtual Machine extension" b
- name: $1
	azure_rm_virtualmachine_extension:
		resource_group: ${2:# Name of a resource group where the vm extension exists or will be created.}
		name: ${3:# Name of the vm extension}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cert_validation_mode: validate|ignore
		# cloud_environment: AzureCloud
		# state: absent|#present
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: resource_group location
		# protected_settings: # Json formatted protected settings for the extension.
		# subscription_id: # Your Azure subscription Id.
		# type_handler_version: # The type version of the extension handler.
		# profile: # Security profile found in ~/.azure/credentials file.
		# auto_upgrade_minor_version: # Whether the extension handler should be automatically upgraded across minor versions.
		# virtual_machine_extension_type: # The type of the extension handler.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# virtual_machine_name: # The name of the virtual machine where the extension should be create or updated.
		# publisher: # The name of the extension handler publisher.
		# settings: # Json formatted public settings for the extension.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_acs "Manage an Azure Container Service Instance (ACS)." b
- name: $1
	azure_rm_acs:
		resource_group: ${2:# Name of a resource group where the Container Services exists or will be created.}
		diagnostics_profile: ${3:# Should VM Diagnostics be enabled for the Container Service VM's.}
		master_profile: ${4:# Master profile suboptions.}
		orchestration_platform: ${5:# Specifies the Container Orchestration Platform to use. Currently can be either DCOS, Kubernetes or Swarm.}
		linux_profile: ${6:# The linux profile suboptions.}
		agent_pool_profiles: ${7:# The agent pool profile suboptions.}
		name: ${8:# Name of the Container Services instance.}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cert_validation_mode: validate|ignore
		# append_tags: yes
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# location: resource_group location
		# subscription_id: # Your Azure subscription Id.
		# service_principal: # The service principal suboptions.
		# profile: # Security profile found in ~/.azure/credentials file.
		# state: absent|#present
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_networkinterface_facts "Get network interface facts." b
- name: $1
	azure_rm_networkinterface_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific network interface.
		# resource_group: # Name of the resource group containing the network interface(s). Required when searching by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_dnsrecordset "Create, delete and update DNS record sets and records." b
- name: $1
	azure_rm_dnsrecordset:
		resource_group: ${2:# name of resource group}
		record_type: ${3:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		relative_name: ${4:# relative name of the record set}
		zone_name: ${5:# name of the existing DNS zone in which to manage the record set}
		# profile: # Security profile found in ~/.azure/credentials file.
		# api_profile: #latest
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# record_mode: append|#purge
		# state: absent|#present
		# records: # list of records to be created depending on the type of record (set)
		# time_to_live: 3600
		# auth_source: #auto|cli|credential_file|env
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_storageblob "Manage blob containers and blob objects." b
- name: $1
	azure_rm_storageblob:
		resource_group: ${2:# Name of the resource group to use.}
		container: ${3:# Name of a blob container within the storage account.}
		storage_account_name: ${4:# Name of the storage account to use.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# force: no
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# dest: # Destination file path. Use with state 'present' to download a blob.
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# content_language: # Set the blob content-language header.
		# content_type: # Set the blob content-type header. For example, 'image/png'.
		# cert_validation_mode: validate|ignore
		# public_access: container|blob
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# src: # Source file path. Use with state 'present' to upload a blob.
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# blob_type: #block|page
		# state: absent|#present
		# blob: # Name of a blob object within the container.
		# auth_source: #auto|cli|credential_file|env
		# content_md5: # Set the blob md5 hash value.
		# subscription_id: # Your Azure subscription Id.
		# content_disposition: # Set the blob content-disposition header.
		# cache_control: # Set the blob cache-control header.
		# content_encoding: # Set the blob encoding header.
$0
endsnippet

snippet azure_rm_publicipaddress_facts "Get public IP facts." b
- name: $1
	azure_rm_publicipaddress_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific Public IP.
		# resource_group: # Limit results by resource group. Required when using name parameter.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_virtualmachineimage_facts "Get virtual machine image facts." b
- name: $1
	azure_rm_virtualmachineimage_facts:
		location: ${2:# Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# offer: # Name of an image offering. Combine with sku to see a list of available image versions.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# sku: # Image offering SKU. Combine with offer to see a list of available versions.
		# publisher: # Name of an image publisher. List image offerings associated with a particular publisher.
		# name: # Only show results for a specific security group.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# version: # Specific version number of an image.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset_facts "Get Virtual Machine Scale Set facts" b
- name: $1
	azure_rm_virtualmachine_scaleset_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Limit results to a specific virtual machine scale set
		# resource_group: # The resource group to search for the desired virtual machine scale set
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_functionapp "Manage Azure Function Apps" b
- name: $1
	azure_rm_functionapp:
		name: ${2:# Name of the Azure Function App}
		resource_group: ${3:# Name of resource group}
		# profile: # Security profile found in ~/.azure/credentials file.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# state: absent|#present
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_managed_disk "Manage Azure Manage Disks" b
- name: $1
	azure_rm_managed_disk:
		resource_group: ${2:# Name of a resource group where the managed disk exists or will be created.}
		name: ${3:# Name of the managed disk.}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# managed_by: # Name of an existing virtual machine with which the disk is or will be associated, this VM should be in the same resource group.
		# cert_validation_mode: validate|ignore
		# source_resource_uri: # The resource ID of the managed disk to copy when I(create_option) is C(copy).
		# append_tags: yes
		# cloud_environment: AzureCloud
		# state: absent|#present
		# storage_account_type: Standard_LRS|Premium_LRS
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: resource_group location
		# subscription_id: # Your Azure subscription Id.
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Tags to assign to the managed disk.
		# source_uri: # URI to a valid VHD file to be used when I(create_option) is C(import).
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# create_option: empty|import|copy
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# disk_size_gb: # Size in GB of the managed disk to be created. If I(create_option) is C(copy) then the value must be greater than or equal to the source's size.
		# auth_source: #auto|cli|credential_file|env
		# os_type: linux|windows
$0
endsnippet

snippet azure_rm_virtualnetwork "Manage Azure virtual networks." b
- name: $1
	azure_rm_virtualnetwork:
		name: ${2:# name of the virtual network.}
		resource_group: ${3:# name of resource group.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# dns_servers: # Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# cloud_environment: AzureCloud
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# cert_validation_mode: validate|ignore
		# state: absent|#present
		# auth_source: #auto|cli|credential_file|env
		# address_prefixes_cidr: # List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# purge_address_prefixes: no
		# purge_dns_servers: no
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# location: resource_group location
$0
endsnippet

snippet azure_rm_storageaccount_facts "Get storage account facts." b
- name: $1
	azure_rm_storageaccount_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific account.
		# resource_group: # Limit results to a resource group. Required when filtering by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_resourcegroup "Manage Azure resource groups." b
- name: $1
	azure_rm_resourcegroup:
		name: ${2:# Name of the resource group.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# force: no
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# cloud_environment: AzureCloud
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# state: absent|#present
		# location: # Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_availabilityset "Manage Azure availability set." b
- name: $1
	azure_rm_availabilityset:
		resource_group: ${2:# Name of a resource group where the availability set exists or will be created.}
		name: ${3:# Name of the availability set.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# sku: #Classic|Aligned
		# append_tags: yes
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# platform_update_domain_count: 5
		# platform_fault_domain_count: 3
		# state: absent|#present
		# location: resource_group location
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_containerinstance "Manage an Azure Container Instance." b
- name: $1
	azure_rm_containerinstance:
		resource_group: ${2:# Name of resource group.}
		name: ${3:# The name of the container group.}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cert_validation_mode: validate|ignore
		# registry_password: # The password to log in container image registry server.
		# cloud_environment: AzureCloud
		# state: absent|#present
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: # Valid azure location. Defaults to location of the resource group.
		# subscription_id: # Your Azure subscription Id.
		# containers: # List of containers.
		# profile: # Security profile found in ~/.azure/credentials file.
		# registry_login_server: # The container image registry login server.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# ip_address: public|none
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# registry_username: # The username to log in container image registry server.
		# force_update: no
		# auth_source: #auto|cli|credential_file|env
		# os_type: #linux|windows
		# ports: # List of ports exposed within the container group.
$0
endsnippet

snippet azure_rm_mysqldatabase "Manage MySQL Database instance." b
- name: $1
	azure_rm_mysqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the database.}
		server_name: ${4:# The name of the server.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# force_update: no
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# collation: # The collation of the database. Check MySQL documentation for possible values.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# charset: # The charset of the database. Check MySQL documentation for possible values.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_mysqlserver "Manage MySQL Server instance." b
- name: $1
	azure_rm_mysqlserver:
		name: ${2:# The name of the server.}
		resource_group: ${3:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# sku: # The SKU (pricing tier) of the server.
		# profile: # Security profile found in ~/.azure/credentials file.
		# cloud_environment: AzureCloud
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# storage_mb: # The maximum storage allowed for a server.
		# admin_username: # The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
		# api_profile: #latest
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# version: 5.6|5.7
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# enforce_ssl: no
		# admin_password: # The password of the administrator login.
$0
endsnippet

snippet azure_rm_sqlserver_facts "Get SQL Server facts." b
- name: $1
	azure_rm_sqlserver_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# server_name: # The name of the server.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_virtualmachine "Manage Azure virtual machines." b
- name: $1
	azure_rm_virtualmachine:
		resource_group: ${2:# Name of the resource group containing the virtual machine.}
		image: ${3:# Specifies the image used to build the VM.}
		name: ${4:# Name of the virtual machine.}
		# virtual_network_resource_group: # When creating a virtual machine, if a specific virtual network from another resource group should be used, use this parameter to specify the resource group to use.
		# storage_container_name: vhds
		# allocated: yes
		# ssh_password_enabled: yes
		# availability_set: # Name or ID of an existing availability set to add the VM to. The availability_set should be in the same resource group as VM.
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# state: absent|#present
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# subnet_name: # When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead.
		# location: # Valid Azure location. Defaults to location of the resource group.
		# admin_password: # Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.
		# virtual_network_name: # When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# storage_blob_name: # Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# restarted: no
		# api_profile: #latest
		# os_type: [Windows, #Linux
		# public_ip_allocation_method: [Dynamic, #Static
		# managed_disk_type: Standard_LRS|Premium_LRS
		# ssh_public_keys: # For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.
		# remove_on_absent: [u'all']
		# cloud_environment: AzureCloud
		# short_hostname: # Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.
		# started: yes
		# cert_validation_mode: validate|ignore
		# network_interface_names: # List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist.
		# subscription_id: # Your Azure subscription Id.
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# open_ports: # If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.
		# plan: # A dictionary describing a third-party billing plan for an instance
		# auth_source: #auto|cli|credential_file|env
		# vm_size: # A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices. Required when creating a VM.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# admin_username: # Admin username used to access the host after it is created. Required when creating a VM.
		# custom_data: # Data which is made available to the virtual machine and used by e.g., cloud-init.
		# storage_account_name: # Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.
		# data_disks: # Describes list of data disks.
		# os_disk_caching: #ReadOnly|ReadWrite
$0
endsnippet

snippet azure_rm_keyvaultsecret "Use Azure KeyVault Secrets." b
- name: $1
	azure_rm_keyvaultsecret:
		keyvault_uri: ${2:# URI of the keyvault endpoint.}
		secret_name: ${3:# Name of the keyvault secret.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# cloud_environment: AzureCloud
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# state: absent|#present
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# secret_value: # Secret to be secured by keyvault.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_postgresqldatabase "Manage PostgreSQL Database instance." b
- name: $1
	azure_rm_postgresqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the database.}
		server_name: ${4:# The name of the server.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# force_update: no
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# collation: # The collation of the database. Check PostgreSQL documentation for possible values.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# charset: # The charset of the database. Check PostgreSQL documentation for possible values.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_dnszone_facts "Get DNS zone facts." b
- name: $1
	azure_rm_dnszone_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific zone.
		# resource_group: # Limit results by resource group. Required when filtering by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# append_tags: yes
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_securitygroup_facts "Get security group facts." b
- name: $1
	azure_rm_securitygroup_facts:
		resource_group: ${2:# Name of the resource group to use.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific security group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_virtualnetwork_facts "Get virtual network facts." b
- name: $1
	azure_rm_virtualnetwork_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific security group.
		# resource_group: # Limit results by resource group. Required when filtering by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_functionapp_facts "Get Azure Function App facts" b
- name: $1
	azure_rm_functionapp_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Only show results for a specific Function App
		# resource_group: # Limit results to a resource group. Required when filtering by name
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_deployment "Create or destroy Azure Resource Manager template deployments" b
- name: $1
	azure_rm_deployment:
		resource_group_name: ${2:# The resource group name to use or create to host the deployed template}
		# deployment_name: ansible-arm
		# wait_for_deployment_polling_period: 10
		# cloud_environment: AzureCloud
		# wait_for_deployment_completion: yes|no
		# cert_validation_mode: validate|ignore
		# parameters: # A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'parameters_link'. Either one of them is required if "state" parameter is "present".
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# state: #present|absent
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: westus
		# template: # A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if "state" parameter is "present".
		# subscription_id: # Your Azure subscription Id.
		# profile: # Security profile found in ~/.azure/credentials file.
		# template_link: # Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if "state" parameter is "present".
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# deployment_mode: complete|#incremental
		# parameters_link: # Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if "state" parameter is "present".
		# auth_source: #auto|cli|credential_file|env
$0
endsnippet

snippet azure_rm_subnet "Manage Azure subnets." b
- name: $1
	azure_rm_subnet:
		resource_group: ${2:# Name of resource group.}
		virtual_network_name: ${3:# Name of an existing virtual network with which the subnet is or will be associated.}
		name: ${4:# Name of the subnet.}
		address_prefix_cidr: ${5:# CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# security_group_name: # Name of an existing security group with which to associate the subnet.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# state: absent|#present
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_networkinterface "Manage Azure network interfaces." b
- name: $1
	azure_rm_networkinterface:
		resource_group: ${2:# Name of a resource group where the network interface exists or will be created.}
		subnet_name: ${3:# Name of an existing subnet within the specified virtual network. Required when creating a network interface}
		virtual_network_name: ${4:# Name or id of an existing virtual network with which the network interface will be associated. Required when creating a network interface.}
		name: ${5:# Name of the network interface.}
		# public_ip_allocation_method: #Dynamic|Static
		# public_ip: yes
		# cert_validation_mode: validate|ignore
		# ip_configurations: # List of ip configuration if contains mutilple configuration, should contain configuration object include field private_ip_address, private_ip_allocation_method, public_ip_address_name, public_ip, subnet_name, virtual_network_name, public_ip_allocation_method, name
		# public_ip_address_name: # (Deprecate) Name of an existing public IP address object to associate with the security group.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# append_tags: yes
		# cloud_environment: AzureCloud
		# state: absent|#present
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: resource_group location
		# subscription_id: # Your Azure subscription Id.
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# security_group_name: # Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created.
		# private_ip_allocation_method: #Dynamic|Static
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# open_ports: # When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# private_ip_address: # (Deprecate) Valid IPv4 address that falls within the specified subnet.
		# auth_source: #auto|cli|credential_file|env
		# os_type: Windows|#Linux
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset "Manage Azure virtual machine scale sets." b
- name: $1
	azure_rm_virtualmachine_scaleset:
		resource_group: ${2:# Name of the resource group containing the virtual machine scale set.}
		image: ${3:# Specifies the image used to build the VM.}
		vm_size: ${4:# A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices.}
		capacity: ${5:# Capacity of VMSS.}
		name: ${6:# Name of the virtual machine.}
		# load_balancer: # Load balancer name.
		# profile: # Security profile found in ~/.azure/credentials file.
		# admin_password: # Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# virtual_network_name: # Virtual Network name.
		# cloud_environment: AzureCloud
		# upgrade_policy: Manual|Automatic
		# managed_disk_type: Standard_LRS|Premium_LRS
		# ssh_public_keys: # For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# tier: Basic|Standard
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# ssh_password_enabled: yes
		# subscription_id: # Your Azure subscription Id.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# remove_on_absent: [u'all']
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# admin_username: # Admin username used to access the host after it is created. Required when creating a VM.
		# state: absent|#present
		# subnet_name: # Subnet name.
		# location: # Valid Azure location. Defaults to location of the resource group.
		# auth_source: #auto|cli|credential_file|env
		# os_type: [Windows, #Linux
		# data_disks: # Describes list of data disks.
		# os_disk_caching: #ReadOnly|ReadWrite
$0
endsnippet

snippet azure_rm_managed_disk_facts "Get managed disk facts." b
- name: $1
	azure_rm_managed_disk_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Limit results to a specific managed disk
		# resource_group: # Limit results to a specific resource group
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_postgresqlserver "Manage PostgreSQL Server instance." b
- name: $1
	azure_rm_postgresqlserver:
		name: ${2:# The name of the server.}
		resource_group: ${3:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# sku: # The SKU (pricing tier) of the server.
		# profile: # Security profile found in ~/.azure/credentials file.
		# cloud_environment: AzureCloud
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# storage_mb: # The maximum storage allowed for a server.
		# admin_username: # The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
		# api_profile: #latest
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# version: 9.5|9.6
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# enforce_ssl: no
		# admin_password: # The password of the administrator login.
$0
endsnippet

snippet azure_rm_keyvaultkey "Use Azure KeyVault keys." b
- name: $1
	azure_rm_keyvaultkey:
		key_name: ${2:# Name of the keyvault key.}
		keyvault_uri: ${3:# URI of the keyvault endpoint.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# pem_password: # PEM password.
		# state: absent|#present
		# pem_file: # PEM file.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# append_tags: yes
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# byok_file: # BYOK file.
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_keyvault "Manage Key Vault instance." b
- name: $1
	azure_rm_keyvault:
		resource_group: ${2:# The name of the Resource Group to which the server belongs.}
		vault_name: ${3:# Name of the vault}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# enabled_for_deployment: # Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault.
		# cert_validation_mode: validate|ignore
		# access_policies: # An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID.
		# sku: # SKU details
		# cloud_environment: AzureCloud
		# state: absent|#present
		# enabled_for_template_deployment: # Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# subscription_id: # Your Azure subscription Id.
		# profile: # Security profile found in ~/.azure/credentials file.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# auth_source: #auto|cli|credential_file|env
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# vault_tenant: # The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
		# recover_mode: # Create vault in recovery mode.
		# enabled_for_disk_encryption: # Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
		# api_profile: #latest
		# enable_soft_delete: # Property to specify whether the soft delete functionality is enabled for this key vault.
$0
endsnippet

snippet azure_rm_publicipaddress "Manage Azure Public IP Addresses." b
- name: $1
	azure_rm_publicipaddress:
		resource_group: ${2:# Name of resource group with which the Public IP is associated.}
		name: ${3:# Name of the Public IP.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# domain_name_label: # The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# allocation_method: #Dynamic|Static
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# append_tags: yes
		# cloud_environment: AzureCloud
		# state: absent|#present
		# cert_validation_mode: validate|ignore
		# location: resource_group location
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
$0
endsnippet

snippet azure_rm_availabilityset_facts "Get availability set facts." b
- name: $1
	azure_rm_availabilityset_facts:
		# profile: # Security profile found in ~/.azure/credentials file.
		# name: # Limit results to a specific availability set
		# resource_group: # The resource group to search for the desired availability set
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# cert_validation_mode: validate|ignore
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
$0
endsnippet

snippet azure_rm_loadbalancer "Manage Azure load balancers." b
- name: $1
	azure_rm_loadbalancer:
		resource_group: ${2:# Name of a resource group where the load balancer exists or will be created.}
		name: ${3:# Name of the load balancer.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# probe_port: # (deprecated) The port that the health probe will use.
		# append_tags: yes
		# load_balancing_rules: # Object collection representing the load balancing rules Gets the provisioning.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# natpool_protocol: # (deprecated) The protocol for the NAT pool.
		# inbound_nat_pools: # Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer.
		# idle_timeout: 4
		# probe_interval: 15
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# probe_protocol: Tcp|Http
		# load_distribution: Default|SourceIP|SourceIPProtocol
		# frontend_port: # (deprecated) Frontend port that will be exposed for the load balancer.
		# backend_port: # (deprecated) Backend port that will be exposed for the load balancer.
		# probes: # L
		# public_ip_address_name: # (deprecated) Name of an existing public IP address object to associate with the security group.
		# probe_fail_count: 3
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# natpool_frontend_port_end: # (deprecated) End of the port range for a NAT pool.
		# natpool_backend_port: # (deprecated) Backend port used by the NAT pool.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# backend_address_pools: # L
		# natpool_frontend_port_start: # (deprecated) Start of the port range for a NAT pool.
		# protocol: Tcp|Udp
		# frontend_ip_configurations: # L
		# cert_validation_mode: validate|ignore
		# state: absent|#present
		# location: resource_group location
		# probe_request_path: # (deprecated) The URL that an HTTP probe will use (only relevant if probe_protocol is set to Http).
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_sqldatabase "Manage SQL Database instance." b
- name: $1
	azure_rm_sqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the database to be operated on (updated or created).}
		server_name: ${4:# The name of the server.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# cloud_environment: AzureCloud
		# recovery_services_recovery_point_resource_id: # Required if I(create_mode) is C(restore_long_term_retention_backup), then this value is required. Specifies the resource ID of the recovery point to restore from.
		# edition: web|business|basic|standard|premium|free|stretch|data_warehouse|system|system2
		# elastic_pool_name: # The name of the elastic pool the database is in. Not supported for C(data_warehouse) edition.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# max_size_bytes: # The max size of the database expressed in bytes. If I(create_mode) is not C(default), this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: 'Capabilities_ListByLocation.'
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# zone_redundant: no
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# restore_point_in_time: # Required if I(create_mode) is C(point_in_time_restore), this value is required. If I(create_mode) is C(restore), this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database's earliestRestoreDate value.
		# create_mode: copy|default|non_readable_secondary|online_secondary|point_in_time_restore|recovery|restore|restore_long_term_retention_backup
		# source_database_deletion_date: # Required if I(create_mode) is C(restore) and I(source_database_id) is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
		# force_update: # SQL Database will be updated if given parameters differ from existing resource state.
		# collation: # The collation of the database. If I(create_mode) is not C(default), this value is ignored.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# source_database_id: # Required unless I(create_mode) is C(default) or C(restore_long_term_retention_backup).
		# state: absent|#present
		# location: # Resource location. If not set, location from the resource group will be used as C(default).
		# sample_name: adventure_works_lt
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# read_scale: no
		# api_profile: #latest
$0
endsnippet

snippet azure_rm_image "Manage Azure image." b
- name: $1
	azure_rm_image:
		resource_group: ${2:# Name of resource group.}
		name: ${3:# Name of the image.}
		source: ${4:# OS disk source from the same region, including a virtual machine id or name, OS disk blob uri, managed OS disk id or name, or OS snapshot id or name.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# subscription_id: # Your Azure subscription Id.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# api_profile: #latest
		# append_tags: yes
		# cloud_environment: AzureCloud
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# data_disk_sources: # List of data disk sources, including unmanaged blob uri, managed disk id or name, or snapshot id or name.
		# state: absent|#present
		# location: # Location of the image. Derived from I(resource_group) if not specified.
		# auth_source: #auto|cli|credential_file|env
		# os_type: Windows|Linux
$0
endsnippet

snippet azure_rm_securitygroup "Manage Azure network security groups." b
- name: $1
	azure_rm_securitygroup:
		resource_group: ${2:# Name of the resource group the security group belongs to.}
		# profile: # Security profile found in ~/.azure/credentials file.
		# purge_rules: no
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# rules: # Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.
		# cloud_environment: AzureCloud
		# append_tags: yes
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# default_rules: # The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.
		# api_profile: #latest
		# purge_default_rules: no
		# state: absent|#present
		# location: resource_group location
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# cert_validation_mode: validate|ignore
		# auth_source: #auto|cli|credential_file|env
		# subscription_id: # Your Azure subscription Id.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# name: # Name of the security group to operate on.
$0
endsnippet

snippet linode "Manage instances on the Linode Public Cloud" b
- name: $1
	linode:
		# alert_diskio_enabled: # Set status of receiving disk IO alerts.
		# additional_disks: # List of dictionaries for creating additional disks that are added to the Linode configuration settings.
		# alert_bwin_enabled: # Set status of bandwidth in alerts.
		# payment_term: #1|12|24
		# kernel_id: # kernel to use for the instance (Linode Kernel)
		# alert_bwin_threshold: # Set threshold in MB of bandwidth in alerts.
		# alert_cpu_enabled: # Set status of receiving CPU usage alerts.
		# alert_bwquota_enabled: # Set status of bandwidth quota alerts as percentage of network transfer quota.
		# linode_id: # Unique ID of a linode server
		# alert_diskio_threshold: # Set threshold for average IO ops/sec over 2 hour period.
		# wait_timeout: 300
		# private_ip: no
		# watchdog: True
		# password: # root password to apply to a new server (auto generated if missing)
		# ssh_pub_key: # SSH public key applied to root user
		# wait: no
		# datacenter: # datacenter to create an instance in (Linode Datacenter)
		# alert_bwquota_threshold: # Set threshold in MB of bandwidth quota alerts.
		# backupweeklyday: # Integer value for what day of the week to store weekly backups.
		# name: # Name to give the instance (alphanumeric, dashes, underscore).
		# displaygroup: # Add the instance to a Display Group in Linode Manager.
		# alert_cpu_threshold: # Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.
		# alert_bwout_enabled: # Set status of bandwidth out alerts.
		# state: absent|active|deleted|#present|restarted|started|stopped
		# swap: 512
		# alert_bwout_threshold: # Set threshold in MB of bandwidth out alerts.
		# distribution: # distribution to use for the instance (Linode Distribution)
		# api_key: # Linode API key
		# plan: # plan to use for the instance (Linode plan)
$0
endsnippet

snippet rax_cdb_user "create / delete a Rackspace Cloud Database" b
- name: $1
	rax_cdb_user:
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# db_username: # Name of the database user
		# db_password: # Database user password
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# cdb_id: # The databases server UUID
		# region: DFW
		# host: %
		# state: #present|absent
		# tenant_id: # The tenant ID used for authentication.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# databases: []
		# api_key: # Rackspace API key, overrides I(credentials).
$0
endsnippet

snippet rax_dns_record "Manage DNS records on Rackspace Cloud DNS" b
- name: $1
	rax_dns_record:
		name: ${2:# FQDN record name to create}
		data: ${3:# IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT}
		type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		# comment: # Brief description of the domain. Maximum length of 160 characters
		# username: # Rackspace username, overrides I(credentials).
		# domain: # Domain name to create the record in. This is an invalid option when type=PTR
		# tenant_name: # The tenant name used for authentication.
		# identity_type: rackspace
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# server: # Server ID to create a PTR record for. Only used with type=PTR
		# priority: # Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.
		# state: #present|absent
		# tenant_id: # The tenant ID used for authentication.
		# loadbalancer: # Load Balancer ID to create a PTR record for. Only used with type=PTR
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# ttl: 3600
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# overwrite: yes
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_mon_notification "Create or delete a Rackspace Cloud Monitoring notification." b
- name: $1
	rax_mon_notification:
		label: ${2:# Defines a friendly name for this notification. String between 1 and 255 characters long.}
		details: ${3:# Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.}
		notification_type: ${4:webhook|email|pagerduty}
		# username: # Rackspace username, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_files_objects "Upload, download, and delete objects in Rackspace Cloud Files" b
- name: $1
	rax_files_objects:
		container: ${2:# The container to use for file object operations.}
		# username: # Rackspace username, overrides I(credentials).
		# src: # Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17".  src and dest are mutually exclusive on remote-only object operations
		# dest: # The destination of a "get" operation; i.e. a local directory, "/home/user/myfolder". Used to specify the destination of an operation on a remote object; i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17"
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# expires: # Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# identity_type: rackspace
		# state: #present|absent
		# clear_meta: yes|#no
		# meta: # A hash of items to set as metadata values on an uploaded file or folder
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# type: #file|meta
		# method: #get|put|delete
		# structure: True|no
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_cbs "Manipulate Rackspace Cloud Block Storage Volumes" b
- name: $1
	rax_cbs:
		size: ${2:100}
		volume_type: ${3:#SATA|SSD}
		state: ${4:#present|absent}
		name: ${5:# Name to give the volume being created}
		# username: # Rackspace username, overrides I(credentials).
		# api_key: # Rackspace API key, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# description: # Description to give the volume being created
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# image: # image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# meta: # A hash of metadata to associate with the volume
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# snapshot_id: # The id of the snapshot to create the volume from
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# wait: yes|#no
		# region: DFW
		# wait_timeout: 300
$0
endsnippet

snippet rax_facts "Gather facts for Rackspace Cloud Servers" b
- name: $1
	rax_facts:
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# name: # Server name to retrieve facts for
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# address: # Server IP address to retrieve facts for, will match any IP assigned to the server
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# id: # Server ID to retrieve facts for
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_files "Manipulate Rackspace Cloud Files Containers" b
- name: $1
	rax_files:
		container: ${2:# The container to use for container or metadata operations.}
		# username: # Rackspace username, overrides I(credentials).
		# web_index: # Sets an object to be presented as the HTTP index page when accessed by the CDN URL
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# private: # Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires
		# state: #present|absent
		# clear_meta: yes|#no
		# meta: # A hash of items to set as metadata values on a container
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# ttl: # In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public
		# web_error: # Sets an object to be presented as the HTTP error page when accessed by the CDN URL
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# tenant_name: # The tenant name used for authentication.
		# api_key: # Rackspace API key, overrides I(credentials).
		# type: #file|meta
		# public: # Used to set a container as public, available via the Cloud Files CDN
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_queue "create / delete a queue in Rackspace Public Cloud" b
- name: $1
	rax_queue:
		# username: # Rackspace username, overrides I(credentials).
		# name: # Name to give the queue
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_clb_nodes "add, modify and remove nodes from a Rackspace Cloud Load Balancer" b
- name: $1
	rax_clb_nodes:
		load_balancer_id: ${2:# Load balancer id}
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# weight: # Weight of node
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# wait_timeout: 30
		# condition: enabled|disabled|draining
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# address: # IP address or domain name of the node
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# type: primary|secondary
		# port: # Port number of the load balanced service on the node
		# node_id: # Node id
		# wait: yes|#no
$0
endsnippet

snippet rax_network "create / delete an isolated network in Rackspace Public Cloud" b
- name: $1
	rax_network:
		# username: # Rackspace username, overrides I(credentials).
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# label: # Label (name) to give the network
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# cidr: # cidr of the network being created
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_meta "Manipulate metadata for Rackspace Cloud Servers" b
- name: $1
	rax_meta:
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# name: # Server name to modify metadata for
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# meta: # A hash of metadata to associate with the instance
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# address: # Server IP address to modify metadata for, will match any IP assigned to the server
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# id: # Server ID to modify metadata for
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_scaling_policy "Manipulate Rackspace Cloud Autoscale Scaling Policy" b
- name: $1
	rax_scaling_policy:
		name: ${2:# Name to give the policy}
		scaling_group: ${3:# Name of the scaling group that this policy will be added to}
		policy_type: ${4:webhook|schedule}
		# username: # Rackspace username, overrides I(credentials).
		# is_percent: no
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# cron: # The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)
		# desired_capacity: # The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.
		# state: #present|absent
		# cooldown: # The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
		# at: # The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# change: # The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_clb "create / delete a load balancer in Rackspace Public Cloud" b
- name: $1
	rax_clb:
		# username: # Rackspace username, overrides I(credentials).
		# protocol: DNS_TCP|DNS_UDP|FTP|#HTTP|HTTPS|IMAPS|IMAPv4|LDAP|LDAPS|MYSQL|POP3|POP3S|SMTP|TCP|TCP_CLIENT_FIRST|UDP|UDP_STREAM|SFTP
		# name: # Name to give the load balancer
		# algorithm: RANDOM|#LEAST_CONNECTIONS|ROUND_ROBIN|WEIGHTED_LEAST_CONNECTIONS|WEIGHTED_ROUND_ROBIN
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# vip_id: # Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol
		# state: #present|absent
		# wait_timeout: 300
		# meta: # A hash of metadata to associate with the instance
		# timeout: 30
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# type: #PUBLIC|SERVICENET
		# port: 80
		# wait: yes|#no
$0
endsnippet

snippet rax_mon_entity "Create or delete a Rackspace Cloud Monitoring entity" b
- name: $1
	rax_mon_entity:
		label: ${2:# Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.}
		# username: # Rackspace username, overrides I(credentials).
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: present|absent
		# agent_id: # Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# named_ip_addresses: # Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.
		# metadata: # Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.
$0
endsnippet

snippet rax "create / delete an instance in Rackspace Public Cloud" b
- name: $1
	rax:
		# files: # Files to insert into the instance. remotefilename:localcontent
		# boot_volume_terminate: no
		# tenant_name: # The tenant name used for authentication.
		# auto_increment: yes|no
		# image: # image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image
		# user_data: # Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string
		# boot_volume: # Cloud Block Storage ID or Name to use as the boot volume of the instance
		# count_offset: 1
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# meta: # A hash of metadata to associate with the instance
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances
		# tenant_id: # The tenant ID used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# region: DFW
		# flavor: # flavor to use for the instance
		# networks: [u'public', u'private']
		# wait: yes|#no
		# boot_from_volume: yes|#no
		# api_key: # Rackspace API key, overrides I(credentials).
		# group: # host group to assign to server, is also used for idempotent operations to ensure a specific number of instances
		# name: # Name to give the instance
		# identity_type: rackspace
		# extra_client_args: # A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.
		# exact_count: yes|no
		# disk_config: #auto|manual
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# count: 1
		# username: # Rackspace username, overrides I(credentials).
		# state: #present|absent
		# wait_timeout: 300
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# key_name: # key pair to use on the instance
		# boot_volume_size: 100
		# extra_create_args: # A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.
		# config_drive: yes|no
$0
endsnippet

snippet rax_keypair "Create a keypair for use with Rackspace Cloud Servers" b
- name: $1
	rax_keypair:
		name: ${2:# Name of keypair}
		# username: # Rackspace username, overrides I(credentials).
		# public_key: # Public Key string to upload. Can be a file path or string
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_cdb_database "create / delete a database in the Cloud Databases" b
- name: $1
	rax_cdb_database:
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# name: # Name to give to the database
		# identity_type: rackspace
		# cdb_id: # The databases server UUID
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# collate: utf8_general_ci
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_id: # The tenant ID used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# character_set: utf8
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_dns "Manage domains on Rackspace Cloud DNS" b
- name: $1
	rax_dns:
		# comment: # Brief description of the domain. Maximum length of 160 characters
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# name: # Domain name to create
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# ttl: 3600
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# email: # Email address of the domain administrator
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_clb_ssl "Manage SSL termination for a Rackspace Cloud Load Balancer." b
- name: $1
	rax_clb_ssl:
		loadbalancer: ${2:# Name or ID of the load balancer on which to manage SSL termination.}
		# username: # Rackspace username, overrides I(credentials).
		# private_key: # The private SSL key as a string in PEM format.
		# tenant_name: # The tenant name used for authentication.
		# certificate: # The public SSL certificates as a string in PEM format.
		# tenant_id: # The tenant ID used for authentication.
		# identity_type: rackspace
		# enabled: yes
		# region: DFW
		# https_redirect: # If "true", the load balancer will redirect HTTP traffic to HTTPS.
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# state: #present|absent
		# wait_timeout: 300
		# intermediate_certificate: # One or more intermediate certificate authorities as a string in PEM
		# secure_traffic_only: no
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# secure_port: 443
		# api_key: # Rackspace API key, overrides I(credentials).
		# wait: no
$0
endsnippet

snippet rax_mon_check "Create or delete a Rackspace Cloud Monitoring check for an existing entity." b
- name: $1
	rax_mon_check:
		entity_id: ${2:# ID of the rax_mon_entity to target with this check.}
		check_type: ${3:remote.dns|remote.ftp-banner|remote.http|remote.imap-banner|remote.mssql-banner|remote.mysql-banner|remote.ping|remote.pop3-banner|remote.postgresql-banner|remote.smtp-banner|remote.smtp|remote.ssh|remote.tcp|remote.telnet-banner|agent.filesystem|agent.memory|agent.load_average|agent.cpu|agent.disk|agent.network|agent.plugin}
		label: ${4:# Defines a label for this check, between 1 and 64 characters long.}
		# tenant_name: # The tenant name used for authentication.
		# period: # The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.
		# disabled: yes|no
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# state: present|absent
		# details: # Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# api_key: # Rackspace API key, overrides I(credentials).
		# metadata: # Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.
		# username: # Rackspace username, overrides I(credentials).
		# target_hostname: # One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# target_alias: # One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# timeout: # The number of seconds this check will wait when attempting to collect results. Must be less than the period.
		# monitoring_zones_poll: # Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.
$0
endsnippet

snippet rax_identity "Load Rackspace Cloud Identity" b
- name: $1
	rax_identity:
		# username: # Rackspace username, overrides I(credentials).
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_cdb "create/delete or resize a Rackspace Cloud Databases instance" b
- name: $1
	rax_cdb:
		# cdb_type: MySQL
		# username: # Rackspace username, overrides I(credentials).
		# name: # Name of the databases server instance
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# cdb_version: 5.1|5.6|10
		# volume: 2
		# state: #present|absent
		# wait_timeout: 300
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# flavor: 1
		# api_key: # Rackspace API key, overrides I(credentials).
		# wait: yes|#no
$0
endsnippet

snippet rax_cbs_attachments "Manipulate Rackspace Cloud Block Storage Volume Attachments" b
- name: $1
	rax_cbs_attachments:
		volume: ${2:# Name or id of the volume to attach/detach}
		server: ${3:# Name or id of the server to attach/detach}
		state: ${4:#present|absent}
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# wait_timeout: 300
		# device: # The device path to attach the volume to, e.g. /dev/xvde.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# wait: yes|#no
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# api_key: # Rackspace API key, overrides I(credentials).
$0
endsnippet

snippet rax_mon_notification_plan "Create or delete a Rackspace Cloud Monitoring notification plan." b
- name: $1
	rax_mon_notification_plan:
		label: ${2:# Defines a friendly name for this notification plan. String between 1 and 255 characters long.}
		# username: # Rackspace username, overrides I(credentials).
		# warning_state: # Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# critical_state: # Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# ok_state: # Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.
		# state: present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
$0
endsnippet

snippet rax_scaling_group "Manipulate Rackspace Cloud Autoscale Groups" b
- name: $1
	rax_scaling_group:
		image: ${2:# image to use for the instance. Can be an C(id), C(human_id) or C(name)}
		min_entities: ${3:# The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		flavor: ${4:# flavor to use for the instance}
		max_entities: ${5:# The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		name: ${6:# Name to give the scaling group}
		server_name: ${7:# The base name for servers created by Autoscale}
		# files: # Files to insert into the instance. Hash of C(remotepath: localpath)
		# username: # Rackspace username, overrides I(credentials).
		# key_name: # key pair to use on the instance
		# user_data: # Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# cooldown: # The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# networks: [u'public', u'private']
		# wait: yes|#no
		# loadbalancers: # List of load balancer C(id) and C(port) hashes
		# tenant_id: # The tenant ID used for authentication.
		# wait_timeout: 300
		# disk_config: #auto|manual
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# state: #present|absent
		# meta: # A hash of metadata to associate with the instance
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# tenant_name: # The tenant name used for authentication.
		# api_key: # Rackspace API key, overrides I(credentials).
		# region: DFW
		# config_drive: yes|no
$0
endsnippet

snippet rax_mon_alarm "Create or delete a Rackspace Cloud Monitoring alarm." b
- name: $1
	rax_mon_alarm:
		entity_id: ${2:# ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.}
		notification_plan_id: ${3:# ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.}
		check_id: ${4:# ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.}
		label: ${5:# Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.}
		# username: # Rackspace username, overrides I(credentials).
		# tenant_name: # The tenant name used for authentication.
		# tenant_id: # The tenant ID used for authentication.
		# region: DFW
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# disabled: yes|no
		# identity_type: rackspace
		# state: #present|absent
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# criteria: # Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# api_key: # Rackspace API key, overrides I(credentials).
		# metadata: # Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.
$0
endsnippet

snippet pubnub_blocks "PubNub blocks management module." b
- name: $1
	pubnub_blocks:
		name: ${2:# Name of managed block which will be later visible on admin.pubnub.com.}
		keyset: ${3:# Name of application's keys set which is bound to managed blocks.}
		application: ${4:# Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.}
		# account: # Name of PubNub account for from which C(application) will be used to manage blocks.
		# changes: {}
		# cache: {}
		# state: #started|stopped|present|absent
		# password: # Password which match to account to which specified C(email) belong.
		# validate_certs: yes
		# email: # Email from account for which new session should be started.
		# event_handlers: []
		# description: New block
$0
endsnippet

snippet gcp_target_proxy "Create, Update or Destroy a Target_Proxy." b
- name: $1
	gcp_target_proxy:
		target_proxy_type: ${2:# Type of Target_Proxy. HTTP, HTTPS or SSL. Only HTTP is currently supported.}
		target_proxy_name: ${3:# Name of the Target_Proxy.}
		# url_map_name: # Name of the Url Map.  Required if type is HTTP or HTTPS proxy.
$0
endsnippet

snippet gce_mig "Create, Update or Destroy a Managed Instance Group (MIG)." b
- name: $1
	gce_mig:
		name: ${2:# Name of the Managed Instance Group.}
		zone: ${3:# The GCE zone to use for this Managed Instance Group.}
		# service_account_email: # service account email
		# autoscaling: # A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.
		# named_ports: # Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.
		# state: absent|#present
		# template: # Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.
		# credentials_file: # Path to the JSON file associated with the service account email
		# project_id: # GCE project ID
		# size: # Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.
$0
endsnippet

snippet gcp_backend_service "Create or Destroy a Backend Service." b
- name: $1
	gcp_backend_service:
		backends: ${2:# List of backends that make up the backend service. A backend is made up of an instance group and optionally several other parameters.  See U(https://cloud.google.com/compute/docs/reference/latest/backendServices) for details.}
		healthchecks: ${3:# List of healthchecks. Only one healthcheck is supported.}
		backend_service_name: ${4:# Name of the Backend Service.}
		# protocol: # The protocol this Backend Service uses to communicate with backends. Possible values are HTTP, HTTPS, TCP, and SSL. The default is HTTP.
		# enable_cdn: # If true, enable Cloud CDN for this Backend Service.
		# service_account_email: # Service account email
		# state: absent|#present
		# port_name: # Name of the port on the managed instance group (MIG) that backend services can forward data to. Required for external load balancing.
		# timeout: # How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is 1-86400.
		# credentials_file: # Path to the JSON file associated with the service account email.
		# project_id: # GCE project ID.
$0
endsnippet

snippet gcdns_record "Creates or removes resource records in Google Cloud DNS" b
- name: $1
	gcdns_record:
		record: ${2:# The fully-qualified domain name of the resource record.}
		type: ${3:A|AAAA|CNAME|SRV|TXT|SOA|NS|MX|SPF|PTR}
		# zone_id: # The Google Cloud ID of the zone (e.g., example-com).
		# zone: # The DNS domain name of the zone (e.g., example.com).
		# service_account_email: # The e-mail address for a service account with access to Google Cloud DNS.
		# ttl: 300
		# pem_file: # The path to the PEM file associated with the service account email.
		# record_data: # The record_data to use for the resource record.
		# state: #present|absent
		# credentials_file: # The path to the JSON file associated with the service account email.
		# project_id: # The Google Cloud Platform project ID to use.
		# overwrite: True|#False
$0
endsnippet

snippet gcdns_zone "Creates or removes zones in Google Cloud DNS" b
- name: $1
	gcdns_zone:
		zone: ${2:# The DNS domain name of the zone.}
		# state: #present|absent
		# description: 
		# credentials_file: # The path to the JSON file associated with the service account email.
		# service_account_email: # The e-mail address for a service account with access to Google Cloud DNS.
		# project_id: # The Google Cloud Platform project ID to use.
		# pem_file: # The path to the PEM file associated with the service account email.
$0
endsnippet

snippet gcp_healthcheck "Create, Update or Destroy a Healthcheck." b
- name: $1
	gcp_healthcheck:
		healthcheck_name: ${2:# Name of the Healthcheck.}
		healthcheck_type: ${3:HTTP|HTTPS}
		host_header: ${4:}
		state: ${5:present|absent}
		# check_interval: 5
		# service_account_email: # service account email
		# healthy_threshold: 2
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# unhealthy_threshold: 2
		# timeout: 5
		# credentials_file: # Path to the JSON file associated with the service account email
		# project_id: # Your GCP project ID
		# port: # The TCP port number for the health check request. The default value is 443 for HTTPS and 80 for HTTP.
		# request_path: /
$0
endsnippet

snippet gce_net "create/destroy GCE networks and firewall rules" b
- name: $1
	gce_net:
		# src_tags: []
		# subnet_region: # region of subnet to create
		# ipv4_range: # the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# target_tags: []
		# allowed: # the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or 'tcp:80-800;udp:1-25') this parameter is mandatory when creating or updating a firewall rule
		# fwname: # name of the firewall rule
		# name: # name of the network
		# src_range: []
		# state: active|#present|absent|deleted
		# subnet_name: # name of subnet to create
		# mode: #legacy|auto|custom
		# credentials_file: # path to the JSON file associated with the service account email
		# service_account_email: # service account email
		# project_id: # your GCE project ID
		# subnet_desc: # description of subnet to create
$0
endsnippet

snippet gcpubsub "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub" b
- name: $1
	gcpubsub:
		topic: ${2:# GCP pubsub topic name.}
		# pull: # Subfield of subscription. Not required. If specified, messages will be retrieved from topic via the provided subscription name. max_messages (int; default None; max number of messages to pull), message_ack (bool; default False; acknowledge the message) and return_immediately (bool; default True, don't wait for messages to appear). If the messages are acknowledged, changed is set to True, otherwise, changed is False.
		# ack_deadline: # S
		# name: # S
		# publish: # List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.
		# state: absent|#present
		# push_endpoint: # Subfield of subscription.  Not required.  If specified, message will be sent to an endpoint. See U(https://cloud.google.com/pubsub/docs/advanced#push_endpoints) for more information.
		# subscription: # Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields. See subfields name, push_endpoint and ack_deadline for more information.
$0
endsnippet

snippet gce "create or terminate GCE instances" b
- name: $1
	gce:
		zone: ${2:us-central1-a}
		# disks: # a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).
		# num_instances: # can be used with 'name', specifies the number of nodes to provision using 'name' as a base name
		# ip_forward: false
		# image: debian-8
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# instance_names: # a comma-separated list of instance names to create or destroy
		# machine_type: n1-standard-1
		# external_projects: # A list of other projects (accessible with the provisioning credentials) to be searched for the image.
		# name: # either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes
		# disk_size: 10
		# network: default
		# external_ip: ephemeral
		# service_account_email: # service account email
		# tags: # a comma-separated list of tags to associate with the instance
		# persistent_boot_disk: false
		# disk_auto_delete: true
		# preemptible: false
		# state: active|#present|absent|deleted|started|stopped|terminated
		# credentials_file: # path to the JSON file associated with the service account email
		# subnetwork: # name of the subnetwork in which the instance should be created
		# project_id: # your GCE project ID
		# image_family: # image family from which to select the image.  The most recent non-deprecated image in the family will be used.
		# metadata: # a hash/dictionary of custom data for the instance; '{"key":"value", ...}'
$0
endsnippet

snippet gcspanner "Create and Delete Instances/Databases on Spanner" b
- name: $1
	gcspanner:
		instance_id: ${2:# GCP spanner instance name.}
		configuration: ${3:# Configuration the instance should use.}
		# state: absent|#present
		# instance_display_name: # Name of Instance to display.
		# database_name: # Name of database contained on the instance.
		# force_instance_delete: no
		# node_count: 1
$0
endsnippet

snippet gcp_forwarding_rule "Create, Update or Destroy a Forwarding_Rule." b
- name: $1
	gcp_forwarding_rule:
		forwarding_rule_name: ${2:# Name of the Forwarding_Rule.}
		state: ${3:present|absent}
		# port_range: # For global forwarding rules, must be set to 80 or 8080 for TargetHttpProxy, and 443 for TargetHttpsProxy or TargetSslProxy.
		# protocol: # For global forwarding rules, TCP, UDP, ESP, AH, SCTP or ICMP. Default is TCP.
		# target: # Target resource for forwarding rule. For global proxy, this is a Global TargetProxy resource. Required for external load balancing (including Global load balancing)
		# address: # IPv4 or named IP address. Must be of the same scope (regional, global). Reserved addresses can (and probably should) be used for global forwarding rules. You may reserve IPs from the console or via the gce_eip module.
		# region: # The region for this forwarding rule. Currently, only 'global' is supported.
$0
endsnippet

snippet gce_img "utilize GCE image resources" b
- name: $1
	gce_img:
		name: ${2:# the name of the image to create or delete}
		# project_id: # your GCE project ID
		# family: # an optional family name
		# service_account_email: # service account email
		# pem_file: # path to the pem file associated with the service account email
		# source: # the source disk or the Google Cloud Storage URI to create the image from
		# state: #present|absent
		# timeout: 180
		# zone: us-central1-a
		# description: # an optional description
$0
endsnippet

snippet gcp_url_map "Create, Update or Destory a Url_Map." b
- name: $1
	gcp_url_map:
		default_service: ${2:# Default Backend Service if no host rules match.}
		url_map_name: ${3:# Name of the Url_Map.}
		# host_rules: # The list of HostRules to use against the URL. Contains a list of hosts and an associated path_matcher.
		# path_matchers: # The list of named PathMatchers to use against the URL. Contains path_rules, which is a list of paths and an associated service. A default_service can also be specified for each path_matcher.
$0
endsnippet

snippet gce_lb "create/destroy GCE load-balancer resources" b
- name: $1
	gce_lb:
		# httphealthcheck_host: # host header to pass through on HTTP check requests
		# protocol: #tcp|udp
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# members: # a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]
		# httphealthcheck_port: 80
		# httphealthcheck_name: # the name identifier for the HTTP health check
		# name: # name of the load-balancer resource
		# external_ip: # the external static IPv4 (or auto-assigned) address for the LB
		# service_account_email: # service account email
		# region: # the GCE region where the load-balancer is defined
		# httphealthcheck_unhealthy_count: 2
		# httphealthcheck_healthy_count: 2
		# httphealthcheck_path: /
		# port_range: # the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports
		# state: active|#present|absent|deleted
		# httphealthcheck_timeout: 5
		# credentials_file: # path to the JSON file associated with the service account email
		# project_id: # your GCE project ID
		# httphealthcheck_interval: 5
$0
endsnippet

snippet gc_storage "This module manages objects/buckets in Google Cloud Storage." b
- name: $1
	gc_storage:
		gs_access_key: ${2:# GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.}
		bucket: ${3:# Bucket name.}
		mode: ${4:get|put|get_url|get_str|delete|create}
		gs_secret_key: ${5:# GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used.}
		# src: # The source file path when performing a PUT operation.
		# force: yes
		# permission: private
		# dest: # The destination file path when downloading an object/key with a GET operation.
		# object: # Keyname of the object inside the bucket. Can be also be used to create "virtual directories" (see examples).
		# expiration: # Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.
		# region: US
		# versioning: yes|no
		# headers: {}
$0
endsnippet

snippet gce_pd "utilize GCE persistent disk resources" b
- name: $1
	gce_pd:
		name: ${2:# name of the disk}
		# size_gb: 10
		# project_id: # your GCE project ID
		# zone: us-central1-b
		# service_account_email: # service account email
		# image: # the source image to use for the disk
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# instance_name: # instance name if you wish to attach or detach the disk
		# state: active|#present|absent|deleted
		# snapshot: # the source snapshot to use for the disk
		# detach_only: yes|#no
		# credentials_file: # path to the JSON file associated with the service account email
		# disk_type: #pd-standard|pd-ssd
		# delete_on_termination: yes|no
		# mode: READ_WRITE|#READ_ONLY
$0
endsnippet

snippet gce_labels "Create, Update or Destroy GCE Labels." b
- name: $1
	gce_labels:
		# labels: # A list of labels (key/value pairs) to add or remove for the resource.
		# resource_url: # The 'self_link' for the resource (instance, disk, snapshot, etc)
		# resource_name: # The name of resource.
		# resource_type: # The type of resource (instances, disks, snapshots, images)
		# resource_location: # The location of resource (global, us-central1-f, etc.)
$0
endsnippet

snippet gcpubsub_facts "List Topics/Subscriptions and Messages from Google PubSub." b
- name: $1
	gcpubsub_facts:
		view: ${2:# Choices are 'topics' or 'subscriptions'}
		# topic: # GCP pubsub topic name.  Only the name, not the full path, is required.
		# state: # list is the only valid option.
$0
endsnippet

snippet gce_snapshot "Create or destroy snapshots for GCE storage volumes" b
- name: $1
	gce_snapshot:
		instance_name: ${2:# The GCE instance to snapshot}
		project_id: ${3:# The GCP project ID to use}
		credentials_file: ${4:# The path to the credentials file associated with the service account}
		service_account_email: ${5:# GCP service account email for the project where the instance resides}
		# state: #present|absent
		# snapshot_name: # The name of the snapshot to manage
		# disks: all
$0
endsnippet

snippet gce_instance_template "create or destroy instance templates of Compute Engine of GCP." b
- name: $1
	gce_instance_template:
		name: ${2:# The name of the GCE instance template.}
		# description: # description of instance template
		# tags: # a comma-separated list of tags to associate with the instance
		# automatic_restart: # Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.
		# image: # The image to use to create the instance. Cannot specify both both I(image) and I(source).
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# subnetwork_region: # Region that subnetwork resides in. (Required for subnetwork to successfully complete)
		# disk_type: pd-standard
		# size: f1-micro
		# network: default
		# external_ip: ephemeral
		# service_account_email: # service account email
		# disks: # a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).
		# nic_gce_struct: # Support passing in the GCE-specific formatted networkInterfaces[] structure.
		# disk_auto_delete: yes
		# source: # A source disk to attach to the instance. Cannot specify both I(image) and I(source).
		# state: #present|absent
		# disks_gce_struct: # Support passing in the GCE-specific formatted formatted disks[] structure. Case sensitive. see U(https://cloud.google.com/compute/docs/reference/latest/instanceTemplates#resource) for detailed information
		# credentials_file: # path to the JSON file associated with the service account email
		# image_family: # The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source).
		# subnetwork: # The Subnetwork resource name for this instance.
		# project_id: # your GCE project ID
		# can_ip_forward: no
		# preemptible: # Defines whether the instance is preemptible.
		# metadata: # a hash/dictionary of custom data for the instance; '{"key":"value", ...}'
$0
endsnippet

snippet gce_eip "Create or Destroy Global or Regional External IP addresses." b
- name: $1
	gce_eip:
		region: ${2:# Region to create the address in. Set to 'global' to create a global address.}
		name: ${3:# Name of Address.}
		# state: #present|absent
$0
endsnippet

snippet gcp_dns_managed_zone "Creates a GCP ManagedZone" b
- name: $1
	gcp_dns_managed_zone:
		scopes: ${2:# Array of scopes to be used.}
		state: ${3:#present|absent}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		name: ${5:# User assigned name for this resource. Must be unique within the project.}
		# description: # A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.
		# name_server_set: # Optionally specifies the NameServerSet for this ManagedZone. A NameServerSet is a set of DNS name servers that all host the same ManagedZones. Most users will leave this field unset.
		# dns_name: # The DNS name of this managed zone, for instance "example.com.".
		# project: # The Google Cloud Platform project to use.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
$0
endsnippet

snippet gce_tag "add or remove tag(s) to/from GCE instances" b
- name: $1
	gce_tag:
		tags: ${2:# Comma-separated list of tags to add or remove.}
		# zone: us-central1-a
		# service_account_email: # Service account email.
		# pem_file: # Path to the PEM file associated with the service account email.
		# instance_name: # The name of the GCE instance to add/remove tags.
		# state: absent|#present
		# instance_pattern: # The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details.
		# project_id: # Your GCE project ID.
$0
endsnippet

snippet cs_resourcelimit "Manages resource limits on Apache CloudStack based clouds." b
- name: $1
	cs_resourcelimit:
		resource_type: ${2:instance|ip_address|volume|snapshot|template|network|vpc|cpu|memory|primary_storage|secondary_storage}
		# domain: # Domain the resource is related to.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the resource is related to.
		# api_region: cloudstack
		# project: # Name of the project the resource is related to.
		# limit: -1
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_instance_nic_secondaryip "Manages secondary IPs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic_secondaryip:
		vm: ${2:# Name of instance.}
		# vm_guest_ip: # Secondary IP address to be added to the instance nic.
		# account: # Account the instance is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# network: # Name of the network.
		# zone: # Name of the zone in which the instance is deployed in.
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# domain: # Domain the instance is related to.
		# project: # Name of the project the instance is deployed in.
		# state: #present|absent
		# api_region: cloudstack
		# vpc: # Name of the VPC the C(vm) is related to.
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_iso "Manages ISO images on Apache CloudStack based clouds." b
- name: $1
	cs_iso:
		name: ${2:# Name of the ISO.}
		# is_featured: # Register the ISO to be featured. Only used if C(state) is present.
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# iso_filter: featured|#self|selfexecutable|sharedexecutable|executable|community
		# api_region: cloudstack
		# domain: # Domain the ISO is related to.
		# is_public: # Register the ISO to be publicly available to all users. Only used if C(state) is present.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# display_text: # Display text of the ISO.
		# account: # Account the ISO is related to.
		# poll_async: yes
		# zone: # Name of the zone you wish the ISO to be registered or deleted from.
		# url: # URL where the ISO can be downloaded from. Required if C(state) is present.
		# checksum: # The MD5 checksum value of this ISO. If set, we search by checksum instead of name.
		# is_dynamically_scalable: # Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if C(state) is present.
		# cross_zones: no
		# project: # Name of the project the ISO to be registered in.
		# bootable: # Register the ISO to be bootable. Only used if C(state) is present.
		# state: #present|absent
		# is_ready: no
		# os_type: # Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present.
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_vpc_offering "Manages vpc offerings on Apache CloudStack based clouds." b
- name: $1
	cs_vpc_offering:
		name: ${2:# The name of the vpc offering}
		# display_text: # Display text of the vpc offerings
		# service_providers: # provider to service mapping. If not specified, the provider for the service will be mapped to the default provider on the physical network
		# poll_async: yes
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# state: enabled|#present|disabled|absent
		# supported_services: # Services supported by the vpc offering
		# service_capabilities: # Desired service capabilities as part of vpc offering.
		# api_region: cloudstack
		# service_offering: # The name or ID of the service offering for the VPC router appliance.
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_region "Manages regions on Apache CloudStack based clouds." b
- name: $1
	cs_region:
		id: ${2:# ID of the region.}
		# endpoint: # Endpoint URL of the region.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# name: # Name of the region.
$0
endsnippet

snippet cs_zone "Manages zones on Apache CloudStack based clouds." b
- name: $1
	cs_zone:
		name: ${2:# Name of the zone.}
		# internal_dns1: # First internal DNS for the zone.
		# domain: # Domain the zone is related to.
		# api_key: # API key of the CloudStack API.
		# api_http_method: get|post
		# state: #present|enabled|disabled|absent
		# dns2: # Second DNS for the zone.
		# dns1: # First DNS for the zone.
		# api_timeout: # HTTP timeout in seconds.
		# internal_dns2: # Second internal DNS for the zone.
		# network_type: #basic|advanced
		# guest_cidr_address: # Guest CIDR address for the zone.
		# api_region: cloudstack
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# dhcp_provider: # DHCP provider for the Zone.
		# network_domain: # Network domain for the zone.
		# dns2_ipv6: # Second DNS for IPv6 for the zone.
		# id: # uuid of the existing zone.
		# dns1_ipv6: # First DNS for IPv6 for the zone.
$0
endsnippet

snippet cs_network_acl_rule "Manages network access control list (ACL) rules on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl_rule:
		vpc: ${2:# VPC the network ACL is related to.}
		network_acl: ${3:# Name of the network ACL.}
		rule_position: ${4:# CIDR of the rule.}
		# icmp_code: # Error code for this icmp message.
		# domain: # Domain the VPC is related to.
		# api_timeout: # HTTP timeout in seconds.
		# start_port: # Start port for this rule.
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# end_port: # End port for this rule.
		# api_region: cloudstack
		# action_policy: allow|deny
		# protocol: #tcp|udp|icmp|all|by_number
		# cidr: 0.0.0.0/0
		# icmp_type: # Type of the icmp message being sent.
		# account: # Account the VPC is related to.
		# poll_async: yes
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# zone: # Name of the zone the VPC related to.
		# protocol_number: # Protocol number from 1 to 256 required if C(protocol=by_number).
		# project: # Name of the project the VPC is related to.
		# state: #present|absent
		# traffic_type: #ingress|egress
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_securitygroup_rule "Manages security group rules on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup_rule:
		security_group: ${2:# Name of the security group the rule is related to. The security group must be existing.}
		# icmp_code: # Error code for this icmp message. Required if C(protocol=icmp).
		# api_key: # API key of the CloudStack API.
		# protocol: #tcp|udp|icmp|ah|esp|gre
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# start_port: # Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).
		# user_security_group: # Security group this rule is based of.
		# end_port: # End port for this rule. Required if C(protocol=tcp) or C(protocol=udp), but C(start_port) will be used if not set.
		# api_region: cloudstack
		# project: # Name of the project the security group to be created in.
		# state: #present|absent
		# api_timeout: # HTTP timeout in seconds.
		# api_secret: # Secret key of the CloudStack API.
		# poll_async: yes
		# cidr: 0.0.0.0/0
		# icmp_type: # Type of the icmp message being sent. Required if C(protocol=icmp).
		# type: #ingress|egress
$0
endsnippet

snippet cs_instance_facts "Gathering facts from the API of instances from Apache CloudStack based clouds." b
- name: $1
	cs_instance_facts:
		name: ${2:# Name or display name of the instance.}
		# account: # Account the instance is related to.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# domain: # Domain the instance is related to.
		# api_region: cloudstack
		# project: # Project the instance is related to.
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_zone_facts "Gathering facts of zones from Apache CloudStack based clouds." b
- name: $1
	cs_zone_facts:
		name: ${2:# Name of the zone.}
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_loadbalancer_rule_member "Manages load balancer rule members on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule_member:
		name: ${2:# The name of the load balancer rule.}
		vms: ${3:# List of VMs to assign to or remove from the rule.}
		# domain: # Domain the rule is related to.
		# zone: # Name of the zone in which the rule should be located.
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the rule is related to.
		# api_region: cloudstack
		# project: # Name of the project the firewall rule is related to.
		# state: #present|absent
		# api_http_method: get|post
		# api_key: # API key of the CloudStack API.
		# ip_address: # Public IP address from where the network traffic will be load balanced from.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_template "Manages templates on Apache CloudStack based clouds." b
- name: $1
	cs_template:
		name: ${2:# Name of the template.}
		# is_featured: no
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# format: QCOW2|RAW|VHD|OVA
		# api_timeout: # HTTP timeout in seconds.
		# vm: # VM name the template will be created from its volume or alternatively from a snapshot.
		# api_region: cloudstack
		# domain: # Domain the template, snapshot or VM is related to.
		# is_extractable: no
		# is_public: no
		# checksum: no
		# requires_hvm: no
		# display_text: # Display text of the template.
		# account: # Account the template, snapshot or VM is related to.
		# api_key: # API key of the CloudStack API.
		# poll_async: yes
		# password_enabled: no
		# zone: # Name of the zone you wish the template to be registered or deleted from.
		# url: # URL of where the template is hosted on C(state=present).
		# bits: 64
		# sshkey_enabled: no
		# is_dynamically_scalable: no
		# cross_zones: no
		# project: # Name of the project the template to be registered in.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# state: #present|absent|extracted
		# is_ready: no
		# details: # Template details in key/value pairs.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# is_routing: # True if the template type is routing i.e., if template is used to deploy router.
		# os_type: # OS type that best represents the OS of this template.
		# template_tag: # the tag for this template.
		# template_filter: featured|#self|selfexecutable|sharedexecutable|executable|community
		# snapshot: # Name of the snapshot, created from the VM ROOT volume, the template will be created from.
		# mode: #http_download|ftp_upload
$0
endsnippet

snippet cs_staticnat "Manages static NATs on Apache CloudStack based clouds." b
- name: $1
	cs_staticnat:
		ip_address: ${2:# Public IP address the static NAT is assigned to.}
		# vm_guest_ip: no
		# domain: # Domain the static NAT is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# network: # Network the IP address is related to.
		# zone: # Name of the zone in which the virtual machine is in.
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# vm: # Name of virtual machine which we make the static NAT for.
		# api_region: cloudstack
		# project: # Name of the project the static NAT is related to.
		# state: #present|absent
		# vpc: # VPC the network related to.
		# account: # Account the static NAT is related to.
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_affinitygroup "Manages affinity groups on Apache CloudStack based clouds." b
- name: $1
	cs_affinitygroup:
		name: ${2:# Name of the affinity group.}
		# account: # Account the affinity group is related to.
		# poll_async: yes
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# domain: # Domain the affinity group is related to.
		# affinity_type: # Type of the affinity group. If not specified, first found affinity type is used.
		# api_region: cloudstack
		# project: # Name of the project the affinity group is related to.
		# state: #present|absent
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_key: # API key of the CloudStack API.
		# description: # Description of the affinity group.
$0
endsnippet

snippet cs_configuration "Manages configuration on Apache CloudStack based clouds." b
- name: $1
	cs_configuration:
		name: ${2:# Name of the configuration.}
		value: ${3:# Value of the configuration.}
		# domain: ROOT
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# cluster: # Ensure the value for corresponding cluster.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# account: # Ensure the value for corresponding account.
		# zone: # Ensure the value for corresponding zone.
		# storage: # Ensure the value for corresponding storage pool.
		# api_region: cloudstack
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_network_offering "Manages network offerings on Apache CloudStack based clouds." b
- name: $1
	cs_network_offering:
		name: ${2:# The name of the network offering.}
		# keepalive_enabled: True|False
		# api_http_method: get|post
		# specify_vlan: True|False
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# egress_default_policy: allow|deny
		# specify_ip_ranges: True|False
		# service_capabilities: # Desired service capabilities as part of network offering.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# service_offering: # The service offering name or ID used by virtual router provider.
		# supported_services: Dns|PortForwarding|Dhcp|SourceNat|UserData|Firewall|StaticNat|Vpn|Lb
		# conserve_mode: True|False
		# availability: # The availability of network offering. Default value is Optional
		# guest_ip_type: Shared|Isolated
		# max_connections: # Maximum number of concurrent connections supported by the network offering.
		# display_text: # Display text of the network offerings.
		# api_key: # API key of the CloudStack API.
		# persistent: # True if network offering supports persistent networks
		# state: enabled|#present|disabled|absent
		# api_region: cloudstack
		# details: internallbprovider|publiclbprovider
		# network_rate: # Data transfer rate in megabits per second allowed.
		# traffic_type: Guest
		# service_provider: # Provider to service mapping.
$0
endsnippet

snippet cs_securitygroup "Manages security groups on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup:
		name: ${2:# Name of the security group.}
		# domain: # Domain the security group is related to.
		# description: # Description of the security group.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# account: # Account the security group is related to.
		# api_region: cloudstack
		# project: # Name of the project the security group to be created in.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_domain "Manages domains on Apache CloudStack based clouds." b
- name: $1
	cs_domain:
		path: ${2:# Path of the domain.}
		# api_key: # API key of the CloudStack API.
		# poll_async: yes
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# clean_up: no
		# api_region: cloudstack
		# state: #present|absent
		# network_domain: # Network domain for networks in the domain.
$0
endsnippet

snippet cs_vpn_gateway "Manages site-to-site VPN gateways on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_gateway:
		vpc: ${2:# Name of the VPC.}
		# domain: # Domain the VPN gateway is related to.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the VPN gateway is related to.
		# poll_async: yes
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# zone: # Name of the zone the VPC is related to.
		# api_region: cloudstack
		# project: # Name of the project the VPN gateway is related to.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_router "Manages routers on Apache CloudStack based clouds." b
- name: $1
	cs_router:
		name: ${2:# Name of the router.}
		# account: # Account the router is related to.
		# poll_async: yes
		# zone: # Name of the zone the router is deployed in.
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# domain: # Domain the router is related to.
		# api_region: cloudstack
		# project: # Name of the project the router is related to.
		# state: #present|absent|started|stopped|restarted
		# api_http_method: get|post
		# service_offering: # Name or id of the service offering of the router.
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_network_acl "Manages network access control lists (ACL) on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl:
		name: ${2:# Name of the network ACL.}
		vpc: ${3:# VPC the network ACL is related to.}
		# account: # Account the network ACL rule is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# zone: # Name of the zone the VPC is related to.
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# domain: # Domain the network ACL rule is related to.
		# api_region: cloudstack
		# project: # Name of the project the network ACL is related to.
		# state: #present|absent
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_key: # API key of the CloudStack API.
		# description: # Description of the network ACL.
$0
endsnippet

snippet cs_vpn_connection "Manages site-to-site VPN connections on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_connection:
		vpn_customer_gateway: ${2:# Name of the VPN customer gateway.}
		vpc: ${3:# Name of the VPC the VPN connection is related to.}
		# passive: no
		# domain: # Domain the VPN connection is related to.
		# force: no
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the VPN connection is related to.
		# api_region: cloudstack
		# project: # Name of the project the VPN connection is related to.
		# state: #present|absent
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_portforward "Manages port forwarding rules on Apache CloudStack based clouds." b
- name: $1
	cs_portforward:
		private_port: ${2:# Start private port for this rule.}
		ip_address: ${3:# Public IP address the rule is assigned to.}
		public_port: ${4:# Start public port for this rule.}
		# vm_guest_ip: no
		# domain: # Domain the C(vm) is related to.
		# protocol: #tcp|udp
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# vm: # Name of virtual machine which we make the port forwarding rule for.
		# vpc: # Name of the VPC.
		# private_end_port: # End private port for this rule.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# account: # Account the C(vm) is related to.
		# api_key: # API key of the CloudStack API.
		# poll_async: yes
		# network: # Name of the network.
		# open_firewall: no
		# api_region: cloudstack
		# public_end_port: # End public port for this rule.
		# project: # Name of the project the C(vm) is located in.
		# state: #present|absent
		# zone: # Name of the zone in which the virtual machine is in.
$0
endsnippet

snippet cs_user "Manages users on Apache CloudStack based clouds." b
- name: $1
	cs_user:
		username: ${2:# Username of the user.}
		# keys_registered: # If API keys of the user should be generated.
		# account: # Account the user will be created under.
		# last_name: # Last name of the user.
		# poll_async: yes
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# first_name: # First name of the user.
		# api_region: cloudstack
		# api_key: # API key of the CloudStack API.
		# state: #present|absent|enabled|disabled|locked|unlocked
		# domain: ROOT
		# timezone: # Timezone of the user.
		# password: # Password of the user to be created.
		# email: # Email of the user.
$0
endsnippet

snippet cs_pod "Manages pods on Apache CloudStack based clouds." b
- name: $1
	cs_pod:
		name: ${2:# Name of the pod.}
		# zone: # Name of the zone in which the pod belongs to.
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# netmask: # Netmask for the Pod.
		# api_region: cloudstack
		# gateway: # Gateway for the Pod.
		# state: #present|enabled|disabled|absent
		# end_ip: # Ending IP address for the Pod.
		# api_http_method: get|post
		# start_ip: # Starting IP address for the Pod.
		# api_key: # API key of the CloudStack API.
		# id: # uuid of the existing pod.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_project "Manages projects on Apache CloudStack based clouds." b
- name: $1
	cs_project:
		name: ${2:# Name of the project.}
		# domain: # Domain the project is related to.
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# display_text: # Display text of the project.
		# account: # Account the project is related to.
		# poll_async: yes
		# api_region: cloudstack
		# state: #present|absent|active|suspended
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_storage_pool "Manages Primary Storage Pools on Apache CloudStack based clouds." b
- name: $1
	cs_storage_pool:
		name: ${2:# Name of the storage pool.}
		# api_timeout: # HTTP timeout in seconds.
		# managed: # Whether the storage pool should be managed by CloudStack.
		# zone: # Name of the zone in which the host should be deployed.
		# cluster: # Name of the cluster.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# api_http_method: get|post
		# storage_tags: # Tags associated with this storage pool.
		# api_region: cloudstack
		# capacity_iops: # Bytes CloudStack can provision from this storage pool.
		# state: #present|absent
		# capacity_bytes: # Bytes CloudStack can provision from this storage pool.
		# provider: DefaultPrimary
		# api_secret: # Secret key of the CloudStack API.
		# scope: cluster|zone
		# pod: # Name of the pod.
		# api_key: # API key of the CloudStack API.
		# allocation_state: enabled|disabled
		# storage_url: # URL of the storage pool.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_account "Manages accounts on Apache CloudStack based clouds." b
- name: $1
	cs_account:
		name: ${2:# Name of account.}
		# username: # Username of the user to be created if account did not exist.
		# first_name: # First name of the user to be created if account did not exist.
		# last_name: # Last name of the user to be created if account did not exist.
		# account_type: #user|root_admin|domain_admin
		# api_http_method: get|post
		# password: # Password of the user to be created if account did not exist.
		# api_timeout: # HTTP timeout in seconds.
		# domain: ROOT
		# api_region: cloudstack
		# api_key: # API key of the CloudStack API.
		# state: #present|absent|enabled|disabled|locked|unlocked
		# api_secret: # Secret key of the CloudStack API.
		# timezone: # Timezone of the user to be created if account did not exist.
		# poll_async: yes
		# network_domain: # Network domain of the account.
		# email: # Email of the user to be created if account did not exist.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_volume "Manages volumes on Apache CloudStack based clouds." b
- name: $1
	cs_volume:
		name: ${2:# Name of the volume.}
		# domain: # Name of the domain the volume to be deployed in.
		# force: no
		# disk_offering: # Name of the disk offering to be used.
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the volume is related to.
		# shrink_ok: no
		# display_volume: yes
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# min_iops: # Min iops
		# size: # Size of disk in GB
		# custom_id: # Custom id to the resource.
		# poll_async: yes
		# zone: # Name of the zone in which the volume should be deployed.
		# max_iops: # Max iops
		# project: # Name of the project the volume to be deployed in.
		# state: #present|absent|attached|detached
		# api_region: cloudstack
		# snapshot: # The snapshot name for the disk volume.
		# vm: # Name of the virtual machine to attach the volume to.
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_firewall "Manages firewall rules on Apache CloudStack based clouds." b
- name: $1
	cs_firewall:
		# icmp_code: # Error code for this icmp message.
		# domain: # Domain the firewall rule is related to.
		# api_timeout: # HTTP timeout in seconds.
		# protocol: #tcp|udp|icmp|all
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# end_port: # End port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).
		# start_port: # Start port for this rule.
		# icmp_type: # Type of the icmp message being sent.
		# ip_address: # Public IP address the ingress rule is assigned to.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# account: # Account the firewall rule is related to.
		# poll_async: yes
		# network: # Network the egress rule is related to.
		# zone: # Name of the zone in which the virtual machine is in.
		# cidrs: 0.0.0.0/0
		# api_region: cloudstack
		# project: # Name of the project the firewall rule is related to.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# type: #ingress|egress
$0
endsnippet

snippet cs_facts "Gather facts on instances of Apache CloudStack based clouds." b
- name: $1
	cs_facts:
		# filter: cloudstack_service_offering|cloudstack_availability_zone|cloudstack_public_hostname|cloudstack_public_ipv4|cloudstack_local_hostname|cloudstack_local_ipv4|cloudstack_instance_id|cloudstack_user_data
		# meta_data_host: # Host or IP of the meta data API service.
$0
endsnippet

snippet cs_vpn_customer_gateway "Manages site-to-site VPN customer gateway configurations on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_customer_gateway:
		name: ${2:# Name of the gateway.}
		# domain: # Domain the VPN customer gateway is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# api_http_method: get|post
		# ipsec_psk: # IPsec Preshared-Key.
		# esp_lifetime: # Lifetime in seconds of phase 2 VPN connection.
		# esp_policy: # ESP policy in the format e.g. C(aes256-sha1;modp1536).
		# cidrs: # List of guest CIDRs behind the gateway.
		# account: # Account the VPN customer gateway is related to.
		# api_region: cloudstack
		# gateway: # Public IP address of the gateway.
		# project: # Name of the project the VPN gateway is related to.
		# state: #present|absent
		# dpd: True|False
		# ike_policy: # IKE policy in the format e.g. C(aes256-sha1;modp1536).
		# force_encap: True|False
		# api_secret: # Secret key of the CloudStack API.
		# api_key: # API key of the CloudStack API.
		# ike_lifetime: # Lifetime in seconds of phase 1 VPN connection.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_role "Manages user roles on Apache CloudStack based clouds." b
- name: $1
	cs_role:
		name: ${2:# Name of the role.}
		# description: # Description of the role.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# state: #present|absent
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_key: # API key of the CloudStack API.
		# id: # ID of the role.
		# role_type: #User|DomainAdmin|ResourceAdmin|Admin
$0
endsnippet

snippet cs_cluster "Manages host clusters on Apache CloudStack based clouds." b
- name: $1
	cs_cluster:
		name: ${2:# name of the cluster.}
		# username: # Username for the cluster.
		# guest_vswitch_type: vmwaresvs|vmwaredvs
		# ovm3_cluster: # Ovm3 native OCFS2 clustering enabled for cluster.
		# ovm3_pool: # Ovm3 native pooling enabled for cluster.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# pod: # Name of the pod in which the cluster belongs to.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM
		# guest_vswitch_name: # Name of virtual switch used for guest traffic in the cluster.
		# vms_username: # Username for the VSM associated with this cluster.
		# password: # Password for the cluster.
		# public_vswitch_type: vmwaresvs|vmwaredvs
		# zone: # Name of the zone in which the cluster belongs to.
		# url: # URL for the cluster
		# cluster_type: CloudManaged|ExternalManaged
		# ovm3_vip: # Ovm3 vip to use for pool (and cluster).
		# vms_ip_address: # IP address of the VSM associated with this cluster.
		# state: #present|absent|disabled|enabled
		# public_vswitch_name: # Name of virtual switch used for public traffic in the cluster.
		# api_key: # API key of the CloudStack API.
		# vms_password: # Password for the VSM associated with this cluster.
$0
endsnippet

snippet cs_vpc "Manages VPCs on Apache CloudStack based clouds." b
- name: $1
	cs_vpc:
		name: ${2:# Name of the VPC.}
		# display_text: # Display text of the VPC.
		# vpc_offering: # Name of the VPC offering.
		# api_key: # API key of the CloudStack API.
		# poll_async: yes
		# zone: # Name of the zone.
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# clean_up: # Whether to redeploy a VPC router or not when C(state=restarted)
		# api_region: cloudstack
		# project: # Name of the project the VPC is related to.
		# state: #present|absent|restarted
		# api_timeout: # HTTP timeout in seconds.
		# domain: # Domain the VPC is related to.
		# account: # Account the VPC is related to.
		# cidr: # CIDR of the VPC, e.g. 10.1.0.0/16
		# network_domain: # Network domain for the VPC.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_sshkeypair "Manages SSH keys on Apache CloudStack based clouds." b
- name: $1
	cs_sshkeypair:
		name: ${2:# Name of public key.}
		# domain: # Domain the public key is related to.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# public_key: # String of the public key.
		# account: # Account the public key is related to.
		# api_region: cloudstack
		# project: # Name of the project the public key to be registered in.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_host "Manages hosts on Apache CloudStack based clouds." b
- name: $1
	cs_host:
		name: ${2:# Name of the host.}
		# username: # Username for the host.
		# api_key: # API key of the CloudStack API.
		# zone: # Name of the zone in which the host should be deployed.
		# host_tags: # Tags of the host.
		# url: # Url of the host used to create a host.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# cluster: # Name of the cluster.
		# state: #present|absent
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# pod: # Name of the pod.
		# password: # Password for the host.
		# allocation_state: enabled|disabled
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_instancegroup "Manages instance groups on Apache CloudStack based clouds." b
- name: $1
	cs_instancegroup:
		name: ${2:# Name of the instance group.}
		# account: # Account the instance group is related to.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# domain: # Domain the instance group is related to.
		# api_region: cloudstack
		# project: # Project the instance group is related to.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_loadbalancer_rule "Manages load balancer rules on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule:
		name: ${2:# The name of the load balancer rule.}
		public_port: ${3:# The public port from where the network traffic will be load balanced from.}
		state: ${4:#present|absent}
		ip_address: ${5:# Public IP address from where the network traffic will be load balanced from.}
		# domain: # Domain the rule is related to.
		# api_key: # API key of the CloudStack API.
		# protocol: # The protocol to be used on the load balancer
		# algorithm: #source|roundrobin|leastconn
		# open_firewall: no
		# api_timeout: # HTTP timeout in seconds.
		# account: # Account the rule is related to.
		# api_region: cloudstack
		# project: # Name of the project the load balancer IP address is related to.
		# private_port: # The private port of the private ip address/virtual machine where the network traffic will be load balanced to.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# cidr: # CIDR (full notation) to be used for firewall rule if required.
		# zone: # Name of the zone in which the rule should be created.
		# description: # The description of the load balancer rule.
$0
endsnippet

snippet cs_service_offering "Manages service offerings on Apache CloudStack based clouds." b
- name: $1
	cs_service_offering:
		name: ${2:# Name of the service offering.}
		# offer_ha: True|#False
		# cpu_number: # The number of CPUs of the service offering.
		# domain: # Domain the service offering is related to.
		# api_timeout: # HTTP timeout in seconds.
		# api_http_method: get|post
		# host_tags: # The host tagsfor this service offering.
		# system_vm_type: domainrouter|consoleproxy|secondarystoragevm
		# limit_cpu_usage: True|False
		# memory: # The total memory of the service offering in MB.
		# is_system: True|#False
		# storage_tags: # The storage tags for this service offering.
		# storage_type: local|shared
		# is_volatile: True|#False
		# api_secret: # Secret key of the CloudStack API.
		# cpu_speed: # The CPU speed of the service offering in MHz.
		# service_offering_details: # Details for planner, used to store specific parameters.
		# disk_iops_max: # Max. iops of the compute offering.
		# disk_iops_read_rate: # IO requests read rate of the disk offering.
		# display_text: # Display text of the service offering.
		# disk_iops_customized: no
		# provisioning_type: thin|sparse|fat
		# bytes_read_rate: # Bytes read rate of the disk offering.
		# api_region: cloudstack
		# deployment_planner: # The deployment planner heuristics used to deploy a VM of this offering.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# state: #present|absent
		# disk_iops_min: # Min. iops of the compute offering.
		# disk_iops_write_rate: # IO requests write rate of the disk offering.
		# network_rate: # Data transfer rate in Mb/s allowed.
		# api_key: # API key of the CloudStack API.
		# hypervisor_snapshot_reserve: # Hypervisor snapshot reserve space as a percent of a volume.
		# bytes_write_rate: # Bytes write rate of the disk offering.
$0
endsnippet

snippet cs_snapshot_policy "Manages volume snapshot policies on Apache CloudStack based clouds." b
- name: $1
	cs_snapshot_policy:
		# volume: # Name of the volume.
		# domain: # Domain the volume is related to.
		# api_timeout: # HTTP timeout in seconds.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# schedule: # Time the snapshot is scheduled. Required if C(state=present).
		# api_secret: # Secret key of the CloudStack API.
		# interval_type: hourly|#daily|weekly|monthly
		# vm: # Name of the instance to select the volume from.
		# volume_type: DATADISK|ROOT
		# time_zone: UTC
		# project: # Name of the project the volume is related to.
		# state: #present|absent
		# api_region: cloudstack
		# vpc: # Name of the vpc the instance is deployed in.
		# account: # Account the volume is related to.
		# max_snaps: 8
		# api_key: # API key of the CloudStack API.
		# device_id: # ID of the device on a VM the volume is attached to.
$0
endsnippet

snippet cs_network "Manages networks on Apache CloudStack based clouds." b
- name: $1
	cs_network:
		name: ${2:# Name (case sensitive) of the network.}
		# domain: # Domain the network is related to.
		# api_timeout: # HTTP timeout in seconds.
		# end_ipv6: # The ending IPv6 address of the network belongs to.
		# api_http_method: get|post
		# api_secret: # Secret key of the CloudStack API.
		# vlan: # The ID or VID of the network.
		# clean_up: no
		# netmask: # The netmask of the network.
		# network_offering: # Name of the offering for the network.
		# vpc: # Name of the VPC of the network.
		# start_ip: # The beginning IPv4 address of the network belongs to.
		# acl: # The name of the access control list for the VPC network tier.
		# gateway: # The gateway of the network.
		# gateway_ipv6: # The gateway of the IPv6 network.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# display_text: # Display text of the network.
		# isolated_pvlan: # The isolated private VLAN for this network.
		# account: # Account the network is related to.
		# subdomain_access: # Defines whether to allow subdomains to use networks dedicated to their parent domain(s).
		# poll_async: yes
		# zone: # Name of the zone in which the network should be deployed.
		# acl_type: #account|domain
		# api_region: cloudstack
		# start_ipv6: # The beginning IPv6 address of the network belongs to.
		# cidr_ipv6: # CIDR of IPv6 network, must be at least /64.
		# project: # Name of the project the network to be deployed in.
		# api_key: # API key of the CloudStack API.
		# state: #present|absent|restarted
		# end_ip: # The ending IPv4 address of the network belongs to.
		# network_domain: # The network domain.
$0
endsnippet

snippet cs_ip_address "Manages public IP address associations on Apache CloudStack based clouds." b
- name: $1
	cs_ip_address:
		# account: # Account the IP address is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# network: # Network the IP address is related to.
		# zone: # Name of the zone in which the IP address is in.
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# domain: # Domain the IP address is related to.
		# api_region: cloudstack
		# project: # Name of the project the IP address is related to.
		# state: #present|absent
		# vpc: # VPC the IP address is related to.
		# api_key: # API key of the CloudStack API.
		# ip_address: # Public IP address.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_instance_nic "Manages NICs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic:
		network: ${2:# Name of the network.}
		vm: ${3:# Name of instance.}
		# account: # Account the instance is related to.
		# api_timeout: # HTTP timeout in seconds.
		# poll_async: yes
		# zone: # Name of the zone in which the instance is deployed in.
		# api_secret: # Secret key of the CloudStack API.
		# api_http_method: get|post
		# domain: # Domain the instance is related to.
		# project: # Name of the project the instance is deployed in.
		# state: #present|absent
		# api_region: cloudstack
		# vpc: # Name of the VPC the C(vm) is related to.
		# api_key: # API key of the CloudStack API.
		# ip_address: # IP address to be used for the nic.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
$0
endsnippet

snippet cs_vmsnapshot "Manages VM snapshots on Apache CloudStack based clouds." b
- name: $1
	cs_vmsnapshot:
		vm: ${2:# Name of the virtual machine.}
		name: ${3:# Unique Name of the snapshot. In CloudStack terms display name.}
		# snapshot_memory: no
		# domain: # Domain the VM snapshot is related to.
		# poll_async: yes
		# description: # Description of the snapshot.
		# zone: # Name of the zone in which the VM is in. If not set, default zone is used.
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
		# project: # Name of the project the VM is assigned to.
		# state: #present|absent|revert
		# api_http_method: get|post
		# account: # Account the VM snapshot is related to.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_key: # API key of the CloudStack API.
$0
endsnippet

snippet cs_instance "Manages instances and virtual machines on Apache CloudStack based clouds." b
- name: $1
	cs_instance:
		# domain: # Domain the instance is related to.
		# api_timeout: # HTTP timeout in seconds.
		# force: no
		# disk_offering: # Name of the disk offering to be used.
		# api_http_method: get|post
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_secret: # Secret key of the CloudStack API.
		# keyboard: de|de-ch|es|fi|fr|fr-be|fr-ch|is|it|jp|nl-be|False|pt|uk|us
		# user_data: # Optional data (ASCII) that can be sent to the instance upon a successful deployment.
		# root_disk_size: # Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)
		# ssh_key: # Name of the SSH key to be deployed on the new instance.
		# cpu_speed: # The clock speed/shares allocated to the instance, used with custom service offerings
		# ip6_address: # IPv6 address for default instance's network.
		# service_offering: # Name or id of the service offering of the new instance.
		# ip_address: # IPv4 address for default instance's network during creation.
		# networks: # List of networks to use for the new instance.
		# security_groups: # List of security groups the instance to be applied to.
		# display_name: # Custom display name of the instances.
		# account: # Account the instance is related to.
		# api_key: # API key of the CloudStack API.
		# group: # Group in where the new instance should be in.
		# name: # Host name of the instance. C(name) can only contain ASCII letters.
		# zone: # Name of the zone in which the instance should be deployed.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# ip_to_networks: # List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4}
		# disk_size: # Disk size in GByte required if deploying instance from ISO.
		# project: # Name of the project the instance to be deployed in.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# state: deployed|started|stopped|restarted|restored|destroyed|expunged|#present|absent
		# api_region: cloudstack
		# affinity_groups: # Affinity groups names to be applied to the new instance.
		# template: # Name or id of the template to be used for creating the new instance.
		# memory: # The memory allocated to the instance, used with custom service offerings
		# iso: # Name or id of the ISO to be used for creating the new instance.
		# poll_async: yes
		# template_filter: featured|self|selfexecutable|sharedexecutable|#executable|community
		# cpu: # The number of CPUs to allocate to the instance, used with custom service offerings
$0
endsnippet

snippet clc_group "Create/delete Server Groups at Centurylink Cloud" b
- name: $1
	clc_group:
		name: ${2:# The name of the Server Group}
		# state: #present|absent
		# parent: # The parent group of the server group. If parent is not provided, it creates the group at top level.
		# wait: #True|False
		# location: # Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account
		# description: # A description of the Server Group
$0
endsnippet

snippet clc_firewall_policy "Create/delete/update firewall policies" b
- name: $1
	clc_firewall_policy:
		location: ${2:# Target datacenter for the firewall policy}
		source_account_alias: ${3:# CLC alias for the source account}
		# destination_account_alias: # CLC alias for the destination account
		# destination: # The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'
		# enabled: #True|False
		# source: # The list  of source addresses for traffic on the originating firewall. This is required when state is 'present"
		# state: #present|absent
		# firewall_policy_id: # Id of the firewall policy. This is required to update or delete an existing firewall policy
		# ports: any|icmp|TCP/123|UDP/123|TCP/123-456|UDP/123-456
		# wait: #True|False
$0
endsnippet

snippet clc_loadbalancer "Create, Delete shared loadbalancers in CenturyLink Cloud." b
- name: $1
	clc_loadbalancer:
		name: ${2:# The name of the loadbalancer}
		alias: ${3:# The alias of your CLC Account}
		location: ${4:# The location of the datacenter where the load balancer resides in}
		# status: #enabled|disabled
		# method: leastConnection|roundRobin
		# state: #present|absent|port_absent|nodes_present|nodes_absent
		# nodes: []
		# port: 80|443
		# persistence: standard|sticky
		# description: # A description for the loadbalancer
$0
endsnippet

snippet clc_server "Create, Delete, Start and Stop servers in CenturyLink Cloud." b
- name: $1
	clc_server:
		# cpu_autoscale_policy_id: # The autoscale policy to assign to the server.
		# anti_affinity_policy_name: # The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.
		# storage_type: #standard|hyperscale
		# anti_affinity_policy_id: # The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.
		# ttl: # The time to live for the server in seconds.  The server will be deleted when this time expires.
		# count_group: # Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.
		# secondary_dns: # Secondary DNS used by the server.
		# custom_fields: []
		# packages: []
		# group: Default Group
		# exact_count: # Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.
		# state: #present|absent|started|stopped
		# location: # The Datacenter to create servers in.
		# template: # The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'
		# memory: 1
		# server_ids: []
		# type: #standard|hyperscale|bareMetal
		# managed_os: True|#False
		# additional_disks: []
		# description: # The description to set for the server.
		# add_public_ip: #False|True
		# alert_policy_id: # The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.
		# alert_policy_name: # The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.
		# password: # Password for the administrator / root user
		# ip_address: # The IP Address for the server. One is assigned if not provided.
		# public_ip_protocol: #TCP|UDP|ICMP
		# wait: #True|False
		# count: 1
		# name: # A 1 to 6 character identifier to use for the server. This is required when state is 'present'
		# network_id: # The network UUID on which to create servers.
		# primary_dns: # Primary DNS used by the server.
		# alias: # The account alias to provision the servers under.
		# public_ip_ports: []
		# source_server_password: # The password for the source server if a clone is specified.
		# os_type: redHat6_64Bit|centOS6_64Bit|windows2012R2Standard_64Bit|ubuntu14_64Bit
		# configuration_id: # Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.
		# cpu: 1
$0
endsnippet

snippet clc_aa_policy "Create or Delete Anti Affinity Policies at CenturyLink Cloud." b
- name: $1
	clc_aa_policy:
		location: ${2:# Datacenter in which the policy lives/should live.}
		name: ${3:# The name of the Anti Affinity Policy.}
		# state: #present|absent
		# wait: #True|False
$0
endsnippet

snippet clc_publicip "Add and Delete public ips on servers in CenturyLink Cloud." b
- name: $1
	clc_publicip:
		server_ids: ${2:# A list of servers to create public ips on.}
		# state: #present|absent
		# protocol: #TCP|UDP|ICMP
		# ports: # A list of ports to expose. This is required when state is 'present'
		# wait: #True|False
$0
endsnippet

snippet clc_server_snapshot "Create, Delete and Restore server snapshots in CenturyLink Cloud." b
- name: $1
	clc_server_snapshot:
		server_ids: ${2:# The list of CLC server Ids.}
		# expiration_days: 7
		# state: #present|absent|restore
		# wait: #True|False
$0
endsnippet

snippet clc_modify_server "modify servers in CenturyLink Cloud." b
- name: $1
	clc_modify_server:
		server_ids: ${2:# A list of server Ids to modify.}
		# alert_policy_id: # The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'
		# anti_affinity_policy_name: # The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'
		# state: #present|absent
		# anti_affinity_policy_id: # The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'
		# alert_policy_name: # The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'
		# memory: # Memory (in GB) to set to the server.
		# cpu: # How many CPUs to update on the server
		# wait: #True|False
$0
endsnippet

snippet clc_blueprint_package "deploys a blue print package on a set of servers in CenturyLink Cloud." b
- name: $1
	clc_blueprint_package:
		server_ids: ${2:# A list of server Ids to deploy the blue print package.}
		package_id: ${3:# The package id of the blue print.}
		# package_params: {}
		# state: #present
		# wait: #True|False
$0
endsnippet

snippet clc_alert_policy "Create or Delete Alert Policies at CenturyLink Cloud." b
- name: $1
	clc_alert_policy:
		alias: ${2:# The alias of your CLC Account}
		# name: # The name of the alert policy. This is mutually exclusive with id
		# metric: cpu|memory|disk
		# alert_recipients: # A list of recipient email ids to notify the alert. This is required for state 'present'
		# state: #present|absent
		# threshold: # The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0
		# id: # The alert policy id. This is mutually exclusive with name
		# duration: # The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'
$0
endsnippet

snippet atomic_image "Manage the container images on the atomic host platform" b
- name: $1
	atomic_image:
		name: ${2:# Name of the container image.}
		# started: yes
		# state: absent|#latest|present
		# backend: docker|ostree
$0
endsnippet

snippet atomic_container "Manage the containers on the atomic host platform" b
- name: $1
	atomic_container:
		state: ${2:#latest|absent|rollback}
		name: ${3:# Name of the container}
		image: ${4:# The image to use to install the container}
		backend: ${5:docker|ostree}
		mode: ${6:user|system}
		# values: # Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'. The values specified here will be used at installation time as --set arguments for atomic install.
		# rootfs: # Define the rootfs of the image
$0
endsnippet

snippet atomic_host "Manage the atomic host platform" b
- name: $1
	atomic_host:
		# revision: latest
$0
endsnippet

snippet digital_ocean_floating_ip_facts "DigitalOcean Floating IPs facts" b
- name: $1
	digital_ocean_floating_ip_facts:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# timeout: 30
$0
endsnippet

snippet digital_ocean_tag "Create and remove tag(s) to DigitalOcean resource." b
- name: $1
	digital_ocean_tag:
		name: ${2:# The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.}
		# state: #present|absent
		# resource_id: # The ID of the resource to operate on.
		# resource_type: #droplet
		# api_token: # DigitalOcean api token.
$0
endsnippet

snippet digital_ocean_block_storage "Create/destroy or attach/detach Block Storage volumes in DigitalOcean" b
- name: $1
	digital_ocean_block_storage:
		volume_name: ${2:# The name of the Block Storage volume.}
		region: ${3:# The slug of the region where your Block Storage volume should be located in. If snapshot_id is included, this will be ignored.}
		state: ${4:present|absent}
		command: ${5:create|attach}
		api_token: ${6:# DigitalOcean api token.}
		# droplet_id: # The droplet id you want to operate on. Required when command=attach.
		# description: # Description of the Block Storage volume.
		# snapshot_id: # The snapshot id you would like the Block Storage volume created with. If included, region and block_size will be ignored and changed to null.
		# timeout: 10
		# block_size: # The size of the Block Storage volume in gigabytes. Required when command=create and state=present. If snapshot_id is included, this will be ignored.
$0
endsnippet

snippet digital_ocean_sshkey "Manage DigitalOcean SSH keys" b
- name: $1
	digital_ocean_sshkey:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# state: #present|absent
		# fingerprint: # This is a unique identifier for the SSH key used to delete a key
		# ssh_pub_key: # The Public SSH key to add.
		# name: # The name for the SSH key
$0
endsnippet

snippet digital_ocean_sshkey_facts "DigitalOcean SSH keys facts" b
- name: $1
	digital_ocean_sshkey_facts:
		oauth_token: ${2:# DigitalOcean API token.}
		# timeout: 30
$0
endsnippet

snippet digital_ocean_certificate "Manage certificates in DigitalOcean." b
- name: $1
	digital_ocean_certificate:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		name: ${3:# The name of the certificate.}
		# private_key: # A PEM-formatted private key content of SSL Certificate.
		# leaf_certificate: # A PEM-formatted public SSL Certificate.
		# certificate_chain: # The full PEM-formatted trust chain between the certificate authority's certificate and your domain's SSL certificate.
		# state: #present|absent
$0
endsnippet

snippet digital_ocean_floating_ip "Manage DigitalOcean Floating IPs" b
- name: $1
	digital_ocean_floating_ip:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# ip: # Public IP address of the Floating IP. Used to remove an IP
		# state: #present|absent
		# region: # The region that the Floating IP is reserved to.
		# droplet_id: # The Droplet that the Floating IP has been assigned to.
$0
endsnippet

snippet digital_ocean "Create/delete a droplet/SSH_key in DigitalOcean" b
- name: $1
	digital_ocean:
		# unique_name: yes|#no
		# virtio: #yes|no
		# region_id: # This is the slug of the region you would like your server to be created in.
		# backups_enabled: yes|#no
		# user_data: # opaque blob of data which is made available to the droplet
		# image_id: # This is the slug of the image you would like the droplet created with.
		# wait_timeout: 300
		# api_token: # DigitalOcean api token.
		# ssh_pub_key: # The public SSH key you want to add to your account.
		# wait: #yes|no
		# name: # String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.
		# size_id: # This is the slug of the size you would like the droplet created with.
		# id: # Numeric, the droplet id you want to operate on.
		# state: #present|active|absent|deleted
		# command: #droplet|ssh
		# ssh_key_ids: # Optional, array of SSH key (numeric) ID that you would like to be added to the server.
		# ipv6: yes|#no
		# private_networking: yes|#no
$0
endsnippet

snippet digital_ocean_domain "Create/delete a DNS record in DigitalOcean" b
- name: $1
	digital_ocean_domain:
		# ip: # The IP address to point a domain at.
		# state: #present|absent
		# oauth_token: # DigitalOcean api token.
		# id: # Numeric, the droplet id you want to operate on.
		# name: # String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.
$0
endsnippet

snippet cloudscale_server "Manages servers on the cloudscale.ch IaaS service" b
- name: $1
	cloudscale_server:
		# volume_size_gb: 10
		# uuid: # UUID of the server.
		# name: # Name of the Server.
		# use_public_network: yes
		# state: #running|stopped|absent
		# image: # Image used to create the server.
		# api_timeout: 30
		# user_data: # Cloud-init configuration (cloud-config) data to use for the server.
		# anti_affinity_with: # UUID of another server to create an anti-affinity group with.
		# use_private_network: no
		# bulk_volume_size_gb: # Size of the bulk storage volume in GB.
		# use_ipv6: yes
		# api_token: # cloudscale.ch API token.
		# flavor: # Flavor of the server.
		# ssh_keys: # List of SSH public keys.
$0
endsnippet

snippet cloudscale_floating_ip "Manages floating IPs on the cloudscale.ch IaaS service" b
- name: $1
	cloudscale_floating_ip:
		# reverse_ptr: # Reverse PTR entry for this address.
		# ip: # Floating IP address to change.
		# api_timeout: 30
		# server: # UUID of the server assigned to this floating IP.
		# state: #present|absent
		# prefix_length: 56
		# api_token: # cloudscale.ch API token.
		# ip_version: 4|6
$0
endsnippet

snippet oneandone_public_ip "Configure 1&1 public IPs." b
- name: $1
	oneandone_public_ip:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		public_ip_id: ${3:# The ID of the public IP used with update and delete states.}
		# datacenter: # ID of the datacenter where the IP will be created (only for unassigned IPs).
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# wait_interval: 5
		# reverse_dns: # Reverse DNS name. maxLength=256
		# state: #present|absent|update
		# wait_timeout: 600
		# type: #IPV4|IPV6
		# wait: #yes|no
$0
endsnippet

snippet oneandone_monitoring_policy "Configure 1&1 monitoring policy." b
- name: $1
	oneandone_monitoring_policy:
		name: ${2:# Monitoring policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		thresholds: ${3:# Monitoring policy thresholds. Each of the suboptions have warning and critical, which both have alert and value suboptions. Warning is used to set limits for warning alerts, critical is used to set critical alerts. alert enables alert, and value is used to advise when the value is exceeded.}
		agent: ${4:# Set true for using agent.}
		email: ${5:# User's email. maxLength=128}
		monitoring_policy: ${6:# The identifier (id or name) of the monitoring policy used with update state.}
		processes: ${7:# Array of processes that will be monitoring.}
		auth_token: ${8:# Authenticating API token provided by 1&1.}
		ports: ${9:# Array of ports that will be monitoring.}
		# add_ports: # Ports to add to the monitoring policy.
		# wait_timeout: 600
		# remove_servers: # Servers to remove from the monitoring policy.
		# update_ports: # Ports to be updated on the monitoring policy.
		# description: # Monitoring policy description. maxLength=256
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# wait_interval: 5
		# remove_processes: # Processes to remove from the monitoring policy.
		# add_servers: # Servers to add to the monitoring policy.
		# state: #present|absent|update
		# update_processes: # Processes to be updated on the monitoring policy.
		# remove_ports: # Ports to remove from the monitoring policy.
		# add_processes: # Processes to add to the monitoring policy.
		# wait: #yes|no
$0
endsnippet

snippet oneandone_firewall_policy "Configure 1&1 firewall policy." b
- name: $1
	oneandone_firewall_policy:
		firewall_policy: ${2:# The identifier (id or name) of the firewall policy used with update state.}
		name: ${3:# Firewall policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		auth_token: ${4:# Authenticating API token provided by 1&1.}
		# add_rules: # A list of rules that will be added to an existing firewall policy. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
		# rules: # A list of rules that will be set for the firewall policy. Each rule must contain protocol parameter, in addition to three optional parameters (port_from, port_to, and source)
		# remove_server_ips: # A list of server IP ids to be unassigned from a firewall policy. Used in combination with update state.
		# wait_interval: 5
		# state: #present|absent|update
		# wait_timeout: 600
		# add_server_ips: # A list of server identifiers (id or name) to be assigned to a firewall policy. Used in combination with update state.
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# wait: #yes|no
		# remove_rules: # A list of rule ids that will be removed from an existing firewall policy. Used in combination with update state.
		# description: # Firewall policy description. maxLength=256
$0
endsnippet

snippet oneandone_server "Create, destroy, start, stop, and reboot a 1&1 Host server." b
- name: $1
	oneandone_server:
		auth_token: ${2:# Authenticating API token provided by 1&1. Overrides the ONEANDONE_AUTH_TOKEN environement variable.}
		fixed_instance_size: ${3:S|M|L|XL|XXL|3XL|4XL|5XL}
		# load_balancer: # The load balancer name or ID.
		# vcore: # The total number of processors. It must be provided with cores_per_processor, ram, and hdds parameters.
		# description: # The description of the server.
		# server_type: #cloud|baremetal|k8s_node
		# auto_increment: #yes|no
		# ram: # The amount of RAM memory. It must be provided with with vcore, cores_per_processor, and hdds parameters.
		# ssh_key: # User's public SSH key (contents, not path).
		# wait_timeout: 600
		# private_network: # The private network name or ID.
		# monitoring_policy: # The monitoring policy name or ID.
		# wait: #yes|no
		# count: 1
		# datacenter: #US|ES|DE|GB
		# firewall_policy: # The firewall policy name or ID.
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# cores_per_processor: # The number of cores per processor. It must be provided with vcore, ram, and hdds parameters.
		# hdds: # A list of hard disks with nested "size" and "is_main" properties. It must be provided with vcore, cores_per_processor, and ram parameters.
		# wait_interval: 5
		# hostname: # The hostname or ID of the server. Only used when state is 'present'.
		# appliance: # The operating system name or ID for the server. It is required only for 'present' state.
		# server: # Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.
		# state: #present|absent|running|stopped
$0
endsnippet

snippet oneandone_private_network "Configure 1&1 private networking." b
- name: $1
	oneandone_private_network:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		name: ${3:# Private network name used with present state. Used as identifier (id or name) when used with absent state.}
		private_network: ${4:# The identifier (id or name) of the network used with update state.}
		# datacenter: # The identifier of the datacenter where the private network will be created
		# description: # Set a description for the network.
		# wait_interval: 5
		# network_address: # Set a private network space, i.e. 192.168.1.0
		# subnet_mask: # Set the netmask for the private network, i.e. 255.255.255.0
		# state: #present|absent|update
		# wait_timeout: 600
		# add_members: # List of server identifiers (name or id) to be added to the private network.
		# wait: #yes|no
		# remove_members: # List of server identifiers (name or id) to be removed from the private network.
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
$0
endsnippet

snippet oneandone_load_balancer "Configure 1&1 load balancer." b
- name: $1
	oneandone_load_balancer:
		load_balancer: ${2:# The identifier (id or name) of the load balancer used with update state.}
		rules: ${3:# A list of rule objects that will be set for the load balancer. Each rule must contain protocol, port_balancer, and port_server parameters, in addition to source parameter, which is optional.}
		auth_token: ${4:# Authenticating API token provided by 1&1.}
		health_check_test: ${5:NONE|TCP|HTTP|ICMP}
		persistence_time: ${6:# Persistence time in seconds. Required if persistence is enabled. minimum=30, maximum=1200, multipleOf=1}
		health_check_interval: ${7:# Health check period in seconds. minimum=5, maximum=300, multipleOf=1}
		name: ${8:# Load balancer name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		method: ${9:ROUND_ROBIN|LEAST_CONNECTIONS}
		persistence: ${10:# Persistence.}
		# add_rules: # A list of rules that will be added to an existing load balancer. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
		# description: # Description of the load balancer. maxLength=256
		# health_check_parse: # Regular expression to check. Required for HTTP health check. maxLength=64
		# wait_timeout: 600
		# add_server_ips: # A list of server identifiers (id or name) to be assigned to a load balancer. Used in combination with update state.
		# health_check_path: # Url to call for cheking. Required for HTTP health check. maxLength=1000
		# wait: #yes|no
		# datacenter: #US|ES|DE|GB
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# wait_interval: 5
		# remove_server_ips: # A list of server IP ids to be unassigned from a load balancer. Used in combination with update state.
		# state: #present|absent|update
		# remove_rules: # A list of rule ids that will be removed from an existing load balancer. Used in combination with update state.
$0
endsnippet

snippet lxc_container "Manage LXC Containers" b
- name: $1
	lxc_container:
		name: ${2:# Name of a container.}
		# archive_path: # Path the save the archived container. If the path does not exist the archive method will attempt to create it.
		# zfs_root: # Create zfs under given zfsroot.
		# container_log_level: #INFO|ERROR|DEBUG
		# template_options: # Template options when building the container.
		# container_command: # Run a command within a container.
		# clone_name: no
		# lxc_path: # Place container under PATH
		# container_config: # list of 'key=value' options to use when configuring a container.
		# fs_type: ext4
		# archive: True|#False
		# vg_name: lxc
		# clone_snapshot: True|#False
		# container_log: True|#False
		# lv_name: $CONTAINER_NAME
		# fs_size: 5G
		# archive_compression: #gzip|bzip2|none
		# backing_store: #dir|lvm|loop|btrfs|overlayfs|zfs
		# state: #started|stopped|restarted|absent|frozen
		# thinpool: # Use LVM thin pool called TP.
		# template: ubuntu
		# directory: # Place rootfs directory under DIR.
		# config: # Path to the LXC configuration file.
$0
endsnippet

snippet lxd_container "Manage LXD Containers" b
- name: $1
	lxd_container:
		name: ${2:# Name of a container.}
		# source: # The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# url: unix:/var/lib/lxd/unix.socket
		# config: # The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# cert_file: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
		# ephemeral: # Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# devices: # The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# wait_for_ipv4_addresses: no
		# state: #started|stopped|restarted|absent|frozen
		# architecture: # The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# timeout: 30
		# key_file: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
		# trust_password: # The client trusted password.
		# force_stop: no
$0
endsnippet

snippet lxd_profile "Manage LXD profiles" b
- name: $1
	lxd_profile:
		name: ${2:# Name of a profile.}
		# new_name: # A new name of a profile.
		# url: unix:/var/lib/lxd/unix.socket
		# config: # The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
		# cert_file: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
		# devices: # The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
		# state: #present|absent
		# key_file: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
		# trust_password: # The client trusted password.
		# description: # Description of the profile.
$0
endsnippet

snippet spotinst_aws_elastigroup "Create, update or delete Spotinst AWS Elastigroups" b
- name: $1
	spotinst_aws_elastigroup:
		unit: ${2:instance|weight}
		availability_zones: ${3:# (List of Objects) a list of hash/dictionaries of Availability Zones that are configured in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are name (String), subnet_id (String), placement_group_name (String),}
		monitoring: ${4:# (Boolean) Describes whether instance Enhanced Monitoring is enabled}
		name: ${5:# (String) Unique name for elastigroup to be created, updated or deleted}
		key_pair: ${6:# (String) Specify a Key Pair to attach to the instances}
		on_demand_instance_type: ${7:# (String) On-demand instance type that will be provisioned}
		product: ${8:Linux/UNIX|SUSE Linux|Windows|Linux/UNIX (Amazon VPC)|SUSE Linux (Amazon VPC)|Windows}
		min_size: ${9:# (Integer) The lower limit number of instances that you can scale down to}
		image_id: ${10:# (String) The image Id used to launch the instance.; In case of conflict between Instance type and image type, an error will be returned}
		security_group_ids: ${11:# (List of Strings) One or more security group IDs. ; In case of update it will override the existing Security Group with the new given array}
		max_size: ${12:# (Integer) The upper limit number of instances that you can scale up to}
		availability_vs_cost: ${13:availabilityOriented|costOriented|balanced}
		target: ${14:# (Integer) The number of instances to launch}
		spot_instance_types: ${15:# (List of Strings) Spot instance type that will be provisioned.}
		# ebs_volume_pool: # (List of Objects) a list of hash/dictionaries of EBS devices to reattach to the elastigroup when available; '[{"key":"value", "key":"value"}]'; keys allowed are - volume_ids (List of Strings), device_name (String)
		# opsworks: # (Object) The elastigroup OpsWorks integration configration.; Expects the following key - layer_id (String)
		# ebs_optimized: # (Boolean) Enable EBS optimization for supported instances which are not enabled by default.; Note - additional charges will be applied.
		# roll_config: # (Object) Roll configuration.; If you would like the group to roll after updating, please use this feature. Accepts the following keys - batch_size_percentage(Integer, Required), grace_period - (Integer, Required), health_check_type(String, Optional)
		# shutdown_script: # (String) The Base64-encoded shutdown script that executes prior to instance termination. Encode before setting.
		# elastic_ips: # (List of Strings) List of ElasticIps Allocation Ids to associate to the group instances
		# account_id: # (String) Optional parameter that allows to set an account-id inside the module configuration By default this is retrieved from the credentials path
		# chef: # (Object) The Chef integration configuration.; Expects the following keys - chef_server (String), organization (String), user (String), pem_key (String), chef_version (String)
		# iam_role_name: # (String) The instance profile iamRole name
		# spin_up_time: # (Integer) spin up time, in seconds, for the instance
		# id: # (String) The group id if it already exists and you want to update, or delete it. This will not work unless the uniqueness_by field is set to id. When this is set, and the uniqueness_by field is set, the group will either be updated or deleted, but not created.
		# risk: # (Integer) required if on demand is not set. The percentage of Spot instances to launch (0 - 100).
		# kubernetes: # (Object) The Kubernetes integration configuration. Expects the following keys - api_server (String), token (String)
		# right_scale: # (Object) The Rightscale integration configuration.; Expects the following keys - account_id (String), refresh_token (String)
		# health_check_grace_period: 300
		# draining_timeout: # (Integer) Time for instance to be drained from incoming requests and deregistered from ELB before termination.
		# target_group_arns: # (List of Strings) List of target group arns instances should be registered to
		# iam_role_arn: # (String) The instance profile iamRole arn
		# signals: # (List of Objects) a list of hash/dictionaries of signals to configure in the elastigroup; keys allowed are - name (String, required), timeout (Integer)
		# state: present|absent
		# health_check_type: ELB|HCS|TARGET_GROUP|MLB|EC2
		# down_scaling_policies: # (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions ((List of Objects), Keys allowed are name (String, required) and value (String)), statistic (String, required), evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), max_target_capacity (String), target (String), maximum (String), minimum (String)
		# health_check_unhealthy_duration_before_replacement: # (Integer) Minimal mount of time instance should be unhealthy for us to consider it unhealthy.
		# rancher: # (Object) The Rancher integration configuration.; Expects the following keys - access_key (String), secret_key (String), master_host (String)
		# on_demand_count: # (Integer) Required if risk is not set
		# fallback_to_od: # (Boolean) In case of no spots available, Elastigroup will launch an On-demand instance instead
		# ignore_changes: image_id|target
		# scheduled_tasks: # (List of Objects) a list of hash/dictionaries of scheduled tasks to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - adjustment (Integer), scale_target_capacity (Integer), scale_min_capacity (Integer), scale_max_capacity (Integer), adjustment_percentage (Integer), batch_size_percentage (Integer), cron_expression (String), frequency (String), grace_period (Integer), task_type (String, required), is_enabled (Boolean)
		# target_tracking_policies: # (List of Objects) a list of hash/dictionaries of target tracking policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), source (String, required), metric_name (String, required), statistic (String, required), unit (String, required), cooldown (String, required), target (String, required)
		# tags: # (List of tagKey:tagValue paris) a list of tags to configure in the elastigroup. Please specify list of keys and values (key colon value);
		# mesosphere: # (Object) The Mesosphere integration configuration. Expects the following key - api_server (String)
		# wait_timeout: # (Integer) How long the module should wait for instances before failing the action.; Only works if wait_for_instances is True.
		# ecs: # (Object) The ECS integration configuration.; Expects the following key - cluster_name (String)
		# terminate_at_end_of_billing_hour: # (Boolean) terminate at the end of billing hour
		# load_balancers: # (List of Strings) List of classic ELB names
		# block_device_mappings: # (List of Objects) a list of hash/dictionaries of Block Device Mappings for elastigroup instances; You can specify virtual devices and EBS volumes.; '[{"key":"value", "key":"value"}]'; keys allowed are device_name (List of Strings), virtual_name (String), no_device (String), ebs (Object, expects the following keys- delete_on_termination(Boolean), encrypted(Boolean), iops (Integer), snapshot_id(Integer), volume_type(String), volume_size(Integer))
		# uniqueness_by: id|name
		# credentials_path: # (String) Optional parameter that allows to set a non-default credentials path. Default is ~/.spotinst/credentials
		# up_scaling_policies: # (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions (List of Objects, Keys allowed are name (String, required) and value (String)), statistic (String, required) evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), min_target_capacity (String), target (String), maximum (String), minimum (String)
		# network_interfaces: # (List of Objects) a list of hash/dictionaries of network interfaces to add to the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - description (String), device_index (Integer), secondary_private_ip_address_count (Integer), associate_public_ip_address (Boolean), delete_on_termination (Boolean), groups (List of Strings), network_interface_id (String), private_ip_address (String), subnet_id (String), associate_ipv6_address (Boolean), private_ip_addresses (List of Objects, Keys are privateIpAddress (String, required) and primary (Boolean))
		# lifetime_period: # (String) lifetime period
		# tenancy: default|dedicated
		# user_data: # (String) Base64-encoded MIME user data. Encode before setting the value.
		# persistence: # (Object) The Stateful elastigroup configration.; Accepts the following keys - should_persist_root_device (Boolean), should_persist_block_devices (Boolean), should_persist_private_ip (Boolean)
		# utilize_reserved_instances: # (Boolean) In case of any available Reserved Instances, Elastigroup will utilize your reservations before purchasing Spot instances.
		# wait_for_instances: # (Boolean) Whether or not the elastigroup creation / update actions should wait for the instances to spin
$0
endsnippet

snippet imgadm "Manage SmartOS images" b
- name: $1
	imgadm:
		state: ${2:present|absent|deleted|imported|updated|vacuumed}
		# source: # URI for the image source.
		# force: True|False
		# uuid: # Image UUID. Can either be a full UUID or C(*) for all images.
		# type: #imgapi|docker|dsapi
		# pool: zones
$0
endsnippet

snippet smartos_image_facts "Get SmartOS image details." b
- name: $1
	smartos_image_facts:
		# filters: # Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.
$0
endsnippet

snippet vmadm "Manage SmartOS virtual machines and zones." b
- name: $1
	vmadm:
		state: ${2:present|absent|stopped|restarted}
		brand: ${3:#joyent|joyent-minimal|kvm|lx}
		# customer_metadata: # Metadata to be set and associated with this VM, this contain customer modifiable keys.
		# disk_driver: # Default value for a virtual disk model for KVM guests.
		# force: # Force a particular action (i.e. stop or delete a VM).
		# zfs_root_compression: # Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.
		# virtio_txtimer: # Timeout (in nanoseconds) for the TX timer of virtio NICs.
		# spice_password: # Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.
		# zfs_io_priority: # IO throttle priority value relative to other VMs.
		# ram: # Amount of virtual RAM for a KVM guest (in MiBs).
		# dns_domain: # Domain value for C(/etc/hosts).
		# max_physical_memory: # Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.
		# nic_driver: # Default value for a virtual NIC model for KVM guests.
		# zfs_data_compression: # Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.
		# image_uuid: # Image UUID.
		# fs_allowed: # Comma separated list of filesystem types this zone is allowed to mount.
		# indestructible_delegated: # Adds an C(@indestructible) snapshot to delegated datasets.
		# qemu_opts: # Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.
		# delegate_dataset: # Whether to delegate a ZFS dataset to an OS VM.
		# firewall_enabled: # Enables the firewall, allowing fwadm(1M) rules to be applied.
		# mdata_exec_timeout: # Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.
		# archive_on_delete: # When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.
		# nics: # A list of nics to add, valid properties are documented in vmadm(1M).
		# hostname: # Zone/VM hostname.
		# boot: # Set the boot order for KVM VMs.
		# vga: # Specify VGA emulation used by KVM VMs.
		# zfs_snapshot_limit: # Number of snapshots the VM can have.
		# limit_priv: # Set (comma separated) list of privileges the zone is allowed to use.
		# cpu_cap: # Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.
		# maintain_resolvers: # Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.
		# indestructible_zoneroot: # Adds an C(@indestructible) snapshot to zoneroot.
		# vnc_password: # Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.
		# vcpus: # Number of virtual CPUs for a KVM guest.
		# disks: # A list of disks to add, valid properties are documented in vmadm(1M).
		# max_swap: # Maximum amount of virtual memory (in MiBs) the VM is allowed to use.
		# zfs_root_recsize: # Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.
		# zfs_filesystem_limit: # Maximum number of filesystems the VM can have.
		# quota: # Quota on zone filesystems (in MiBs).
		# filesystems: # Mount additional filesystems into an OS VM.
		# autoboot: # Whether or not a VM is booted when the system is rebooted.
		# tmpfs: # Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.
		# qemu_extra_opts: # Additional qemu cmdline arguments for KVM guests.
		# resolvers: # List of resolvers to be put into C(/etc/resolv.conf).
		# max_lwps: # Maximum number of lightweight processes this VM is allowed to have running.
		# nowait: # Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.
		# name: # Name of the VM. vmadm(1M) uses this as an optional name.
		# kernel_version: # Kernel version to emulate for LX VMs.
		# max_locked_memory: # Total amount of memory (in MiBs) on the host that can be locked by this VM.
		# vnc_port: # TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.
		# uuid: # UUID of the VM. Can either be a full UUID or C(*) for all VMs.
		# internal_metadata_namespace: # List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata).
		# virtio_txburst: # Number of packets that can be sent in a single flush of the tx queue of virtio NICs.
		# spice_opts: # Addition options for SPICE-enabled KVM VMs.
		# zfs_data_recsize: # Suggested block size (power of 2) for files in the delegated dataset's filesystem.
		# internal_metadata: # Metadata to be set and associated with this VM, this contains operator generated keys.
		# cpu_type: #qemu64|host
		# routes: # Dictionary that maps destinations to gateways, these will be set as static routes in the VM.
		# zpool: # ZFS pool the VM's zone dataset will be created in.
		# docker: # Docker images need this flag enabled along with the I(brand) set to C(lx).
		# cpu_shares: # Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.
$0
endsnippet

snippet vr_dns_domain "Manages DNS domains on Vultr." b
- name: $1
	vr_dns_domain:
		name: ${2:# The domain name.}
		# api_retries: 5
		# api_timeout: 60
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# server_ip: # The default server IP.
		# api_account: default
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
$0
endsnippet

snippet vr_firewall_group "Manages firewall groups on Vultr." b
- name: $1
	vr_firewall_group:
		name: ${2:# Name of the firewall group.}
		# api_retries: 5
		# api_timeout: 60
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# api_account: default
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
$0
endsnippet

snippet vr_account_facts "Gather facts about the Vultr account." b
- name: $1
	vr_account_facts:
		# api_endpoint: https://api.vultr.com
		# api_key: # API key of the Vultr API.
		# api_retries: 5
		# api_account: default
		# api_timeout: 60
		# validate_certs: yes
$0
endsnippet

snippet vr_firewall_rule "Manages firewall rules on Vultr." b
- name: $1
	vr_firewall_rule:
		group: ${2:# Name of the firewall group.}
		# api_timeout: 60
		# protocol: icmp|#tcp|udp|gre
		# end_port: # End port for the firewall rule.
		# api_account: default
		# start_port: # Start port for the firewall rule.
		# api_retries: 5
		# cidr: 0.0.0.0/0 or ::/0 depending on C(ip_version)
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# ip_version: #v4|v6
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
$0
endsnippet

snippet vr_startup_script "Manages startup scripts on Vultr." b
- name: $1
	vr_startup_script:
		name: ${2:# The script name.}
		# api_retries: 5
		# script: # The script source code.
		# api_timeout: 60
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# api_account: default
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
		# script_type: #boot|pxe
$0
endsnippet

snippet vr_ssh_key "Manages ssh keys on Vultr." b
- name: $1
	vr_ssh_key:
		name: ${2:# Name of the ssh key.}
		# api_retries: 5
		# api_timeout: 60
		# ssh_key: # SSH public key.
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# api_account: default
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
$0
endsnippet

snippet vr_dns_record "Manages DNS records on Vultr." b
- name: $1
	vr_dns_record:
		domain: ${2:# The domain the record is related to.}
		# api_endpoint: https://api.vultr.com
		# api_timeout: 60
		# multiple: no
		# name: 
		# validate_certs: yes
		# api_account: default
		# priority: 0
		# record_type: #A|AAAA|CNAME|MX|SRV|ALIAS|SPF|TXT|NS
		# state: #present|absent
		# ttl: 300
		# api_retries: 5
		# api_key: # API key of the Vultr API.
		# data: # Data of the record.
$0
endsnippet

snippet vr_user "Manages users on Vultr." b
- name: $1
	vr_user:
		name: ${2:# Name of the user}
		# force: True|#False
		# api_timeout: 60
		# api_account: default
		# api_retries: 5
		# password: # Password of the user.
		# api_enabled: #True|False
		# api_endpoint: https://api.vultr.com
		# state: #present|absent
		# acls: manage_users|subscriptions|provisioning|billing|support|abuse|dns|upgrade
		# api_key: # API key of the Vultr API.
		# validate_certs: yes
		# email: # Email of the user.
$0
endsnippet

snippet vr_server "Manages virtual servers on Vultr." b
- name: $1
	vr_server:
		name: ${2:# Name of the server.}
		# reserved_ip_v4: # IP address of the floating IP to use as the main IP of this server.
		# force: # Force stop/start the server if required to apply changes
		# api_timeout: 60
		# user_data: # User data to be passed to the server.
		# tag: # Tag for the server.
		# plan: # Plan to use for the server.
		# api_account: default
		# ipv6_enabled: # Whether to enable IPv6 or not.
		# ssh_keys: # List of SSH keys passed to the server on creation.
		# private_network_enabled: # Whether to enable private networking or not.
		# api_retries: 5
		# validate_certs: yes
		# region: # Region the server is deployed into.
		# hostname: # Hostname to assign to this server.
		# firewall_group: # The firewall group to assign this server to.
		# notify_activate: # Whether to send an activation email when the server is ready or not.
		# api_endpoint: https://api.vultr.com
		# state: #present|absent|restarted|reinstalled|started|stopped
		# auto_backup_enabled: # Whether to enable automatic backups or not.
		# startup_script: # Name of the startup script to execute on boot.
		# api_key: # API key of the Vultr API.
		# os: # The operating system.
$0
endsnippet

snippet dimensiondata_network "Create, update, and delete MCP 1.0 & 2.0 networks" b
- name: $1
	dimensiondata_network:
		name: ${2:# The name of the network domain to create.}
		location: ${3:# The target datacenter.}
		# service_plan: #ESSENTIALS|ADVANCED
		# mcp_user: # The username used to authenticate to the CloudControl API.
		# mcp_password: # The password used to authenticate to the CloudControl API.
		# region: Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.
		# wait_time: 600
		# state: #present|absent
		# wait_poll_interval: 2
		# wait: no
		# validate_certs: yes
		# description: # Additional description of the network domain.
$0
endsnippet

snippet dimensiondata_vlan "Manage a VLAN in a Cloud Control network domain." b
- name: $1
	dimensiondata_vlan:
		location: ${2:# The target datacenter.}
		network_domain: ${3:# The Id or name of the target network domain.}
		# description: # A description of the VLAN.
		# private_ipv4_base_address: # The base address for the VLAN's IPv4 network (e.g. 192.168.1.0).
		# private_ipv4_prefix_size: # The size of the IPv4 address space, e.g 24.
		# allow_expand: no
		# wait_poll_interval: 2
		# mcp_user: # The username used to authenticate to the CloudControl API.
		# name: # The name of the target VLAN.
		# mcp_password: # The password used to authenticate to the CloudControl API.
		# region: Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.
		# wait: no
		# wait_time: 600
		# state: #present|absent|readonly
		# validate_certs: yes
$0
endsnippet

snippet ovirt_storage_domains "Module to manage storage domains in oVirt/RHV" b
- name: $1
	ovirt_storage_domains:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the storage domain.
		# fcp: # Dictionary with values for fibre channel storage type:
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# description: # Description of the storage domain.
		# format: # If I(True) storage domain will be formatted after removing it from oVirt/RHV.
		# warning_low_space: # Inidcates the minimum percentage of a free space in a storage domain to present a warning.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# glusterfs: # Dictionary with values for GlusterFS storage type:
		# localfs: # Dictionary with values for localfs storage type:
		# discard_after_delete: # If I(True) storage domain blocks will be discarded upon deletion. Enabled by default.
		# data_center: # Data center name where storage domain should be attached.
		# id: # Id of the storage domain to be imported.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# domain_function: #data|iso|export
		# name: # Name of the storage domain to manage. (Not required when state is I(imported))
		# critical_space_action_blocker: # Inidcates the minimal free space the storage domain should contain in percentages.
		# iscsi: # Dictionary with values for iSCSI storage type:
		# posixfs: # Dictionary with values for PosixFS storage type:
		# poll_interval: 3
		# host: # Host to be used to mount storage.
		# state: #present|absent|maintenance|unattached|update_ovf_store
		# nfs: # Dictionary with values for NFS storage type:
		# timeout: 180
		# wipe_after_delete: # Boolean flag which indicates whether the storage domain should wipe the data after delete.
		# destroy: # Logical remove of the storage domain. If I(true) retains the storage domain's data for import.
		# backup: # Boolean flag which indicates whether the storage domain is configured as backup or not.
$0
endsnippet

snippet ovirt_quotas "Module to manage datacenter quotas in oVirt/RHV" b
- name: $1
	ovirt_quotas:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		data_center: ${3:# Name of the datacenter where quota should be managed.}
		name: ${4:# Name of the quota to manage.}
		# timeout: 180
		# description: # Description of the quota to manage.
		# cluster_grace: # Cluster grace(hard limit) defined in percentage (1-100).
		# cluster_threshold: # Cluster threshold(soft limit) defined in percentage (0-100).
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: #present|absent
		# storage_grace: # Storage grace(hard limit) defined in percentage (1-100).
		# storage_threshold: # Storage threshold(soft limit) defined in percentage (0-100).
		# clusters: # List of dictionary of cluster limits, which is valid to specific cluster.
		# storages: # List of dictionary of storage limits, which is valid to specific storage.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_snapshots "Module to manage Virtual Machine Snapshots in oVirt/RHV" b
- name: $1
	ovirt_snapshots:
		vm_name: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the snapshot.
		# use_memory: # If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.
		# poll_interval: 3
		# state: restore|#present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# timeout: 180
		# snapshot_id: # ID of the snapshot to manage.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_templates_facts "Retrieve facts about one or more oVirt/RHV templates" b
- name: $1
	ovirt_templates_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the data center.
		# compatibility_version: # Compatibility version of the data center.
		# force: no
		# mac_pool: # MAC pool to be used by this datacenter.
		# local: # I(True) if the data center should be local, I(False) if should be shared.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: #present|absent
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# quota_mode: disabled|audit|enabled
		# description: # Description of the data center.
$0
endsnippet

snippet ovirt_nics_facts "Retrieve facts about one or more oVirt/RHV virtual machine network interfaces" b
- name: $1
	ovirt_nics_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		vm: ${3:# Name of the VM where NIC is attached.}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# name: # Name of the NIC, can be used as glob expression.
$0
endsnippet

snippet ovirt_storage_connections "Module to manage storage connections in oVirt" b
- name: $1
	ovirt_storage_connections:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: # A CHAP username for logging into a target.
		# force: # This parameter is releven only when updating a connection.
		# poll_interval: 3
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# mount_options: # Option which will be passed when mounting storage.
		# address: # Address of the storage server. E.g.: myserver.mydomain.com
		# nfs_timeout: # The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.
		# path: # Path of the mount point of the storage. E.g.: /path/to/my/data
		# password: # A CHAP password for logging into a target.
		# nfs_version: # NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# target: # The target IQN for the storage device.
		# id: # Id of the storage connection to manage.
		# storage: # Name of the storage domain to be used with storage connection.
		# nfs_retrans: # The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.
		# port: # Port of the iSCSI storage server.
		# state: #present|absent
		# timeout: 180
		# vfs_type: # Virtual File System type.
		# type: # Storage type. For example: I(nfs), I(iscsi), etc.
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the affinity labels which should be listed.
		# host: # Name of the host, which affinity labels should be listed.
		# vm: # Name of the VM, which affinity labels should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_scheduling_policies_facts "Retrieve facts about one or more oVirt scheduling policies" b
- name: $1
	ovirt_scheduling_policies_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		id: ${3:# ID of the scheduling policy.}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# name: # Name of the scheduling policy, can be used as glob expression.
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: # Username to be used for login to external provider.
		# read_only: # Specify if the network should be read only.
		# name: # Name of the external provider to manage.
		# url: # URL where external provider is hosted.
		# tenant_name: # Name of the tenant.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: #present|absent
		# authentication_url: # Keystone authentication URL of the openstack provider.
		# timeout: 180
		# data_center: # Name of the data center where provider should be attached.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# password: # Password of the user specified in C(username) parameter.
		# type: os_image|network|os_volume|foreman
		# network_type: [#external, neutron
		# description: # Description of the external provider.
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# namespace: # Namespace of the authorization provider, where group resides.
		# state: #present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_users_facts "Retrieve facts about one or more oVirt/RHV users" b
- name: $1
	ovirt_users_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: 3
		# state: #present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster where vms and hosts resides.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# hosts: # List of the hosts names, which should have assigned this affinity label.
		# timeout: 180
		# vms: # List of the VMs names, which should have assigned this affinity label.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# namespace: # Namespace of the authorization provider, where group resides.
		# state: #present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_mac_pools "Module to manage MAC pools in oVirt/RHV" b
- name: $1
	ovirt_mac_pools:
		name: ${2:# Name of the MAC pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# ranges: # List of MAC ranges. The from and to should be split by comma.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# allow_duplicates: # If (true) allow a MAC address to be used multiple times in a pool.
		# state: #present|absent
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# description: # Description of the MAC pool.
$0
endsnippet

snippet ovirt_storage_templates_facts "Retrieve facts about one or more oVirt/RHV templates relate to a storage domain." b
- name: $1
	ovirt_storage_templates_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: # Flag which indicates whether to get unregistered templates which contain one or more disks which reside on a storage domain or diskless templates.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_networks "Module to manage logical networks in oVirt/RHV" b
- name: $1
	ovirt_networks:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the network to manage.}
		# comment: # Comment of the network.
		# timeout: 180
		# description: # Description of the network.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# mtu: # Maximum transmission unit (MTU) of the network.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# state: #present|absent
		# vm_network: # If I(True) network will be marked as network for VM.
		# data_center: # Datacenter name where network reside.
		# clusters: # List of dictionaries describing how the network is managed in specific cluster.
		# vlan_tag: # Specify VLAN tag.
		# label: # Name of the label to assign to the network.
$0
endsnippet

snippet ovirt_storage_vms_facts "Retrieve facts about one or more oVirt/RHV virtual machines relate to a storage domain." b
- name: $1
	ovirt_storage_vms_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: # Flag which indicates whether to get unregistered virtual machines which contain one or more disks which reside on a storage domain or diskless virtual machines.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_storage_domains_facts "Retrieve facts about one or more oVirt/RHV storage domains" b
- name: $1
	ovirt_storage_domains_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_host_storage_facts "Retrieve facts about one or more oVirt/RHV HostStorages (applicable only for block storage)" b
- name: $1
	ovirt_host_storage_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		host: ${3:# Host to get device list from.}
		# fcp: # Dictionary with values for fibre channel storage type:
		# iscsi: # Dictionary with values for iSCSI storage type:
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_vms "Module to manage Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_vms:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the Virtual Machine.
		# graphical_console: # Assign graphical console to the virtual machine.
		# cloud_init_nics: # List of dictionaries representing network interafaces to be setup by cloud init.
		# boot_menu: # I(True) enable menu to select boot device, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# xen: # Dictionary of values to be used to connect to XEN and import a virtual machine to oVirt.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# watchdog: # Assign watchdog device for the virtual machine.
		# memory_max: # Upper bound of virtual machine memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# cpu_sockets: # Number of virtual CPUs sockets of the Virtual Machine.
		# high_availability: # If I(yes) Virtual Machine will be set as highly available.
		# storage_domain: # Name of the storage domain where all template disks should be created.
		# domain_mappings: # Mapper which maps aaa domain name between VM's OVF and the destination aaa domain this VM should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# disk_format: #cow|raw
		# cpu_cores: # Number of virtual CPUs cores of the Virtual Machine.
		# ballooning_enabled: # If I(true), use memory ballooning.
		# memory_guaranteed: # Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory: # Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# clone_permissions: no
		# type: desktop|server|high_performance
		# initrd_path: # Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.
		# lease: # Name of the storage domain this virtual machine lease reside on.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# lun_mappings: # Mapper which maps lun between VM's OVF and the destination lun this VM should contain, relevant when C(state) is registered. lun_mappings is described by the following dictionary: - C(logical_unit_id): The logical unit number to identify a logical unit, - C(logical_unit_port): The port being used to connect with the LUN disk. - C(logical_unit_portal): The portal being used to connect with the LUN disk. - C(logical_unit_address): The address of the block storage host. - C(logical_unit_target): The iSCSI specification located on an iSCSI server - C(logical_unit_username): Username to be used to connect to the block storage host. - C(logical_unit_password): Password to be used to connect to the block storage host. - C(storage_type): The storage type which the LUN reside on (iscsi or fcp)
		# serial_console: # I(True) enable VirtIO serial console, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# sso: # I(True) enable Single Sign On by Guest Agent, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# cpu_threads: # Number of virtual CPUs sockets of the Virtual Machine.
		# quota_id: # Virtual Machine quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# use_latest_template_version: # Specify if latest template version should be used, when running a stateless VM.
		# affinity_group_mappings: # Mapper which maps affinty name between VM's OVF and the destination affinity this VM should be registered to, relevant when C(state) is registered.
		# operating_system: debian_7|freebsd|freebsdx64|other|other_linux|other_linux_ppc64|other_ppc64|rhel_3|rhel_4|rhel_4x64|rhel_5|rhel_5x64|rhel_6|rhel_6x64|rhel_6_ppc64|rhel_7x64|rhel_7_ppc64|sles_11|sles_11_ppc64|ubuntu_12_04|ubuntu_12_10|ubuntu_13_04|ubuntu_13_10|ubuntu_14_04|ubuntu_14_04_ppc64|windows_10|windows_10x64|windows_2003|windows_2003x64|windows_2008|windows_2008x64|windows_2008r2x64|windows_2008R2x64|windows_2012x64|windows_2012R2x64|windows_7|windows_7x64|windows_8|windows_8x64|windows_xp
		# serial_policy_value: # Allows you to specify a custom serial number.
		# name: # Name of the Virtual Machine to manage.
		# cpu_pinning: # CPU Pinning topology to map virtual machine CPU to host CPU.
		# timeout: 180
		# kernel_params: # Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.
		# cpu_shares: # Set a CPU shares for this Virtual Machine.
		# affinity_label_mappings: # Mappper which maps affinity label name between VM's OVF and the destination label this VM should be registered to, relevant when C(state) is registered.
		# disks: # List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary.
		# force: no
		# placement_policy: # The configuration of the virtual machine's placement policy.
		# usb_support: # I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# cluster: # Name of the cluster, where Virtual Machine should be created.
		# io_threads: # Number of IO threads used by virtual machine. I(0) means IO threading disabled.
		# timezone: # Sets time zone offset of the guest hardware clock.
		# id: # ID of the Virtual Machine to manage.
		# vmware: # Dictionary of values to be used to connect to VMware and import a virtual machine to oVirt.
		# soundcard_enabled: # If I(true), the sound card is added to the virtual machine.
		# high_availability_priority: # Indicates the priority of the virtual machine inside the run and migration queues. Virtual machines with higher priorities will be started and migrated before virtual machines with lower priorities. The value is an integer between 0 and 100. The higher the value, the higher the priority.
		# nics: # List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.
		# custom_properties: # Properties sent to VDSM to configure various hooks.
		# sysprep: # Dictionary with values for Windows Virtual Machine initialization using sysprep.
		# cpu_mode: # CPU mode of the virtual machine. It can be some of the following: I(host_passthrough), I(host_model) or I(custom).
		# state: absent|next_run|#present|registered|running|stopped|suspended
		# template: # Name of the template, which should be used to create Virtual Machine.
		# cd_iso: # ISO file from ISO storage domain which should be attached to Virtual Machine.
		# cloud_init_persist: # If I(true) the C(cloud_init) or C(sysprep) parameters will be saved for the virtual machine and won't be virtual machine won't be started as run-once.
		# kernel_path: # Path to a kernel image used to boot the virtual machine.
		# rng_device: # Random number generator (RNG). You can choose of one the following devices I(urandom), I(random) or I(hwrng).
		# description: # Description of the Virtual Machine.
		# boot_devices: cdrom|hd|network
		# clone: no
		# kvm: # Dictionary of values to be used to connect to kvm and import a virtual machine to oVirt.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# host: # Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.
		# role_mappings: # Mapper which maps role name between VM's OVF and the destination role this VM should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# serial_policy: # Specify a serial number policy for the Virtual Machine.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# stateless: # If I(yes) Virtual Machine will be set as stateless.
		# cloud_init: # Dictionary with values for Unix-like Virtual Machine initialization using cloud init.
		# template_version: # Version number of the template to be used for VM.
		# poll_interval: 3
		# instance_type: # Name of virtual machine's hardware configuration.
		# reassign_bad_macs: # Boolean indication whether to reassign bad macs when C(state) is registered.
		# smartcard_enabled: # If I(true), use smart card authentication.
		# allow_partial_import: # Boolean indication whether to allow partial registration of Virtual Machine when C(state) is registered.
		# cluster_mappings: # Mapper which maps cluster name between VM's OVF and the destination cluster this VM should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# delete_protected: # If I(yes) Virtual Machine will be set as delete protected.
$0
endsnippet

snippet ovirt_quotas_facts "Retrieve facts about one or more oVirt/RHV quotas" b
- name: $1
	ovirt_quotas_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		data_center: ${3:# Name of the datacenter where quota resides.}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# name: # Name of the quota, can be used as glob expression.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		name: ${2:# Name of the affinity group to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm_enforcing: # If I(yes) VM cannot start if it does not satisfy the C(vm_rule).
		# host_rule: negative|positive
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster of the affinity group.
		# state: absent|#present
		# hosts: # List of the hosts names, which should have assigned this affinity group.
		# timeout: 180
		# vm_rule: disabled|negative|positive
		# host_enforcing: # If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# vms: # List of the VMs names, which should have assigned this affinity group.
		# description: # Description of the affinity group.
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		type: ${3:os_image|os_network|os_volume|foreman}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# name: # Name of the external provider, can be used as glob expression.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# profile: # Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.
		# vm_name: # Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# storage_domains: # Storage domain names where disk should be copied.
		# force: # Please take a look at C(image_path) documentation to see the correct usage of this parameter.
		# description: # Description of the disk image to manage.
		# sparsify: # I(True) if the disk should be sparsified.
		# poll_interval: 3
		# logical_unit: # Dictionary which describes LUN to be directly attached to VM:
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# quota_id: # Disk quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# download_image_path: # Path on a file system where disk should be downloaded.
		# interface: #virtio|ide|virtio_scsi
		# vm_id: # ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# id: # ID of the disk to manage. Either C(id) or C(name) is required.
		# size: # Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.
		# storage_domain: # Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.
		# openstack_volume_type: # Name of the openstack volume type. This is valid when working with cinder.
		# bootable: # I(True) if the disk should be bootable. By default when disk is created it isn't bootable.
		# format: raw|cow
		# upload_image_path: # Path to disk image, which should be uploaded.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# name: # Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.
		# state: #present|absent|attached|detached
		# shareable: # I(True) if the disk should be shareable. By default when disk is created it isn't shareable.
		# sparse: # I(True) if the disk should be sparse (also known as I(thin provision)). If the parameter is omitted, cow disks will be created as sparse and raw disks as I(preallocated)
		# image_provider: # When C(state) is I(exported) disk is exported to given Glance image provider.
$0
endsnippet

snippet ovirt_nics "Module to manage network interfaces of Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_nics:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the network interface to manage.}
		# profile: # Virtual network interface profile to be attached to VM network interface.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# network: # Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.
		# poll_interval: 3
		# vm: # Name of the Virtual Machine to manage.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: absent|plugged|#present|unplugged
		# timeout: 180
		# template: # Name of the template to manage.
		# mac_address: # Custom MAC address of the network interface, by default it's obtained from MAC pool.
		# interface: e1000|pci_passthrough|rtl8139|rtl8139_virtio|spapr_vlan|#virtio
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_api_facts "Retrieve facts about the oVirt/RHV API" b
- name: $1
	ovirt_api_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_vmpools "Module to manage VM pools in oVirt/RHV" b
- name: $1
	ovirt_vmpools:
		name: ${2:# Name of the VM pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# timeout: 180
		# description: # Description of the VM pool.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# vm_per_user: # Maximum number of VMs a single user can attach to from this pool.
		# cluster: # Name of the cluster, where VM pool should be created.
		# state: #present|absent
		# prestarted: # Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.
		# template: # Name of the template, which will be used to create VM pool.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# type: manual|automatic
		# vm_count: # Number of VMs in the pool.
$0
endsnippet

snippet ovirt_permissions "Module to manage permissions of users/groups in oVirt/RHV" b
- name: $1
	ovirt_permissions:
		authz_name: ${2:# Authorization provider of the user/group.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# object_type: cluster|cpu_profile|data_center|disk|disk_profile|host|network|storage_domain|system|template|#vm|vm_pool|vnic_profile
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# state: absent|#present
		# object_id: # ID of the object where the permissions should be managed.
		# group_name: # Name of the group to manage.
		# object_name: # Name of the object where the permissions should be managed.
		# role: UserRole
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_auth "Module to manage authentication to oVirt/RHV" b
- name: $1
	ovirt_auth:
		# username: # The name of the user. For example: I(admin@internal) Default value is set by I(OVIRT_USERNAME) environment variable.
		# ca_file: # A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used. Default value is set by I(OVIRT_CAFILE) environment variable.
		# url: # A string containing the base URL of the server. For example: I(https://server.example.com/ovirt-engine/api). Default value is set by I(OVIRT_URL) environment variable.
		# insecure: # A boolean flag that indicates if the server TLS certificate and host name should be checked.
		# kerberos: # A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.
		# compress: # A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).
		# state: #present|absent
		# headers: # A dictionary of HTTP headers to be added to each API call.
		# token: # SSO token to be used instead of login with username/password. Default value is set by I(OVIRT_TOKEN) environment variable.
		# timeout: # The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.
		# password: # The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.
$0
endsnippet

snippet ovirt_tags "Module to manage tags in oVirt/RHV" b
- name: $1
	ovirt_tags:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the tag to manage.}
		# description: # Description of the tag to manage.
		# parent: # Name of the parent tag.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# vms: # List of the VMs names, which should have assigned this tag.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# poll_interval: 3
		# state: #present|absent|attached|detached
		# hosts: # List of the hosts names, which should have assigned this tag.
		# timeout: 180
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_templates "Module to manage virtual machine templates in oVirt/RHV" b
- name: $1
	ovirt_templates:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# exclusive: # When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.
		# description: # Description of the template.
		# image_provider: # When C(state) is I(imported) this parameter specifies the name of the image provider to be used.
		# image_disk: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.
		# vm: # Name of the VM, which will be used to create template.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster, where template should be created/imported.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# role_mappings: # Mapper which maps role name between Template's OVF and the destination role this Template should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# seal: no
		# id: # ID of the template to be registered.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# storage_domain: # When C(state) is I(imported) this parameter specifies the name of the destination data storage domain. When C(state) is I(registered) this parameter specifies the name of the data storage domain of the unregistered template.
		# domain_mappings: # Mapper which maps aaa domain name between Template's OVF and the destination aaa domain this Template should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# export_domain: # When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.
		# template_image_disk_name: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the new name for imported disk, if omitted then I(image_disk) name is used by default. This parameter is used only in case of importing disk image from Glance domain.
		# cpu_profile: # CPU profile to be set to template.
		# poll_interval: 3
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# name: # Name of the template to manage.
		# state: #present|absent|exported|imported|registered
		# timeout: 180
		# allow_partial_import: # Boolean indication whether to allow partial registration of a template when C(state) is registered.
		# cluster_mappings: # Mapper which maps cluster name between Template's OVF and the destination cluster this Template should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# clone_permissions: no
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_hosts "Module to manage hosts in oVirt/RHV" b
- name: $1
	ovirt_hosts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the host to manage.}
		# comment: # Description of the host.
		# activate: yes
		# force: no
		# address: # Host address. It can be either FQDN (preferred) or IP address.
		# power_management_enabled: # Enable or disable power management of the host.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster, where host should be created.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# hosted_engine: # If I(deploy) it means this host should deploy also hosted engine components.
		# override_iptables: # If True host iptables will be overridden by host deploy script.
		# kdump_integration: #enabled|disabled
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# check_upgrade: yes
		# public_key: no
		# password: # Password of the root. It's required in case C(public_key) is set to I(False).
		# spm_priority: # SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.
		# iscsi: # If C(state) is I(iscsidiscover) it means that the iscsi attribute is being used to discover targets
		# poll_interval: 3
		# kernel_params: # List of kernel boot parameters.
		# state: #present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled|iscsidiscover|iscsilogin
		# timeout: 180
		# override_display: # Override the display address of all VMs on this host with specified address.
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# profile: # Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.
		# vm_name: # Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# storage_domains: # Storage domain names where disk should be copied.
		# force: # Please take a look at C(image_path) documentation to see the correct usage of this parameter.
		# description: # Description of the disk image to manage.
		# sparsify: # I(True) if the disk should be sparsified.
		# poll_interval: 3
		# logical_unit: # Dictionary which describes LUN to be directly attached to VM:
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# quota_id: # Disk quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# download_image_path: # Path on a file system where disk should be downloaded.
		# interface: #virtio|ide|virtio_scsi
		# vm_id: # ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# id: # ID of the disk to manage. Either C(id) or C(name) is required.
		# size: # Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.
		# storage_domain: # Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.
		# openstack_volume_type: # Name of the openstack volume type. This is valid when working with cinder.
		# bootable: # I(True) if the disk should be bootable. By default when disk is created it isn't bootable.
		# format: raw|cow
		# upload_image_path: # Path to disk image, which should be uploaded.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# name: # Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.
		# state: #present|absent|attached|detached
		# shareable: # I(True) if the disk should be shareable. By default when disk is created it isn't shareable.
		# sparse: # I(True) if the disk should be sparse (also known as I(thin provision)). If the parameter is omitted, cow disks will be created as sparse and raw disks as I(preallocated)
		# image_provider: # When C(state) is I(exported) disk is exported to given Glance image provider.
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		name: ${2:# Name of the affinity group to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm_enforcing: # If I(yes) VM cannot start if it does not satisfy the C(vm_rule).
		# host_rule: negative|positive
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster of the affinity group.
		# state: absent|#present
		# hosts: # List of the hosts names, which should have assigned this affinity group.
		# timeout: 180
		# vm_rule: disabled|negative|positive
		# host_enforcing: # If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# vms: # List of the VMs names, which should have assigned this affinity group.
		# description: # Description of the affinity group.
$0
endsnippet

snippet ovirt_tags_facts "Retrieve facts about one or more oVirt/RHV tags" b
- name: $1
	ovirt_tags_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the tag which should be listed.
		# poll_interval: 3
		# host: # Name of the host, which tags should be listed.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# vm: # Name of the VM, which tags should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_networks_facts "Retrieve facts about one or more oVirt/RHV networks" b
- name: $1
	ovirt_networks_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		type: ${3:os_image|os_network|os_volume|foreman}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# name: # Name of the external provider, can be used as glob expression.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_snapshots_facts "Retrieve facts about one or more oVirt/RHV virtual machine snapshots" b
- name: $1
	ovirt_snapshots_facts:
		vm: ${2:# Name of the VM with snapshot.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the snapshot, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# snapshot_id: # Id of the snaphost we want to retrieve facts about.
$0
endsnippet

snippet ovirt_hosts_facts "Retrieve facts about one or more oVirt/RHV hosts" b
- name: $1
	ovirt_hosts_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the data center.
		# compatibility_version: # Compatibility version of the data center.
		# force: no
		# mac_pool: # MAC pool to be used by this datacenter.
		# local: # I(True) if the data center should be local, I(False) if should be shared.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: #present|absent
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# quota_mode: disabled|audit|enabled
		# description: # Description of the data center.
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: 3
		# state: #present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# cluster: # Name of the cluster where vms and hosts resides.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# hosts: # List of the hosts names, which should have assigned this affinity label.
		# timeout: 180
		# vms: # List of the VMs names, which should have assigned this affinity label.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_vmpools_facts "Retrieve facts about one or more oVirt/RHV vmpools" b
- name: $1
	ovirt_vmpools_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: # Username to be used for login to external provider.
		# read_only: # Specify if the network should be read only.
		# name: # Name of the external provider to manage.
		# url: # URL where external provider is hosted.
		# tenant_name: # Name of the tenant.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# state: #present|absent
		# authentication_url: # Keystone authentication URL of the openstack provider.
		# timeout: 180
		# data_center: # Name of the data center where provider should be attached.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# password: # Password of the user specified in C(username) parameter.
		# type: os_image|network|os_volume|foreman
		# network_type: [#external, neutron
		# description: # Description of the external provider.
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the cluster to manage.}
		# comment: # Comment of the cluster.
		# ha_reservation: # If I(True) enable the oVirt/RHV to monitor cluster capacity for highly available virtual machines.
		# fence_skip_if_connectivity_broken: # If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.
		# mac_pool: # MAC pool to be used by this cluster.
		# virt: # If I(True), hosts in this cluster will be used to run virtual machines.
		# threads_as_cores: # If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.
		# gluster: # If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.
		# vm_reason: # If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# migration_bandwidth_limit: # Set the I(custom) migration bandwidth limit.
		# switch_type: legacy|ovs
		# data_center: # Datacenter name where cluster reside.
		# ksm_numa: # If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.
		# description: # Description of the cluster.
		# cpu_arch: x86_64|ppc64|undefined
		# rng_sources: # List that specify the random number generator devices that all hosts in the cluster will use.
		# network: # Management network of cluster to access cluster hosts.
		# state: #present|absent
		# ksm: # I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.
		# external_network_providers: # List of references to the external network providers available in the cluster. If the automatic deployment of the external network provider is supported, the networks of the referenced network provider are available on every host in the cluster.
		# migration_compressed: true|false|inherit
		# ballooning: # If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.
		# migration_auto_converge: true|false|inherit
		# fence_enabled: # If I(True) enables fencing on the cluster.
		# migration_policy: legacy|minimal_downtime|suspend_workload|post_copy
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# resilience_policy: do_not_migrate|migrate|migrate_highly_available
		# fence_connectivity_threshold: # The threshold used by C(fence_skip_if_connectivity_broken).
		# spice_proxy: # The proxy by which the SPICE client will connect to virtual machines.
		# memory_policy: disabled|server|desktop
		# migration_bandwidth: auto|hypervisor_default|custom
		# fence_skip_if_sd_active: # If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.
		# scheduling_policy: # Name of the scheduling policy to be used for cluster.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# compatibility_version: # The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.
		# serial_policy_value: # Allows you to specify a custom serial number.
		# host_reason: # If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# poll_interval: 3
		# cpu_type: # CPU codename. For example I(Intel SandyBridge Family).
		# timeout: 180
		# serial_policy: # Specify a serial number policy for the virtual machines in the cluster.
		# trusted_service: # If (True) enable integration with an OpenAttestation server.
$0
endsnippet

snippet ovirt_disk_facts "Retrieve facts about one or more oVirt/RHV disks" b
- name: $1
	ovirt_disk_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		name: ${3:# Name of the cluster to manage.}
		# comment: # Comment of the cluster.
		# ha_reservation: # If I(True) enable the oVirt/RHV to monitor cluster capacity for highly available virtual machines.
		# fence_skip_if_connectivity_broken: # If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.
		# mac_pool: # MAC pool to be used by this cluster.
		# virt: # If I(True), hosts in this cluster will be used to run virtual machines.
		# threads_as_cores: # If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.
		# gluster: # If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.
		# vm_reason: # If I(True) enable an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# migration_bandwidth_limit: # Set the I(custom) migration bandwidth limit.
		# switch_type: legacy|ovs
		# data_center: # Datacenter name where cluster reside.
		# ksm_numa: # If I(True) enables KSM C(ksm) for best berformance inside NUMA nodes.
		# description: # Description of the cluster.
		# cpu_arch: x86_64|ppc64|undefined
		# rng_sources: # List that specify the random number generator devices that all hosts in the cluster will use.
		# network: # Management network of cluster to access cluster hosts.
		# state: #present|absent
		# ksm: # I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.
		# external_network_providers: # List of references to the external network providers available in the cluster. If the automatic deployment of the external network provider is supported, the networks of the referenced network provider are available on every host in the cluster.
		# migration_compressed: true|false|inherit
		# ballooning: # If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.
		# migration_auto_converge: true|false|inherit
		# fence_enabled: # If I(True) enables fencing on the cluster.
		# migration_policy: legacy|minimal_downtime|suspend_workload|post_copy
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# resilience_policy: do_not_migrate|migrate|migrate_highly_available
		# fence_connectivity_threshold: # The threshold used by C(fence_skip_if_connectivity_broken).
		# spice_proxy: # The proxy by which the SPICE client will connect to virtual machines.
		# memory_policy: disabled|server|desktop
		# migration_bandwidth: auto|hypervisor_default|custom
		# fence_skip_if_sd_active: # If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.
		# scheduling_policy: # Name of the scheduling policy to be used for cluster.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# compatibility_version: # The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.
		# serial_policy_value: # Allows you to specify a custom serial number.
		# host_reason: # If I(True) enable an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# poll_interval: 3
		# cpu_type: # CPU codename. For example I(Intel SandyBridge Family).
		# timeout: 180
		# serial_policy: # Specify a serial number policy for the virtual machines in the cluster.
		# trusted_service: # If (True) enable integration with an OpenAttestation server.
$0
endsnippet

snippet ovirt_users "Module to manage users in oVirt/RHV" b
- name: $1
	ovirt_users:
		name: ${2:# Name of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		authz_name: ${3:# Authorization provider of the user. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# poll_interval: 3
		# state: #present|absent
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# timeout: 180
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_permissions_facts "Retrieve facts about one or more oVirt/RHV permissions" b
- name: $1
	ovirt_permissions_facts:
		authz_name: ${2:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# group_name: # Name of the group to manage.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
$0
endsnippet

snippet ovirt_host_pm "Module to manage power management of hosts in oVirt/RHV" b
- name: $1
	ovirt_host_pm:
		name: ${2:# Name of the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# username: # Username to be used to connect to power management interface.
		# slot: # Power management slot.
		# password: # Password of the user specified in C(username) parameter.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# order: # Integer value specifying, by default it's added at the end.
		# port: # Power management interface port.
		# state: #present|absent
		# timeout: 180
		# address: # Address of the power management interface.
		# encrypt_options: # If (true) options will be encrypted when send to agent.
		# type: # Type of the power management. oVirt/RHV predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type.
		# options: # Dictionary of additional fence agent options.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
$0
endsnippet

snippet ovirt_host_networks "Module to manage host networks in oVirt/RHV" b
- name: $1
	ovirt_host_networks:
		name: ${2:# Name of the host to manage networks for.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# labels: # List of names of the network label to be assigned to bond or interface.
		# poll_interval: 3
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# networks: # List of dictionary describing networks to be attached to interface or bond:
		# state: #present|absent
		# timeout: 180
		# interface: # Name of the network interface where logical network should be attached.
		# wait: # I(True) if the module should wait for the entity to get into desired state.
		# save: # If I(true) network configuration will be persistent, by default they are temporary.
		# check: # If I(true) verify connectivity between host and engine.
		# bond: # Dictionary describing network bond:
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the affinity labels which should be listed.
		# host: # Name of the host, which affinity labels should be listed.
		# vm: # Name of the VM, which affinity labels should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_vms_facts "Retrieve facts about one or more oVirt/RHV virtual machines" b
- name: $1
	ovirt_vms_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# all_content: # If I(true) all the attributes of the virtual machines should be included in the response.
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# case_sensitive: # If I(true) performed search will take case into account.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# max: # The maximum number of results to return.
$0
endsnippet

snippet packet_device "Manage a bare metal server in the Packet Host." b
- name: $1
	packet_device:
		project_id: ${2:# ID of project of the device.}
		# features: # Dict with "features" for device creation. See Packet API docs for details.
		# facility: # Facility slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/facilities/).
		# wait_for_public_IPv: 4|6
		# auth_token: # Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).
		# count_offset: 1
		# user_data: # Userdata blob made available to the machine
		# always_pxe: no
		# hostnames: # A hostname of a device, or a list of hostnames.
		# plan: # Plan slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/plans/).
		# ipxe_script_url: # URL of custom iPXE script for provisioning.
		# count: 1
		# operating_system: # OS slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/operatingsystems/).
		# locked: no
		# device_ids: # List of device IDs on which to operate.
		# state: #present|absent|active|inactive|rebooted
		# wait_timeout: 900
$0
endsnippet

snippet packet_sshkey "Create/delete an SSH key in Packet host." b
- name: $1
	packet_sshkey:
		# state: #present|absent
		# key: # Public Key string ({type} {base64 encoded key} {description}).
		# fingerprint: # Fingerprint of the key which you want to remove.
		# id: # UUID of the key which you want to remove.
		# auth_token: # Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).
		# key_file: # File with the public key.
		# label: # Label for the key. If you keep it empty, it will be read from key string.
$0
endsnippet

snippet udm_user "Manage posix users on a univention corporate server" b
- name: $1
	udm_user:
		username: ${2:# User name}
		# update_password: always
		# samba_user_workstations: []
		# homedrive: # Windows home drive, e.g. C("H:").
		# room_number: # Room number of users business address.
		# primary_group: cn=Domain Users,cn=groups,$LDAP_BASE_DN
		# postcode: # Postal code of users business address.
		# scriptpath: # Windows logon script.
		# home_share: # Home NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com).
		# override_pw_history: no
		# city: # City of users business address.
		# display_name: # Display name (not gecos)
		# pager_telephonenumber: []
		# employee_number: # Employee number
		# serviceprovider: [u'']
		# organisation: # Organisation
		# subpath: cn=users
		# state: #present|absent
		# home_share_path: # Path to home NFS share, inside the homeShare.
		# userexpiry: Today + 1 year
		# unixhome: /home/$USERNAME
		# mail_home_server: # FQDN of mail server
		# email: [u'']
		# sambahome: # Windows home path, e.g. C('\\$FQDN\$USERNAME').
		# home_telephone_number: []
		# shell: /bin/bash
		# description: # Description (not gecos)
		# firstname: # First name. Required if C(state=present).
		# lastname: # Last name. Required if C(state=present).
		# mail_alternative_address: []
		# phone: []
		# birthday: # Birthday
		# groups: []
		# profilepath: # Windows profile directory
		# employee_type: # Employee type
		# password: # Password. Required if C(state=present).
		# pwd_change_next_login: 0|1
		# mail_primary_address: # Primary e-mail address
		# country: # Country of users business address.
		# title: # Title, e.g. C(Prof.).
		# override_pw_length: no
		# street: # Street of users business address.
		# gecos: # GECOS
		# mobile_telephone_number: []
		# position: 
		# ou: 
		# department_number: # Department number of users business address.
		# samba_privileges: []
		# secretary: []
$0
endsnippet

snippet udm_share "Manage samba shares on a univention corporate server" b
- name: $1
	udm_share:
		name: ${2:# Name}
		ou: ${3:# Organisational unit, inside the LDAP Base DN.}
		# samba_name: # Windows name. Required if C(state=present).
		# samba_hide_files: # Hide files.
		# samba_blocking_locks: 0|#1
		# samba_directory_mode: 0755
		# samba_dos_filemode: #0|1
		# samba_postexec: # Postexec script.
		# owner: 0
		# samba_fake_oplocks: #0|1
		# samba_strict_locking: Auto
		# samba_public: #0|1
		# samba_force_directory_security_mode: #0|1
		# group: 0
		# samba_writeable: 0|#1
		# samba_nt_acl_support: 0|#1
		# samba_write_list: # Restrict write access to these users/groups.
		# samba_preexec: # Preexec script.
		# samba_browseable: 0|#1
		# samba_inherit_acls: 0|#1
		# samba_msdfs_root: #0|1
		# state: #present|absent
		# samba_valid_users: # Valid users or groups.
		# samba_force_create_mode: #0|1
		# root_squash: 0|#1
		# samba_directory_security_mode: 0777
		# samba_force_group: # Force group.
		# samba_vfs_objects: # VFS objects.
		# samba_force_directory_mode: #0|1
		# writeable: 0|#1
		# samba_locking: 0|#1
		# samba_security_mode: 0777
		# samba_inherit_owner: #0|1
		# samba_csc_policy: manual
		# sync: sync
		# nfs_hosts: []
		# path: # Directory on the providing server, e.g. C(/home). Required if C(state=present).
		# nfs_custom_settings: []
		# samba_force_user: # Force user.
		# samba_invalid_users: # Invalid users or groups.
		# samba_create_mode: 0744
		# samba_force_security_mode: #0|1
		# samba_level_2_oplocks: 0|#1
		# samba_custom_settings: []
		# samba_hide_unreadable: #0|1
		# host: # Host FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present).
		# samba_block_size: # Blocking size.
		# samba_oplocks: 0|#1
		# samba_hosts_allow: []
		# samba_inherit_permissions: #0|1
		# subtree_checking: 0|#1
		# directorymode: 00755
		# samba_hosts_deny: []
$0
endsnippet

snippet udm_group "Manage of the posix group" b
- name: $1
	udm_group:
		name: ${2:# Name of the posix group.}
		# state: #present|absent
		# position: # define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).
		# ou: # LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).
		# subpath: # Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).
		# description: # Group description.
$0
endsnippet

snippet udm_dns_record "Manage dns entries on a univention corporate server" b
- name: $1
	udm_dns_record:
		type: ${2:host_record|alias|ptr_record|srv_record|txt_record}
		name: ${3:# Name of the record, this is also the DNS record. E.g. www for www.example.com.}
		zone: ${4:# Corresponding DNS zone for this record, e.g. example.com.}
		# state: #present|absent
		# data: []
$0
endsnippet

snippet udm_dns_zone "Manage dns zones on a univention corporate server" b
- name: $1
	udm_dns_zone:
		zone: ${2:# DNS zone name, e.g. C(example.com).}
		type: ${3:forward_zone|reverse_zone}
		# retry: 1800
		# interfaces: # List of interface IP addresses, on which the server should response this zone. Required if C(state=present).
		# refresh: 3600
		# state: #present|absent
		# contact: 
		# expire: 604800
		# ttl: 600
		# nameserver: # List of appropriate name servers. Required if C(state=present).
		# mx: []
$0
endsnippet

snippet vmware_guest_powerstate "Manages power states of virtual machines in vCenter" b
- name: $1
	vmware_guest_powerstate:
		# username: # The username of the vSphere vCenter or ESXi server.
		# force: no
		# name_match: #first|last
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
		# name: # Name of the virtual machine to work with.
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# state: powered-off|powered-on|reboot-guest|restarted|shutdown-guest|suspended|#present
		# folder: /vm
		# validate_certs: True
		# scheduled_at: # Date and time in string format at which specificed task needs to be performed.
$0
endsnippet

snippet vca_fw "add remove firewall rules in a gateway  in a vca" b
- name: $1
	vca_fw:
		fw_rules: ${2:no}
		# username: # The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.
		# gateway_name: gateway
		# state: #present|absent
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp.
		# host: # The authentication host to be used when service type is vcd.
		# service_type: #vca|vchs|vcd
		# org: # The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).
		# password: # The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.
		# vdc_name: # The name of the vdc where the gateway is located.
		# api_version: 5.7
		# verify_certs: yes
$0
endsnippet

snippet vmware_host_config_facts "Gathers facts about an ESXi host's advance configuration information" b
- name: $1
	vmware_host_config_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_target_canonical_facts "Return canonical (NAA) from an ESXi host" b
- name: $1
	vmware_target_canonical_facts:
		target_id: ${2:# The target id based on order of scsi device}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion" b
- name: $1
	vmware_vmotion:
		vm_name: ${2:# Name of the VM to perform a vMotion on}
		destination_host: ${3:# Name of the end host the VM should be running on}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vsphere_copy "Copy a file to a vCenter datastore" b
- name: $1
	vsphere_copy:
		src: ${2:# The file to push to vCenter}
		datacenter: ${3:# The datacenter on the vCenter server that holds the datastore.}
		host: ${4:# The vCenter server on which the datastore is available.}
		path: ${5:# The file to push to the datastore on the vCenter server.}
		login: ${6:# The login name to authenticate on the vCenter server.}
		password: ${7:# The password to authenticate on the vCenter server.}
		datastore: ${8:# The datastore on the vCenter server to push files to.}
		# validate_certs: yes
$0
endsnippet

snippet vmware_host_service_facts "Gathers facts about an ESXi host's services" b
- name: $1
	vmware_host_service_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_guest_tools_wait "Wait for VMware tools to become available" b
- name: $1
	vmware_guest_tools_wait:
		# username: # The username of the vSphere vCenter or ESXi server.
		# uuid: # UUID of the VM  for which to wait until the tools become available, if known. This is VMware's unique identifier.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# name_match: #first|last
		# folder: /vm
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
		# name: # Name of the VM for which to wait until the tools become available.
$0
endsnippet

snippet vmware_host_firewall_manager "Manage firewall configurations about an ESXi host" b
- name: $1
	vmware_host_firewall_manager:
		# username: # The username of the vSphere vCenter or ESXi server.
		# rules: []
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host_facts "Gathers facts about remote vmware host" b
- name: $1
	vmware_host_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
$0
endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup." b
- name: $1
	vmware_dvs_portgroup:
		portgroup_name: ${2:# The name of the portgroup that is to be created or deleted.}
		state: ${3:present|absent}
		num_ports: ${4:# The number of ports the portgroup should contain.}
		vlan_id: ${5:# The VLAN ID that should be configured with the portgroup, use 0 for no VLAN.}
		portgroup_type: ${6:earlyBinding|lateBinding|ephemeral}
		switch_name: ${7:# The name of the distributed vSwitch the port group should be created on.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# teaming_policy: {u'notify_switches': True, u'load_balance_policy': u'loadbalance_srcid', u'inbound_policy': False, u'rolling_order': False}
		# port_policy: {u'traffic_filter_override': False, u'network_rp_override': False, u'live_port_move': False, u'security_override': False, u'vendor_config_override': False, u'port_config_reset_at_disconnect': True, u'uplink_teaming_override': False, u'block_override': True, u'shaping_override': False, u'vlan_override': False, u'ipfix_override': False}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# network_policy: {u'promiscuous': False, u'mac_changes': False, u'forged_transmits': False}
		# validate_certs: True
		# vlan_trunk: no
$0
endsnippet

snippet vmware_host_firewall_facts "Gathers facts about an ESXi host's firewall configuration information" b
- name: $1
	vmware_host_firewall_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_cluster "Manage VMware vSphere clusters" b
- name: $1
	vmware_cluster:
		datacenter_name: ${2:# The name of the datacenter the cluster will be created in.}
		cluster_name: ${3:# The name of the cluster that will be created.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# enable_drs: no
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
		# enable_ha: no
		# enable_vsan: no
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# state: absent|#present
		# validate_certs: True
$0
endsnippet

snippet vmware_guest_facts "Gather facts about a single VM" b
- name: $1
	vmware_guest_facts:
		datacenter: ${2:# Destination datacenter for the deploy operation}
		# username: # The username of the vSphere vCenter or ESXi server.
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# name_match: #first|last
		# folder: /vm
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
		# name: # Name of the VM to work with
$0
endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vCenter" b
- name: $1
	vmware_guest_snapshot:
		datacenter: ${2:# Destination datacenter for the deploy operation}
		state: ${3:#present|absent|revert|remove_all}
		# username: # The username of the vSphere vCenter or ESXi server.
		# new_snapshot_name: # Value to rename the existing snapshot to
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# quiesce: no
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# memory_dump: no
		# name: # Name of the VM to work with
		# new_description: # Value to change the description of an existing snapshot to
		# snapshot_name: # Sets the snapshot name to manage.
		# name_match: #first|last
		# remove_children: no
		# folder: # Destination folder, absolute or relative path to find an existing guest.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
		# description: 
$0
endsnippet

snippet vmware_guest "Manages virtual machines in vCenter" b
- name: $1
	vmware_guest:
		name: ${2:# Name of the VM to work with.}
		# resource_pool: # Affect machine to the given resource pool.
		# username: # The username of the vSphere vCenter or ESXi server.
		# snapshot_src: # Name of the existing snapshot to use to create a clone of a VM.
		# force: no
		# esxi_hostname: # The ESXi hostname where the virtual machine will run.
		# datacenter: ha-datacenter
		# hardware: # Manage virtual machine's hardware attributes.
		# cluster: # The cluster name where the virtual machine will run.
		# name_match: #first|last
		# customization: # Parameters for OS customization when cloning from template.
		# cdrom: # A CD-ROM configuration for the VM.
		# disk: # A list of disks to add.
		# networks: # A list of networks (in the order of the NICs).
		# wait_for_ip_address: no
		# guest_id: # Set the guest ID.
		# password: # The password of the vSphere vCenter or ESXi server.
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# customvalues: # Define a list of custom values to set on virtual machine.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# is_template: no
		# annotation: # A note or annotation to include in the virtual machine.
		# port: 443
		# state: #present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest
		# template: # Template or existing VM used to create VM.
		# linked_clone: no
		# folder: # Destination folder, absolute path to find an existing guest or create the new guest.
		# validate_certs: True
$0
endsnippet

snippet vcenter_folder "Manage folders on given datacenter" b
- name: $1
	vcenter_folder:
		datacenter: ${2:# Name of the datacenter.}
		folder_name: ${3:# Name of folder to be managed.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# folder_type: datastore|host|network|#vm
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# state: #present|absent
		# parent_folder: # Name of the parent folder under which new folder needs to be created.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_cfg_backup "Backup / Restore / Reset ESXi host configuration" b
- name: $1
	vmware_cfg_backup:
		# username: # The username of the vSphere vCenter or ESXi server.
		# src: # The file containing the ESXi configuration that will be restored.
		# dest: # The destination where the ESXi configuration bundle will be saved. The I(dest) can be a folder or a file.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# state: saved|absent|loaded
		# esxi_hostname: # Name of ESXi server. This is required only if authentication against a vCenter is done.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed" b
- name: $1
	vmware_vm_vss_dvs_migrate:
		vm_name: ${2:# Name of the virtual machine to migrate to a dvSwitch}
		dvportgroup_name: ${3:# Name of the portgroup to migrate to the virtual machine to}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_drs_rule_facts "Gathers facts about DRS rule on the given cluster" b
- name: $1
	vmware_drs_rule_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# datacenter: # Name of the datacenter.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_dvswitch "Create or remove a distributed vSwitch" b
- name: $1
	vmware_dvswitch:
		datacenter_name: ${2:# The name of the datacenter that will contain the dvSwitch}
		discovery_proto: ${3:cdp|lldp}
		mtu: ${4:# The switch maximum transmission unit}
		switch_name: ${5:# The name of the switch to create or remove}
		uplink_quantity: ${6:# Quantity of uplink per ESXi host added to the switch}
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# state: #present|absent
		# discovery_operation: both|none|advertise|listen
		# validate_certs: True
		# switch_version: # The version of the switch to create. Can be 6.5.0, 6.0.0, 5.5.0, 5.1.0, 5.0.0 with a vcenter running vSphere 6.5
$0
endsnippet

snippet vmware_host_service_manager "Manage services on a given ESXi host" b
- name: $1
	vmware_host_service_manager:
		service_name: ${2:# Name of Service to be managed. This is brief identifier for the service, for example, ntpd, vxsyslogd etc.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# service_policy: automatic|off|on
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# state: absent|present|restart|#start|stop
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host_dns_facts "Gathers facts about an ESXi host's DNS configuration information" b
- name: $1
	vmware_host_dns_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_local_role_manager "Manage local roles on an ESXi host" b
- name: $1
	vmware_local_role_manager:
		local_role_name: ${2:# The local role name to be managed.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# force_remove: no
		# state: #present|absent
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# local_privilege_ids: []
$0
endsnippet

snippet vmware_host_ntp "Manage NTP configurations about an ESXi host" b
- name: $1
	vmware_host_ntp:
		ntp_servers: ${2:# IP or FQDN of NTP server/s.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# state: #present|absent
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host_acceptance "Manage acceptance level of ESXi host" b
- name: $1
	vmware_host_acceptance:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# state: #list|present
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
		# acceptance_level: community|partner|vmware_accepted|vmware_certified
$0
endsnippet

snippet vmware_host_lockdown "Manage administrator permission for the local administrative account for the ESXi host" b
- name: $1
	vmware_host_lockdown:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of cluster.
		# state: #present|absent
		# esxi_hostname: # List of ESXi hostname to manage lockdown.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_vm_vm_drs_rule "Configure VMware DRS Affinity rule for virtual machine in given cluster" b
- name: $1
	vmware_vm_vm_drs_rule:
		drs_rule_name: ${2:# The name of the DRS rule to manage.}
		cluster_name: ${3:# Desired cluster name where virtual machines are present for the DRS rule.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# mandatory: no
		# affinity_rule: yes
		# password: # The password of the vSphere vCenter or ESXi server.
		# vms: # List of virtual machines name for which DRS rule needs to be applied.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# enabled: no
		# port: 443
		# state: #present|absent
		# validate_certs: True
$0
endsnippet

snippet vmware_resource_pool "Add/remove resource pools to/from vCenter" b
- name: $1
	vmware_resource_pool:
		resource_pool: ${2:# Resource pool name to manage.}
		datacenter: ${3:# Name of the datacenter to add the host.}
		cluster: ${4:# Name of the cluster to add the host.}
		# cpu_reservation: 0
		# password: # The password of the vSphere vCenter or ESXi server.
		# mem_expandable_reservations: yes
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cpu_expandable_reservations: yes
		# username: # The username of the vSphere vCenter or ESXi server.
		# state: #present|absent
		# cpu_limit: -1
		# mem_shares: high|custom|low|#normal
		# mem_limit: -1
		# mem_reservation: 0
		# validate_certs: True
		# port: 443
		# cpu_shares: high|custom|low|#normal
$0
endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode" b
- name: $1
	vmware_maintenancemode:
		esxi_hostname: ${2:# Name of the host as defined in vCenter.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# timeout: 0
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# evacuate: no
		# state: #present|absent
		# password: # The password of the vSphere vCenter or ESXi server.
		# vsan: ensureObjectAccessibility|evacuateAllData|noAction
		# port: 443
$0
endsnippet

snippet vmware_vmkernel "Manage a VMware VMkernel Interface aka. Virtual NICs of host system." b
- name: $1
	vmware_vmkernel:
		portgroup_name: ${2:# The name of the port group for the VMKernel interface.}
		esxi_hostname: ${3:# Name of ESXi host to which VMKernel is to be managed.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# enable_vsan: # Enable the VMKernel interface for VSAN traffic.
		# network: # A dictionary of network details.
		# enable_vmotion: # Enable the VMKernel interface for vMotion traffic.
		# subnet_mask: # The Subnet Mask for the VMKernel interface.
		# vswitch_name: # The name of the vSwitch where to add the VMKernel interface.
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# mtu: 1500
		# enable_mgmt: # Enable the VMKernel interface for Management traffic.
		# state: #present|absent
		# password: # The password of the vSphere vCenter or ESXi server.
		# ip_address: # The IP Address for the VMKernel interface.
		# port: 443
		# vlan_id: # The VLAN ID for the VMKernel interface.
		# enable_ft: # Enable the VMKernel interface for Fault Tolerance traffic.
$0
endsnippet

snippet vmware_vswitch "Add or remove a VMware Standard Switch to an ESXi host" b
- name: $1
	vmware_vswitch:
		switch: ${2:# vSwitch name to add.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
		# number_of_ports: 128
		# nics: # A list of vmnic names or vmnic name to attach to vSwitch.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# mtu: 1500
		# state: absent|#present
		# esxi_hostname: # Manage the vSwitch using this ESXi host system
		# validate_certs: True
$0
endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host" b
- name: $1
	vmware_vsan_cluster:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_uuid: # Desired cluster UUID
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vca_vapp "Manages vCloud Air vApp instances." b
- name: $1
	vca_vapp:
		vapp_name: ${2:# The name of the vCloud Air vApp instance}
		# vm_name: # The name of the virtual machine instance in the vApp to manage.
		# username: # The vCloud Air username to use during authentication
		# vm_memory: # The amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp.
		# gateway_name: gateway
		# template_name: # The name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)
		# network_mode: #pool|dhcp|static
		# org: # The org to login to for creating vapp, mostly set when the service_type is vdc.
		# operation: #noop|poweron|poweroff|suspend|shutdown|reboot|reset
		# password: # The vCloud Air password to use during authentication
		# vm_cpus: # The number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.
		# vdc_name: # The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.
		# network_name: # The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided.
		# host: # The authentication host to be used when service type  is vcd.
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp
		# state: #present|absent|deployed|undeployed
		# service_type: #vca|vchs|vcd
		# api_version: 5.7
		# verify_certs: yes
$0
endsnippet

snippet vmware_vm_shell "Run commands in a VMware guest operating system" b
- name: $1
	vmware_vm_shell:
		vm_password: ${2:# The password used to login-in to the virtual machine.}
		vm_shell: ${3:# The absolute path to the program to start.}
		vm_username: ${4:# The user to login-in to the virtual machine.}
		vm_id: ${5:# Name of the virtual machine to work with.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# datacenter: # The datacenter hosting the virtual machine.
		# vm_shell_cwd: # The current working directory of the application from which it will be run.
		# vm_shell_args:  
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# vm_shell_env: # Comma separated list of environment variable, specified in the guest OS notation.
		# cluster: # The cluster hosting the virtual machine.
		# vm_id_type: uuid|dns_name|inventory_path|#vm_name
		# validate_certs: True
		# folder: /vm
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
$0
endsnippet

snippet vmware_portgroup "Create a VMware portgroup" b
- name: $1
	vmware_portgroup:
		switch_name: ${2:# vSwitch to modify.}
		vlan_id: ${3:# VLAN ID to assign to portgroup.}
		portgroup_name: ${4:# Portgroup name to add.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# network_policy: {u'mac_changes': False, u'promiscuous_mode': False, u'forged_transmits': False}
		# password: # The password of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# cluster_name: # Name of cluster name for host membership.
		# state: #present|absent
		# hosts: # List of name of host or hosts on which portgroup needs to be added.
		# validate_certs: True
$0
endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS" b
- name: $1
	vmware_migrate_vmk:
		current_switch_name: ${2:# Switch VMK interface is currently on}
		device: ${3:# VMK interface name}
		migrate_switch_name: ${4:# Switch name to migrate VMK interface to}
		migrate_portgroup_name: ${5:# Portgroup name to migrate VMK interface to}
		current_portgroup_name: ${6:# Portgroup name VMK interface is currently on}
		esxi_hostname: ${7:# ESXi hostname to be managed}
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# validate_certs: True
$0
endsnippet

snippet vmware_host_vmnic_facts "Gathers facts about vmnics available on the given ESXi host" b
- name: $1
	vmware_host_vmnic_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch" b
- name: $1
	vmware_dvs_host:
		state: ${2:#present|absent}
		esxi_hostname: ${3:# The ESXi hostname.}
		vmnics: ${4:# The ESXi hosts vmnics to use with the Distributed vSwitch.}
		switch_name: ${5:# The name of the Distributed vSwitch.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# password: # The password of the vSphere vCenter or ESXi server.
$0
endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration" b
- name: $1
	vmware_dns_config:
		dns_servers: ${2:# The DNS servers that the host should be configured to use.}
		domainname: ${3:# The domain the ESXi host should be apart of.}
		change_hostname_to: ${4:# The hostname that an ESXi host should be changed to.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_vmkernel_facts "Gathers VMKernel facts about an ESXi host" b
- name: $1
	vmware_vmkernel_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host_package_facts "Gathers facts about available packages on an ESXi host" b
- name: $1
	vmware_host_package_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host "Add / Remove ESXi host to / from vCenter" b
- name: $1
	vmware_host:
		datacenter_name: ${2:# Name of the datacenter to add the host.}
		cluster_name: ${3:# Name of the cluster to add the host.}
		esxi_hostname: ${4:# ESXi hostname to manage.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# esxi_password: # ESXi password.
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# esxi_username: # ESXi username.
		# esxi_ssl_thumbprint: 
		# state: #present|absent|add_or_reconnect|reconnect
		# validate_certs: True
$0
endsnippet

snippet vmware_host_config_manager "Manage advance configurations about an ESXi host" b
- name: $1
	vmware_host_config_manager:
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# options: {}
$0
endsnippet

snippet vmware_guest_file_operation "Files operation in a VMware guest operating system without network" b
- name: $1
	vmware_guest_file_operation:
		vm_password: ${2:# The password used to login-in to the virtual machine.}
		vm_username: ${3:# The user to login in to the virtual machine.}
		vm_id: ${4:# Name of the virtual machine to work with.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# datacenter: # The datacenter hosting the virtual machine.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# port: 443
		# cluster: # The cluster hosting the virtual machine.
		# vm_id_type: uuid|dns_name|inventory_path|#vm_name
		# directory: # Create or delete directory.
		# folder: # Destination folder, absolute path to find an existing guest or create the new guest.
		# copy: # Copy file to vm without requiring network.
		# fetch: # Get file from virtual machine without requiring network.
$0
endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters" b
- name: $1
	vmware_datacenter:
		username: ${2:# The username of the vSphere vCenter}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		hostname: ${4:# The hostname or IP address of the vSphere vCenter API server}
		password: ${5:# The password of the vSphere vCenter}
		# state: #present|absent
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_datastore_facts "Gather facts about datastores" b
- name: $1
	vmware_datastore_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# datacenter: # Datacenter to search for datastores
		# name: # Name of a datastore to match
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# cluster: # Cluster to search for datastores
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_host_datastore "Manage a datastore on ESXi host" b
- name: $1
	vmware_host_datastore:
		datacenter_name: ${2:# Name of the datacenter to add the datastore.}
		esxi_hostname: ${3:# ESXi hostname to manage the datastore.}
		datastore_type: ${4:nfs|vmfs}
		datastore_name: ${5:# Name of the datastore to add/remove.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# vmfs_version: # VMFS version to use for datastore creation.
		# nfs_path: # Resource path on NFS host.
		# port: 443
		# nfs_ro: no
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# nfs_server: # NFS host serving nfs datastore.
		# vmfs_device_name: # Name of the device to be used as VMFS datastore.
		# validate_certs: True
$0
endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host" b
- name: $1
	vmware_local_user_manager:
		local_user_name: ${2:# The local user name to be changed.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# local_user_description: # Description for the user.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# local_user_password: # The password to be set.
		# state: #present|absent
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vca_nat "add remove nat rules in a gateway  in a vca" b
- name: $1
	vca_nat:
		nat_rules: ${2:no}
		# username: # The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.
		# gateway_name: gateway
		# purge_rules: no
		# state: #present|absent
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp.
		# host: # The authentication host to be used when service type is vcd.
		# org: # The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).
		# service_type: #vca|vchs|vcd
		# password: # The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.
		# vdc_name: # The name of the vdc where the gateway is located.
		# api_version: 5.7
		# verify_certs: yes
$0
endsnippet

snippet vmware_guest_find "Find the folder path(s) for a virtual machine by name or UUID" b
- name: $1
	vmware_guest_find:
		# username: # The username of the vSphere vCenter or ESXi server.
		# datacenter: # Destination datacenter for the find operation.
		# name: # Name of the VM to work with.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
		# uuid: # UUID of the instance to manage if known, this is VMware's BIOS UUID.
$0
endsnippet

snippet vmware_vm_facts "Return basic facts pertaining to a vSphere virtual machine guest" b
- name: $1
	vmware_vm_facts:
		# username: # The username of the vSphere vCenter or ESXi server.
		# vm_type: #all|vm|template
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vcenter_license "Manage VMware vCenter license keys" b
- name: $1
	vcenter_license:
		license: ${2:# The license key to manage in vSphere vCenter.}
		# username: # The username of the vSphere vCenter or ESXi server.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# labels: {u'source': u'ansible'}
		# state: absent|#present
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# port: 443
$0
endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address" b
- name: $1
	vmware_vmkernel_ip_config:
		vmk_name: ${2:# VMkernel interface name}
		subnet_mask: ${3:# Subnet Mask to assign to VMkernel interface}
		ip_address: ${4:# IP address to assign to VMkernel interface}
		# username: # The username of the vSphere vCenter or ESXi server.
		# validate_certs: True
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# port: 443
$0
endsnippet

snippet fetch "Fetches a file from remote nodes" b
- name: $1
	fetch:
		dest: ${2:# A directory to save the file into. For example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile)}
		src: ${3:# The file on the remote system to fetch. This I(must) be a file, not a directory. Recursive fetching may be supported in a later release.}
		# validate_checksum: #yes|no
		# fail_on_missing: #yes|no
		# flat: # Allows you to override the default behavior of appending hostname/path/to/file to the destination.  If dest ends with '/', it will use the basename of the source file, similar to the copy module. Obviously this is only handy if the filenames are unique.
$0
endsnippet

snippet tempfile "Creates temporary files and directories." b
- name: $1
	tempfile:
		# path: # Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.
		# state: directory|#file
		# prefix: ansible.
		# suffix: 
$0
endsnippet

snippet patch "Apply patch files using the GNU patch tool" b
- name: $1
	patch:
		src: ${2:# Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's I(files) directory.}
		# strip: 0
		# remote_src: #no|yes
		# dest: # Path of the file on the remote machine to be patched.
		# binary: #no|yes
		# basedir: # Path of a base directory in which the patch file will be applied. May be omitted when C(dest) option is specified, otherwise required.
		# backup: #no|yes
$0
endsnippet

snippet xml "Manage bits and pieces of XML files or strings" b
- name: $1
	xml:
		xmlstring: ${2:# A string containing XML on which to operate.}
		path: ${3:# Path to the file to operate on. File must exist ahead of time.}
		# xpath: /
		# count: no
		# set_children: # Set the child-element(s) of a selected element for a given C(xpath).
		# attribute: # The attribute to select when using parameter C(value).
		# pretty_print: no
		# add_children: # Add additional child-element(s) to a selected element for a given C(xpath).
		# value: # Desired state of the selected attribute.
		# content: attribute|text
		# state: absent|#present
		# namespaces: # The namespace C(prefix:uri) mapping for the XPath expression.
		# input_type: xml|#yaml
		# print_match: no
		# backup: no
$0
endsnippet

snippet copy "Copies files to remote locations" b
- name: $1
	copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If I(src) is a directory, this must be a directory too. If I(dest) is a nonexistent path and if either I(dest) ends with "/" or I(src) is a directory, I(dest) is created. If I(src) and I(dest) are files, the parent directory of I(dest) isn't created: the task fails if it doesn't already exist.}
		# src: # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.
		# directory_mode: # When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.
		# force: yes
		# remote_src: no
		# checksum: # SHA1 checksum of the file being transferred. Used to valdiate that the copy of the file was successful.
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# decrypt: Yes
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# content: # When used instead of I(src), sets the contents of a file directly to the specified value. For anything advanced or with formatting also look at the template module.
		# unsafe_writes: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# selevel: s0
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# follow: no
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# backup: no
		# local_follow: yes
$0
endsnippet

snippet assemble "Assembles a configuration file from fragments" b
- name: $1
	assemble:
		src: ${2:# An already existing directory full of source files.}
		dest: ${3:# A file to create using the concatenation of all of the source files.}
		# ignore_hidden: no
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# remote_src: yes
		# selevel: s0
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# decrypt: Yes
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# unsafe_writes: no
		# delimiter: # A delimiter to separate the file contents.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# regexp: # Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
		# validate: # The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.
		# backup: no
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet file "Sets attributes of files" b
- name: $1
	file:
		path: ${2:# path to the file being managed.  Aliases: I(dest), I(name)}
		# force: no
		# selevel: s0
		# follow: yes
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# src: # path of the file to link to (applies only to C(state=link) and C(state=hard)). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# unsafe_writes: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# recurse: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# state: absent|directory|#file|hard|link|touch
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet acl "Sets and retrieves file ACL information." b
- name: $1
	acl:
		path: ${2:# The full path of the file or object.}
		# recursive: no
		# default: no
		# entity: # actual user or group that the ACL applies to when matching entity types user or group are selected.
		# state: absent|present|#query
		# follow: yes
		# etype: group|mask|other|user
		# entry: # DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '<etype>:<qualifier>:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields.
		# permissions: # Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)
$0
endsnippet

snippet lineinfile "Manage lines in text files" b
- name: $1
	lineinfile:
		path: ${2:# The file to modify.}
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# insertbefore: BOF|*regex*
		# unsafe_writes: no
		# selevel: s0
		# create: no
		# others: # All arguments accepted by the M(file) module also work here.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# backrefs: no
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# state: absent|#present
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# firstmatch: no
		# insertafter: #EOF|*regex*
		# regexp: # The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found. Only the last line found will be replaced. For C(state=absent), the pattern of the line(s) to remove. Uses Python regular expressions. See U(http://docs.python.org/2/library/re.html).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# backup: no
		# line: # Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines" b
- name: $1
	blockinfile:
		path: ${2:# The file to modify.}
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# insertbefore: BOF|*regex*
		# unsafe_writes: no
		# backup: no
		# create: no
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# marker: # {mark} ANSIBLE MANAGED BLOCK
		# state: absent|#present
		# block: 
		# selevel: s0
		# insertafter: #EOF|*regex*
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# marker_begin: BEGIN
		# marker_end: END
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet stat "Retrieve file or file system status" b
- name: $1
	stat:
		path: ${2:# The full path of the file/object to get the facts of.}
		# get_checksum: yes
		# follow: no
		# checksum_algorithm: md5|#sha1|sha224|sha256|sha384|sha512
		# get_mime: yes
		# get_md5: no
		# get_attributes: yes
$0
endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy." b
- name: $1
	synchronize:
		src: ${2:# Path on the source host that will be synchronized to the destination; The path can be absolute or relative.}
		dest: ${3:# Path on the destination host that will be synchronized from the source; The path can be absolute or relative.}
		# dirs: no
		# private_key: # Specify the private key to use for SSH-based rsync connections (e.g. C(~/.ssh/id_rsa))
		# partial: no
		# links: the value of the archive option
		# copy_links: no
		# perms: the value of the archive option
		# compress: yes
		# rsync_timeout: 0
		# rsync_opts: # Specify additional rsync options by passing in an array.
		# owner: the value of the archive option
		# existing_only: no
		# set_remote_user: yes
		# times: the value of the archive option
		# rsync_path: # Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.
		# dest_port: Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set
		# group: the value of the archive option
		# link_dest: # add a destination to hard link against during the rsync.
		# recursive: the value of the archive option
		# archive: yes
		# mode: pull|#push
		# checksum: no
		# verify_host: no
		# use_ssh_args: no
		# delete: no
$0
endsnippet

snippet xattr "Manage user defined extended attributes" b
- name: $1
	xattr:
		path: ${2:# The full path of the file/object to get the facts of.}
		# state: absent|all|keys|present|#read
		# key: # The name of a specific Extended attribute key to set/retrieve.
		# value: # The value to set the named name/key to, it automatically sets the C(state) to 'set'.
		# follow: yes
$0
endsnippet

snippet archive "Creates a compressed archive of one or more files or trees" b
- name: $1
	archive:
		path: ${2:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# format: bz2|#gz|tar|xz|zip
		# dest: # The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.
		# selevel: s0
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# remove: no
		# unsafe_writes: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# exclude_path: # Remote absolute path, glob, or list of paths or globs for the file or files to exclude from the archive
$0
endsnippet

snippet template "Templates a file out to a remote server" b
- name: $1
	template:
		src: ${2:# Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		# unsafe_writes: no
		# force: yes
		# trim_blocks: no
		# selevel: s0
		# block_end_string: %}
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# variable_start_string: {{
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# newline_sequence: #\n|\r|\r\n
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# block_start_string: {%
		# variable_end_string: }}
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# follow: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# backup: no
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
$0
endsnippet

snippet find "Return a list of files based on specific criteria" b
- name: $1
	find:
		paths: ${2:# List of paths of directories to search. All paths must be fully qualified.}
		# excludes: # One or more (shell or regex) patterns, which type is controlled by C(use_regex) option.
		# file_type: any|directory|#file|link
		# age: # Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., "1w").
		# contains: # One or more regex patterns which should be matched against the file content.
		# recurse: #no|yes
		# age_stamp: atime|ctime|#mtime
		# patterns: *
		# get_checksum: #no|yes
		# use_regex: #no|yes
		# follow: #no|yes
		# hidden: #no|yes
		# size: # Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.
$0
endsnippet

snippet iso_extract "Extract files from an ISO image" b
- name: $1
	iso_extract:
		dest: ${2:# The destination directory to extract files to.}
		files: ${3:# A list of files to extract from the image.}
		image: ${4:# The ISO image to extract files from.}
		# force: yes
		# executable: 7z
$0
endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine." b
- name: $1
	unarchive:
		src: ${2:# If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.}
		dest: ${3:# Remote absolute path where the archive should be unpacked.}
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# remote_src: no
		# selevel: s0
		# list_files: no
		# keep_newer: no
		# decrypt: Yes
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# creates: # If the specified absolute path (file or directory) already exists, this step will B(not) be run.
		# unsafe_writes: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# exclude: # List the directory and file entries that you would like to exclude from the unarchive action.
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# extra_opts: 
		# copy: yes
		# validate_certs: yes
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet ini_file "Tweak settings in INI files" b
- name: $1
	ini_file:
		section: ${2:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}
		path: ${3:# Path to the INI-style file; this file is created if required.}
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# option: # If set (required for changing a I(value)), this is the name of the option.
		# unsafe_writes: no
		# selevel: s0
		# no_extra_spaces: no
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# value: # The string value to be associated with an I(option). May be omitted when removing an I(option).
		# state: absent|#present
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# others: # All arguments accepted by the M(file) module also work here
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# backup: no
		# create: yes
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
$0
endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression." b
- name: $1
	replace:
		path: ${2:# The file to modify.}
		regexp: ${3:# The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses MULTILINE mode, which means C(^) and C($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.}
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# encoding: utf-8
		# unsafe_writes: no
		# selevel: s0
		# after: # If specified, the line after the replace/remove will start. Can be used in combination with C(before). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# replace: # The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# backup: no
		# others: # All arguments accepted by the M(file) module also work here.
		# before: # If specified, the line before the replace/remove will occur. Can be used in combination with C(after). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
$0
endsnippet

snippet telnet "Executes a low-down and dirty telnet command" b
- name: $1
	telnet:
		command: ${2:# List of commands to be executed in the telnet session.}
		# pause: 1
		# host: remote_addr
		# prompts: [u'$']
		# user: remote_user
		# timeout: 120
		# login_prompt: login: 
		# password: # The password for login
		# port: 23
		# password_prompt: Password: 
$0
endsnippet

snippet expect "Executes a command and responds to prompts." b
- name: $1
	expect:
		command: ${2:# The command module takes command to run.}
		responses: ${3:# Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.}
		# creates: # A filename, when it already exists, this step will B(not) be run.
		# chdir: # Change into this directory before running the command.
		# timeout: 30
		# removes: # A filename, when it does not exist, this step will B(not) be run.
		# echo: no
$0
endsnippet

snippet command "Executes a command on a remote node" b
- name: $1
	command: $2
	args:
		# warn: yes
		# creates: # A filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.
		# chdir: # Change into this directory before running the command.
		# stdin: # Set the stdin of the command directly to the specified value.
		# removes: # A filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.
$0
endsnippet

snippet raw "Executes a low-down and dirty SSH command" b
- name: $1
	raw: $2
	args:
		# executable: # change the shell used to execute the command. Should be an absolute path to the executable.
$0
endsnippet

snippet shell "Execute commands in nodes." b
- name: $1
	shell: $2
	args:
		# warn: yes
		# creates: # a filename, when it already exists, this step will B(not) be run.
		# executable: # change the shell used to execute the command. Should be an absolute path to the executable.
		# chdir: # cd into this directory before running the command
		# stdin: # Set the stdin of the command directly to the specified value.
		# removes: # a filename, when it does not exist, this step will B(not) be run.
$0
endsnippet

snippet script "Runs a local script on a remote node after transferring it" b
- name: $1
	script: $2
	args:
		# creates: # a filename, when it already exists, this step will B(not) be run.
		# decrypt: Yes
		# chdir: # cd into this directory on the remote node before running the script
		# removes: # a filename, when it does not exist, this step will B(not) be run.
$0
endsnippet

snippet win_dsc "Invokes a PowerShell DSC configuration" b
- name: $1
	win_dsc: $2
	args:
		# module_version: latest
$0
endsnippet

snippet win_whoami "Returns information about the current user and process" b
- name: $1
$0
endsnippet

snippet win_iis_webapppool "configures an IIS Web Application Pool" b
- name: $1
	win_iis_webapppool:
		name: ${2:# Name of the application pool.}
		# attributes: # As of Ansible 2.4, this field can take in dict entries to set the application pool attributes.
		# state: #present|absent|stopped|started|restarted
$0
endsnippet

snippet win_tempfile "Creates temporary files and directories." b
- name: $1
	win_tempfile:
		# path: %TEMP%
		# state: #file|directory
		# prefix: ansible.
		# suffix: 
$0
endsnippet

snippet win_stat "returns information about a Windows file" b
- name: $1
	win_stat:
		path: ${2:# The full path of the file/object to get the facts of; both forward and back slashes are accepted.}
		# get_md5: no
		# get_checksum: yes
		# checksum_algorithm: md5|#sha1|sha256|sha384|sha512
$0
endsnippet

snippet win_disk_facts "Show the attached disks and disk information of the target host" b
- name: $1
$0
endsnippet

snippet win_find "Return a list of files based on specific criteria" b
- name: $1
	win_find:
		paths: ${2:# List of paths of directories to search for files or folders in. This can be supplied as a single path or a list of paths.}
		# file_type: #file|directory
		# checksum_algorithm: md5|#sha1|sha256|sha384|sha512
		# age: # Select files or folders whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., "2s", "10d", 1w").
		# recurse: no
		# age_stamp: atime|#mtime|ctime
		# patterns: # One or more (powershell or regex) patterns to compare filenames with. The type of pattern matching is controlled by C(use_regex) option. The patterns retrict the list of files or folders to be returned based on the filenames. For a file to be matched it only has to match with one pattern in a list provided.
		# get_checksum: yes
		# use_regex: no
		# follow: no
		# hidden: no
		# size: # Select files or folders whose size is equal to or greater than the specified size. Use a negative value to find files equal to or less than the specified size. You can specify the size with a suffix of the byte type i.e. kilo = k, mega = m... Size is not evaluated for symbolic links.
$0
endsnippet

snippet win_scheduled_task_stat "Returns information about a Windows Scheduled Task" b
- name: $1
	win_scheduled_task_stat:
		# path: \
		# name: # T
$0
endsnippet

snippet win_owner "Set owner" b
- name: $1
	win_owner:
		path: ${2:# Path to be used for changing owner}
		user: ${3:# Name to be used for changing owner}
		# recurse: no
$0
endsnippet

snippet win_reboot "Reboot a windows machine" b
- name: $1
	win_reboot:
		# pre_reboot_delay: 2
		# post_reboot_delay: 0
		# test_command: whoami
		# shutdown_timeout: 600
		# reboot_timeout: 600
		# msg: Reboot initiated by Ansible
		# connect_timeout: 5
$0
endsnippet

snippet win_dns_client "Configures DNS lookup on Windows hosts" b
- name: $1
	win_dns_client:
		adapter_names: ${2:# Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value). The adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection).}
		ipv4_addresses: ${3:# Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.}
$0
endsnippet

snippet win_acl_inheritance "Change ACL inheritance" b
- name: $1
	win_acl_inheritance:
		path: ${2:# Path to be used for changing inheritance}
		# state: present|#absent
		# reorganize: #False|True
$0
endsnippet

snippet win_wait_for "Waits for a condition before continuing" b
- name: $1
	win_wait_for:
		# host: 127.0.0.1
		# port: # The port number to poll on C(host).
		# delay: # The number of seconds to wait before starting to poll.
		# state: present|#started|stopped|absent|drained
		# sleep: 1
		# timeout: 300
		# exclude_hosts: # The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained).
		# search_regex: # Can be used to match a string in a file.
		# path: # The path to a file on the filesystem to check.
		# connect_timeout: 5
$0
endsnippet

snippet win_domain_controller "Manage domain controller/member server state for a Windows host" b
- name: $1
	win_domain_controller:
		domain_admin_user: ${2:# Username of a domain admin for the target domain (necessary to promote or demote a domain controller).}
		domain_admin_password: ${3:# Password for the specified C(domain_admin_user).}
		# read_only: no
		# database_path: # The path to a directory on a fixed disk of the Windows host where the domain database will be created..
		# site_name: # Specifies the name of an existing site where you can place the new domain controller.
		# dns_domain_name: # When C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC.
		# safe_mode_password: # Safe mode password for the domain controller (required when C(state) is C(domain_controller)).
		# state: domain_controller|member_server
		# local_admin_password: # Password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server)).
		# sysvol_path: # The path to a directory on a fixed disk of the Windows host where the Sysvol folder will be created.
$0
endsnippet

snippet win_unzip "Unzips compressed files and archives on the Windows node" b
- name: $1
	win_unzip:
		dest: ${2:# Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.}
		src: ${3:# File to be unzipped (provide absolute path).}
		# delete_archive: no
		# recurse: no
		# creates: # If this file or directory exists the specified src will not be extracted.
$0
endsnippet

snippet win_say "Text to speech module for Windows to speak messages and optionally play sounds" b
- name: $1
	win_say:
		# end_sound_path: # Full path to a C(.wav) file containing a sound to play after the text has been spoken.
		# msg: # The text to be spoken.
		# start_sound_path: # Full path to a C(.wav) file containing a sound to play before the text is spoken.
		# voice: system default voice
		# msg_file: # Full path to a windows format text file containing the text to be spokend.
		# speech_speed: 0
$0
endsnippet

snippet win_route "Add or remove a static route." b
- name: $1
	win_route:
		destination: ${2:# Destination IP address in CIDR format (ip address/prefix length)}
		# metric: 1
		# gateway: # The gateway used by the static route.
		# state: present
$0
endsnippet

snippet win_product_facts "Provides Windows product information (product id, product key)" b
- name: $1
	win_product_facts:
$0
endsnippet

snippet win_shell "Execute shell commands on target hosts." b
- name: $1
	win_shell: $2
	args:
		# creates: # a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.
		# executable: # change the shell used to execute the command (eg, C(cmd)). The target shell must accept a C(/c) parameter followed by the raw command line to be executed.
		# chdir: # set the specified path as the current working directory before executing a command
		# stdin: # Set the stdin of the command directly to the specified value.
		# removes: # a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.
$0
endsnippet

snippet win_firewall_rule "Windows firewall automation" b
- name: $1
	win_firewall_rule:
		direction: ${2:in|out}
		name: ${3:# The rules name}
		action: ${4:allow|block|bypass}
		# remoteport: # The remote port this rule applies to.
		# protocol: any
		# service: # The service this rule applies to.
		# description: # Description for the firewall rule.
		# enabled: yes
		# profiles: domain,private,public
		# localip: any
		# state: #present|absent
		# program: # The program this rule applies to.
		# remoteip: any
		# force: #no|yes
		# localport: # The local port this rule applies to.
$0
endsnippet

snippet win_security_policy "changes local security policy settings" b
- name: $1
	win_security_policy:
		section: ${2:# The ini section the key exists in.}
		key: ${3:# The ini key of the section or policy name to modify.}
		value: ${4:# The value for the ini key or policy name.}
$0
endsnippet

snippet win_file "Creates, touches or removes files or directories." b
- name: $1
	win_file:
		path: ${2:# path to the file being managed.  Aliases: I(dest), I(name)}
		# state: file|directory|touch|absent
$0
endsnippet

snippet win_firewall "Enable or disable the Windows Firewall" b
- name: $1
	win_firewall:
		# state: enabled|disabled
		# profiles: [#Domain, #Private, #Public
$0
endsnippet

snippet win_get_url "Downloads file from HTTP, HTTPS, or FTP to node" b
- name: $1
	win_get_url:
		url: ${2:# The full URL of a file to download.}
		dest: ${3:# The location to save the file at the URL.}
		# url_password: # Basic authentication password.
		# force_basic_auth: no
		# force: yes
		# use_proxy: yes
		# skip_certificate_validation: no
		# proxy_url: # The full URL of the proxy server to download through.
		# proxy_password: # Proxy authentication password.
		# headers: # Add custom HTTP headers to a request (as a dictionary).
		# proxy_username: # Proxy authentication username.
		# timeout: 10
		# url_username: # Basic authentication username.
		# validate_certs: yes
$0
endsnippet

snippet win_nssm "NSSM - the Non-Sucking Service Manager" b
- name: $1
	win_nssm:
		name: ${2:# Name of the service to operate on}
		# start_mode: #auto|delayed|manual|disabled
		# state: present|#started|stopped|restarted|absent
		# app_parameters_free_form: # Single string of parameters to be passed to the service.
		# application: # The application binary to run as a service
		# stderr_file: # Path to receive error output
		# dependencies: # Service dependencies that has to be started to trigger startup, separated by comma.
		# user: # User to be used for service startup
		# password: # Password to be used for service startup
		# stdout_file: # Path to receive output
		# app_parameters: # Parameters to be passed to the application when it starts.
$0
endsnippet

snippet win_path "Manage Windows path environment variables" b
- name: $1
	win_path:
		elements: ${2:# A single path element, or a list of path elements (ie, directories) to add or remove.}
		# scope: #machine|user
		# state: present|absent
		# name: PATH
$0
endsnippet

snippet win_rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	win_rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# state: #enabled|disabled
		# new_only: no
		# prefix: # Specify a custom install prefix to a Rabbit.
$0
endsnippet

snippet win_psmodule "Adds or removes a Powershell Module." b
- name: $1
	win_psmodule:
		name: ${2:# Name of the powershell module that has to be installed.}
		# url: # Url of the custom repository.
		# allow_clobber: #False|True
		# repository: # Name of the custom repository to register.
		# state: #present|absent
$0
endsnippet

snippet win_ping "A windows version of the classic ping module" b
- name: $1
	win_ping:
		# data: pong
$0
endsnippet

snippet win_defrag "Consolidate fragmented files on local volumes" b
- name: $1
	win_defrag:
		# priority: #low|normal
		# freespace_consolidation: # Perform free space consolidation on the specified volumes.
		# include_volumes: # A list of drive letters or mount point paths of the volumes to be defragmented.
		# parallel: no
		# exclude_volumes: # A list of drive letters or mount point paths to exclude from defragmentation.
$0
endsnippet

snippet win_dotnet_ngen "Runs ngen to recompile DLLs after .NET  updates" b
- name: $1
	win_dotnet_ngen:
$0
endsnippet

snippet win_domain_user "Manages Windows Active Directory user accounts" b
- name: $1
	win_domain_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# upn: # Configures the User Principal Name (UPN) for the account. This is not required, but is best practice to configure for modern versions of Active Directory. The format is "<username>@<domain>".
		# update_password: #always|on_create
		# surname: # Configures the user's last name (surname)
		# description: # Description of the user
		# firstname: # Configures the user's first name (given name)
		# company: # Configures the user's company name
		# groups_action: #replace|add|remove
		# password_expired: # C(yes) will require the user to change their password at next login. C(no) will clear the expired password flag. This is mutually exclusive with I(password_never_expires).
		# street: # Configures the user's street address
		# postal_code: # Configures the user's postal code / zip code
		# groups: # Adds or removes the user from this list of groups, depending on the value of I(groups_action). To remove all but the Principal Group, set C(groups=<principal group name>) and I(groups_action=replace). Note that users cannot be removed from their principal group (for example, "Domain Users").
		# path: # Container or OU for the new user; if you do not specify this, the user will be placed in the default container for users in the domain. Setting the path is only available when a new user is created; if you specify a path on an existing user, the user's path will not be updated - you must delete (e.g., state=absent) the user and then re-add the user with the appropriate path.
		# password_never_expires: # C(yes) will set the password to never expire.  C(no) will allow the password to expire. This is mutually exclusive with I(password_expired)
		# account_locked: no
		# state_province: # Configures the user's state or province
		# city: # Configures the user's city
		# password: # Optionally set the user's password to this (plain text) value. In order to enable an account - I(enabled) - a password must already be configured on the account, or you must provide a password here.
		# domain_username: # The username to use when interacting with AD.
		# country: # Configures the user's country code. Note that this is a two-character ISO 3166 code.
		# enabled: yes
		# state: #present|absent|query
		# domain_password: # The password for C(username).
		# domain_server: # Specifies the Active Directory Domain Services instance to connect to.
		# attributes: # A dict of custom LDAP attributes to set on the user.
		# email: # Configures the user's email address. This is a record in AD and does not do anything to configure any email servers or systems.
		# user_cannot_change_password: # C(yes) will prevent the user from changing their password.  C(no) will allow the user to change their password.
$0
endsnippet

snippet win_eventlog "Manage Windows event logs" b
- name: $1
	win_eventlog:
		name: ${2:# Name of the event log to manage.}
		# parameter_file: # For one or more sources specified, the path to a custom parameter resource file.
		# overflow_action: OverwriteOlder|OverwriteAsNeeded|DoNotOverwrite
		# retention_days: # The minimum number of days event entries must remain in the log.
		# sources: # A list of one or more sources to ensure are present/absent in the log.
		# state: #present|clear|absent
		# message_file: # For one or more sources specified, the path to a custom event message resource file.
		# maximum_size: # The maximum size of the event log.
		# category_file: # For one or more sources specified, the path to a custom category resource file.
$0
endsnippet

snippet win_psexec "Runs commands (remotely) as another (privileged) user" b
- name: $1
	win_psexec:
		command: ${2:# The command line to run through PsExec (limited to 260 characters).}
		# username: # The (remote) user to run the command as.
		# limited: no
		# executable: psexec.exe
		# chdir: # Run the command from this (remote) directory.
		# interactive: no
		# noprofile: no
		# system: no
		# elevated: no
		# priority: background|low|belownormal|abovenormal|high|realtime
		# password: # The password for the (remote) user to run the command as.
		# hostnames: # The hostnames to run the command.
		# timeout: # The connection timeout in seconds
		# nobanner: no
		# wait: yes
$0
endsnippet

snippet win_hotfix "install and uninstalls Windows hotfixes" b
- name: $1
	win_hotfix:
		# hotfix_identifier: # The name of the hotfix as shown in DISM, see examples for details.
		# state: absent|#present
		# hotfix_kb: # The name of the KB the hotfix relates to, see examples for details.
		# source: # The path to the downloaded hotfix .msu file.
$0
endsnippet

snippet win_reg_stat "returns information about a Windows registry key or property of a key" b
- name: $1
	win_reg_stat:
		path: ${2:# T}
		# name: # The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.
$0
endsnippet

snippet win_service "Manage and query Windows services" b
- name: $1
	win_service:
		name: ${2:# Name of the service.}
		# username: # The username to set the service to start as.
		# display_name: # The display name to set for the service.
		# desktop_interact: no
		# force_dependent_services: no
		# dependency_action: #set|add|remove
		# description: # The description to set for the service.
		# start_mode: auto|manual|disabled|delayed
		# state: started|stopped|restarted|absent|paused
		# dependencies: # A list of service dependencies to set for this particular service.
		# path: # The path to the executable to set for the service.
		# password: # The password to set the service to start as.
$0
endsnippet

snippet win_user_right "Manage Windows User Rights" b
- name: $1
	win_user_right:
		name: ${2:# The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).}
		users: ${3:# A list of users or groups to add/remove on the User Right.}
		# action: #set|add|remove
$0
endsnippet

snippet win_regedit "Add, change, or remove registry keys and values" b
- name: $1
	win_regedit:
		path: ${2:# Name of the registry path.}
		# state: #present|absent
		# delete_key: yes
		# name: # Name of the registry entry in the above C(path) parameters.
		# type: binary|dword|expandstring|multistring|#string|qword
		# hive: # A path to a hive key like C:\Users\Default\NTUSER.DAT to load in the registry.
		# data: # Value of the registry entry C(name) in C(path).
$0
endsnippet

snippet win_iis_webbinding "Configures a IIS Web site binding." b
- name: $1
	win_iis_webbinding:
		name: ${2:# Names of web site}
		# protocol: http
		# certificate_hash: # Certificate hash (thumbprint) for the SSL binding. The certificate hash is the unique identifier for the certificate.
		# ip: *
		# host_header: # The host header to bind to / use for the new site.
		# state: #present|absent
		# certificate_store_name: my
		# port: 80
		# ssl_flags: # This parameter is only valid on Server 2012 and newer.
$0
endsnippet

snippet win_audit_policy_system "Used to make changes to the system wide Audit Policy." b
- name: $1
	win_audit_policy_system:
		audit_type: ${2:success|failure|none}
		# category: # Single string value for the category you would like to adjust the policy on.
		# subcategory: # Single string value for the subcategory you would like to adjust the policy on.
$0
endsnippet

snippet win_package "Installs/uninstalls an installable package" b
- name: $1
	win_package:
		# username: # Username of an account with access to the package if it is located on a file share.
		# creates_path: # Will check the existance of the path specified and use the result to determine whether the package is already installed.
		# name: # Name of the package, if name isn't specified the path will be used for log messages.
		# creates_service: # Will check the existing of the service specified and use the result to determine whether the package is already installed.
		# expected_return_code: [0, 3010]
		# state: present
		# arguments: # Any arguments the installer needs to either install or uninstall the package.
		# creates_version: # Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.
		# path: # Location of the package to be installed or uninstalled.
		# password: # The password for C(user_name), must be set when C(user_name) is.
		# validate_certs: yes
		# product_id: # The product id of the installed packaged.
$0
endsnippet

snippet win_certificate_store "Manages the certificate store" b
- name: $1
	win_certificate_store:
		# key_exportable: yes
		# key_storage: #default|machine|user
		# file_type: #der|pem|pkcs12
		# store_location: CurrentUser|#LocalMachine
		# store_name: AddressBook|AuthRoot|CertificateAuthority|Disallowed|#My|Root|TrustedPeople|TrustedPublisher
		# state: #present|absent|exported
		# thumbprint: # The thumbprint as a hex string to either export or remove.
		# path: # The path to a certificate file.
		# password: # The password of the pkcs12 certificate key.
$0
endsnippet

snippet win_wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	win_wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: 255.255.255.255
		# port: 7
$0
endsnippet

snippet win_domain_group "creates, modifies or removes domain groups" b
- name: $1
	win_domain_group:
		name: ${2:# The name of the group to create, modify or remove.}
		# category: distribution|security
		# protect: # Will set the C(ProtectedFromAccidentalDeletion) flag based on this value.
		# display_name: # The value to assign to the LDAP C(displayName) attribute.
		# description: # The value to be assigned to the LDAP C(description) attribute.
		# domain_username: # The username to use when interacting with AD.
		# ignore_protection: no
		# state: absent|#present
		# domain_password: # The password for C(username).
		# organizational_unit: # The full LDAP path to create or move the group to.
		# domain_server: # Specifies the Active Directory Domain Services instance to connect to.
		# managed_by: # The value to be assigned to the LDAP C(managedBy) attribute.
		# attributes: # A dict of custom LDAP attributes to set on the group.
		# scope: domainlocal|global|universal
$0
endsnippet

snippet win_msg "Sends a message to logged in users on Windows hosts." b
- name: $1
	win_msg:
		# msg: Hello world!
		# to: *
		# display_seconds: 10
		# wait: no
$0
endsnippet

snippet win_eventlog_entry "Write entries to Windows event logs" b
- name: $1
	win_eventlog_entry:
		source: ${2:# Name of the log source to indicate where the entry is from.}
		log: ${3:# Name of the event log to write an entry to.}
		event_id: ${4:# The numeric event identifier for the entry.}
		message: ${5:# The message for the given log entry.}
		# category: # A numeric task category associated with the category message file for the log source.
		# raw_data: # Binary data associated with the log entry.
		# entry_type: Error|FailureAudit|Information|SuccessAudit|Warning
$0
endsnippet

snippet win_iis_webapplication "Configures IIS web applications" b
- name: $1
	win_iis_webapplication:
		name: ${2:# Name of the web application.}
		site: ${3:# Name of the site on which the application is created.}
		# state: absent|#present
		# application_pool: # The application pool in which the new site executes.
		# physical_path: # The physical path on the remote host to use for the new application.
$0
endsnippet

snippet win_chocolatey "Manage packages using chocolatey" b
- name: $1
	win_chocolatey:
		name: ${2:# Name of the package to be installed.}
		# force: no
		# proxy_password: # Proxy password used to install chocolatey and the package.
		# install_args: # Arguments to pass to the native installer.
		# ignore_dependencies: no
		# upgrade: no
		# skip_scripts: no
		# ignore_checksums: no
		# proxy_url: # Proxy url used to install chocolatey and the package.
		# allow_empty_checksums: no
		# source: # Specify source rather than using default chocolatey repository.
		# state: absent|downgrade|latest|#present|reinstalled
		# version: # Specific version of the package to be installed.
		# params: # Parameters to pass to the package
		# proxy_username: # Proxy username used to install chocolatey and the package.
		# timeout: 2700
$0
endsnippet

snippet win_pagefile "Query or change pagefile configuration" b
- name: $1
	win_pagefile:
		# test_path: yes
		# initial_size: # The initial size of the pagefile in megabytes.
		# drive: # The drive of the pagefile.
		# state: present|absent|#query
		# system_managed: no
		# remove_all: no
		# override: yes
		# maximum_size: # The maximum size of the pagefile in megabytes.
		# automatic: # Configures AutomaticManagedPagefile for the entire system.
$0
endsnippet

snippet win_scheduled_task "Manage scheduled tasks" b
- name: $1
	win_scheduled_task:
		name: ${2:# T}
		# run_only_if_network_available: # Whether the task will run only when a network is available.
		# update_password: yes
		# execution_time_limit: # The amount of time allowed to complete the task.
		# actions: # A list of action to configure for the task.
		# group: # The group that will run the task.
		# frequency: daily|once|weekly
		# wake_to_run: # Whether the task will wake the computer when it is time to run the task.
		# run_only_if_idle: # Whether the task will run the task only if the computer is in an idle state.
		# executable: # The path to the executable to run for a scheduled task action.
		# display_name: # The name of the user/group that is displayed in the Task Scheduler UI.
		# author: # The author of the task.
		# restart_count: # The number of times that the Task Scheduler will attempt to restart the task.
		# run_level: limited|highest
		# priority: # The priority level (0-10) of the task.
		# source: # The source of the task.
		# state: absent|#present
		# version: # The version number of the task.
		# allow_demand_start: # Whether the task can be started by using either the Run command or the Context menu.
		# arguments: # Arguments to provide for a scheduled task action.
		# logon_type: none|password|s4u|interactive_token|group|service_account|token_or_password
		# hidden: # Whether the task will be hidden in the UI.
		# username: # The user to run the scheduled task as.
		# stop_if_going_on_batteries: # Whether the task will be stopped if the computer begins to run on battery power.
		# disallow_start_if_on_batteries: # Whether the task will not be started if the computer is running on battery power.
		# description: # The description of the task.
		# delete_expired_task_after: # The amount of time that the Task Scheduler will wait before deleting the task after it expires.
		# days_of_week: # Days of the week to run a weekly task.
		# restart_interval: # How long the Task Scheduler will attempt to restart the task.
		# start_when_available: # Whether the task can start at any time after its scheduled time has passed.
		# date: # The date when the task was registered.
		# path: \
		# password: # The password for the user account to run the scheduled task as.
		# compatibility: 0|1|2
		# multiple_instances: 0|1|2|3
		# triggers: # A list of triggers to configure for the task.
		# enabled: # Whether the task is enabled, the task can only run when C(yes).
		# store_password: yes
		# allow_hard_terminate: # Whether the task can be terminated by using TerminateProcess.
		# time: # The start time to execute the scheduled task.
$0
endsnippet

snippet win_audit_rule "Adds an audit rule to files, folders, or registry keys" b
- name: $1
	win_audit_rule:
		user: ${2:# The user or group to adjust rules for.}
		rights: ${3:# Comma seperated list of the rights desired. Only required for adding a rule.}
		audit_flags: ${4:Success|Failure}
		path: ${5:# Path to the file, folder, or registry key.}
		# state: #present|absent
		# inheritance_flags: ContainerInherit|ObjectInherit
		# propagation_flags: #None|InherityOnly|NoPropagateInherit
$0
endsnippet

snippet win_command "Executes a command on a remote Windows node" b
- name: $1
	win_command: $2
	args:
		# creates: # a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.
		# chdir: # set the specified path as the current working directory before executing a command.
		# removes: # a path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.
		# stdin: # Set the stdin of the command directly to the specified value.
$0
endsnippet

snippet win_power_plan "Changes the power plan of a Windows system" b
- name: $1
	win_power_plan:
		name: ${2:# String value that indicates the desired power plan. The power plan must already be present on the system. Commonly there will be options for C(balanced) and C(high performance).}
$0
endsnippet

snippet win_webpicmd "Installs packages using Web Platform Installer command-line" b
- name: $1
	win_webpicmd:
		name: ${2:# Name of the package to be installed}
$0
endsnippet

snippet win_user "Manages local Windows user accounts" b
- name: $1
	win_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# update_password: #always|on_create
		# password: # Optionally set the user's password to this (plain text) value.
		# description: # Description of the user
		# groups_action: #replace|add|remove
		# password_expired: yes|no
		# state: #present|absent|query
		# groups: # Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.
		# account_disabled: yes|no
		# fullname: # Full name of the user
		# password_never_expires: yes|no
		# account_locked: no
		# user_cannot_change_password: yes|no
$0
endsnippet

snippet win_domain "Ensures the existence of a Windows domain." b
- name: $1
	win_domain:
		dns_domain_name: ${2:# the DNS name of the domain which should exist and be reachable or reside on the target Windows host}
		safe_mode_password: ${3:# safe mode password for the domain controller}
		# database_path: # The path to a directory on a fixed disk of the Windows host where the domain database will be created.
		# sysvol_path: # The path to a directory on a fixed disk of the Windows host where the Sysvol file will be created.
$0
endsnippet

snippet win_group_membership "Manage Windows local group membership" b
- name: $1
	win_group_membership:
		name: ${2:# Name of the local group to manage membership on.}
		members: ${3:# A list of members to ensure are present/absent from the group.}
		# state: #present|absent
$0
endsnippet

snippet win_template "Templates a file out to a remote server." b
- name: $1
	win_template:
		src: ${2:# Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		# force: #yes|no
		# trim_blocks: no
		# block_end_string: %}
		# variable_start_string: {{
		# newline_sequence: \n|\r|#\r\n
		# variable_end_string: }}
		# block_start_string: {%
$0
endsnippet

snippet win_robocopy "Synchronizes the contents of two directories using Robocopy" b
- name: $1
	win_robocopy:
		dest: ${2:# Destination file/directory to sync (Will receive contents of src).}
		src: ${3:# Source file/directory to sync.}
		# recurse: no
		# purge: no
		# flags: # Directly supply Robocopy flags. If set, C(purge) and C(recurse) will be ignored.
$0
endsnippet

snippet win_region "Set the region and format settings" b
- name: $1
	win_region:
		# unicode_language: # The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect.
		# copy_settings: true|false
		# location: # The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to. This needs to be set if C(format) or C(unicode_language) is not set.
		# format: # The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(unicode_language) is not set.
$0
endsnippet

snippet win_environment "Modify environment variables on windows hosts" b
- name: $1
	win_environment:
		name: ${2:# The name of the environment variable.}
		level: ${3:machine|user|process}
		# state: absent|#present
		# value: # The value to store in the environment variable.
$0
endsnippet

snippet win_copy "Copies files to remote locations on windows hosts" b
- name: $1
	win_copy:
		src: ${2:# Local path to a file to copy to the remote server; can be absolute or relative.}
		dest: ${3:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		# content: # When used instead of C(src), sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.
		# force: yes
		# remote_src: no
		# decrypt: yes
		# local_follow: yes
$0
endsnippet

snippet win_share "Manage Windows shares" b
- name: $1
	win_share:
		name: ${2:# Share name.}
		path: ${3:# Share directory.}
		# deny: # Specify user list that should get no access, regardless of implied access on share, separated by comma.
		# full: # Specify user list that should get full access on share, separated by comma.
		# encrypt: no
		# read: # Specify user list that should get read access on share, separated by comma.
		# list: no
		# state: #present|absent
		# caching_mode: BranchCache|Documents|#Manual|None|Programs|Unknown
		# change: # Specify user list that should get read and write access on share, separated by comma.
		# description: # Share description
$0
endsnippet

snippet win_lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression." b
- name: $1
	win_lineinfile:
		path: ${2:# The path of the file to modify.}
		# insertbefore: BOF|*regex*
		# encoding: auto
		# create: yes|#no
		# newline: #windows|unix
		# backrefs: yes|#no
		# state: #present|absent
		# insertafter: #EOF|*regex*
		# regexp: # The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).

		# line: # Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.
		# backup: yes|#no
		# validate: # Validation to run before copying into place. Use %s in the command to indicate the current file to validate.
$0
endsnippet

snippet win_timezone "Sets Windows machine timezone" b
- name: $1
	win_timezone:
		timezone: ${2:# Timezone to set to. Example Central Standard Time}
$0
endsnippet

snippet win_iis_virtualdirectory "Configures a virtual directory in IIS." b
- name: $1
	win_iis_virtualdirectory:
		name: ${2:# The name of the virtual directory to create or remove}
		site: ${3:# The site name under which the virtual directory is created or exists.}
		# application: # The application under which the virtual directory is created or exists.
		# state: absent|#present
		# physical_path: # The physical path to the folder in which the new virtual directory is created. The specified folder must already exist.
$0
endsnippet

snippet win_shortcut "Manage shortcuts on Windows" b
- name: $1
	win_shortcut:
		dest: ${2:# Destination file for the shortcuting file.}
		# windowstyle: maximized|minimized|normal
		# src: # Executable or URL the shortcut points to.
		# description: # Description for the shortcut.
		# args: # Additional arguments for the executable defined in C(src).
		# directory: # Working directory for executable defined in C(src).
		# state: absent|#present
		# hotkey: # Key combination for the shortcut.
		# icon: # Icon used for the shortcut.
$0
endsnippet

snippet win_mapped_drive "maps a network drive for a user" b
- name: $1
	win_mapped_drive:
		letter: ${2:# The letter of the network path to map to.}
		# username: # Credentials to map the drive with.
		# path: # The UNC path to map the drive to.
		# state: absent|#present
		# password: # The password for C(username).
$0
endsnippet

snippet win_updates "Download and install Windows updates" b
- name: $1
	win_updates:
		# blacklist: # A list of update titles or KB numbers that can be used to specify which updates are to be excluded from installation.
		# reboot_timeout: 1200
		# state: #installed|searched
		# log_path: # If set, C(win_updates) will append update progress to the specified file. The directory must already exist.
		# whitelist: # A list of update titles or KB numbers that can be used to specify which updates are to be searched or installed.
		# category_names: [Application, Connectors, #CriticalUpdates, DefinitionUpdates, DeveloperKits, FeaturePacks, Guidance, #SecurityUpdates, ServicePacks, Tools, #UpdateRollups, Updates
		# reboot: no
$0
endsnippet

snippet win_uri "Interacts with webservices" b
- name: $1
	win_uri:
		url: ${2:# Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path.}
		# body: # The body of the HTTP request/response to the web service.
		# dest: # Output the response body to a file.
		# status_code: 200
		# force_basic_auth: no
		# removes: # A filename, when it does not exist, this step will be skipped.
		# client_cert_password: # The password for the client certificate (.pfx) file that is used for a secure web request.
		# use_basic_parsing: yes
		# content_type: # Sets the "Content-Type" header.
		# password: # Password to use for authentication.
		# maximum_redirection: 5
		# method: CONNECT|DELETE|#GET|HEAD|MERGE|OPTIONS|PATCH|POST|PUT|REFRESH|TRACE
		# creates: # A filename, when it already exists, this step will be skipped.
		# headers: # Extra headers to set on the request, see the examples for more details on how to set this.
		# timeout: 30
		# follow_redirects: all|none|#safe
		# return_content: no
		# validate_certs: yes
		# client_cert: # Specifies the client certificate (.pfx) that is used for a secure web request.
		# user: # Username to use for authentication.
$0
endsnippet

snippet win_file_version "Get DLL or EXE file build version" b
- name: $1
	win_file_version:
		path: ${2:# File to get version(provide absolute path)}
$0
endsnippet

snippet win_regmerge "Merges the contents of a registry file into the windows registry" b
- name: $1
	win_regmerge:
		path: ${2:no default}
		# compare_key: no default
$0
endsnippet

snippet win_group "Add and remove local groups" b
- name: $1
	win_group:
		name: ${2:# Name of the group}
		# state: #present|absent
		# description: # Description of the group
$0
endsnippet

snippet win_toast "Sends Toast windows notification to logged in users on Windows 10 or later hosts" b
- name: $1
	win_toast:
		# popup: yes
		# group: Powershell
		# expire: 45
		# title: Notification HH:mm
		# msg: Hello, World!
		# tag: Ansible
$0
endsnippet

snippet win_feature "Installs and uninstalls Windows Features on Windows Server" b
- name: $1
	win_feature:
		name: ${2:# Names of roles or features to install as a single feature or a comma-separated list of features.}
		# source: # Specify a source to install the feature from.
		# state: #present|absent
		# include_management_tools: no
		# include_sub_features: no
		# restart: no
$0
endsnippet

snippet win_acl "Set file/directory/registry permissions for a system user or group" b
- name: $1
	win_acl:
		user: ${2:# User or Group to add specified rights to act on src file/folder or registry key.}
		rights: ${3:# The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).}
		path: ${4:# The path to the file or directory.}
		type: ${5:allow|deny}
		# propagation: InheritOnly|#None|NoPropagateInherit
		# state: absent|#present
		# inherit: ContainerInherit|ObjectInherit
$0
endsnippet

snippet win_domain_membership "Manage domain/workgroup membership for a Windows host" b
- name: $1
	win_domain_membership:
		domain_admin_user: ${2:# username of a domain admin for the target domain (required to join or leave the domain)}
		# workgroup_name: # when C(state) is C(workgroup), the name of the workgroup that the Windows host should be in
		# domain_ou_path: # The desired OU path for adding the computer object.
		# state: domain|workgroup
		# dns_domain_name: # when C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined
		# hostname: # the desired hostname for the Windows host
		# domain_admin_password: # password for the specified C(domain_admin_user)
$0
endsnippet

snippet win_disk_image "Manage ISO/VHD/VHDX mounts on Windows hosts" b
- name: $1
	win_disk_image:
		image_path: ${2:# path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)}
		# state: #present|absent
$0
endsnippet

snippet win_iis_website "Configures a IIS Web site." b
- name: $1
	win_iis_website:
		name: ${2:# Names of web site}
		# application_pool: # The application pool in which the new site executes.
		# parameters: # Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. "foo:1|bar:2"
		# ip: # The IP address to bind to / use for the new site.
		# physical_path: # The physical path on the remote host to use for the new site. The specified folder must already exist.
		# hostname: # The host header to bind to / use for the new site.
		# site_id: # Explicitly set the IIS numeric ID for a site. Note that this value cannot be changed after the website has been created.
		# ssl: # Enables HTTPS binding on the site..
		# state: started|restarted|stopped|absent
		# port: # The port to bind to / use for the new site.
$0
endsnippet

snippet sensu_check "Manage Sensu checks" b
- name: $1
	sensu_check:
		name: ${2:# The name of the check}
		command: ${3:# Path to the sensu check to run (not required when I(state=absent))}
		# interval: # Check interval in seconds
		# handle: yes|no
		# subscribers: []
		# metric: yes|no
		# subdue_begin: # When to disable handling of check failures
		# dependencies: []
		# occurrences: 1
		# low_flap_threshold: # The low threshold for flap detection
		# ttl: # Time to live in seconds until the check is considered stale
		# aggregate: yes|no
		# path: /etc/sensu/conf.d/checks.json
		# standalone: yes|no
		# backup: yes|no
		# handlers: []
		# publish: yes|no
		# custom: {}
		# source: # The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).
		# state: #present|absent
		# high_flap_threshold: # The high threshold for flap detection
		# timeout: 10
		# subdue_end: # When to enable handling of check failures
		# refresh: # Number of seconds handlers should wait before taking second action
$0
endsnippet

snippet nagios "Perform common tasks in Nagios related to downtime and notifications." b
- name: $1
	nagios:
		action: ${2:downtime|delete_downtime|enable_alerts|disable_alerts|silence|unsilence|silence_nagios|unsilence_nagios|command|servicegroup_service_downtime|servicegroup_host_downtime}
		command: ${3:# The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action.}
		services: ${4:# What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions.}
		# comment: Scheduling downtime
		# servicegroup: # The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime).
		# author: Ansible
		# host: # Host to operate on in Nagios.
		# minutes: 30
		# cmdfile: auto-detected
$0
endsnippet

snippet grafana_dashboard "Manage Grafana dashboards" b
- name: $1
	grafana_dashboard:
		grafana_url: ${2:# The Grafana URL.}
		state: ${3:absent|export|#present}
		# grafana_user: admin
		# org_id: 1
		# grafana_api_key: # The Grafana API key.
		# grafana_password: admin
		# path: # The path to the json file containing the Grafana dashboard to import or export.
		# message: # Set a commit message for the version history.
		# validate_certs: yes
		# slug: # slug of the dashboard. It's the friendly url name of the dashboard.
		# overwrite: no
$0
endsnippet

snippet circonus_annotation "create an annotation in circonus" b
- name: $1
	circonus_annotation:
		category: ${2:# Annotation Category}
		description: ${3:# Description of annotation}
		title: ${4:# Title of annotation}
		api_key: ${5:# Circonus API key}
		# start: I(now)
		# duration: 0
		# stop: I(now) + I(duration)
$0
endsnippet

snippet datadog_monitor "Manages Datadog monitors" b
- name: $1
	datadog_monitor:
		app_key: ${2:# Your DataDog app key.}
		name: ${3:# The name of the alert.}
		state: ${4:present|absent|mute|unmute}
		api_key: ${5:# Your DataDog API key.}
		# notify_audit: no
		# timeout_h: # The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.
		# tags: # A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.
		# thresholds: {u'warning': 1, u'ok': 1, u'critical': 1}
		# new_host_delay: # A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts. This gives the host time to fully initialize.
		# query: # The monitor query to notify on with syntax varying depending on what type of monitor you are creating.
		# message: # A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.
		# id: # The id of the alert. If set, will be used instead of the name to locate the alert.
		# locked: no
		# no_data_timeframe: 2x timeframe for metric, 2 minutes for service
		# silenced: 
		# require_full_window: # A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.
		# notify_no_data: no
		# renotify_interval: # The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.
		# escalation_message: # A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None
		# type: metric alert|service check|event alert
$0
endsnippet

snippet bigpanda "Notify BigPanda about deployments" b
- name: $1
	bigpanda:
		component: ${2:# The name of the component being deployed. Ex: billing}
		token: ${3:# API token.}
		state: ${4:started|finished|failed}
		version: ${5:# The deployment version.}
		# description: # Free text description of the deployment.
		# url: https://api.bigpanda.io
		# hosts: machine's hostname
		# env: # The environment name, typically 'production', 'staging', etc.
		# owner: # The person responsible for the deployment.
		# validate_certs: #yes|no
$0
endsnippet

snippet statusio_maintenance "Create maintenance windows for your status.io dashboard" b
- name: $1
	statusio_maintenance:
		api_id: ${2:# Your unique API ID from status.io}
		statuspage: ${3:# Your unique StatusPage ID from status.io}
		api_key: ${4:# Your unique API Key from status.io}
		# maintenance_notify_72_hr: no
		# maintenance_notify_now: no
		# start_time: # Time maintenance is expected to start (Hour:Minutes) (UTC)
		# automation: no
		# maintenance_notify_24_hr: no
		# all_infrastructure_affected: no
		# maintenance_id: # The maintenance id number when deleting a maintenance window
		# desc: Created by Ansible
		# maintenance_notify_1_hr: no
		# title: A new maintenance window
		# url: https://api.status.io
		# state: #present|absent
		# components: # The given name of your component (server name)
		# minutes: 10
		# start_date: # Date maintenance is expected to start (Month/Day/Year) (UTC)
		# containers: # The given name of your container (data center)
$0
endsnippet

snippet monit "Manage the state of a program monitored via Monit" b
- name: $1
	monit:
		state: ${2:present|started|stopped|restarted|monitored|unmonitored|reloaded}
		name: ${3:# The name of the I(monit) program/process to manage}
		# timeout: 300
$0
endsnippet

snippet honeybadger_deployment "Notify Honeybadger.io about app deployments" b
- name: $1
	honeybadger_deployment:
		environment: ${2:# The environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		# repo: # URL of the project repository
		# user: # The username of the person doing the deployment
		# url: https://api.honeybadger.io/v1/deploys
		# validate_certs: #yes|no
		# revision: # A hash, number, tag, or other identifier showing what revision was deployed
$0
endsnippet

snippet icinga2_host "Manage a host in Icinga2" b
- name: $1
	icinga2_host:
		ip: ${2:# The IP address of the host.}
		name: ${3:# Name used to create / delete the host. This does not need to be the FQDN, but does needs to be unique.}
		url: ${4:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		# url_username: # The username for use in HTTP basic authentication.
		# variables: # List of variables.
		# force_basic_auth: no
		# url_password: # The password for use in HTTP basic authentication.
		# display_name: if none is give it is the value of the <name> parameter
		# use_proxy: yes
		# zone: # The zone from where this host should be polled.
		# check_command: hostalive
		# state: #present|absent
		# template: # The template used to define the host.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
$0
endsnippet

snippet sensu_handler "Manages Sensu handler configuration" b
- name: $1
	sensu_handler:
		name: ${2:# A unique name for the handler. The name cannot contain special characters or spaces.}
		handlers: ${3:# An array of Sensu event handlers (names) to use for events using the handler set.}
		type: ${4:pipe|tcp|udp|transport|set}
		# filter: # The Sensu event filter (name) to use when filtering events for the handler.
		# filters: # An array of Sensu event filters (names) to use when filtering events for the handler.
		# severities: warning|critical|unknown
		# pipe: # The pipe definition scope, used to configure the Sensu transport pipe.
		# mutator: # The Sensu event mutator (name) to use to mutate event data for the handler.
		# state: #present|absent
		# command: # The handler command to be executed.
		# timeout: 10
		# handle_flapping: no
		# handle_silenced: no
		# socket: # The socket definition scope, used to configure the TCP/UDP handler socket.
$0
endsnippet

snippet datadog_event "Posts events to DataDog  service" b
- name: $1
	datadog_event:
		title: ${2:# The event title.}
		text: ${3:# The body of the event.}
		app_key: ${4:# Your DataDog app key.}
		api_key: ${5:# Your DataDog API key.}
		# date_happened: now
		# alert_type: error|warning|#info|success
		# tags: # Comma separated list of tags to apply to the event.
		# priority: #normal|low
		# host: {{ ansible_hostname }}
		# aggregation_key: # An arbitrary string to use for aggregation.
		# validate_certs: #yes|no
$0
endsnippet

snippet grafana_datasource "Manage Grafana datasources" b
- name: $1
	grafana_datasource:
		grafana_url: ${2:# The Grafana URL.}
		ds_type: ${3:elasticsearch|graphite|influxdb|mysql|opentsdb|postgres|prometheus}
		name: ${4:# The name of the datasource.}
		url: ${5:# The URL of the datasource.}
		# time_interval: # Minimum group by interval for C(influxdb) or C(elasticsearch) datasources.
		# tls_client_key: # The client TLS private key
		# interval: |Hourly|Daily|Weekly|Monthly|Yearly
		# grafana_user: admin
		# es_version: 2|#5|56
		# tsdb_version: #1|2|3
		# is_default: no
		# sslmode: disable|require|verify-ca|verify-full
		# grafana_api_key: # The Grafana API key.
		# password: # The datasource password
		# max_concurrent_shard_requests: 256
		# tls_ca_cert: # The TLS CA certificate for self signed certificates.
		# basic_auth_password: # The datasource basic auth password, when C(basic auth) is C(yes).
		# basic_auth_user: # The datasource basic auth user.
		# database: # Name of the database for the datasource.
		# time_field: timestamp
		# with_credentials: no
		# org_id: 1
		# tsdb_resolution: millisecond|#second
		# access: direct|#proxy
		# state: absent|#present
		# tls_client_cert: # The client TLS certificate.
		# grafana_password: admin
		# validate_certs: yes
		# user: # The datasource login user for influxdb datasources.
$0
endsnippet

snippet logstash_plugin "Manage Logstash plugins" b
- name: $1
	logstash_plugin:
		name: ${2:# Install plugin with that name.}
		# proxy_port: # Proxy port to use during plugin installation.
		# state: #present|absent
		# version: # Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.
		# proxy_host: # Proxy host to use during plugin installation.
		# plugin_bin: /usr/share/logstash/bin/logstash-plugin
$0
endsnippet

snippet logicmonitor "Manage your LogicMonitor account through Ansible Playbooks" b
- name: $1
	logicmonitor:
		company: ${2:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."}
		user: ${3:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${4:# The password of the specified LogicMonitor user}
		target: ${5:collector|host|datsource|hostgroup}
		action: ${6:add|remove|update|sdt}
		# displayname: hostname -f
		# description: 
		# groups: []
		# duration: 30
		# collector: # The fully qualified domain name of a collector in your LogicMonitor account.
		# id: # ID of the datasource to target.
		# alertenable: #True|False
		# hostname: hostname -f
		# properties: {}
		# starttime: Now
		# fullpath: # The fullpath of the host group object you would like to manage.
$0
endsnippet

snippet logicmonitor_facts "Collect facts about LogicMonitor objects" b
- name: $1
	logicmonitor_facts:
		target: ${2:host|hostgroup}
		company: ${3:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".}
		user: ${4:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${5:# The password for the chosen LogicMonitor User.}
		# displayname: hostname -f
		# hostname: hostname -f
		# fullpath: # The fullpath of the hostgroup object you would like to manage.
		# collector: # The fully qualified domain name of a collector in your LogicMonitor account.
$0
endsnippet

snippet sensu_silence "Manage Sensu silence entries" b
- name: $1
	sensu_silence:
		state: ${2:#present|absent}
		subscription: ${3:[]}
		# expire_on_resolve: # If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.
		# url: http://127.0.01:4567
		# creator: # Specifies the entity responsible for this entry.
		# reason: # If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.
		# expire: # If specified, the silence entry will be automatically cleared after this number of seconds.
		# check: # Specifies the check which the silence entry applies to.
$0
endsnippet

snippet logentries "Module for tracking logs via logentries.com" b
- name: $1
	logentries:
		path: ${2:# path to a log file}
		# state: #present|absent
		# name: # name of the log
		# logtype: # type of the log
$0
endsnippet

snippet pagerduty_alert "Trigger, acknowledge or resolve PagerDuty incidents" b
- name: $1
	pagerduty_alert:
		name: ${2:# PagerDuty unique subdomain.}
		state: ${3:triggered|acknowledged|resolved}
		service_key: ${4:# The GUID of one of your "Generic API" services.}
		api_key: ${5:# The pagerduty API key (readonly access), generated on the pagerduty site.}
		# client_url: # The URL of the monitoring client that is triggering this event.
		# incident_key: # Identifies the incident to which this I(state) should be applied.
		# client: # The name of the monitoring client that is triggering this event.
		# desc: Created via Ansible
$0
endsnippet

snippet grafana_plugin "Manage Grafana plugins via grafana-cli" b
- name: $1
	grafana_plugin:
		name: ${2:# Name of the plugin.}
		# state: absent|#present
		# grafana_repo: # Grafana repository. If not set, gafana-cli will use the default value C(https://grafana.net/api/plugins).
		# version: # Version of the plugin to install.
		# grafana_plugin_url: # Custom Grafana plugin URL.
		# grafana_plugins_dir: # Directory where Grafana plugin will be installed.
$0
endsnippet

snippet newrelic_deployment "Notify newrelic about app deployments" b
- name: $1
	newrelic_deployment:
		token: ${2:# API token, to place in the x-api-key header.}
		# application_id: # (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM
		# description: # Text annotation for the deployment - notes for you
		# changelog: # A list of changes for this deployment
		# appname: # Name of the application
		# environment: # The environment for this deployment
		# user: # The name of the user/process that triggered this deployment
		# revision: # A revision number (e.g., git commit SHA)
		# validate_certs: #yes|no
		# app_name: # (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application
$0
endsnippet

snippet uptimerobot "Pause and start Uptime Robot monitoring" b
- name: $1
	uptimerobot:
		monitorid: ${2:}
		state: ${3:started|paused}
		apikey: ${4:}
$0
endsnippet

snippet sensu_client "Manages Sensu client configuration" b
- name: $1
	sensu_client:
		subscriptions: ${2:# An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).}
		# address: Non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu)
		# chef: # The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).
		# redact: # Client definition attributes to redact (values) when logging and sending client keepalives.
		# socket: # The socket definition scope, used to configure the Sensu client socket.
		# puppet: # The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).
		# ec2: # The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).
		# safe_mode: true|false
		# registration: # The registration definition scope, used to configure Sensu registration event handlers.
		# deregistration: # The deregistration definition scope, used to configure automated Sensu client de-registration.
		# keepalive: # The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).
		# deregister: true|false
		# name: System hostname as determined by Ruby Socket.gethostname (provided by Sensu)
		# state: #present|absent
		# keepalives: true|false
		# servicenow: # The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).
$0
endsnippet

snippet librato_annotation "create an annotation in librato" b
- name: $1
	librato_annotation:
		links: ${2:# See examples}
		title: ${3:# The title of an annotation is a string and may contain spaces}
		api_key: ${4:# Librato account api key}
		user: ${5:# Librato account username}
		# description: # The description contains extra meta-data about a particular annotation
		# start_time: # The unix timestamp indicating the time at which the event referenced by this annotation started
		# name: # The annotation stream name
		# source: # A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population
		# end_time: # The unix timestamp indicating the time at which the event referenced by this annotation ended
$0
endsnippet

snippet sensu_subscription "Manage Sensu subscriptions" b
- name: $1
	sensu_subscription:
		name: ${2:# The name of the channel}
		# path: /etc/sensu/conf.d/subscriptions.json
		# state: #present|absent
		# backup: yes|no
$0
endsnippet

snippet icinga2_feature "Manage Icinga2 feature" b
- name: $1
	icinga2_feature:
		name: ${2:# This is the feature name to enable or disable.}
		# state: #present|absent
$0
endsnippet

snippet rollbar_deployment "Notify Rollbar about app deployments" b
- name: $1
	rollbar_deployment:
		environment: ${2:# Name of the environment being deployed, e.g. 'production'.}
		token: ${3:# Your project access token.}
		revision: ${4:# Revision number/sha being deployed.}
		# comment: # Deploy comment (e.g. what is being deployed).
		# rollbar_user: # Rollbar username of the user who deployed.
		# url: https://api.rollbar.com/api/1/deploy/
		# user: # User who deployed.
		# validate_certs: #yes|no
$0
endsnippet

snippet airbrake_deployment "Notify airbrake about app deployments" b
- name: $1
	airbrake_deployment:
		environment: ${2:# The airbrake environment name, typically 'production', 'staging', etc.}
		token: ${3:# API token.}
		# repo: # URL of the project repository
		# user: # The username of the person doing the deployment
		# url: https://airbrake.io/deploys.txt
		# validate_certs: #yes|no
		# revision: # A hash, number, tag, or other identifier showing what revision was deployed
$0
endsnippet

snippet pingdom "Pause/unpause Pingdom alerts" b
- name: $1
	pingdom:
		checkid: ${2:}
		passwd: ${3:}
		state: ${4:running|paused}
		uid: ${5:}
		key: ${6:}
$0
endsnippet

snippet pagerduty "Create PagerDuty maintenance windows" b
- name: $1
	pagerduty:
		name: ${2:}
		passwd: ${3:}
		state: ${4:running|started|ongoing|absent}
		token: ${5:}
		user: ${6:}
		requester_id: ${7:}
		# service: 
		# minutes: 
		# hours: 
		# validate_certs: #yes|no
		# desc: 
$0
endsnippet

snippet stackdriver "Send code deploy and annotation events to stackdriver" b
- name: $1
	stackdriver:
		key: ${2:# API key.}
		# repository: # The repository (or project) deployed
		# level: #INFO|WARN|ERROR
		# annotated_by: Ansible
		# deployed_to: # The environment code was deployed to. (ie: development, staging, production)
		# deployed_by: Ansible
		# instance_id: # id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown
		# msg: # The contents of the annotation message, in plain text.  Limited to 256 characters. Required for annotation.
		# event_epoch: # Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.
		# revision_id: # The revision of the code that was deployed. Required for deploy events
		# event: annotation|deploy
$0
endsnippet

snippet zabbix_template "create/delete/dump zabbix template" b
- name: $1
	zabbix_template:
		login_user: ${2:# Zabbix user name.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_password: ${4:# Zabbix user password.}
		template_name: ${5:# Name of zabbix template}
		# template_groups: # List of template groups to create or delete.
		# http_login_password: # Basic Auth password
		# clear_templates: # List of templates cleared from the template.
		# http_login_user: # Basic Auth login
		# template_json: # JSON dump of template to import
		# macros: # List of templates macro
		# state: #present|absent|dump
		# timeout: 10
		# validate_certs: true|false
		# link_templates: # List of templates linked to the template.
$0
endsnippet

snippet zabbix_group "Zabbix host groups creates/deletes" b
- name: $1
	zabbix_group:
		host_groups: ${2:# List of host groups to create or delete.}
		login_user: ${3:# Zabbix user name.}
		server_url: ${4:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_password: ${5:# Zabbix user password.}
		# http_login_password: # Basic Auth password
		# http_login_user: # Basic Auth login
		# state: #present|absent
		# timeout: 10
		# validate_certs: true|false
$0
endsnippet

snippet zabbix_host "Zabbix host creates/updates/deletes" b
- name: $1
	zabbix_host:
		server_url: ${2:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${3:# Zabbix user name.}
		login_password: ${4:# Zabbix user password.}
		host_name: ${5:# Name of the host in Zabbix.}
		# status: #enabled|disabled
		# http_login_user: # Basic Auth login
		# force: #yes|no
		# description: # Description of the host in Zabbix.
		# interfaces: []
		# tls_accept: 1
		# ipmi_username: # IPMI username.
		# ipmi_authtype: # IPMI authentication algorithm.
		# proxy: # The name of the Zabbix Proxy to be used
		# host_groups: # List of host groups the host is part of.
		# inventory_zabbix: # Add Facts for a zabbix inventory (e.g. Tag) (see example below).
		# inventory_mode: automatic|manual|disabled
		# tls_psk_identity: # PSK value is a hard to guess string of hexadecimal digits.
		# tls_issuer: # Required certificate issuer.
		# http_login_password: # Basic Auth password
		# tls_psk: # The preshared key, at least 32 hex digits. Required if either tls_connect or tls_accept has PSK enabled.
		# ipmi_privilege: # IPMI privilege level.
		# tls_connect: 1
		# ipmi_password: # IPMI password.
		# visible_name: # Visible name of the host in Zabbix.
		# state: #present|absent
		# timeout: 10
		# tls_subject: # Required certificate subject.
		# validate_certs: true|false
		# link_templates: # List of templates linked to the host.
$0
endsnippet

snippet zabbix_hostmacro "Zabbix host macro creates/updates/deletes" b
- name: $1
	zabbix_hostmacro:
		macro_value: ${2:# Value of the host macro.}
		macro_name: ${3:# Name of the host macro.}
		login_user: ${4:# Zabbix user name.}
		server_url: ${5:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		host_name: ${6:# Name of the host.}
		login_password: ${7:# Zabbix user password.}
		# http_login_password: # Basic Auth password
		# http_login_user: # Basic Auth login
		# state: #present|absent
		# timeout: 10
		# force: #yes|no
		# validate_certs: true|false
$0
endsnippet

snippet zabbix_maintenance "Create Zabbix maintenance windows" b
- name: $1
	zabbix_maintenance:
		login_user: ${2:# Zabbix user name.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_password: ${4:# Zabbix user password.}
		desc: ${5:Created by Ansible}
		name: ${6:# Unique name of maintenance window.}
		# host_names: # Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.
		# host_groups: # Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.
		# collect_data: true
		# http_login_password: # Basic Auth password
		# validate_certs: true|false
		# http_login_user: # Basic Auth login
		# state: #present|absent
		# timeout: 10
		# minutes: 10
$0
endsnippet

snippet zabbix_proxy "Zabbix proxy creates/deletes/gets/updates" b
- name: $1
	zabbix_proxy:
		login_password: ${2:# Zabbix user password.}
		login_user: ${3:# Zabbix user name.}
		server_url: ${4:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		proxy_name: ${5:# Name of the proxy in Zabbix.}
		# status: #active|passive
		# http_login_password: # Basic Auth password
		# tls_psk: # The preshared key, at least 32 hex digits. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.
		# description: # Description of the proxy..
		# tls_connect: #no_encryption|PSK|certificate
		# tls_accept: #no_encryption|PSK|certificate
		# state: #present|absent
		# timeout: 10
		# tls_issuer: # Certificate issuer.
		# interface: {}
		# tls_subject: # Certificate subject.
		# validate_certs: true|false
		# tls_psk_identity: # PSK identity. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.
		# http_login_user: # Basic Auth login
$0
endsnippet

snippet zabbix_screen "Zabbix screen creates/updates/deletes" b
- name: $1
	zabbix_screen:
		login_user: ${2:# Zabbix user name.}
		server_url: ${3:# Url of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		screens: ${4:# List of screens to be created/updated/deleted(see example).}
		login_password: ${5:# Zabbix user password.}
		# http_login_password: # Basic Auth password
		# http_login_user: # Basic Auth login
		# timeout: 10
		# validate_certs: true|false
$0
endsnippet

snippet snmp_facts "Retrieve facts for a device using SNMP." b
- name: $1
	snmp_facts:
		host: ${2:# Set to target snmp server (normally {{inventory_hostname}})}
		version: ${3:v2|v2c|v3}
		# username: # Username for SNMPv3, required if version is v3
		# level: authPriv|authNoPriv
		# privacy: des|aes
		# community: # The SNMP community string, required if version is v2/v2c
		# authkey: # Authentication key, required if version is v3
		# integrity: md5|sha
		# privkey: # Encryption key, required if version is authPriv
$0
endsnippet

snippet ipinfoio_facts "Retrieve IP geolocation facts of a host's IP address" b
- name: $1
	ipinfoio_facts:
		# http_agent: ansible-ipinfoio-module/0.0.1
		# timeout: 10
$0
endsnippet

snippet ip_netns "Manage network namespaces" b
- name: $1
	ip_netns:
		# state: #present|absent
		# name: # Name of the namespace
$0
endsnippet

snippet cloudflare_dns "manage Cloudflare DNS records" b
- name: $1
	cloudflare_dns:
		account_email: ${2:# Account email.}
		account_api_token: ${3:# Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://www.cloudflare.com/a/account)
}
		zone: ${4:# The name of the Zone to work with (e.g. "example.com"). The Zone must already exist.}
		# solo: # Whether the record should be the only one for that record type and record name. Only use with C(state=present)
		# weight: 1
		# proxied: no
		# ttl: 1 (automatic)
		# port: # S
		# service: # R
		# proto: tcp|udp
		# value: # The record value. Required for C(state=present)
		# priority: 1
		# record: @
		# state: #present|absent
		# timeout: 30
		# type: A|AAAA|CNAME|TXT|SRV|MX|NS|SPF
$0
endsnippet

snippet haproxy "Enable, disable, and set weights for HAProxy backend servers using socket commands." b
- name: $1
	haproxy:
		state: ${2:enabled|disabled|drain}
		host: ${3:# Name of the backend host to change.}
		# drain: no
		# socket: /var/run/haproxy.sock
		# weight: # The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.
		# wait_interval: 5
		# backend: auto-detected
		# wait_retries: 25
		# fail_on_not_found: no
		# shutdown_sessions: no
		# wait: no
$0
endsnippet

snippet dnsimple "Interface with dnsimple.com (a DNS hosting service)." b
- name: $1
	dnsimple:
		# solo: # Whether the record should be the only one for that record type and record name. Only use with state=present on a record
		# domain: # Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned.
		# account_email: # Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_TOKEN will be looked for. If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started)

		# record_ids: # List of records to ensure they either exist or don't exist
		# value: # Record value
		# priority: # Record priority
		# record: # Record to add, if blank a record for the domain will be created, supports the wildcard (*)
		# state: present|absent
		# ttl: 3600 (one hour)
		# type: A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL
		# account_api_token: # Account API token. See I(account_email) for info.
$0
endsnippet

snippet omapi_host "Setup OMAPI hosts." b
- name: $1
	omapi_host:
		macaddr: ${2:# Sets the lease host MAC address.}
		key_name: ${3:# Sets the TSIG key name for authenticating against OMAPI server.}
		state: ${4:present|absent}
		key: ${5:# Sets the TSIG key content for authenticating against OMAPI server.}
		# statements: []
		# name: # Sets the host lease hostname (mandatory if state=present).
		# host: localhost
		# ddns: no
		# ip: # Sets the lease host IP address.
		# port: 7911
$0
endsnippet

snippet lldp "get details reported by lldp" b
- name: $1
	lldp:
$0
endsnippet

snippet nsupdate "Manage DNS records." b
- name: $1
	nsupdate:
		zone: ${2:# DNS record will be modified on this C(zone).}
		server: ${3:# Apply DNS modification on this server.}
		record: ${4:# Sets the DNS record to modify.}
		# key_algorithm: HMAC-MD5.SIG-ALG.REG.INT|#hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hamc-sha384|hmac-sha512
		# key_name: # Use TSIG key name to authenticate against DNS C(server)
		# value: # Sets the record value.
		# state: #present|absent
		# ttl: 3600
		# type: A
		# port: 53
		# key_secret: # Use TSIG key secret, associated with C(key_name), to authenticate against C(server)
$0
endsnippet

snippet ipify_facts "Retrieve the public IP of your internet gateway." b
- name: $1
	ipify_facts:
		# validate_certs: yes
		# api_url: https://api.ipify.org
		# timeout: 10
$0
endsnippet

snippet nmcli "Manage Networking" b
- name: $1
	nmcli:
		conn_name: ${2:# Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]}
		state: ${3:present|absent}
		# ingress: # This is only used with VLAN - VLAN ingress priority mapping
		# slavepriority: 32
		# path_cost: 100
		# vlandev: # This is only used with VLAN - parent device this VLAN is on, can use ifname
		# forwarddelay: 15
		# primary: # This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'
		# hairpin: yes
		# egress: # This is only used with VLAN - VLAN egress priority mapping
		# ageingtime: 300
		# dns4: # A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: "192.0.2.53 198.51.100.53"
		# dns4_search: # A list of DNS search domains.
		# arp_ip_target: # This is only used with bond - ARP IP target
		# dhcp_client_id: # DHCP Client Identifier sent to the DHCP server.
		# maxage: 20
		# vlanid: # This is only used with VLAN - VLAN ID in range <0-4095>
		# priority: 128
		# gw4: # The IPv4 gateway for this interface using this format ie: "192.0.2.1"
		# gw6: # The IPv6 gateway for this interface using this format ie: "2001:db8::1"
		# master: # master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.
		# stp: # This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge
		# ifname: conn_name
		# type: ethernet|team|team-slave|bond|bond-slave|bridge|bridge-slave|vlan|generic
		# miimon: 100
		# hellotime: 2
		# downdelay: # This is only used with bond - downdelay
		# mac: # This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)

		# ip6: # The IPv6 address to this interface using this format ie: "abbe::cafe"
		# ip4: # The IPv4 address to this interface using this format ie: "192.0.2.24/24"
		# autoconnect: yes
		# dns6_search: # A list of DNS search domains.
		# dns6: # A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: "2001:4860:4860::8888 2001:4860:4860::8844"
		# mtu: 1500
		# arp_interval: # This is only used with bond - ARP interval
		# flags: # This is only used with VLAN - flags
		# mode: balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb
		# updelay: # This is only used with bond - updelay
$0
endsnippet

snippet dnsmadeeasy "Interface with dnsmadeeasy.com (a DNS hosting service)." b
- name: $1
	dnsmadeeasy:
		domain: ${2:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution}
		protocol: ${3:TCP|UDP|#HTTP|DNS|SMTP|HTTPS}
		autoFailover: ${4:yes|#no}
		sensitivity: ${5:Low|#Medium|High}
		contactList: ${6:}
		account_key: ${7:# Account API Key.}
		port: ${8:80}
		monitor: ${9:yes|#no}
		failover: ${10:yes|#no}
		maxEmails: ${11:1}
		state: ${12:present|absent}
		systemDescription: ${13:}
		account_secret: ${14:# Account Secret Key.}
		# httpFqdn: # The fully qualified domain name used by the monitor.
		# record_ttl: 1800
		# ip2: # Secondary IP address for the failover.
		# record_type: A|AAAA|CNAME|ANAME|HTTPRED|MX|NS|PTR|SRV|TXT
		# ip1: # Primary IP address for the failover.
		# ip4: # Quaternary IP address for the failover.
		# ip5: # Quinary IP address for the failover.
		# record_name: # Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.
		# ip3: # Tertiary IP address for the failover.
		# httpQueryString: # The string in the httpFile that the monitor queries for HTTP or HTTPS.
		# record_value: # Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"

		# httpFile: # The file at the Fqdn that the monitor queries for HTTP or HTTPS.
		# validate_certs: #yes|no
$0
endsnippet

snippet slurp "Slurps a file from remote nodes" b
- name: $1
	slurp:
		src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory.}
$0
endsnippet

snippet uri "Interacts with webservices" b
- name: $1
	uri:
		url: ${2:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}
		# body: # The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.
		# dest: # path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.
		# follow_redirects: all|#safe|none
		# force_basic_auth: no
		# removes: # a filename, when it does not exist, this step will not be run.
		# user: # username for the module to use for Digest, Basic or WSSE authentication.
		# others: # all arguments accepted by the M(file) module also work here
		# body_format: #raw|json
		# password: # password for the module to use for Digest, Basic or WSSE authentication.
		# HEADER_: # Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and will be removed in Ansible-2.9. Use I(headers) instead.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If I(client_cert) contains both the certificate and key, this option is not required.
		# method: #GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH
		# creates: # a filename, when it already exists, this step will not be run.
		# headers: # Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) for I(body_format).
		# timeout: 30
		# status_code: 200
		# return_content: no
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, I(client_key) is not required
$0
endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node" b
- name: $1
	get_url:
		dest: ${2:# Absolute path of where to download the file to.}
		url: ${3:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		# backup: no
		# force: no
		# url_username: # The username for use in HTTP basic authentication.
		# selevel: s0
		# force_basic_auth: no
		# sha256sum: 
		# others: # all arguments accepted by the M(file) module also work here
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# url_password: # The password for use in HTTP basic authentication.
		# unsafe_writes: no
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# use_proxy: yes
		# checksum: 
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# headers: # Add custom HTTP headers to a request in the format "key:value,key:value".
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like C(0644) or C(01777)). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# timeout: 10
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# tmp_dest: # Absolute path of where temporary file is downloaded to.
$0
endsnippet

snippet exo_dns_domain "Manages domain records on Exoscale DNS API." b
- name: $1
	exo_dns_domain:
		name: ${2:# Name of the record.}
		# api_secret: # Secret key of the Exoscale DNS API.
		# api_timeout: 10
		# api_region: cloudstack
		# state: #present|absent
		# api_key: # API key of the Exoscale DNS API.
		# validate_certs: yes
$0
endsnippet

snippet exo_dns_record "Manages DNS records on Exoscale DNS." b
- name: $1
	exo_dns_record:
		domain: ${2:# Domain the record is related to.}
		# multiple: no
		# name: 
		# prio: # Priority of the record.
		# api_secret: # Secret key of the Exoscale DNS API.
		# api_timeout: 10
		# api_region: cloudstack
		# content: # Content of the record.
		# record_type: #A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL
		# state: #present|absent
		# ttl: 3600
		# api_key: # API key of the Exoscale DNS API.
		# validate_certs: yes
$0
endsnippet

snippet nios_dns_view "Configure Infoblox NIOS DNS views" b
- name: $1
	nios_dns_view:
		name: ${2:# Specifies the name of the DNS view to add and/or remove from the system configuration based on the setting of the C(state) argument.}
		network_view: ${3:default}
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_zone "Configure Infoblox NIOS DNS zones" b
- name: $1
	nios_zone:
		fqdn: ${2:# Specifies the qualified domain name to either add or remove from the NIOS instance based on the configured C(state) value.}
		view: ${3:default}
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
		# grid_primary: # Configures the grid primary servers for this zone.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# grid_secondaries: # Configures the grid secondary servers for this zone.
$0
endsnippet

snippet nios_network "Configure Infoblox NIOS network object" b
- name: $1
	nios_network:
		network: ${2:# Specifies the network to add or remove from the system.  The value should use CIDR notation.}
		network_view: ${3:default}
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# provider: # A dict object containing connection details.
		# options: # Configures the set of DHCP options to be included as part of the configured network instance.  This argument accepts a list of values (see suboptions).  When configuring suboptions at least one of C(name) or C(num) must be specified.
$0
endsnippet

snippet nios_host_record "Configure Infoblox NIOS host records" b
- name: $1
	nios_host_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# ipv6addrs: # Configures the IPv6 addresses for the host record.  This argument accepts a list of values (see options)
		# provider: # A dict object containing connection details.
		# state: #present|absent
		# ipv4addrs: # Configures the IPv4 addresses for this host record.  This argument accepts a list of values (see suboptions)
		# ttl: # Configures the TTL to be associated with this host record
$0
endsnippet

snippet nios_network_view "Configure Infoblox NIOS network views" b
- name: $1
	nios_network_view:
		name: ${2:# Specifies the name of the network view to either add or remove from the configuration.}
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
$0
endsnippet

snippet ldap_attr "Add or remove LDAP attribute values." b
- name: $1
	ldap_attr:
		dn: ${2:# The DN of the entry to modify.}
		name: ${3:# The name of the attribute to modify.}
		values: ${4:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}
		# server_uri: ldapi:///
		# start_tls: yes|#no
		# bind_dn: # A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.
		# state: #present|absent|exact
		# bind_pw: # The password to use with I(bind_dn).
		# validate_certs: #yes|no
$0
endsnippet

snippet ldap_entry "Add or remove LDAP entries." b
- name: $1
	ldap_entry:
		dn: ${2:# The DN of the entry to add or remove.}
		# objectClass: # If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.
		# start_tls: yes|#no
		# bind_dn: # A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.
		# server_uri: ldapi:///
		# state: #present|absent
		# params: # List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).
		# bind_pw: # The password to use with I(bind_dn).
		# attributes: # If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.
		# validate_certs: #yes|no
$0
endsnippet

snippet infinity "manage Infinity IPAM using Rest API" b
- name: $1
	infinity:
		username: ${2:# Username to access Infinity}
		server_ip: ${3:# Infinity server_ip with IP address}
		action: ${4:reserve_next_available_ip|release_ip|delete_network|add_network|reserve_network|release_network|get_network_id}
		password: ${5:# Infinity password}
		# network_size: 
		# network_location: -1
		# network_family: 4|6|dual
		# network_id: 
		# ip_address: 
		# network_address: 
		# network_name: 
		# network_type: #lan|shared_lan|supernet
$0
endsnippet

snippet rabbitmq_exchange "This module manages rabbitMQ exchanges" b
- name: $1
	rabbitmq_exchange:
		name: ${2:# Name of the exchange to create}
		# login_port: 15672
		# login_user: guest
		# login_host: localhost
		# durable: yes|no
		# exchange_type: fanout|#direct|headers|topic
		# vhost: /
		# state: #present|absent
		# internal: yes|no
		# arguments: {}
		# login_password: no
		# auto_delete: yes|no
$0
endsnippet

snippet rabbitmq_policy "Manage the state of policies in RabbitMQ." b
- name: $1
	rabbitmq_policy:
		name: ${2:# The name of the policy to manage.}
		tags: ${3:# A dict or string describing the policy.}
		pattern: ${4:# A regex of queues to apply the policy to.}
		# node: rabbit
		# priority: 0
		# vhost: /
		# state: #present|absent
		# apply_to: #all|exchanges|queues
$0
endsnippet

snippet rabbitmq_user "Adds or removes users to RabbitMQ" b
- name: $1
	rabbitmq_user:
		user: ${2:# Name of user to add}
		# node: rabbit
		# force: yes|#no
		# tags: # User tags specified as comma delimited
		# read_priv: ^$
		# write_priv: ^$
		# state: #present|absent
		# configure_priv: ^$
		# vhost: /
		# password: # Password of user to add.
		# permissions: []
$0
endsnippet

snippet rabbitmq_binding "This module manages rabbitMQ bindings" b
- name: $1
	rabbitmq_binding:
		name: ${2:# source exchange to create binding on}
		destination: ${3:# destination exchange or queue for the binding}
		destination_type: ${4:queue|exchange}
		# login_port: 15672
		# login_user: guest
		# login_host: localhost
		# routing_key: #
		# vhost: /
		# state: #present|absent
		# arguments: {}
		# login_password: no
$0
endsnippet

snippet rabbitmq_vhost "Manage the state of a virtual host in RabbitMQ" b
- name: $1
	rabbitmq_vhost:
		name: ${2:# The name of the vhost to manage}
		# node: rabbit
		# tracing: yes|#no
		# state: #present|absent
$0
endsnippet

snippet rabbitmq_queue "This module manages rabbitMQ queues" b
- name: $1
	rabbitmq_queue:
		name: ${2:# Name of the queue to create}
		# dead_letter_exchange: # Optional name of an exchange to which messages will be republished if they
		# max_priority: # Maximum number of priority levels for the queue to support.
		# login_user: guest
		# login_host: localhost
		# vhost: /
		# login_password: no
		# auto_expires: forever
		# login_port: 15672
		# durable: yes|no
		# state: #present|absent
		# max_length: no limit
		# arguments: {}
		# message_ttl: forever
		# dead_letter_routing_key: # Optional replacement routing key to use when a message is dead-lettered.
		# auto_delete: yes|no
$0
endsnippet

snippet rabbitmq_parameter "Adds or removes parameters to RabbitMQ" b
- name: $1
	rabbitmq_parameter:
		name: ${2:# Name of the parameter being set}
		component: ${3:# Name of the component of which the parameter is being set}
		# node: rabbit
		# vhost: /
		# state: #present|absent
		# value: # Value of the parameter, as a JSON term
$0
endsnippet

snippet rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# state: #enabled|disabled
		# new_only: no
		# prefix: # Specify a custom install prefix to a Rabbit.
$0
endsnippet

snippet git "Deploy software (or files) from git checkouts" b
- name: $1
	git:
		dest: ${2:# The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no).}
		repo: ${3:# git, SSH, or HTTP(S) protocol address of the git repository.}
		# force: yes|#no
		# track_submodules: yes|#no
		# reference: # Reference repository (see "git clone --reference ...")
		# accept_hostkey: yes|#no
		# clone: #yes|no
		# update: #yes|no
		# ssh_opts: # Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"
		# bare: yes|#no
		# verify_commit: yes|#no
		# archive: # Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats ["zip", "tar.gz", "tar", "tgz"]
		# recursive: #yes|no
		# executable: # Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# remote: origin
		# refspec: # Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".
		# umask: # The umask to set before doing any checkouts, or any other repository maintenance.
		# depth: # Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.
		# version: HEAD
		# key_file: # Specify an optional private key file to use for the checkout.
$0
endsnippet

snippet github_deploy_key "Manages deploy keys for GitHub repositories." b
- name: $1
	github_deploy_key:
		name: ${2:# The name for the deploy key.}
		repo: ${3:# The name of the GitHub repository.}
		owner: ${4:# The name of the individual account or organization that owns the GitHub repository.}
		key: ${5:# The SSH public key to add to the repository as a deploy key.}
		# read_only: yes
		# username: # The username to authenticate with.
		# force: no
		# state: #present|absent
		# token: # The OAuth2 token or personal access token to authenticate with. Mutually exclusive with I(password).
		# otp: # The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password).
		# password: # The password to authenticate with. A personal access token can be used here in place of a password.
$0
endsnippet

snippet github_issue "View GitHub issue." b
- name: $1
	github_issue:
		repo: ${2:none}
		organization: ${3:none}
		issue: ${4:none}
		# action: [u'get_status']
$0
endsnippet

snippet github_release "Interact with GitHub Releases" b
- name: $1
	github_release:
		repo: ${2:# Repository name}
		user: ${3:# The GitHub account that owns the repository}
		action: ${4:latest_release|create_release}
		# body: # Description of the release when creating a release
		# target: # Target of release when creating a release
		# token: # GitHub Personal Access Token for authenticating
		# tag: # Tag name when creating a release. Required when using action is set to C(create_release).
		# draft: True|False
		# prerelease: True|False
		# password: # The GitHub account password for the user
		# name: # Name of release when creating a release
$0
endsnippet

snippet bzr "Deploy software (or files) from bzr branches" b
- name: $1
	bzr:
		dest: ${2:# Absolute path of where the branch should be cloned to.}
		name: ${3:# SSH or HTTP protocol address of the parent branch.}
		# executable: # Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# version: head
		# force: no
$0
endsnippet

snippet git_config "Read and write git configuration" b
- name: $1
	git_config:
		# repo: # Path to a git repository for reading and writing values from a specific repo.
		# scope: local|global|system
		# list_all: yes|no
		# name: # The name of the setting. If no value is supplied, the value will be read from the config if it has been set.
		# value: # When specifying the name of a single setting, supply a value to set that setting to the given value.
$0
endsnippet

snippet gitlab_group "Creates/updates/deletes Gitlab Groups" b
- name: $1
	gitlab_group:
		name: ${2:# Name of the group you want to create.}
		server_url: ${3:# Url of Gitlab server, with protocol (http or https).}
		# login_user: # Gitlab user name.
		# login_token: # Gitlab token for logging in.
		# state: #present|absent
		# login_password: # Gitlab password for login_user
		# path: # The path of the group you want to create, this will be server_url/group_path
		# validate_certs: yes
$0
endsnippet

snippet github_key "Manage GitHub access keys." b
- name: $1
	github_key:
		token: ${2:# GitHub Access Token with permission to list and create public keys.}
		name: ${3:# SSH key name}
		# pubkey: none
		# force: #yes|no
		# state: #present|absent
$0
endsnippet

snippet gitlab_user "Creates/updates/deletes Gitlab Users" b
- name: $1
	gitlab_user:
		username: ${2:# The username of the user.}
		name: ${3:# Name of the user you want to create}
		server_url: ${4:# Url of Gitlab server, with protocol (http or https).}
		password: ${5:# The password of the user.}
		email: ${6:# The email that belongs to the user.}
		# group: # Add user as an member to this group.
		# sshkey_file: # The ssh key itself.
		# sshkey_name: # The name of the sshkey
		# login_user: # Gitlab user name.
		# login_token: # Gitlab token for logging in.
		# confirm: yes
		# access_level: # The access level to the group. One of the following can be used.
		# state: #present|absent
		# login_password: # Gitlab password for login_user
		# validate_certs: yes
$0
endsnippet

snippet hg "Manages Mercurial (hg) repositories" b
- name: $1
	hg:
		repo: ${2:# The repository address.}
		dest: ${3:# Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no}
		# executable: # Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# force: no
		# clone: yes
		# update: yes
		# purge: no
		# revision: # Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.
$0
endsnippet

snippet subversion "Deploys a subversion repository" b
- name: $1
	subversion:
		dest: ${2:# Absolute path where the repository should be deployed.}
		repo: ${3:# The subversion URL to the repository.}
		# username: # C(--username) parameter passed to svn.
		# executable: # Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# force: no
		# update: yes
		# switch: yes
		# export: no
		# password: # C(--password) parameter passed to svn.
		# checkout: yes
		# revision: HEAD
$0
endsnippet

snippet github_hooks "Manages GitHub service hooks." b
- name: $1
	github_hooks:
		repo: ${2:# This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.
}
		oauthkey: ${3:# The oauth key provided by GitHub. It can be found/generated on GitHub under "Edit Your Profile" >> "Developer settings" >> "Personal Access Tokens"}
		user: ${4:# Github username.}
		action: ${5:create|cleanall|list|clean504}
		# content_type: #json|form
		# validate_certs: #yes|no
		# hookurl: # When creating a new hook, this is the url that you want GitHub to post to. It is only required when creating a new hook.
$0
endsnippet

snippet gitlab_project "Creates/updates/deletes Gitlab Projects" b
- name: $1
	gitlab_project:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# The name of the project}
		# merge_requests_enabled: yes
		# import_url: no
		# login_user: # Gitlab user name.
		# login_password: # Gitlab password for login_user
		# group: # The name of the group of which this projects belongs to.
		# wiki_enabled: yes
		# visibility_level: 0
		# description: # An description for the project.
		# snippets_enabled: yes
		# login_token: # Gitlab token for logging in.
		# state: #present|absent
		# issues_enabled: yes
		# path: # The path of the project you want to create, this will be server_url/<group>/path
		# validate_certs: yes
		# public: no
$0
endsnippet

