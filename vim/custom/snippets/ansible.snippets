priority 50

# THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DON'T MODIFY BY HAND

snippet play "Execute an Ansible play" b
- name: ${1:name}
	hosts: ${2:host_group}
	become: ${3:true}
	tasks:
		$0
endsnippet

snippet when "Conditionally execute play" b
when:
	- ansible_os_family == "RedHat"
	- foo is defined
endsnippet

snippet with_items "Loop over items" b
with_items:
	- $1
	- $2
	- $0
endsnippet

snippet block "Example block task" b
- name: Install Apache
	block:
		- yum: name={{ item }} state=installed
			with_items:
				- httpd
				- memcached
		- template: src=templates/src.j2 dest=/etc/foo.conf
		- service: name=bar state=started enabled=True
	when: ansible_distribution == 'CentOS'
	become: true
	become_user: root
$0
endsnippet

snippet bundler "Manage Ruby Gem dependencies with Bundler" b
- name: $1
	bundler:
		# executable: # The path to the bundler executable
		# state: #present|latest
		# chdir: temporary working directory
		# exclude_groups: # A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set
		# clean: no
		# gemfile: Gemfile in current directory
		# local: no
		# deployment_mode: no
		# user_install: yes
		# gem_path: RubyGems gem paths
		# binstub_directory: # Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)
		# extra_args: # A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information
$0
endsnippet

snippet easy_install "Installs Python libraries" b
- name: $1
	easy_install:
		name: ${2:# A Python library name}
		# virtualenv: # an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically
		# virtualenv_site_packages: no
		# virtualenv_command: virtualenv
		# executable: # The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.
		# state: #present|latest
$0
endsnippet

snippet composer "Dependency Manager for PHP" b
- name: $1
	composer:
		# command: install
		# arguments: # Composer arguments like required package, version and so on.
		# executable: # Path to PHP Executable on the remote host, if PHP is not in PATH.
		# working_dir: # Directory of your project (see --working-dir). This is required when the command is not run globally.
		# global_command: no
		# prefer_source: no
		# prefer_dist: no
		# no_dev: yes
		# no_scripts: no
		# no_plugins: no
		# optimize_autoloader: yes
		# classmap_authoritative: no
		# apcu_autoloader: no
		# ignore_platform_reqs: no
$0
endsnippet

snippet maven_artifact "Downloads an Artifact from a Maven Repository" b
- name: $1
	maven_artifact:
		group_id: ${2:# The Maven groupId coordinate}
		artifact_id: ${3:# The maven artifactId coordinate}
		dest: ${4:# The path where the artifact should be written to}
		# version: latest
		# classifier: # The maven classifier coordinate
		# extension: jar
		# repository_url: http://repo1.maven.org/maven2
		# username: # The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3
		# password: # The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3
		# state: #present|absent
		# timeout: 10
		# validate_certs: yes
		# keep_name: no
		# verify_checksum: never|#download|change|always
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet npm "Manage node.js packages with npm" b
- name: $1
	npm:
		# name: # The name of a node.js library to install
		# path: # The base path where to install the node.js libraries
		# version: # The version to be installed
		# global: no
		# executable: # The executable location for npm.
		# ignore_scripts: no
		# production: no
		# registry: # The registry to install modules from.
		# state: #present|absent|latest
$0
endsnippet

snippet yarn "Manage node.js packages with Yarn" b
- name: $1
	yarn:
		# name: # The name of a node.js library to install
		# path: # The base path where Node.js libraries will be installed.
		# version: # The version of the library to be installed.
		# global: no
		# executable: # The executable location for yarn.
		# ignore_scripts: no
		# production: no
		# registry: # The registry to install modules from.
		# state: #present|absent|latest
$0
endsnippet

snippet bower "Manage bower packages with bower" b
- name: $1
	bower:
		path: ${2:# The base path where to install the bower packages}
		# name: # The name of a bower package to install
		# offline: no
		# production: no
		# relative_execpath: # Relative path to bower executable from install path
		# state: #present|absent|latest
		# version: # The version to be installed
$0
endsnippet

snippet pear "Manage pear/pecl packages" b
- name: $1
	pear:
		name: ${2:# Name of the package to install, upgrade, or remove.}
		# state: #present|absent|latest
		# executable: # Path to the pear executable
$0
endsnippet

snippet cpanm "Manages Perl library dependencies." b
- name: $1
	cpanm:
		# name: # The name of the Perl library to install. You may use the "full distribution path", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz
		# from_path: # The local directory from where to install
		# notest: no
		# locallib: no
		# mirror: no
		# mirror_only: no
		# installdeps: no
		# version: no
		# system_lib: no
		# executable: # Override the path to the cpanm executable
$0
endsnippet

snippet pip "Manages Python library dependencies" b
- name: $1
	pip:
		# name: # The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.
		# version: # The version number to install of the Python library specified in the I(name) parameter.
		# requirements: # The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.
		# virtualenv: # An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.
		# virtualenv_site_packages: no
		# virtualenv_command: virtualenv
		# virtualenv_python: # The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.
		# state: absent|forcereinstall|latest|#present
		# extra_args: # Extra arguments passed to pip.
		# editable: no
		# chdir: # cd into this directory before running the command
		# executable: # The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.
		# umask: # The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., "0077") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., "0022").
$0
endsnippet

snippet gem "Manage Ruby gems" b
- name: $1
	gem:
		name: ${2:# The name of the gem to be managed.}
		# state: #present|absent|latest
		# gem_source: # The path to a local gem used as installation source.
		# include_dependencies: yes
		# repository: # The repository from which the gem will be installed
		# user_install: yes
		# executable: # Override the path to the gem executable
		# install_dir: # Install the gems into a specific directory. These gems will be independant from the global installed ones. Specifying this requires user_install to be false.
		# env_shebang: no
		# version: # Version of the gem to be installed/removed.
		# pre_release: no
		# include_doc: no
		# build_flags: # Allow adding build flags for gem compilation
$0
endsnippet

snippet package "Generic OS package manager" b
- name: $1
	package:
		name: ${2:# Package name, or package specifier with version, like C(name-1.0).}
		state: ${3:# Whether to install (C(present)), or remove (C(absent)) a package. Other states depend on the underlying package module, i.e C(latest).}
		# use: auto
$0
endsnippet

snippet xbps "Manage packages with XBPS" b
- name: $1
	xbps:
		# name: # Name of the package to install, upgrade, or remove.
		# state: #present|absent|latest
		# recurse: no
		# update_cache: yes
		# upgrade: no
$0
endsnippet

snippet pkgutil "Manage CSW-Packages on Solaris" b
- name: $1
	pkgutil:
		name: ${2:# Package name, e.g. (C(CSWnrpe))}
		state: ${3:present|absent|latest}
		# site: # Specifies the repository path to install the package from.
		# update_catalog: no
$0
endsnippet

snippet pacman "Manage packages with I(pacman)" b
- name: $1
	pacman:
		# name: # Name or list of names of the packages to install, upgrade, or remove.
		# state: absent|latest|#present
		# recurse: no
		# force: no
		# update_cache: no
		# upgrade: no
$0
endsnippet

snippet pulp_repo "Add or remove Pulp repos from a remote host." b
- name: $1
	pulp_repo:
		name: ${2:# Name of the repo to add or remove. This correlates to repo-id in Pulp.}
		relative_url: ${3:# Relative URL for the local repository.}
		# add_export_distributor: no
		# feed: # Upstream feed URL to receive updates from.
		# force_basic_auth: no
		# importer_ssl_ca_cert: # CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file.
		# importer_ssl_client_cert: # Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.
		# importer_ssl_client_key: # Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.
		# proxy_host: # Proxy url setting for the pulp repository importer. This is in the format scheme://host.
		# proxy_port: # Proxy port setting for the pulp repository importer.
		# publish_distributor: # Distributor to use when state is C(publish). The default is to publish all distributors.
		# pulp_host: http://127.0.0.1
		# repo_type: rpm
		# serve_http: no
		# serve_https: yes
		# state: #present|absent|sync|publish
		# url_password: # The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used.
		# url_username: # The username for use in HTTP basic authentication to the pulp API.
		# validate_certs: yes
		# wait_for_completion: no
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet pkgng "Package manager for FreeBSD >= 9.0" b
- name: $1
	pkgng:
		name: ${2:# Name or list of names of packages to install/remove.}
		# state: #present|latest|absent
		# cached: no
		# annotation: # A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.
		# pkgsite: # For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).
		# rootdir: # For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.
		# chroot: # Pkg will chroot in the specified environment.
		# jail: # Pkg will execute in the given jail name or id.
		# autoremove: no
$0
endsnippet

snippet zypper "Manage packages on SUSE and openSUSE" b
- name: $1
	zypper:
		name: ${2:# Package name C(name) or package specifier or a list of either.}
		# state: #present|latest|absent|dist-upgrade
		# type: #package|patch|pattern|product|srcpackage|application
		# extra_args_precommand: # Add additional global target options to C(zypper).
		# disable_gpg_check: no
		# disable_recommends: yes
		# force: no
		# update_cache: no
		# oldpackage: no
		# extra_args: # Add additional options to C(zypper) command.
$0
endsnippet

snippet apt_repository "Add and remove APT repositories" b
- name: $1
	apt_repository:
		repo: ${2:# A source string for the repository.}
		# state: absent|#present
		# mode: 0644
		# update_cache: yes
		# validate_certs: yes
		# filename: # Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.
		# codename: # Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)
$0
endsnippet

snippet swdepot "Manage packages with swdepot package manager (HP-UX)" b
- name: $1
	swdepot:
		name: ${2:# package name.}
		state: ${3:present|latest|absent}
		# depot: # The source repository from which install or upgrade a package.
$0
endsnippet

snippet flatpak_remote "Manage flatpak repository remotes" b
- name: $1
	flatpak_remote:
		name: ${2:# The desired name for the flatpak remote to be registered under on the managed host.}
		# executable: flatpak
		# flatpakrepo_url: # The URL to the I(flatpakrepo) file representing the repository remote to add.
		# method: #system|user
		# state: absent|#present
$0
endsnippet

snippet yum_repository "Add or remove YUM repositories" b
- name: $1
	yum_repository:
		name: ${2:# Unique repository ID. This option builds the section name of the repository in the repo file.}
		# async: yes
		# bandwidth: 0
		# baseurl: # URL to the directory where the yum repository's 'repodata' directory lives.
		# cost: 1000
		# deltarpm_metadata_percentage: 100
		# deltarpm_percentage: 75
		# description: # A human readable string describing the repository. This option corresponds to the "name" property in the repo file.
		# enabled: yes
		# enablegroups: yes
		# exclude: # List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.
		# failovermethod: #roundrobin|priority
		# file: # File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name).
		# gpgcakey: # A URL pointing to the ASCII-armored CA key file for the repository.
		# gpgcheck: # Tells yum whether or not it should perform a GPG signature check on packages.
		# gpgkey: # A URL pointing to the ASCII-armored GPG key file for the repository.
		# http_caching: #all|packages|none
		# include: # Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.
		# includepkgs: # List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.
		# ip_resolve: 4|6|IPv4|IPv6|#whatever
		# keepalive: no
		# keepcache: 0|#1
		# metadata_expire: 21600
		# metadata_expire_filter: never|read-only:past|#read-only:present|read-only:future
		# metalink: # Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).
		# mirrorlist: # Specifies a URL to a file containing a list of baseurls.
		# mirrorlist_expire: 21600
		# password: # Password to use with the username for basic authentication.
		# priority: 99
		# protect: no
		# proxy: # URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.
		# proxy_password: # Username to use for proxy.
		# proxy_username: # Password for this proxy.
		# repo_gpgcheck: no
		# reposdir: /etc/yum.repos.d
		# retries: 10
		# s3_enabled: no
		# skip_if_unavailable: no
		# ssl_check_cert_permissions: no
		# sslcacert: # Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.
		# sslclientcert: # Path to the SSL client certificate yum should use to connect to repos/remote sites.
		# sslclientkey: # Path to the SSL client key yum should use to connect to repos/remote sites.
		# sslverify: yes
		# state: absent|#present
		# throttle: # Enable bandwidth throttling for downloads.
		# timeout: 30
		# ui_repoid_vars: releasever basearch
		# username: # Username to use for basic authentication to a repo or really any url.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet package_facts "package information as facts" b
- name: $1
	package_facts:
		# manager: #auto|rpm|apt
$0
endsnippet

snippet layman "Manage Gentoo overlays" b
- name: $1
	layman:
		name: ${2:# The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated)).}
		# list_url: # An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration.
		# state: #present|absent|updated
		# validate_certs: yes
$0
endsnippet

snippet portage "Package manager for Gentoo" b
- name: $1
	portage:
		# package: # Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)
		# state: #present|installed|emerged|absent|removed|unmerged|latest
		# update: no
		# deep: no
		# newuse: no
		# changed_use: no
		# oneshot: no
		# noreplace: no
		# nodeps: no
		# onlydeps: no
		# depclean: no
		# quiet: no
		# verbose: no
		# sync: web|yes|no
		# getbinpkg: no
		# usepkgonly: no
		# keepgoing: no
		# jobs: # Specifies the number of packages to build simultaneously.
		# loadavg: # Specifies that no new builds should be started if there are
		# quietbuild: no
		# quietfail: no
$0
endsnippet

snippet apk "Manages apk packages" b
- name: $1
	apk:
		# available: no
		# name: # A package name, like C(foo), or multiple packages, like C(foo, bar).
		# repository: # A package repository or multiple repositories. Unlike with the underlying apk command, this list will override the system repositories rather than supplement them.
		# state: #present|absent|latest
		# update_cache: no
		# upgrade: no
$0
endsnippet

snippet homebrew "Package manager for Homebrew" b
- name: $1
	homebrew:
		# name: # list of names of packages to install/remove
		# path: /usr/local/bin
		# state: head|latest|#present|absent|linked|unlinked
		# update_homebrew: no
		# upgrade_all: no
		# install_options: # options flags to install a package
$0
endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command" b
- name: $1
	redhat_subscription:
		# state: #present|absent
		# username: # access.redhat.com or Sat6  username
		# password: # access.redhat.com or Sat6 password
		# server_hostname: # Specify an alternative Red Hat Subscription Management or Sat6 server
		# server_insecure: # Enable or disable https server certificate verification when connecting to C(server_hostname)
		# rhsm_baseurl: # Specify CDN baseurl
		# rhsm_repo_ca_cert: # Specify an alternative location for a CA certificate for CDN
		# server_proxy_hostname: # Specify a HTTP proxy hostname
		# server_proxy_port: # Specify a HTTP proxy port
		# server_proxy_user: # Specify a user for HTTP proxy with basic authentication
		# server_proxy_password: # Specify a password for HTTP proxy with basic authentication
		# auto_attach: no
		# activationkey: # supply an activation key for use with registration
		# org_id: # Organization ID to use in conjunction with activationkey
		# environment: # Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello
		# pool: ^$
		# pool_ids: []
		# consumer_type: # The type of unit to register, defaults to system
		# consumer_name: # Name of the system to register, defaults to the hostname
		# consumer_id: # References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.

		# force_register: no
$0
endsnippet

snippet openbsd_pkg "Manage packages on OpenBSD" b
- name: $1
	openbsd_pkg:
		name: ${2:# A name or a list of names of the packages.}
		# state: absent|latest|#present
		# build: no
		# ports_dir: /usr/ports
		# clean: no
		# quick: no
$0
endsnippet

snippet zypper_repository "Add and remove Zypper repositories" b
- name: $1
	zypper_repository:
		# name: # A name for the repository. Not required when adding repofiles.
		# repo: # URI of the repository or .repo file. Required when state=present.
		# state: absent|#present
		# description: # A description of the repository
		# disable_gpg_check: no
		# autorefresh: yes
		# priority: # Set priority of repository. Packages will always be installed from the repository with the smallest priority number.
		# overwrite_multiple: no
		# auto_import_keys: no
		# runrefresh: no
		# enabled: yes
$0
endsnippet

snippet urpmi "Urpmi manager" b
- name: $1
	urpmi:
		name: ${2:# A list of package names to install, upgrade or remove.}
		# state: absent|#present
		# update_cache: no
		# no-recommends: yes
		# force: yes
		# root: /
$0
endsnippet

snippet apt_key "Add or remove an apt key" b
- name: $1
	apt_key:
		# id: # The identifier of the key.
		# data: # The keyfile contents to add to the keyring.
		# file: # The path to a keyfile on the remote server to add to the keyring.
		# keyring: # The full path to specific keyring file in /etc/apt/trusted.gpg.d/
		# url: # The URL to retrieve key from.
		# keyserver: # The keyserver to retrieve key from.
		# state: absent|#present
		# validate_certs: yes
$0
endsnippet

snippet swupd "Manages updates and bundles in ClearLinux systems." b
- name: $1
	swupd:
		# contenturl: # URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.
		# format: # The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.
		# manifest: # The manifest contains information about the bundles at certaion version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.
		# name: # Name of the (I)bundle to install or remove.
		# state: #present|absent
		# update: # Updates the OS to the latest version.
		# url: # Overrides both I(contenturl) and I(versionurl).
		# verify: # Verify content for OS version.
		# versionurl: # URL for version string download.
$0
endsnippet

snippet homebrew_tap "Tap a Homebrew repository." b
- name: $1
	homebrew_tap:
		name: ${2:# The GitHub user/organization repository to tap.}
		# url: # The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.
		# state: #present|absent
$0
endsnippet

snippet yum "Manages packages with the I(yum) package manager" b
- name: $1
	yum:
		# use_backend: #auto|yum|yum4|dnf
		# name: # A package name or package specifier with version, like C(name-1.0).
		# exclude: # Package name(s) to exclude when state=present, or latest
		# list: # Package name to run the equivalent of yum list <package> against. In addition to listing packages, use can also list the following: C(installed), C(updates), C(available) and C(repos).
		# state: absent|installed|latest|present|removed
		# enablerepo: # I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(",").
		# disablerepo: # I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(",").
		# conf_file: # The remote yum configuration file to use for the transaction.
		# disable_gpg_check: no
		# skip_broken: no
		# update_cache: no
		# validate_certs: yes
		# update_only: no
		# installroot: /
		# security: no
		# bugfix: no
		# allow_downgrade: no
		# enable_plugin: # I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.
		# disable_plugin: # I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.
		# releasever: # Specifies an alternative release from which all packages will be installed.
		# autoremove: no
		# disable_excludes: # Disable the excludes defined in YUM config files.
		# download_only: no
$0
endsnippet

snippet dnf "Manages packages with the I(dnf) package manager" b
- name: $1
	dnf:
		name: ${2:# A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.}
		# list: # Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.
		# state: absent|present|installed|removed|latest
		# enablerepo: # I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# disablerepo: # I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
		# conf_file: # The remote dnf configuration file to use for the transaction.
		# disable_gpg_check: no
		# installroot: /
		# releasever: # Specifies an alternative release from which all packages will be installed.
		# autoremove: no
		# exclude: # Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string.
		# skip_broken: no
		# update_cache: no
		# update_only: no
		# security: no
		# bugfix: no
		# enable_plugin: # I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.
		# disable_plugin: # I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.
		# disable_excludes: # Disable the excludes defined in DNF config files.
		# validate_certs: yes
		# allow_downgrade: no
		# install_repoquery: yes
		# download_only: no
$0
endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels" b
- name: $1
	rhn_channel:
		name: ${2:# Name of the software channel.}
		sysname: ${3:# Name of the system as it is known in RHN/Satellite.}
		url: ${4:# The full URL to the RHN/Satellite API.}
		user: ${5:# RHN/Satellite login.}
		password: ${6:# RHN/Satellite password.}
		# state: present
$0
endsnippet

snippet pkgin "Package manager for SmartOS, NetBSD, et al." b
- name: $1
	pkgin:
		# name: # Name of package to install/remove;
		# state: #present|absent
		# update_cache: no
		# upgrade: no
		# full_upgrade: no
		# clean: no
		# force: no
$0
endsnippet

snippet svr4pkg "Manage Solaris SVR4 packages" b
- name: $1
	svr4pkg:
		name: ${2:# Package name, e.g. C(SUNWcsr)}
		state: ${3:present|absent}
		# src: # Specifies the location to install the package from. Required when C(state=present).
		# proxy: # HTTP[s] proxy to be used if C(src) is a URL.
		# response_file: # Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)
		# zone: current|#all
		# category: # Install/Remove category instead of a single package.
$0
endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks." b
- name: $1
	homebrew_cask:
		name: ${2:# name of cask to install/remove}
		# path: /usr/local/bin
		# state: #present|absent|upgraded
		# update_homebrew: no
		# install_options: # options flags to install a package
		# accept_external_apps: no
		# upgrade_all: no
		# upgrade: no
		# greedy: no
$0
endsnippet

snippet sorcery "Package manager for Source Mage GNU/Linux" b
- name: $1
	sorcery:
		# name: # Name of the spell
		# state: #present|latest|absent|cast|dispelled|rebuild
		# depends: # Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)
		# update: no
		# update_cache: no
		# cache_valid_time: # Time in seconds to invalidate grimoire collection on update
$0
endsnippet

snippet slackpkg "Package manager for Slackware >= 12.2" b
- name: $1
	slackpkg:
		name: ${2:# name of package to install/remove}
		# state: #present|absent|latest
		# update_cache: no
$0
endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db" b
- name: $1
	rpm_key:
		key: ${2:# Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.}
		# state: absent|#present
		# validate_certs: yes
$0
endsnippet

snippet apt "Manages apt-packages" b
- name: $1
	apt:
		# name: # A list of package names, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.
		# state: absent|build-dep|latest|#present
		# update_cache: no
		# cache_valid_time: 0
		# purge: no
		# default_release: # Corresponds to the C(-t) option for I(apt) and sets pin priorities
		# install_recommends: # Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.
		# force: no
		# allow_unauthenticated: no
		# upgrade: dist|full|#no|safe|yes
		# dpkg_options: force-confdef,force-confold
		# deb: # Path to a .deb package on the remote machine.
		# autoremove: no
		# autoclean: no
		# only_upgrade: no
		# force_apt_get: no
$0
endsnippet

snippet flatpak "Manage flatpaks" b
- name: $1
	flatpak:
		name: ${2:# The name of the flatpak to manage.}
		# executable: flatpak
		# method: #system|user
		# remote: flathub
		# state: absent|#present
$0
endsnippet

snippet portinstall "Installing packages from FreeBSD's ports system" b
- name: $1
	portinstall:
		name: ${2:# name of package to install/remove}
		# state: #present|absent
		# use_packages: yes
$0
endsnippet

snippet rhsm_repository "Manage RHSM repositories using the subscription-manager command" b
- name: $1
	rhsm_repository:
		state: ${2:#present|enabled|absent|disabled}
		name: ${3:# The ID of repositories to enable.}
$0
endsnippet

snippet pkg5 "Manages packages with the Solaris 11 Image Packaging System" b
- name: $1
	pkg5:
		name: ${2:# An FRMI of the package(s) to be installed/removed/updated.}
		# state: absent|latest|#present
		# accept_licenses: no
$0
endsnippet

snippet opkg "Package manager for OpenWrt" b
- name: $1
	opkg:
		name: ${2:# name of package to install/remove}
		# state: #present|absent
		# force: |depends|maintainer|reinstall|overwrite|downgrade|space|postinstall|remove|checksum|removal-of-dependent-packages
		# update_cache: no
$0
endsnippet

snippet pkg5_publisher "Manages Solaris 11 Image Packaging System publishers" b
- name: $1
	pkg5_publisher:
		name: ${2:# The publisher's name.}
		# state: #present|absent
		# sticky: # Packages installed from a sticky repository can only receive updates from that repository.
		# enabled: # Is the repository enabled or disabled?
		# origin: # A path or URL to the repository.
		# mirror: # A path or URL to the repository mirror.
$0
endsnippet

snippet dpkg_selections "Dpkg package selection selections" b
- name: $1
	dpkg_selections:
		name: ${2:# Name of the package}
		selection: ${3:install|hold|deinstall|purge}
$0
endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command" b
- name: $1
	rhn_register:
		# state: #present|absent
		# username: # Red Hat Network username
		# password: # Red Hat Network password
		# server_url: Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default
		# activationkey: # supply an activation key for use with registration
		# profilename: # supply an profilename for use with registration
		# sslcacert: # supply a custom ssl CA certificate file for use with registration
		# systemorgid: # supply an organizational id for use with registration
		# channels: []
		# enable_eus: no
		# nopackages: no
$0
endsnippet

snippet apt_rpm "apt_rpm package manager" b
- name: $1
	apt_rpm:
		pkg: ${2:# name of package to install, upgrade or remove.}
		# state: absent|#present
		# update_cache: no
$0
endsnippet

snippet macports "Package manager for MacPorts" b
- name: $1
	macports:
		name: ${2:# A list of port names.}
		# state: #present|absent|active|inactive
		# update_ports: no
		# variant: # A port variant specification.
$0
endsnippet

snippet kibana_plugin "Manage Kibana plugins" b
- name: $1
	kibana_plugin:
		name: ${2:# Name of the plugin to install}
		# state: #present|absent
		# url: # Set exact URL to download the plugin from. For local file, prefix its absolute path with file://
		# timeout: 1m
		# plugin_bin: /opt/kibana/bin/kibana
		# plugin_dir: /opt/kibana/installedPlugins/
		# version: # Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes
		# force: no
$0
endsnippet

snippet elasticsearch_plugin "Manage Elasticsearch plugins" b
- name: $1
	elasticsearch_plugin:
		name: ${2:# Name of the plugin to install.}
		# state: #present|absent
		# src: # Optionally set the source location to retrieve the plugin from. This can be a file:// URL to install from a local file, or a remote URL. If this is not set, the plugin location is just based on the name.
		# url: # Set exact URL to download the plugin from (Only works for ES 1.x).
		# timeout: 1m
		# force: no
		# plugin_bin: # Location of the plugin binary. If this file is not found, the default plugin binaries will be used.
		# plugin_dir: /usr/share/elasticsearch/plugins/
		# proxy_host: # Proxy host to use during plugin installation
		# proxy_port: # Proxy port to use during plugin installation
		# version: # Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated
$0
endsnippet

snippet riak "This module handles some common Riak operations" b
- name: $1
	riak:
		# command: ping|kv_test|join|plan|commit
		# config_dir: /etc/riak
		# http_conn: 127.0.0.1:8098
		# target_node: riak@127.0.0.1
		# wait_for_handoffs: # Number of seconds to wait for handoffs to complete.
		# wait_for_ring: # Number of seconds to wait for all nodes to agree on the ring.
		# wait_for_service: kv
		# validate_certs: yes
$0
endsnippet

snippet redis "Various redis commands, slave and flush" b
- name: $1
	redis:
		command: ${2:config|flush|slave}
		# login_password: # The password used to authenticate with (usually not used)
		# login_host: localhost
		# login_port: 6379
		# master_host: # The host of the master instance [slave command]
		# master_port: # The port of the master instance [slave command]
		# slave_mode: master|#slave
		# db: # The database to flush (used in db mode) [flush command]
		# flush_mode: #all|db
		# name: # A redis config key.
		# value: # A redis config value.
$0
endsnippet

snippet postgresql_user "Adds or removes a users (roles) from a PostgreSQL database." b
- name: $1
	postgresql_user:
		name: ${2:# Name of the user (role) to add or remove.}
		# password: # Set the user's password, before 1.4 this was required.
		# db: # Name of database where permissions will be granted.
		# fail_on_user: yes
		# port: 5432
		# login_user: postgres
		# login_password: # Password used to authenticate with PostgreSQL.
		# login_host: localhost
		# login_unix_socket: # Path to a Unix domain socket for local connections.
		# priv: # PostgreSQL privileges string in the format: C(table:priv1,priv2).
		# role_attr_flags: [NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION|[NO]BYPASSRLS
		# state: #present|absent
		# encrypted: yes
		# expires: # The date at which the user's password is to expire.
		# no_password_changes: no
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.
		# conn_limit: # Specifies the user connection limit.
$0
endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database." b
- name: $1
	postgresql_lang:
		lang: ${2:# name of the procedural language to add, remove or change}
		# trust: no
		# db: # name of database where the language will be added, removed or changed
		# force_trust: no
		# fail_on_drop: yes
		# cascade: no
		# port: 5432
		# login_user: postgres
		# login_password: # Password used to authenticate with PostgreSQL (must match C(login_user))
		# login_host: localhost
		# state: #present|absent
$0
endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects." b
- name: $1
	postgresql_privs:
		database: ${2:# Name of database to connect to.}
		roles: ${3:# Comma separated list of role (user/group) names to set permissions for.}
		# state: #present|absent
		# privs: # Comma separated list of privileges to grant/revoke.
		# type: #table|sequence|function|database|schema|language|tablespace|group|default_privs
		# objs: # Comma separated list of database objects to set privileges on.
		# schema: # Schema that contains the database objects specified via I(objs).
		# grant_option: # Whether C(role) may grant/revoke the specified privileges/group memberships to others.
		# host: # Database host address. If unspecified, connect via Unix socket.
		# port: 5432
		# unix_socket: # Path to a Unix domain socket for local connections.
		# login: postgres
		# password: # The password to authenticate with.
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.
		# login_user: postgres
		# login_password: # The password used to authenticate with
		# login_host: # Host running the database
		# login_unix_socket: # Path to a Unix domain socket for local connections
$0
endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema from a remote host" b
- name: $1
	postgresql_schema:
		name: ${2:# Name of the schema to add or remove.}
		# database: postgres
		# login_user: # The username used to authenticate with.
		# login_password: # The password used to authenticate with.
		# login_host: localhost
		# login_unix_socket: # Path to a Unix domain socket for local connections.
		# owner: # Name of the role to set as owner of the schema.
		# port: 5432
		# state: #present|absent
$0
endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database." b
- name: $1
	postgresql_ext:
		name: ${2:# name of the extension to add or remove}
		db: ${3:# name of the database to add or remove the extension to/from}
		# login_user: # The username used to authenticate with
		# login_password: # The password used to authenticate with
		# login_host: localhost
		# port: 5432
		# state: #present|absent
$0
endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host." b
- name: $1
	postgresql_db:
		name: ${2:# name of the database to add or remove}
		# owner: # Name of the role to set as owner of the database
		# template: # Template used to create the database
		# encoding: # Encoding of the database
		# lc_collate: # Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.
		# lc_ctype: # Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.
		# state: #present|absent|dump|restore
		# target: # File to back up or restore from. Used when state is "dump" or "restore"
		# target_opts: # Further arguments for pg_dump or pg_restore. Used when state is "dump" or "restore"
		# maintenance_db: postgres
		# login_user: postgres
		# login_password: # The password used to authenticate with
		# login_host: # Host running the database
		# login_unix_socket: # Path to a Unix domain socket for local connections
		# port: 5432
		# ssl_mode: disable|allow|#prefer|require|verify-ca|verify-full
		# ssl_rootcert: # Specifies the name of a file containing SSL certificate authority (CA) certificate(s).
$0
endsnippet

snippet mongodb_user "Adds or removes a user from a MongoDB database." b
- name: $1
	mongodb_user:
		database: ${2:# The name of the database to add/remove the user from}
		name: ${3:# The name of the user to add or remove}
		# login_user: # The username used to authenticate with
		# login_password: # The password used to authenticate with
		# login_host: localhost
		# login_port: 27017
		# login_database: # The database where login credentials are stored
		# replica_set: # Replica set to connect to (automatically connects to primary for writes)
		# password: # The password to use for the user
		# ssl: # Whether to use an SSL connection when connecting to the database
		# ssl_cert_reqs: #CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE
		# roles: readWrite
		# state: #present|absent
		# update_password: #always|on_create
$0
endsnippet

snippet mongodb_parameter "Change an administrative parameter on a MongoDB server." b
- name: $1
	mongodb_parameter:
		database: ${2:# The name of the database to add/remove the user from}
		param: ${3:# MongoDB administrative parameter to modify}
		value: ${4:# MongoDB administrative parameter value to set}
		# login_user: # The username used to authenticate with
		# login_password: # The password used to authenticate with
		# login_host: localhost
		# login_port: 27017
		# login_database: # The database where login credentials are stored
		# replica_set: # Replica set to connect to (automatically connects to primary for writes)
		# ssl: no
		# param_type: str
$0
endsnippet

snippet influxdb_user "Manage InfluxDB users" b
- name: $1
	influxdb_user:
		user_name: ${2:# Name of the user.}
		# user_password: # Password to be set for the user.
		# admin: no
		# state: #present|absent
		# hostname: localhost
		# username: root
		# password: root
		# port: 8086
		# validate_certs: yes
		# ssl: # Use https instead of http to connect to InfluxDB server.
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# retries: 3
		# use_udp: # Use UDP to connect to InfluxDB server.
		# udp_port: 4444
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
$0
endsnippet

snippet influxdb_write "Write data points into InfluxDB." b
- name: $1
	influxdb_write:
		data_points: ${2:# Data points as dict to write into the database.}
		database_name: ${3:# Name of the database.}
		# hostname: localhost
		# username: root
		# password: root
		# port: 8086
		# validate_certs: yes
		# ssl: # Use https instead of http to connect to InfluxDB server.
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# retries: 3
		# use_udp: # Use UDP to connect to InfluxDB server.
		# udp_port: 4444
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
$0
endsnippet

snippet influxdb_query "Query data points from InfluxDB." b
- name: $1
	influxdb_query:
		query: ${2:# Query to be executed.}
		database_name: ${3:# Name of the database.}
		# hostname: localhost
		# username: root
		# password: root
		# port: 8086
		# validate_certs: yes
		# ssl: # Use https instead of http to connect to InfluxDB server.
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# retries: 3
		# use_udp: # Use UDP to connect to InfluxDB server.
		# udp_port: 4444
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
$0
endsnippet

snippet influxdb_database "Manage InfluxDB databases" b
- name: $1
	influxdb_database:
		database_name: ${2:# Name of the database.}
		# state: #present|absent
		# hostname: localhost
		# username: root
		# password: root
		# port: 8086
		# validate_certs: yes
		# ssl: # Use https instead of http to connect to InfluxDB server.
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# retries: 3
		# use_udp: # Use UDP to connect to InfluxDB server.
		# udp_port: 4444
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
$0
endsnippet

snippet influxdb_retention_policy "Manage InfluxDB retention policies" b
- name: $1
	influxdb_retention_policy:
		database_name: ${2:# Name of the database.}
		policy_name: ${3:# Name of the retention policy}
		duration: ${4:# Determines how long InfluxDB should keep the data}
		replication: ${5:# Determines how many independent copies of each point are stored in the cluster}
		default: ${6:# Sets the retention policy as default retention policy}
		# hostname: localhost
		# username: root
		# password: root
		# port: 8086
		# validate_certs: yes
		# ssl: # Use https instead of http to connect to InfluxDB server.
		# timeout: # Number of seconds Requests will wait for client to establish a connection.
		# retries: 3
		# use_udp: # Use UDP to connect to InfluxDB server.
		# udp_port: 4444
		# proxies: # HTTP(S) proxy to use for Requests to connect to InfluxDB server.
$0
endsnippet

snippet mysql_variables "Manage MySQL global variables" b
- name: $1
	mysql_variables:
		variable: ${2:# Variable name to operate}
		# value: # If set, then sets variable value to this
		# login_user: # The username used to authenticate with.
		# login_password: # The password used to authenticate with.
		# login_host: localhost
		# login_port: 3306
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# connect_timeout: 30
		# config_file: ~/.my.cnf
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# ssl_cert: # The path to a client public key certificate.
		# ssl_key: # The path to the client private key.
$0
endsnippet

snippet mysql_replication "Manage MySQL replication" b
- name: $1
	mysql_replication:
		# mode: #getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall
		# master_host: # same as mysql variable
		# master_user: # same as mysql variable
		# master_password: # same as mysql variable
		# master_port: # same as mysql variable
		# master_connect_retry: # same as mysql variable
		# master_log_file: # same as mysql variable
		# master_log_pos: # same as mysql variable
		# relay_log_file: # same as mysql variable
		# relay_log_pos: # same as mysql variable
		# master_ssl: 0|1
		# master_ssl_ca: # same as mysql variable
		# master_ssl_capath: # same as mysql variable
		# master_ssl_cert: # same as mysql variable
		# master_ssl_key: # same as mysql variable
		# master_ssl_cipher: # same as mysql variable
		# master_auto_position: # does the host uses GTID based replication or not
		# login_user: # The username used to authenticate with.
		# login_password: # The password used to authenticate with.
		# login_host: localhost
		# login_port: 3306
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# connect_timeout: 30
		# config_file: ~/.my.cnf
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# ssl_cert: # The path to a client public key certificate.
		# ssl_key: # The path to the client private key.
$0
endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host." b
- name: $1
	mysql_db:
		name: ${2:# name of the database to add or remove}
		# state: #present|absent|dump|import
		# collation: # Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.
		# encoding: # Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)
		# target: # Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.
		# single_transaction: no
		# quick: yes
		# ignore_tables: []
		# login_user: # The username used to authenticate with.
		# login_password: # The password used to authenticate with.
		# login_host: localhost
		# login_port: 3306
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# connect_timeout: 30
		# config_file: ~/.my.cnf
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# ssl_cert: # The path to a client public key certificate.
		# ssl_key: # The path to the client private key.
$0
endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database." b
- name: $1
	mysql_user:
		name: ${2:# name of the user (role) to add or remove}
		# password: # set the user's password.
		# encrypted: no
		# host: localhost
		# host_all: no
		# priv: # MySQL privileges string in the format: C(db.table:priv1,priv2).
		# append_privs: no
		# sql_log_bin: yes
		# state: #present|absent
		# check_implicit_admin: no
		# update_password: #always|on_create
		# login_user: # The username used to authenticate with.
		# login_password: # The password used to authenticate with.
		# login_host: localhost
		# login_port: 3306
		# login_unix_socket: # The path to a Unix domain socket for local connections.
		# connect_timeout: 30
		# config_file: ~/.my.cnf
		# ssl_ca: # The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.
		# ssl_cert: # The path to a client public key certificate.
		# ssl_key: # The path to the client private key.
$0
endsnippet

snippet proxysql_global_variables "Gets or sets the proxysql global variables." b
- name: $1
	proxysql_global_variables:
		variable: ${2:# Defines which variable should be returned, or if I(value) is specified which variable should be updated.}
		# value: # Defines a value the variable specified using I(variable) should be set to.
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_manage_config "Writes the proxysql configuration settings between layers." b
- name: $1
	proxysql_manage_config:
		action: ${2:LOAD|SAVE}
		config_settings: ${3:MYSQL USERS|MYSQL SERVERS|MYSQL QUERY RULES|MYSQL VARIABLES|ADMIN VARIABLES|SCHEDULER}
		direction: ${4:FROM|TO}
		config_layer: ${5:MEMORY|DISK|RUNTIME|CONFIG}
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_scheduler "Adds or removes schedules from proxysql admin interface." b
- name: $1
	proxysql_scheduler:
		filename: ${2:# Full path of the executable to be executed.}
		# active: yes
		# interval_ms: 10000
		# arg1: # Argument that can be passed to the job.
		# arg2: # Argument that can be passed to the job.
		# arg3: # Argument that can be passed to the job.
		# arg4: # Argument that can be passed to the job.
		# arg5: # Argument that can be passed to the job.
		# comment: # Text field that can be used for any purposed defined by the user.
		# state: #present|absent
		# force_delete: no
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_backend_servers "Adds or removes mysql hosts from proxysql admin interface." b
- name: $1
	proxysql_backend_servers:
		hostname: ${2:# The ip address at which the mysqld instance can be contacted.}
		# hostgroup_id: 0
		# port: 3306
		# status: ONLINE|OFFLINE_SOFT|OFFLINE_HARD
		# weight: # The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.
		# compression: # If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.
		# max_connections: # The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.
		# max_replication_lag: # If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.
		# use_ssl: # If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
		# max_latency_ms: # Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.
		# comment: 
		# state: #present|absent
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_mysql_users "Adds or removes mysql users from proxysql admin interface." b
- name: $1
	proxysql_mysql_users:
		username: ${2:# Name of the user connecting to the mysqld or ProxySQL instance.}
		# password: # Password of the user connecting to the mysqld or ProxySQL instance.
		# active: # A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).
		# use_ssl: # If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
		# default_hostgroup: # If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.
		# default_schema: # The schema to which the connection should change to by default.
		# transaction_persistent: # If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).
		# fast_forward: # If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).
		# backend: yes
		# frontend: yes
		# max_connections: # The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.
		# state: #present|absent
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_query_rules "Modifies query rules using the proxysql admin interface." b
- name: $1
	proxysql_query_rules:
		# rule_id: # The unique id of the rule. Rules are processed in rule_id order.
		# active: # A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.
		# username: # Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.
		# schemaname: # Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.
		# flagIN: # Used in combination with I(flagOUT) and I(apply) to create chains of rules.
		# client_addr: # Match traffic from a specific source.
		# proxy_addr: # Match incoming traffic on a specific local IP.
		# proxy_port: # Match incoming traffic on a specific local port.
		# digest: # Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.
		# match_digest: # Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
		# match_pattern: # Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
		# negate_match_pattern: # If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.
		# flagOUT: # Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.
		# replace_pattern: # This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.
		# destination_hostgroup: # Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).
		# cache_ttl: # The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.
		# timeout: # The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.
		# retries: # The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.
		# delay: # Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.
		# mirror_flagOUT: # Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.
		# mirror_hostgroup: # Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.
		# error_msg: # Query will be blocked, and the specified error_msg will be returned to the client.
		# log: # Query will be logged.
		# apply: # Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.
		# comment: # Free form text field, usable for a descriptive comment of the query rule.
		# state: #present|absent
		# force_delete: no
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet proxysql_replication_hostgroups "Manages replication hostgroups using the proxysql admin interface." b
- name: $1
	proxysql_replication_hostgroups:
		writer_hostgroup: ${2:# Id of the writer hostgroup.}
		reader_hostgroup: ${3:# Id of the reader hostgroup.}
		# comment: # Text field that can be used for any purposed defined by the user.
		# state: #present|absent
		# save_to_disk: yes
		# load_to_runtime: yes
		# login_user: # The username used to authenticate to ProxySQL admin interface.
		# login_password: # The password used to authenticate to ProxySQL admin interface.
		# login_host: 127.0.0.1
		# login_port: 6032
		# config_file: 
$0
endsnippet

snippet vertica_role "Adds or removes Vertica database roles and assigns roles to them." b
- name: $1
	vertica_role:
		name: ${2:# Name of the role to add or remove.}
		# assigned_roles: # Comma separated list of roles to assign to the role.
		# state: #present|absent
		# db: # Name of the Vertica database.
		# cluster: localhost
		# port: 5433
		# login_user: dbadmin
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet vertica_user "Adds or removes Vertica database users and assigns roles." b
- name: $1
	vertica_user:
		name: ${2:# Name of the user to add or remove.}
		# profile: # Sets the user's profile.
		# resource_pool: # Sets the user's resource pool.
		# password: # The user's password encrypted by the MD5 algorithm.
		# expired: # Sets the user's password expiration.
		# ldap: # Set to true if users are authenticated via LDAP.
		# roles: # Comma separated list of roles to assign to the user.
		# state: #present|absent|locked
		# db: # Name of the Vertica database.
		# cluster: localhost
		# port: 5433
		# login_user: dbadmin
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet vertica_configuration "Updates Vertica configuration parameters." b
- name: $1
	vertica_configuration:
		name: ${2:# Name of the parameter to update.}
		value: ${3:# Value of the parameter to be set.}
		# db: # Name of the Vertica database.
		# cluster: localhost
		# port: 5433
		# login_user: dbadmin
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet vertica_facts "Gathers Vertica database facts." b
- name: $1
	vertica_facts:
		# cluster: localhost
		# port: 5433
		# db: # Name of the database running the schema.
		# login_user: dbadmin
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet vertica_schema "Adds or removes Vertica database schema and roles." b
- name: $1
	vertica_schema:
		name: ${2:# Name of the schema to add or remove.}
		# usage_roles: # Comma separated list of roles to create and grant usage access to the schema.
		# create_roles: # Comma separated list of roles to create and grant usage and create access to the schema.
		# owner: # Name of the user to set as owner of the schema.
		# state: #present|absent
		# db: # Name of the Vertica database.
		# cluster: localhost
		# port: 5433
		# login_user: dbadmin
		# login_password: # The password used to authenticate with.
$0
endsnippet

snippet mssql_db "Add or remove MSSQL databases from a remote host." b
- name: $1
	mssql_db:
		name: ${2:# name of the database to add or remove}
		# login_user: # The username used to authenticate with
		# login_password: # The password used to authenticate with
		# login_host: # Host running the database
		# login_port: 1433
		# state: #present|absent|import
		# target: # Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.
		# autocommit: no
$0
endsnippet

snippet certificate_complete_chain "Complete certificate chain given a set of untrusted and root certificates" b
- name: $1
	certificate_complete_chain:
		input_chain: ${2:# A concatenated set of certificates in PEM format forming a chain.}
		root_certificates: ${3:# A list of filenames or directories.}
		# intermediate_certificates: []
$0
endsnippet

snippet openssl_certificate "Generate and/or check OpenSSL certificates" b
- name: $1
	openssl_certificate:
		path: ${2:# Remote absolute path where the generated certificate file should be created or is already located.}
		provider: ${3:selfsigned|ownca|assertonly|acme}
		# state: #present|absent
		# force: no
		# csr_path: # Path to the Certificate Signing Request (CSR) used to generate this certificate. This is not required in C(assertonly) mode.
		# privatekey_path: # Path to the private key to use when signing the certificate.
		# privatekey_passphrase: # The passphrase for the I(privatekey_path).
		# selfsigned_version: 3
		# selfsigned_digest: sha256
		# selfsigned_not_before: # The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.
		# selfsigned_not_after: # The timestamp at which the certificate stops being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will stop being valid 10 years from now.
		# ownca_path: # Remote absolute path of the CA (Certificate Authority) certificate.
		# ownca_privatekey_path: # Path to the CA (Certificate Authority) private key to use when signing the certificate.
		# ownca_privatekey_passphrase: # The passphrase for the I(ownca_privatekey_path).
		# ownca_digest: sha256
		# ownca_version: 3
		# ownca_not_before: # The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.
		# ownca_not_after: # The timestamp at which the certificate stops being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will stop being valid 10 years from now.
		# acme_accountkey_path: # Path to the accountkey for the C(acme) provider
		# acme_challenge_path: # Path to the ACME challenge directory that is served on U(http://<HOST>:80/.well-known/acme-challenge/)
		# acme_chain: yes
		# signature_algorithms: # list of algorithms that you would accept the certificate to be signed with (e.g. ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']).
		# issuer: # Key/value pairs that must be present in the issuer name field of the certificate. If you need to specify more than one value with the same key, use a list as value.
		# issuer_strict: no
		# subject: # Key/value pairs that must be present in the subject name field of the certificate. If you need to specify more than one value with the same key, use a list as value.
		# subject_strict: no
		# has_expired: no
		# version: # Version of the certificate. Nowadays it should almost always be 3.
		# valid_at: # The certificate must be valid at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# invalid_at: # The certificate must be invalid at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# not_before: # The certificate must start to become valid at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# not_after: # The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME.
		# valid_in: # The certificate must still be valid in I(valid_in) seconds from now.
		# key_usage: # The I(key_usage) extension field must contain all these values.
		# key_usage_strict: no
		# extended_key_usage: # The I(extended_key_usage) extension field must contain all these values.
		# extended_key_usage_strict: no
		# subject_alt_name: # The I(subject_alt_name) extension field must contain these values.
		# subject_alt_name_strict: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet openssl_publickey "Generate an OpenSSL public key from its private key." b
- name: $1
	openssl_publickey:
		path: ${2:# Name of the file in which the generated TLS/SSL public key will be written.}
		privatekey_path: ${3:# Path to the TLS/SSL private key from which to generate the public key.}
		# state: #present|absent
		# force: no
		# format: #PEM|OpenSSH
		# privatekey_passphrase: # The passphrase for the privatekey.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet openssl_dhparam "Generate OpenSSL Diffie-Hellman Parameters" b
- name: $1
	openssl_dhparam:
		path: ${2:# Name of the file in which the generated parameters will be saved.}
		# state: #present|absent
		# size: 4096
		# force: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet openssl_privatekey "Generate OpenSSL private keys." b
- name: $1
	openssl_privatekey:
		path: ${2:# Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.}
		# state: #present|absent
		# size: 4096
		# type: #RSA|DSA
		# force: no
		# passphrase: # The passphrase for the private key.
		# cipher: # The cipher to encrypt the private key. (cipher can be found by running `openssl list-cipher-algorithms`)
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet openssl_csr "Generate OpenSSL Certificate Signing Request (CSR)" b
- name: $1
	openssl_csr:
		privatekey_path: ${2:# Path to the privatekey to use when signing the certificate signing request}
		path: ${3:# Name of the file into which the generated OpenSSL certificate signing request will be written}
		# state: #present|absent
		# digest: sha256
		# privatekey_passphrase: # The passphrase for the privatekey.
		# version: 1
		# force: no
		# subject: # Key/value pairs that will be present in the subject name field of the certificate signing request.
		# country_name: # countryName field of the certificate signing request subject
		# state_or_province_name: # stateOrProvinceName field of the certificate signing request subject
		# locality_name: # localityName field of the certificate signing request subject
		# organization_name: # organizationName field of the certificate signing request subject
		# organizational_unit_name: # organizationalUnitName field of the certificate signing request subject
		# common_name: # commonName field of the certificate signing request subject
		# email_address: # emailAddress field of the certificate signing request subject
		# subject_alt_name: # SAN extension to attach to the certificate signing request
		# subject_alt_name_critical: # Should the subjectAltName extension be considered as critical
		# key_usage: # This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.
		# key_usage_critical: # Should the keyUsage extension be considered as critical
		# extended_key_usage: # Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.
		# extended_key_usage_critical: # Should the extkeyUsage extension be considered as critical
		# basic_constraints: # Indicates basic constraints, such as if the certificate is a CA.
		# basic_constraints_critical: # Should the basicConstraints extension be considered as critical
		# ocsp_must_staple: # Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools.ietf.org/html/rfc7633)).
		# ocsp_must_staple_critical: # Should the OCSP Must Staple extension be considered as critical
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet openssl_pkcs12 "Generate OpenSSL PKCS#12 archive." b
- name: $1
	openssl_pkcs12:
		path: ${2:# Filename to write the PKCS#12 file to.}
		# action: parse|#export
		# ca_certificates: # List of CA certificate to include.
		# certificate_path: # The path to read certificates and private keys from.  Must be in PEM format.
		# force: no
		# friendly_name: # Specifies the friendly name for the certificate and private key.
		# iter_size: 2048
		# maciter_size: 1
		# passphrase: # The PKCS#12 password.
		# privatekey_passphrase: # Passphrase source to decrypt any input private keys with.
		# privatekey_path: # File to read private key from.
		# state: #present|absent
		# src: # PKCS#12 file path to parse.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet acme_challenge_cert_helper "Prepare certificates required for ACME challenges such as C(tls-alpn-01)" b
- name: $1
	acme_challenge_cert_helper:
		challenge: ${2:tls-alpn-01}
		challenge_data: ${3:# The C(challenge_data) entry provided by M(acme_certificate) for the challenge.}
		# private_key_src: # Path to a file containing the private key file to use for this challenge certificate.
		# private_key_content: # Content of the private key to use for this challenge certificate.
$0
endsnippet

snippet acme_account "Create, modify or delete ACME accounts" b
- name: $1
	acme_account:
		state: ${2:present|absent|changed_key}
		# allow_creation: yes
		# contact: []
		# terms_agreed: no
		# new_account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key to change to.
		# new_account_key_content: # Content of the ACME account RSA or Elliptic Curve key to change to.
		# account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key.
		# account_key_content: # Content of the ACME account RSA or Elliptic Curve key.
		# account_uri: # If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.
		# acme_version: #1|2
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# validate_certs: yes
		# select_crypto_backend: #auto|cryptography|openssl
$0
endsnippet

snippet acme_certificate_revoke "Revoke certificates with the ACME protocol" b
- name: $1
	acme_certificate_revoke:
		certificate: ${2:# Path to the certificate to revoke.}
		# account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key.
		# account_key_content: # Content of the ACME account RSA or Elliptic Curve key.
		# private_key_src: # Path to the certificate's private key.
		# private_key_content: # Content of the certificate's private key.
		# revoke_reason: # One of the revocation reasonCodes defined in L(https://tools.ietf.org/html/rfc5280#section-5.3.1, Section 5.3.1 of RFC5280).
		# account_uri: # If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.
		# acme_version: #1|2
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# validate_certs: yes
		# select_crypto_backend: #auto|cryptography|openssl
$0
endsnippet

snippet acme_certificate "Create SSL/TLS certificates with the ACME protocol" b
- name: $1
	acme_certificate:
		csr: ${2:# File containing the CSR for the new certificate.}
		# account_email: # The email address associated with this account.
		# agreement: # URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).
		# terms_agreed: no
		# modify_account: yes
		# challenge: #http-01|dns-01|tls-alpn-01
		# data: # The data to validate ongoing challenges. This must be specified for the second run of the module only.
		# dest: # The destination file for the certificate.
		# fullchain_dest: # The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).
		# chain_dest: # If specified, the intermediate certificate will be written to this file.
		# remaining_days: 10
		# deactivate_authzs: no
		# force: no
		# account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key.
		# account_key_content: # Content of the ACME account RSA or Elliptic Curve key.
		# account_uri: # If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.
		# acme_version: #1|2
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# validate_certs: yes
		# select_crypto_backend: #auto|cryptography|openssl
$0
endsnippet

snippet acme_certificate "Create SSL/TLS certificates with the ACME protocol" b
- name: $1
	acme_certificate:
		csr: ${2:# File containing the CSR for the new certificate.}
		# account_email: # The email address associated with this account.
		# agreement: # URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).
		# terms_agreed: no
		# modify_account: yes
		# challenge: #http-01|dns-01|tls-alpn-01
		# data: # The data to validate ongoing challenges. This must be specified for the second run of the module only.
		# dest: # The destination file for the certificate.
		# fullchain_dest: # The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).
		# chain_dest: # If specified, the intermediate certificate will be written to this file.
		# remaining_days: 10
		# deactivate_authzs: no
		# force: no
		# account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key.
		# account_key_content: # Content of the ACME account RSA or Elliptic Curve key.
		# account_uri: # If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.
		# acme_version: #1|2
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# validate_certs: yes
		# select_crypto_backend: #auto|cryptography|openssl
$0
endsnippet

snippet acme_account_facts "Retrieves information on ACME accounts" b
- name: $1
	acme_account_facts:
		# account_key_src: # Path to a file containing the ACME account RSA or Elliptic Curve key.
		# account_key_content: # Content of the ACME account RSA or Elliptic Curve key.
		# account_uri: # If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.
		# acme_version: #1|2
		# acme_directory: https://acme-staging.api.letsencrypt.org/directory
		# validate_certs: yes
		# select_crypto_backend: #auto|cryptography|openssl
$0
endsnippet

snippet onepassword_facts "Fetch facts from 1Password items" b
- name: $1
	onepassword_facts:
		search_terms: ${2:# A list of one or more search terms.}
		# auto_login: {}
		# cli_path: op
$0
endsnippet

snippet ipa_role "Manage FreeIPA role" b
- name: $1
	ipa_role:
		cn: ${2:# Role name.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # A description of this role-group.
		# group: # List of group names assign to this role.
		# host: # List of host names to assign.
		# hostgroup: # List of host group names to assign.
		# privilege: # List of privileges granted to the role.
		# service: # List of service names to assign.
		# state: #present|absent
		# user: # List of user names to assign.
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_hbacrule "Manage FreeIPA HBAC rule" b
- name: $1
	ipa_hbacrule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # D
		# host: # List of host names to assign.
		# hostcategory: all
		# hostgroup: # List of hostgroup names to assign.
		# service: # List of service names to assign.
		# servicecategory: all
		# servicegroup: # List of service group names to assign.
		# sourcehost: # List of source host names to assign.
		# sourcehostcategory: all
		# sourcehostgroup: # List of source host group names to assign.
		# state: #present|absent|enabled|disabled
		# user: # List of user names to assign.
		# usercategory: all
		# usergroup: # List of user group names to assign.
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_host "Manage FreeIPA host" b
- name: $1
	ipa_host:
		fqdn: ${2:# Full qualified domain name.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # A description of this host.
		# force: # Force host name even if not in DNS.
		# ip_address: # Add the host to DNS with this IP address.
		# mac_address: # List of Hardware MAC address(es) off this host.
		# ns_host_location: # Host location (e.g. "Lab 2")
		# ns_hardware_platform: # Host hardware platform (e.g. "Lenovo T61")
		# ns_os_version: # Host operating system and version (e.g. "Fedora 9")
		# user_certificate: # List of Base-64 encoded server certificates.
		# state: #present|absent|enabled|disabled
		# update_dns: no
		# random_password: no
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_group "Manage FreeIPA group" b
- name: $1
	ipa_group:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # Description of the group.
		# external: # Allow adding external non-IPA members from trusted domains.
		# gidnumber: # GID (use this option to set it manually).
		# group: # List of group names assigned to this group.
		# nonposix: # Create as a non-POSIX group.
		# user: # List of user names assigned to this group.
		# state: #present|absent
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_vault "Manage FreeIPA vaults" b
- name: $1
	ipa_vault:
		cn: ${2:# Vault name.}
		ipavaulttype: ${3:standard|#symmetric|asymmetric}
		ipa_pass: ${4:# Password of administrative user.}
		# description: # Description.
		# ipavaultpublickey: # Public key.
		# ipavaultsalt: # Vault Salt.
		# username: # Any user can own one or more user vaults.
		# service: # Any service can own one or more service vaults.
		# state: #present|absent
		# replace: True|False
		# validate_certs: yes
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_sudocmdgroup "Manage FreeIPA sudo command group" b
- name: $1
	ipa_sudocmdgroup:
		cn: ${2:# Sudo Command Group.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # Group description.
		# state: #present|absent|enabled|disabled
		# sudocmd: # List of sudo commands to assign to the group.
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_user "Manage FreeIPA users" b
- name: $1
	ipa_user:
		uid: ${2:# u}
		ipa_pass: ${3:# Password of administrative user.}
		# displayname: # D
		# givenname: # F
		# krbpasswordexpiration: # Date at which the user password will expire
		# loginshell: # L
		# mail: # List of mail addresses assigned to the user.
		# password: # Password for new user
		# sn: # S
		# sshpubkey: # List of public SSH key.
		# state: #present|absent|enabled|disabled
		# telephonenumber: # List of telephone numbers assigned to the user.
		# title: # T
		# uidnumber: # Account Settings UID/Posix User ID number
		# gidnumber: # Posix Group ID
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_dnszone "Manage FreeIPA DNS Zones" b
- name: $1
	ipa_dnszone:
		zone_name: ${2:# The DNS zone name to which needs to be managed.}
		ipa_pass: ${3:# Password of administrative user.}
		# state: #present|absent
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_sudorule "Manage FreeIPA sudo rule" b
- name: $1
	ipa_sudorule:
		cn: ${2:# Canonical name.}
		ipa_pass: ${3:# Password of administrative user.}
		# cmdcategory: all
		# cmd: # List of commands assigned to the rule.
		# description: # Description of the sudo rule.
		# host: # List of hosts assigned to the rule.
		# hostcategory: all
		# hostgroup: # List of host groups assigned to the rule.
		# runasusercategory: all
		# runasgroupcategory: all
		# sudoopt: # List of options to add to the sudo rule.
		# user: # List of users assigned to the rule.
		# usercategory: all
		# usergroup: # List of user groups assigned to the rule.
		# state: #present|absent|enabled|disabled
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_service "Manage FreeIPA service" b
- name: $1
	ipa_service:
		krbcanonicalname: ${2:# principal of the service}
		ipa_pass: ${3:# Password of administrative user.}
		# hosts: # defines the list of 'ManagedBy' hosts
		# force: # Force principal name even if host is not in DNS.
		# state: #present|absent
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_subca "Manage FreeIPA Lightweight Sub Certificate Authorities." b
- name: $1
	ipa_subca:
		subca_name: ${2:# The Sub Certificate Authority name which needs to be managed.}
		subca_subject: ${3:# The Sub Certificate Authority's Subject. e.g., 'CN=SampleSubCA1,O=testrelm.test'}
		subca_desc: ${4:# The Sub Certificate Authority's description.}
		ipa_pass: ${5:# Password of administrative user.}
		# state: #present|absent|enabled|disabled
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_sudocmd "Manage FreeIPA sudo command" b
- name: $1
	ipa_sudocmd:
		sudocmd: ${2:# Sudo Command.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # A description of this command.
		# state: #present|absent|enabled|disabled
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_hostgroup "Manage FreeIPA host-group" b
- name: $1
	ipa_hostgroup:
		cn: ${2:# Name of host-group.}
		ipa_pass: ${3:# Password of administrative user.}
		# description: # Description
		# host: # List of hosts that belong to the host-group.
		# hostgroup: # List of host-groups than belong to that host-group.
		# state: #present|absent|enabled|disabled
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_dnsrecord "Manage FreeIPA DNS records" b
- name: $1
	ipa_dnsrecord:
		zone_name: ${2:# The DNS zone name to which DNS record needs to be managed.}
		record_name: ${3:# The DNS record name to manage.}
		record_value: ${4:# Manage DNS record name with this value.}
		ipa_pass: ${5:# Password of administrative user.}
		# record_type: #A|AAAA|A6|CNAME|DNAME|PTR|TXT
		# record_ttl: # Set the TTL for the record.
		# state: #present|absent
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet ipa_config "Manage Global FreeIPA Configuration Settings" b
- name: $1
	ipa_config:
		ipa_pass: ${2:# Password of administrative user.}
		# ipadefaultloginshell: # D
		# ipadefaultemaildomain: # D
		# ipa_port: 443
		# ipa_host: ipa.example.com
		# ipa_user: admin
		# ipa_prot: http|#https
		# validate_certs: yes
		# ipa_timeout: 10
$0
endsnippet

snippet cyberark_user "Module for CyberArk User Management using PAS Web Services SDK" b
- name: $1
	cyberark_user:
		username: ${2:# The name of the user who will be queried (for details), added, updated or deleted.}
		cyberark_session: ${3:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session, please see M(cyberark_authentication) module for an example of cyberark_session.}
		# state: #present|absent
		# initial_password: # The password that the new user will use to log on the first time. This password must meet the password policy requirements. this parameter is required when state is present -- Add User.
		# new_password: # The user updated password. Make sure that this password meets the password policy requirements.
		# email: # The user email address.
		# first_name: # The user first name.
		# last_name: # The user last name.
		# change_password_on_the_next_logon: no
		# expiry_date: # The date and time when the user account will expire and become disabled.
		# user_type_name: EPVUser
		# disabled: no
		# location: # The Vault Location for the user.
		# group_name: # The name of the group the user will be added to.
$0
endsnippet

snippet cyberark_authentication "Module for CyberArk Vault Authentication using PAS Web Services SDK" b
- name: $1
	cyberark_authentication:
		# state: #present|absent
		# username: # The name of the user who will logon to the Vault.
		# password: # The password of the user.
		# new_password: # The new password of the user. This parameter is optional, and enables you to change a password.
		# api_base_url: # A string containing the base URL of the server hosting CyberArk's Privileged Account Security Web Services SDK.
		# validate_certs: yes
		# use_shared_logon_authentication: no
		# use_radius_authentication: no
		# cyberark_session: # Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session.
$0
endsnippet

snippet keycloak_client "Allows administration of Keycloak clients via Keycloak API" b
- name: $1
	keycloak_client:
		auth_keycloak_url: ${2:# URL to the Keycloak instance.}
		auth_client_id: ${3:admin-cli}
		auth_realm: ${4:# Keycloak realm name to authenticate to for API access.}
		auth_username: ${5:# Username to authenticate for API access with.}
		auth_password: ${6:# Password to authenticate for API access with.}
		# state: #present|absent
		# realm: # The realm to create the client in.
		# client_id: # Client id of client to be worked on. This is usually an alphanumeric name chosen by you. Either this or I(id) is required. If you specify both, I(id) takes precedence. This is 'clientId' in the Keycloak REST API.
		# id: # Id of client to be worked on. This is usually an UUID. Either this or I(client_id) is required. If you specify both, this takes precedence.
		# name: # Name of the client (this is not the same as I(client_id))
		# description: # Description of the client in Keycloak
		# root_url: # Root URL appended to relative URLs for this client This is 'rootUrl' in the Keycloak REST API.
		# admin_url: # URL to the admin interface of the client This is 'adminUrl' in the Keycloak REST API.
		# base_url: # Default URL to use when the auth server needs to redirect or link back to the client This is 'baseUrl' in the Keycloak REST API.
		# enabled: # Is this client enabled or not?
		# client_authenticator_type: client-secret|client-jwt
		# secret: # When using I(client_authenticator_type) C(client-secret) (the default), you can specify a secret here (otherwise one will be generated if it does not exit). If changing this secret, the module will not register a change currently (but the changed secret will be saved).
		# registration_access_token: # The registration access token provides access for clients to the client registration service. This is 'registrationAccessToken' in the Keycloak REST API.
		# default_roles: # list of default roles for this client. If the client roles referenced do not exist yet, they will be created. This is 'defaultRoles' in the Keycloak REST API.
		# redirect_uris: # Acceptable redirect URIs for this client. This is 'redirectUris' in the Keycloak REST API.
		# web_origins: # List of allowed CORS origins. This is 'webOrigins' in the Keycloak REST API.
		# not_before: # Revoke any tokens issued before this date for this client (this is a UNIX timestamp). This is 'notBefore' in the Keycloak REST API.
		# bearer_only: # The access type of this client is bearer-only. This is 'bearerOnly' in the Keycloak REST API.
		# consent_required: # If enabled, users have to consent to client access. This is 'consentRequired' in the Keycloak REST API.
		# standard_flow_enabled: # Enable standard flow for this client or not (OpenID connect). This is 'standardFlowEnabled' in the Keycloak REST API.
		# implicit_flow_enabled: # Enable implicit flow for this client or not (OpenID connect). This is 'implictFlowEnabled' in the Keycloak REST API.
		# direct_access_grants_enabled: # Are direct access grants enabled for this client or not (OpenID connect). This is 'directAccessGrantsEnabled' in the Keycloak REST API.
		# service_accounts_enabled: # Are service accounts enabled for this client or not (OpenID connect). This is 'serviceAccountsEnabled' in the Keycloak REST API.
		# authorization_services_enabled: # Are authorization services enabled for this client or not (OpenID connect). This is 'authorizationServicesEnabled' in the Keycloak REST API.
		# public_client: # Is the access type for this client public or not. This is 'publicClient' in the Keycloak REST API.
		# frontchannel_logout: # Is frontchannel logout enabled for this client or not. This is 'frontchannelLogout' in the Keycloak REST API.
		# protocol: openid-connect|saml
		# full_scope_allowed: # Is the "Full Scope Allowed" feature set for this client or not. This is 'fullScopeAllowed' in the Keycloak REST API.
		# node_re_registration_timeout: # Cluster node re-registration timeout for this client. This is 'nodeReRegistrationTimeout' in the Keycloak REST API.
		# registered_nodes: # dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in the Keycloak REST API.
		# client_template: # Client template to use for this client. If it does not exist this field will silently be dropped. This is 'clientTemplate' in the Keycloak REST API.
		# use_template_config: # Whether or not to use configuration from the I(client_template). This is 'useTemplateConfig' in the Keycloak REST API.
		# use_template_scope: # Whether or not to use scope configuration from the I(client_template). This is 'useTemplateScope' in the Keycloak REST API.
		# use_template_mappers: # Whether or not to use mapper configuration from the I(client_template). This is 'useTemplateMappers' in the Keycloak REST API.
		# surrogate_auth_required: # Whether or not surrogate auth is required. This is 'surrogateAuthRequired' in the Keycloak REST API.
		# authorization_settings: # a data structure defining the authorization settings for this client. For reference, please see the Keycloak API docs at U(http://www.keycloak.org/docs-api/3.3/rest-api/index.html#_resourceserverrepresentation). This is 'authorizationSettings' in the Keycloak REST API.
		# protocol_mappers: # a list of dicts defining protocol mappers for this client. This is 'protocolMappers' in the Keycloak REST API.
		# attributes: # A dict of further attributes for this client. This can contain various configuration settings; an example is given in the examples section. While an exhaustive list of permissible options is not available; possible options as of Keycloak 3.4 are listed below. The Keycloak API does not validate whether a given option is appropriate for the protocol used; if specified anyway, Keycloak will simply not use it.
		# auth_client_secret: # Client Secret to use in conjunction with I(auth_client_id) (if required).
		# validate_certs: yes
$0
endsnippet

snippet keycloak_clienttemplate "Allows administration of Keycloak client templates via Keycloak API" b
- name: $1
	keycloak_clienttemplate:
		auth_keycloak_url: ${2:# URL to the Keycloak instance.}
		auth_client_id: ${3:admin-cli}
		auth_realm: ${4:# Keycloak realm name to authenticate to for API access.}
		auth_username: ${5:# Username to authenticate for API access with.}
		auth_password: ${6:# Password to authenticate for API access with.}
		# state: #present|absent
		# id: # Id of client template to be worked on. This is usually a UUID.
		# realm: # Realm this client template is found in.
		# name: # Name of the client template
		# description: # Description of the client template in Keycloak
		# protocol: openid-connect|saml
		# full_scope_allowed: # Is the "Full Scope Allowed" feature set for this client template or not. This is 'fullScopeAllowed' in the Keycloak REST API.
		# protocol_mappers: # a list of dicts defining protocol mappers for this client template. This is 'protocolMappers' in the Keycloak REST API.
		# attributes: # A dict of further attributes for this client template. This can contain various configuration settings, though in the default installation of Keycloak as of 3.4, none are documented or known, so this is usually empty.
		# auth_client_secret: # Client Secret to use in conjunction with I(auth_client_id) (if required).
		# validate_certs: yes
$0
endsnippet

snippet opendj_backendprop "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command." b
- name: $1
	opendj_backendprop:
		hostname: ${2:# The hostname of the OpenDJ server.}
		port: ${3:# The Admin port on which the OpenDJ instance is available.}
		backend: ${4:# The name of the backend on which the property needs to be updated.}
		name: ${5:# The configuration setting to update.}
		value: ${6:# The value for the configuration item.}
		# opendj_bindir: /opt/opendj/bin
		# username: cn=Directory Manager
		# password: # The password for the cn=Directory Manager user.
		# passwordfile: # Location to the password file which holds the password for the cn=Directory Manager user.
		# state: present
$0
endsnippet

snippet mail "Send an email" b
- name: $1
	mail:
		subject: ${2:# The subject of the email being sent.}
		# from: root
		# to: root
		# cc: # The email-address(es) the mail is being copied to.
		# bcc: # The email-address(es) the mail is being 'blind' copied to.
		# body: $subject
		# username: # If SMTP requires username.
		# password: # If SMTP requires password.
		# host: localhost
		# port: 25
		# attach: []
		# headers: []
		# charset: utf-8
		# subtype: html|#plain
		# secure: always|never|starttls|#try
		# timeout: 20
$0
endsnippet

snippet grove "Sends a notification to a grove.io channel" b
- name: $1
	grove:
		channel_token: ${2:# Token of the channel to post to.}
		message: ${3:# Message content}
		# service: ansible
		# url: # Service URL for the web client
		# icon_url: # Icon for the service
		# validate_certs: yes
$0
endsnippet

snippet jabber "Send a message to jabber user or chat room" b
- name: $1
	jabber:
		user: ${2:# User as which to connect}
		password: ${3:# password for user to connect}
		to: ${4:# user ID or name of the room, when using room use a slash to indicate your nick.}
		msg: ${5:# The message body.}
		# host: # host to connect, overrides user info
		# port: 5222
		# encoding: # message encoding
$0
endsnippet

snippet hipchat "Send a message to Hipchat." b
- name: $1
	hipchat:
		token: ${2:# API token.}
		room: ${3:# ID or name of the room.}
		msg: ${4:# The message body.}
		# from: Ansible
		# color: #yellow|red|green|purple|gray|random
		# msg_format: #text|html
		# notify: yes
		# validate_certs: yes
		# api: https://api.hipchat.com/v1
$0
endsnippet

snippet bearychat "Send BearyChat notifications" b
- name: $1
	bearychat:
		url: ${2:# BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like C(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).}
		# text: # Message to send.
		# markdown: yes
		# channel: # Channel to send the message to. If absent, the message goes to the default channel selected by the I(url).
		# attachments: # Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments
$0
endsnippet

snippet telegram "module for sending notifications via telegram" b
- name: $1
	telegram:
		msg: ${2:# What message you wish to send.}
		token: ${3:# Token identifying your telegram bot.}
		chat_id: ${4:# Telegram group or user chat_id}
		# msg_format: #plain|markdown|html
$0
endsnippet

snippet say "Makes a computer to speak." b
- name: $1
	say:
		msg: ${2:# W}
		# voice: # W
$0
endsnippet

snippet pushover "Send notifications via U(https://pushover.net)" b
- name: $1
	pushover:
		msg: ${2:# What message you wish to send.}
		app_token: ${3:# Pushover issued token identifying your pushover app.}
		user_key: ${4:# Pushover issued authentication key for your user.}
		# pri: # Message priority (see U(https://pushover.net) for details.)
$0
endsnippet

snippet hall "Send notification to Hall" b
- name: $1
	hall:
		room_token: ${2:# Room token provided to you by setting up the Ansible room integation on U(https://hall.com)}
		msg: ${3:# The message you wish to deliver as a notification}
		title: ${4:# The title of the message}
		# picture: # The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)

$0
endsnippet

snippet irc "Send a message to an IRC channel" b
- name: $1
	irc:
		msg: ${2:# The message body.}
		channel: ${3:# Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.}
		# server: localhost
		# port: 6667
		# nick: ansible
		# topic: # Set the channel topic
		# color: #none|white|black|blue|green|red|brown|purple|orange|yellow|light_green|teal|light_cyan|light_blue|pink|gray|light_gray
		# nick_to: # A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.
		# key: # Channel key
		# passwd: # Server password
		# timeout: 30
		# use_ssl: no
		# part: yes
		# style: bold|underline|reverse|italic
$0
endsnippet

snippet mattermost "Send Mattermost notifications" b
- name: $1
	mattermost:
		url: ${2:# Mattermost url (i.e. http://mattermost.yourcompany.com).}
		api_key: ${3:# Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)}
		text: ${4:# Text to send. Note that the module does not handle escaping characters.}
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).
		# username: Ansible
		# icon_url: https://www.ansible.com/favicon.ico
		# validate_certs: yes
$0
endsnippet

snippet nexmo "Send a SMS via nexmo" b
- name: $1
	nexmo:
		api_key: ${2:# Nexmo API Key}
		api_secret: ${3:# Nexmo API Secret}
		src: ${4:# Nexmo Number to send from}
		dest: ${5:# Phone number(s) to send SMS message to}
		msg: ${6:# Message to text to send. Messages longer than 160 characters will be split into multiple messages}
		# validate_certs: yes
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet snow_record "Create/Delete/Update records in ServiceNow" b
- name: $1
	snow_record:
		instance: ${2:# The service now instance name}
		username: ${3:# User to connect to ServiceNow as}
		password: ${4:# Password for username}
		state: ${5:present|absent}
		# table: incident
		# data: # key, value pairs of data to load into the record. See Examples. Required for C(state:present)
		# number: # Record number to update. Required for C(state:absent)
		# lookup_field: number
		# attachment: # Attach a file to the record
$0
endsnippet

snippet typetalk "Send a message to typetalk" b
- name: $1
	typetalk:
		client_id: ${2:# OAuth2 client ID}
		client_secret: ${3:# OAuth2 client secret}
		topic: ${4:# topic id to post message}
		msg: ${5:# message body}
$0
endsnippet

snippet mqtt "Publish a message on an MQTT topic for the IoT" b
- name: $1
	mqtt:
		topic: ${2:# MQTT topic name}
		payload: ${3:# Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.}
		# server: localhost
		# port: 1883
		# username: # Username to authenticate against the broker.
		# password: # Password for C(username) to authenticate against the broker.
		# client_id: hostname + pid
		# qos: 0|1|2
		# retain: no
		# ca_certs: # The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.
		# certfile: # The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
		# keyfile: # The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
$0
endsnippet

snippet office_365_connector_card "Use webhooks to create Connector Card messages within an Office 365 group" b
- name: $1
	office_365_connector_card:
		webhook: ${2:# The webhook URL is given to you when you create a new Connector.}
		# summary: # A string used for summarizing card content.
		# color: # Accent color used for branding or indicating status in the card.
		# title: # A title for the Connector message. Shown at the top of the message.
		# text: # The main text of the card.
		# actions: # This array of objects will power the action links
		# sections: # Contains a list of sections to display in the card.
$0
endsnippet

snippet syslogger "Log messages in the syslog" b
- name: $1
	syslogger:
		msg: ${2:# This is the message to place in syslog}
		# priority: emerg|alert|crit|err|warning|notice|#info|debug
		# facility: kern|user|mail|#daemon|auth|lpr|news|uucp|cron|syslog|local0|local1|local2|local3|local4|local5|local6|local7
		# log_pid: no
$0
endsnippet

snippet campfire "Send a message to Campfire" b
- name: $1
	campfire:
		subscription: ${2:# The subscription name to use.}
		token: ${3:# API token.}
		room: ${4:# Room number to which the message should be sent.}
		msg: ${5:# The message body.}
		# notify: 56k|bell|bezos|bueller|clowntown|cottoneyejoe|crickets|dadgummit|dangerzone|danielsan|deeper|drama|greatjob|greyjoy|guarantee|heygirl|horn|horror|inconceivable|live|loggins|makeitso|noooo|nyan|ohmy|ohyeah|pushit|rimshot|rollout|rumble|sax|secret|sexyback|story|tada|tmyk|trololo|trombone|unix|vuvuzela|what|whoomp|yeah|yodel
$0
endsnippet

snippet flowdock "Send a message to a flowdock" b
- name: $1
	flowdock:
		token: ${2:# API token.}
		type: ${3:inbox|chat}
		msg: ${4:# Content of the message}
		# tags: # tags of the message, separated by commas
		# external_user_name: # (chat only - required) Name of the "user" sending the message
		# from_address: # (inbox only - required) Email address of the message sender
		# source: # (inbox only - required) Human readable identifier of the application that uses the Flowdock API
		# subject: # (inbox only - required) Subject line of the message
		# from_name: # (inbox only) Name of the message sender
		# reply_to: # (inbox only) Email address for replies
		# project: # (inbox only) Human readable identifier for more detailed message categorization
		# link: # (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.
		# validate_certs: yes
$0
endsnippet

snippet sendgrid "Sends an email with the SendGrid API" b
- name: $1
	sendgrid:
		from_address: ${2:# the address in the "from" field for the email}
		to_addresses: ${3:# a list with one or more recipient email addresses}
		subject: ${4:# the desired subject for the email}
		# username: # username for logging into the SendGrid account.
		# password: # password that corresponds to the username
		# api_key: # sendgrid API key to use instead of username/password
		# cc: # a list of email addresses to cc
		# bcc: # a list of email addresses to bcc
		# attachments: # a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)
		# from_name: # the name you want to appear in the from field, i.e 'John Doe'
		# html_body: no
		# headers: # a dict to pass on as headers
$0
endsnippet

snippet cisco_spark "Send a message to a Cisco Spark Room or Individual." b
- name: $1
	cisco_spark:
		recipient_type: ${2:roomId|toPersonEmail|toPersonId}
		recipient_id: ${3:# The unique identifier associated with the supplied C(recipient_type).}
		personal_token: ${4:# Your personal access token required to validate the Spark API.}
		message: ${5:# The message you would like to send.}
		# message_type: #text|markdown
$0
endsnippet

snippet twilio "Sends a text message to a mobile phone through Twilio." b
- name: $1
	twilio:
		account_sid: ${2:# u}
		auth_token: ${3:# u}
		msg: ${4:# t}
		to_number: ${5:# o}
		from_number: ${6:# t}
		# media_url: # a
$0
endsnippet

snippet pushbullet "Sends notifications to Pushbullet" b
- name: $1
	pushbullet:
		api_key: ${2:# Push bullet API token}
		title: ${3:# Title of the notification.}
		# channel: # The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.
		# device: # The device NAME you wish to send a push notification, as seen on the Pushbullet main page.
		# push_type: #note|link
		# body: # Body of the notification, e.g. Details of the fault you're alerting.
$0
endsnippet

snippet say "Makes a computer to speak." b
- name: $1
	say:
		msg: ${2:# W}
		# voice: # W
$0
endsnippet

snippet slack "Send Slack notifications" b
- name: $1
	slack:
		token: ${2:# Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.}
		# domain: # Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.
		# msg: # Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(token).
		# username: Ansible
		# icon_url: # Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))
		# icon_emoji: # Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)
		# link_names: #1|0
		# parse: full|none
		# validate_certs: yes
		# color: #normal|good|warning|danger
		# attachments: # Define a list of attachments. This list mirrors the Slack JSON API.
$0
endsnippet

snippet rocketchat "Send notifications to Rocket Chat" b
- name: $1
	rocketchat:
		domain: ${2:# The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))}
		token: ${3:# Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.}
		# protocol: http|#https
		# msg: # Message to be sent.
		# channel: # Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specified during the creation of webhook.
		# username: Ansible
		# icon_url: https://www.ansible.com/favicon.ico
		# icon_emoji: # Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)
		# link_names: #1|0
		# validate_certs: yes
		# color: #normal|good|warning|danger
		# attachments: # Define a list of attachments.
$0
endsnippet

snippet logentries_msg "Send a message to logentries." b
- name: $1
	logentries_msg:
		token: ${2:# Log token.}
		msg: ${3:# The message body.}
		# api: data.logentries.com
		# port: 80
$0
endsnippet

snippet catapult "Send a sms / mms using the catapult bandwidth api" b
- name: $1
	catapult:
		src: ${2:# One of your catapult telephone numbers the message should come from (must be in E.164 format, like C(+19195551212)).}
		dest: ${3:# The phone number or numbers the message should be sent to (must be in E.164 format, like C(+19195551212)).}
		msg: ${4:# The contents of the text message (must be 2048 characters or less).}
		user_id: ${5:# User Id from Api account page.}
		api_token: ${6:# Api Token from Api account page.}
		api_secret: ${7:# Api Secret from Api account page.}
		# media: # For MMS messages, a media url to the location of the media to be sent with the message.
$0
endsnippet

snippet wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: 255.255.255.255
		# port: 7
$0
endsnippet

snippet imc_rest "Manage Cisco IMC hardware through its REST API" b
- name: $1
	imc_rest:
		hostname: ${2:# IP Address or hostname of Cisco IMC, resolvable by Ansible control host.}
		# username: admin
		# password: password
		# path: # Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.
		# content: # When used instead of C(path), sets the content of the API requests directly.
		# protocol: http|#https
		# timeout: 60
		# validate_certs: yes
$0
endsnippet

snippet stacki_host "Add or remove host to stacki front-end" b
- name: $1
	stacki_host:
		name: ${2:# Name of the host to be added to Stacki.}
		stacki_user: ${3:# Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.}
		stacki_password: ${4:# Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.}
		stacki_endpoint: ${5:# URL for the Stacki API Endpoint.}
		# prim_intf_mac: # MAC Address for the primary PXE boot network interface.
		# prim_intf_ip: # IP Address for the primary network interface.
		# prim_intf: # Name of the primary network interface.
		# force_install: # Set value to True to force node into install state if it already exists in stacki.
$0
endsnippet

snippet redfish_config "Manages Out-Of-Band controllers using Redfish APIs" b
- name: $1
	redfish_config:
		category: ${2:# Category to execute on OOB controller}
		command: ${3:# List of commands to execute on OOB controller}
		baseuri: ${4:# Base URI of OOB controller}
		user: ${5:# User for authentication with OOB controller}
		password: ${6:# Password for authentication with OOB controller}
		# bios_attr_name: null
		# bios_attr_value: null
		# mgr_attr_name: null
		# mgr_attr_value: null
$0
endsnippet

snippet redfish_facts "Manages Out-Of-Band controllers using Redfish APIs" b
- name: $1
	redfish_facts:
		baseuri: ${2:# Base URI of OOB controller}
		user: ${3:# User for authentication with OOB controller}
		password: ${4:# Password for authentication with OOB controller}
		# category: ['Systems']
		# command: # List of commands to execute on OOB controller
$0
endsnippet

snippet redfish_command "Manages Out-Of-Band controllers using Redfish APIs" b
- name: $1
	redfish_command:
		category: ${2:# Category to execute on OOB controller}
		command: ${3:# List of commands to execute on OOB controller}
		baseuri: ${4:# Base URI of OOB controller}
		user: ${5:# User for authentication with OOB controller}
		password: ${6:# Password for authentication with OOB controller}
		# userid: # ID of user to add/delete/modify
		# username: # name of user to add/delete/modify
		# userpswd: # password of user to add/delete/modify
		# userrole: # role of user to add/delete/modify
		# bootdevice: # bootdevice when setting boot configuration
$0
endsnippet

snippet oneview_san_manager "Manage OneView SAN Manager resources" b
- name: $1
	oneview_san_manager:
		data: ${2:# List with SAN Manager properties.}
		# state: #present|absent|connection_information_set
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_fcoe_network "Manage OneView FCoE Network resources" b
- name: $1
	oneview_fcoe_network:
		data: ${2:# List with FCoE Network properties.}
		# state: #present|absent
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_fcoe_network_facts "Retrieve the facts about one or more of the OneView FCoE Networks" b
- name: $1
	oneview_fcoe_network_facts:
		# name: # FCoE Network name.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_datacenter_facts "Retrieve facts about the OneView Data Centers" b
- name: $1
	oneview_datacenter_facts:
		# name: # Data Center name.
		# options: # Retrieve additional facts. Options available: 'visualContent'.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_enclosure_facts "Retrieve facts about one or more Enclosures" b
- name: $1
	oneview_enclosure_facts:
		# name: # Enclosure name.
		# options: # List with options to gather additional facts about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_san_manager_facts "Retrieve facts about one or more of the OneView SAN Managers" b
- name: $1
	oneview_san_manager_facts:
		# provider_display_name: # Provider Display Name.
		# params: # List of params to delimit, filter and sort the list of resources.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
$0
endsnippet

snippet oneview_logical_interconnect_group "Manage OneView Logical Interconnect Group resources" b
- name: $1
	oneview_logical_interconnect_group:
		data: ${2:# List with the Logical Interconnect Group properties.}
		# state: absent|#present
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_ethernet_network_facts "Retrieve the facts about one or more of the OneView Ethernet Networks" b
- name: $1
	oneview_ethernet_network_facts:
		# name: # Ethernet Network name.
		# options: # List with options to gather additional facts about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_logical_interconnect_group_facts "Retrieve facts about one or more of the OneView Logical Interconnect Groups" b
- name: $1
	oneview_logical_interconnect_group_facts:
		# name: # Logical Interconnect Group name.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_network_set "Manage HPE OneView Network Set resources" b
- name: $1
	oneview_network_set:
		data: ${2:# List with the Network Set properties.}
		# state: #present|absent
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_fc_network "Manage OneView Fibre Channel Network resources." b
- name: $1
	oneview_fc_network:
		data: ${2:# List with the Fibre Channel Network properties.}
		# state: present|absent
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_ethernet_network "Manage OneView Ethernet Network resources" b
- name: $1
	oneview_ethernet_network:
		data: ${2:# List with Ethernet Network properties.}
		# state: #present|absent|default_bandwidth_reset
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# validate_etag: yes
$0
endsnippet

snippet oneview_network_set_facts "Retrieve facts about the OneView Network Sets" b
- name: $1
	oneview_network_set_facts:
		# name: # Network Set name.
		# options: # List with options to gather facts about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet oneview_fc_network_facts "Retrieve the facts about one or more of the OneView Fibre Channel Networks" b
- name: $1
	oneview_fc_network_facts:
		# name: # Fibre Channel Network name.
		# config: # Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.
		# params: # List of params to delimit, filter and sort the list of resources.
$0
endsnippet

snippet cobbler_sync "Sync Cobbler" b
- name: $1
	cobbler_sync:
		password: ${2:# The password to log in to Cobbler.}
		# host: 127.0.0.1
		# port: # Port number to be used for REST connection.
		# username: cobbler
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet cobbler_system "Manage system objects in Cobbler" b
- name: $1
	cobbler_system:
		password: ${2:# The password to log in to Cobbler.}
		# host: 127.0.0.1
		# port: # Port number to be used for REST connection.
		# username: cobbler
		# use_ssl: yes
		# validate_certs: yes
		# name: # The system name to manage.
		# properties: # A dictionary with system properties.
		# interfaces: # A list of dictionaries containing interface options.
		# sync: no
		# state: absent|#present|query
$0
endsnippet

snippet katello "Manage Katello Resources" b
- name: $1
	katello:
		server_url: ${2:# URL of Foreman server.}
		username: ${3:# Username on Foreman server.}
		password: ${4:# Password for user accessing Foreman server.}
		entity: ${5:repository|manifest|repository_set|sync_plan|content_view|lifecycle_environment|activation_key}
		params: ${6:# Parameters associated to the entity resource and action, to set or edit in dictionary format.}
		# action: sync|publish|promote
		# task_timeout: 1000
		# verify_ssl: no
$0
endsnippet

snippet foreman "Manage Foreman Resources" b
- name: $1
	foreman:
		server_url: ${2:# URL of Foreman server.}
		username: ${3:# Username on Foreman server.}
		password: ${4:# Password for user accessing Foreman server.}
		entity: ${5:# The Foreman resource that the action will be performed on (e.g. organization, host).}
		params: ${6:# Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description).}
$0
endsnippet

snippet hpilo_boot "Boot system using specific media through HP iLO interface" b
- name: $1
	hpilo_boot:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# login: Administrator
		# password: admin
		# media: cdrom|floppy|hdd|#network|normal|usb
		# image: # The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename
		# state: boot_always|#boot_once|connect|disconnect|no_boot|poweroff
		# force: no
		# ssl_version: SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2
$0
endsnippet

snippet hpilo_facts "Gather facts through an HP iLO interface" b
- name: $1
	hpilo_facts:
		host: ${2:# The HP iLO hostname/address that is linked to the physical system.}
		# login: Administrator
		# password: admin
		# ssl_version: SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2
$0
endsnippet

snippet hponcfg "Configure HP iLO interface using hponcfg" b
- name: $1
	hponcfg:
		path: ${2:# The XML file as accepted by hponcfg.}
		# minfw: # The minimum firmware level needed.
		# executable: hponcfg
		# verbose: no
$0
endsnippet

snippet cpm_user "Get various status and parameters from WTI OOB and PDU devices" b
- name: $1
	cpm_user:
		cpm_action: ${2:getuser|adduser|edituser|deleteuser}
		cpm_url: ${3:# This is the URL of the WTI device to send the module.}
		cpm_username: ${4:# This is the Basic Authentication Username of the WTI device to send the module.}
		cpm_password: ${5:# This is the Basic Authentication Password of the WTI device to send the module.}
		user_name: ${6:# This is the User Name that needs to be create/modified/deleted}
		# use_https: yes
		# validate_certs: yes
		# use_proxy: no
		# user_pass: # This is the User Password that needs to be create/modified/deleted
		# user_accesslevel: 0|1|2|3
		# user_accessssh: 0|1
		# user_accessserial: 0|1
		# user_accessweb: 0|1
		# user_accessapi: 0|1
		# user_accessmonitor: 0|1
		# user_accessoutbound: 0|1
		# user_portaccess: # If AccessLevel is lower than Administrator, which ports the user has access
		# user_plugaccess: # If AccessLevel is lower than Administrator, which plugs the user has access
		# user_groupaccess: # If AccessLevel is lower than Administrator, which Groups the user has access
		# user_callbackphone: # This is the Call Back phone number used for POTS modem connections
$0
endsnippet

snippet ucs_vsans "Configures VSANs on Cisco UCS Manager" b
- name: $1
	ucs_vsans:
		name: ${2:# The name assigned to the VSAN.}
		vsan_id: ${3:# The unique identifier assigned to the VSAN.}
		vlan_id: ${4:# The unique string identifier assigned to the VLAN used for Fibre Channel connections.}
		hostname: ${5:# IP address or hostname of Cisco UCS Manager.}
		password: ${6:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# fc_zoning: #disabled|enabled
		# fabric: #common|A|B
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_lan_connectivity "Configures LAN Connectivity Policies on Cisco UCS Manager" b
- name: $1
	ucs_lan_connectivity:
		name: ${2:# The name of the LAN Connectivity Policy.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # A description of the LAN Connectivity Policy.
		# vnic_list: # List of vNICs used by the LAN Connectivity Policy.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_san_connectivity "Configures SAN Connectivity Policies on Cisco UCS Manager" b
- name: $1
	ucs_san_connectivity:
		name: ${2:# The name of the SAN Connectivity Policy.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # A description of the policy.
		# wwnn_pool: default
		# vhba_list: # List of vHBAs used by the SAN Connectivity Policy.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_wwn_pool "Configures WWNN or WWPN pools on Cisco UCS Manager" b
- name: $1
	ucs_wwn_pool:
		name: ${2:# The name of the World Wide Node Name (WWNN) or World Wide Port Name (WWPN) pool.}
		purpose: ${3:node|port}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		password: ${5:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # A description of the WWNN or WWPN pool.
		# order: #default|sequential
		# first_addr: # The first initiator in the World Wide Name (WWN) block.
		# last_addr: # The last initiator in the Worlde Wide Name (WWN) block.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_vhba_template "Configures vHBA templates on Cisco UCS Manager" b
- name: $1
	ucs_vhba_template:
		name: ${2:# The name of the virtual HBA template.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # A user-defined description of the template.
		# fabric: #A|B
		# redundancy_type: #none|primary|secondary
		# vsan: default
		# template_type: #initial-template|updating-template
		# max_data: 2048
		# wwpn_pool: default
		# qos_policy: # The QoS policy that is associated with vHBAs created from this template.
		# pin_group: # The SAN pin group that is associated with vHBAs created from this template.
		# stats_policy: default
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_vlans "Configures VLANs on Cisco UCS Manager" b
- name: $1
	ucs_vlans:
		name: ${2:# The name assigned to the VLAN.}
		id: ${3:# The unique string identifier assigned to the VLAN.}
		hostname: ${4:# IP address or hostname of Cisco UCS Manager.}
		password: ${5:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# multicast_policy: 
		# fabric: #common|A|B
		# sharing: #none|primary|isolated|community
		# native: yes|#no
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_ntp_server "Configures NTP server on Cisco UCS Manager" b
- name: $1
	ucs_ntp_server:
		hostname: ${2:# IP address or hostname of Cisco UCS Manager.}
		password: ${3:# Password for Cisco UCS Manager authentication.}
		# state: absent|#present
		# ntp_server: 
		# description: 
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_uuid_pool "Configures server UUID pools on Cisco UCS Manager" b
- name: $1
	ucs_uuid_pool:
		name: ${2:# The name of the UUID pool.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # The user-defined description of the UUID pool.
		# prefix: # UUID prefix used for the range of server UUIDs.
		# order: #default|sequential
		# first_uuid: # The first UUID in the block of UUIDs.
		# last_uuid: # The last UUID in the block of UUIDs.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_vnic_template "Configures vNIC templates on Cisco UCS Manager" b
- name: $1
	ucs_vnic_template:
		name: ${2:# The name of the vNIC template.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# description: # A user-defined description of the vNIC template.
		# fabric: #A|B|A-B|B-A
		# redundancy_type: #none|primary|secondary
		# peer_redundancy_template: # The Peer Redundancy Template.
		# target: adapter
		# template_type: #initial-template|updating-template
		# vlans_list: # List of VLANs used by the vNIC template.
		# cdn_source: #vnic-name|user-defined
		# cdn_name: # CDN Name used when cdn_source is set to user-defined.
		# mtu: 1500
		# mac_pool: # The MAC address pool that vNICs created from this vNIC template should use.
		# qos_policy: # The quality of service (QoS) policy that vNICs created from this vNIC template should use.
		# network_control_policy: # The network control policy that vNICs created from this vNIC template should use.
		# pin_group: # The LAN pin group that vNICs created from this vNIC template should use.
		# stats_policy: default
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_storage_profile "Configures storage profiles on Cisco UCS Manager" b
- name: $1
	ucs_storage_profile:
		name: ${2:# The name of the storage profile.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: absent|#present
		# description: # The user-defined description of the storage profile.
		# local_luns: # List of Local LUNs used by the storage profile.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_timezone "Configures timezone on Cisco UCS Manager" b
- name: $1
	ucs_timezone:
		hostname: ${2:# IP address or hostname of Cisco UCS Manager.}
		password: ${3:# Password for Cisco UCS Manager authentication.}
		# state: absent|#present
		# admin_state: disabled|#enabled
		# description: 
		# timezone: # The timezone name.
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_ip_pool "Configures IP address pools on Cisco UCS Manager" b
- name: $1
	ucs_ip_pool:
		name: ${2:# The name of the IP address pool.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# descrption: # The user-defined description of the IP address pool.
		# order: #default|sequential
		# first_addr: # The first IPv4 address in the IPv4 addresses block.
		# last_addr: # The last IPv4 address in the IPv4 addresses block.
		# subnet_mask: 255.255.255.0
		# default_gw: 0.0.0.0
		# primary_dns: 0.0.0.0
		# secondary_dns: 0.0.0.0
		# ipv6_first_addr: # The first IPv6 address in the IPv6 addresses block.
		# ipv6_last_addr: # The last IPv6 address in the IPv6 addresses block.
		# ipv6_prefix: 64
		# ipv6_default_gw: ::
		# ipv6_primary_dns: ::
		# ipv6_secondary_dns: ::
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ucs_mac_pool "Configures MAC address pools on Cisco UCS Manager" b
- name: $1
	ucs_mac_pool:
		name: ${2:# The name of the MAC pool.}
		hostname: ${3:# IP address or hostname of Cisco UCS Manager.}
		password: ${4:# Password for Cisco UCS Manager authentication.}
		# state: #present|absent
		# descrption: # A description of the MAC pool.
		# order: #default|sequential
		# first_addr: # The first MAC address in the block of addresses.
		# last_addr: # The last MAC address in the block of addresses.
		# org_dn: org-root
		# username: admin
		# port: # Port number to be used during connection (by default uses 443 for https and 80 for http connection).
		# use_ssl: yes
		# use_proxy: yes
		# proxy: # If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'
$0
endsnippet

snippet ipmi_boot "Management of order of boot devices" b
- name: $1
	ipmi_boot:
		name: ${2:# Hostname or ip address of the BMC.}
		user: ${3:# Username to use to connect to the BMC.}
		password: ${4:# Password to connect to the BMC.}
		bootdev: ${5:network -- Request network boot|floppy -- Boot from floppy|hd -- Boot from hard drive|safe -- Boot from hard drive, requesting 'safe mode'|optical -- boot from CD/DVD/BD drive|setup -- Boot into setup utility|default -- remove any IPMI directed boot device request}
		# port: 623
		# state: present -- Request system turn on|absent -- Request system turn on
		# persistent: no
		# uefiboot: no
$0
endsnippet

snippet ipmi_power "Power management for machine" b
- name: $1
	ipmi_power:
		name: ${2:# Hostname or ip address of the BMC.}
		user: ${3:# Username to use to connect to the BMC.}
		password: ${4:# Password to connect to the BMC.}
		state: ${5:on -- Request system turn on|off -- Request system turn off without waiting for OS to shutdown|shutdown -- Have system request OS proper shutdown|reset -- Request system reset without waiting for OS|boot -- If system is off, then 'on', else 'reset'}
		# port: 623
		# timeout: 300
$0
endsnippet

snippet manageiq_tags "Management of resource tags in ManageIQ." b
- name: $1
	manageiq_tags:
		resource_type: ${2:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
		resource_name: ${3:# the relevant resource name in manageiq}
		manageiq_connection: ${4:# ManageIQ connection configuration information.}
		# state: absent|#present|list
		# tags: # tags - list of dictionaries, each includes 'name' and 'category' keys.
$0
endsnippet

snippet manageiq_user "Management of users in ManageIQ." b
- name: $1
	manageiq_user:
		userid: ${2:# The unique userid in manageiq, often mentioned as username.}
		manageiq_connection: ${3:# ManageIQ connection configuration information.}
		# state: absent|#present
		# name: # The users' full name.
		# password: # The users' password.
		# group: # The name of the group to which the user belongs.
		# email: # The users' E-mail address.
		# update_password: #always|on_create
$0
endsnippet

snippet manageiq_policies "Management of resource policy_profiles in ManageIQ." b
- name: $1
	manageiq_policies:
		resource_type: ${2:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
		resource_name: ${3:# the name of the resource to which the profile should be [un]assigned}
		manageiq_connection: ${4:# ManageIQ connection configuration information.}
		# state: absent|#present|list
		# policy_profiles: # list of dictionaries, each includes the policy_profile 'name' key.
$0
endsnippet

snippet manageiq_provider "Management of provider in ManageIQ." b
- name: $1
	manageiq_provider:
		name: ${2:# T}
		type: ${3:Openshift|Amazon|oVirt|VMware|Azure|Director|OpenStack|GCE}
		manageiq_connection: ${4:# ManageIQ connection configuration information.}
		# state: absent|#present|refresh
		# zone: default
		# provider_region: # T
		# host_default_vnc_port_start: # T
		# host_default_vnc_port_end: # T
		# subscription: # M
		# project: # G
		# azure_tenant_id: # T
		# tenant_mapping_enabled: no
		# api_version: v2|v3
		# provider: # D
		# metrics: # M
		# alerts: # A
		# ssh_keypair: # S
$0
endsnippet

snippet manageiq_alert_profiles "Configuration of alert profiles for ManageIQ" b
- name: $1
	manageiq_alert_profiles:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		# state: absent|#present
		# name: # The unique alert profile name in ManageIQ.
		# resource_type: Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer
		# alerts: # List of alert descriptions to assign to this profile.
		# notes: # Optional notes for this profile
$0
endsnippet

snippet manageiq_alerts "Configuration of alerts in ManageIQ" b
- name: $1
	manageiq_alerts:
		manageiq_connection: ${2:# ManageIQ connection configuration information.}
		# state: absent|#present
		# description: # The unique alert description in ManageIQ.
		# resource_type: Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer
		# expression_type: #hash|miq
		# expression: # The alert expression for ManageIQ.
		# enabled: # Enable or disable the alert. Required if state is "present".
		# options: # Additional alert options, such as notification type and frequency
$0
endsnippet

snippet nginx_status_facts "Retrieve nginx status facts." b
- name: $1
	nginx_status_facts:
		url: ${2:# URL of the nginx status.}
		# timeout: 10
$0
endsnippet

snippet jenkins_job_facts "Get facts about Jenkins jobs" b
- name: $1
	jenkins_job_facts:
		# name: # Exact name of the Jenkins job to fetch facts about.
		# glob: # A shell glob of Jenkins job names to fetch facts about.
		# color: # Only fetch jobs with the given status color.
		# password: # Password to authenticate with the Jenkins server.
		# token: # API token used to authenticate with the Jenkins server.
		# url: http://localhost:8080
		# user: # User to authenticate with the Jenkins server.
		# validate_certs: yes
$0
endsnippet

snippet supervisorctl "Manage the state of a program or group of programs running via supervisord" b
- name: $1
	supervisorctl:
		name: ${2:# The name of the supervisord program or group to manage.}
		state: ${3:present|started|stopped|restarted|absent}
		# config: # The supervisor configuration file path
		# server_url: # URL on which supervisord server is listening
		# username: # username to use for authentication
		# password: # password to use for authentication
		# supervisorctl_path: # path to supervisorctl executable
$0
endsnippet

snippet htpasswd "manage user files for basic authentication" b
- name: $1
	htpasswd:
		path: ${2:# Path to the file that contains the usernames and passwords}
		name: ${3:# User name to add or remove}
		# password: # Password associated with user.
		# crypt_scheme: #apr_md5_crypt|des_crypt|ldap_sha1|plaintext
		# state: #present|absent
		# create: yes
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet jboss "deploy applications to JBoss" b
- name: $1
	jboss:
		deployment: ${2:# The name of the deployment}
		# src: # The remote path of the application ear or war to deploy
		# deploy_path: /var/lib/jbossas/standalone/deployments
		# state: #present|absent
$0
endsnippet

snippet apache2_module "Enables/disables a module of the Apache2 webserver." b
- name: $1
	apache2_module:
		name: ${2:# Name of the module to enable/disable as given to C(a2enmod/a2dismod).}
		# identifier: # Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending C(_module) to I(name) as well as custom exception for popular modules.
		# force: no
		# state: #present|absent
		# ignore_configcheck: no
$0
endsnippet

snippet taiga_issue "Creates/deletes an issue in a Taiga Project Management Platform" b
- name: $1
	taiga_issue:
		project: ${2:# Name of the project containing the issue. Must exist previously.}
		subject: ${3:# The issue subject.}
		issue_type: ${4:# The issue type. Must exist previously.}
		# taiga_host: https://api.taiga.io
		# priority: Normal
		# status: New
		# severity: Normal
		# description: 
		# attachment: # Path to a file to be attached to the issue.
		# attachment_description: 
		# tags: []
		# state: #present|absent
$0
endsnippet

snippet rundeck_project "Manage Rundeck projects." b
- name: $1
	rundeck_project:
		name: ${2:# Sets the project name.}
		url: ${3:# Sets the rundeck instance URL.}
		token: ${4:# Sets the token to authenticate against Rundeck API.}
		# state: #present|absent
		# api_version: 14
$0
endsnippet

snippet gunicorn "Run gunicorn with various settings." b
- name: $1
	gunicorn:
		app: ${2:# The app module. A name refers to a WSGI callable that should be found in the specified module.}
		# venv: # Path to the virtualenv directory.
		# config: # Path to the gunicorn configuration file.
		# chdir: # Chdir to specified directory before apps loading.
		# pid: # A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn.
		# worker: sync|eventlet|gevent|tornado |gthread|gaiohttp
		# user: # Switch worker processes to run as this user.
$0
endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance" b
- name: $1
	jenkins_script:
		script: ${2:# The groovy script to be executed. This gets passed as a string Template if args is defined.}
		# url: http://localhost:8080
		# validate_certs: yes
		# user: # The username to connect to the jenkins server with.
		# password: # The password to connect to the jenkins server with.
		# timeout: 10
		# args: # A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).
$0
endsnippet

snippet jenkins_job "Manage jenkins jobs" b
- name: $1
	jenkins_job:
		name: ${2:# Name of the Jenkins job.}
		# config: # config in XML format.
		# enabled: # Whether the job should be enabled or disabled.
		# password: # Password to authenticate with the Jenkins server.
		# state: #present|absent
		# token: # API token used to authenticate alternatively to password.
		# url: http://localhost:8080
		# user: # User to authenticate with the Jenkins server.
$0
endsnippet

snippet django_manage "Manages a Django application." b
- name: $1
	django_manage:
		command: ${2:cleanup|collectstatic|flush|loaddata|migrate|runfcgi|syncdb|test|validate}
		app_path: ${3:# The path to the root of the Django application where B(manage.py) lives.}
		# settings: # The Python path to the application's settings module, such as 'myapp.settings'.
		# pythonpath: # A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.
		# virtualenv: # An optional path to a I(virtualenv) installation to use while running the manage application.
		# apps: # A list of space-delimited apps to target. Used by the 'test' command.
		# cache_table: # The name of the table used for database-backed caching. Used by the 'createcachetable' command.
		# clear: no
		# database: # The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands.
		# failfast: no
		# fixtures: # A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command.
		# skip: # Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)
		# merge: # Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command
		# link: # Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command
$0
endsnippet

snippet jira "create and modify issues in a JIRA instance" b
- name: $1
	jira:
		uri: ${2:# Base URI for the JIRA instance.}
		operation: ${3:create|comment|edit|fetch|transition|link}
		username: ${4:# The username to log-in with.}
		password: ${5:# The password to log-in with.}
		# project: # The project for this operation. Required for issue creation.
		# summary: # The issue summary, where appropriate.
		# description: # The issue description, where appropriate.
		# issuetype: # The issue type, for issue creation.
		# issue: # An existing issue key to operate on.
		# comment: # The comment text to add.
		# status: # The desired status; only relevant for the transition operation.
		# assignee: # Sets the assignee on create or transition operations. Note not all transitions will allow this.
		# linktype: # Set type of link, when action 'link' selected.
		# inwardissue: # Set issue from which link will be created.
		# outwardissue: # Set issue to which link will be created.
		# fields: # This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet jenkins_plugin "Add or remove Jenkins plugin" b
- name: $1
	jenkins_plugin:
		# group: jenkins
		# jenkins_home: /var/lib/jenkins
		# mode: # File mode applied on versioned plugins.
		# name: # Plugin name.
		# owner: jenkins
		# state: absent|#present|pinned|unpinned|enabled|disabled|latest
		# timeout: 30
		# updates_expiration: 86400
		# updates_url: https://updates.jenkins-ci.org
		# url: http://localhost:8080
		# version: # Plugin version number.
		# with_dependencies: yes
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# validate_certs: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet apache2_mod_proxy "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool" b
- name: $1
	apache2_mod_proxy:
		balancer_vhost: ${2:# (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.}
		# balancer_url_suffix: /balancer-manager/
		# member_host: # (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.
		# state: present|absent|enabled|disabled|drained|hot_standby|ignore_errors
		# tls: no
		# validate_certs: yes
$0
endsnippet

snippet deploy_helper "Manages some of the steps common in deploying projects." b
- name: $1
	deploy_helper:
		path: ${2:# the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact.}
		# state: #present|finalize|absent|clean|query
		# release: # the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).
		# releases_path: releases
		# shared_path: shared
		# current_path: current
		# unfinished_filename: DEPLOY_UNFINISHED
		# clean: yes
		# keep_releases: 5
$0
endsnippet

snippet rundeck_acl_policy "Manage Rundeck ACL policies." b
- name: $1
	rundeck_acl_policy:
		name: ${2:# Sets the project name.}
		url: ${3:# Sets the rundeck instance URL.}
		token: ${4:# Sets the token to authenticate against Rundeck API.}
		# state: #present|absent
		# api_version: 14
		# project: # Sets the project which receive the ACL policy.
		# policy: # Sets the ACL policy content.
$0
endsnippet

snippet ejabberd_user "Manages users for ejabberd servers" b
- name: $1
	ejabberd_user:
		username: ${2:# the name of the user to manage}
		host: ${3:# the ejabberd host associated with this username}
		# password: # the password to assign to the username
		# logging: no
		# state: #present|absent
$0
endsnippet

snippet tower_team "create, update, or destroy Ansible Tower team." b
- name: $1
	tower_team:
		name: ${2:# Name to use for the team.}
		organization: ${3:# Organization the team should be made a member of.}
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_role "create, update, or destroy Ansible Tower role." b
- name: $1
	tower_role:
		role: ${2:admin|read|member|execute|adhoc|update|use|auditor}
		# user: # User that receives the permissions specified by the role.
		# team: # Team that receives the permissions specified by the role.
		# target_team: # Team that the role acts on.
		# inventory: # Inventory the role acts on.
		# job_template: # The job template the role acts on.
		# credential: # Credential the role acts on.
		# organization: # Organization the role acts on.
		# project: # Project the role acts on.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_inventory "create, update, or destroy Ansible Tower inventory." b
- name: $1
	tower_inventory:
		name: ${2:# The name to use for the inventory.}
		organization: ${3:# Organization the inventory belongs to.}
		# description: # The description to use for the inventory.
		# variables: # Inventory variables. Use C(@) to get from file.
		# kind: #|smart
		# host_filter: # The host_filter field. Only useful when C(kind=smart).
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_credential "create, update, or destroy Ansible Tower credential." b
- name: $1
	tower_credential:
		name: ${2:# The name to use for the credential.}
		kind: ${3:ssh|vault|net|scm|aws|vmware|satellite6|cloudforms|gce|azure_rm|openstack|rhv|insights|tower}
		# description: # The description to use for the credential.
		# user: # User that should own this credential.
		# team: # Team that should own this credential.
		# project: # Project that should for this credential.
		# organization: # Organization that should own the credential.
		# host: # Host for this credential.
		# username: # Username for this credential. access_key for AWS.
		# password: # Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX.
		# ssh_key_data: # Path to SSH private key.
		# ssh_key_unlock: # Unlock password for ssh_key. Use ASK for prompting.
		# authorize: no
		# authorize_password: # Password for net credentials that require authorize.
		# client: # Client or application ID for azure_rm type.
		# security_token: # STS token for aws type.
		# secret: # Secret token for azure_rm type.
		# subscription: # Subscription ID for azure_rm type.
		# tenant: # Tenant ID for azure_rm type.
		# domain: # Domain for openstack type.
		# become_method: None|sudo|su|pbrun|pfexec|pmrun
		# become_username: # Become username. Use ASK for prompting.
		# become_password: # Become password. Use ASK for prompting.
		# vault_password: # Vault password. Use ASK for prompting.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_label "create, update, or destroy Ansible Tower label." b
- name: $1
	tower_label:
		name: ${2:# Name to use for the label.}
		organization: ${3:# Organization the label should be applied to.}
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_group "create, update, or destroy Ansible Tower group." b
- name: $1
	tower_group:
		name: ${2:# The name to use for the group.}
		inventory: ${3:# Inventory the group should be made a member of.}
		# description: # The description to use for the group.
		# variables: # Variables to use for the group, use C(@) for a file.
		# credential: # Credential to use for the group.
		# source: manual|file|ec2|rax|vmware|gce|azure|azure_rm|openstack|satellite6|cloudforms|custom
		# source_regions: # Regions for cloud provider.
		# source_vars: # Override variables from source with variables from this field.
		# instance_filters: # Comma-separated list of filter expressions for matching hosts.
		# group_by: # Limit groups automatically created from inventory source.
		# source_script: # Inventory script to be used when group type is C(custom).
		# overwrite: no
		# overwrite_vars: # Override vars in child groups and hosts with those from external source.
		# update_on_launch: no
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_job_cancel "Cancel an Ansible Tower Job." b
- name: $1
	tower_job_cancel:
		job_id: ${2:# ID of the job to cancel}
		# fail_if_not_running: no
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_host "create, update, or destroy Ansible Tower host." b
- name: $1
	tower_host:
		name: ${2:# The name to use for the host.}
		inventory: ${3:# Inventory the host should be made a member of.}
		# description: # The description to use for the host.
		# enabled: yes
		# variables: # Variables to use for the host. Use C(@) for a file.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_credential_type "Create, update, or destroy custom Ansible Tower credential type." b
- name: $1
	tower_credential_type:
		name: ${2:# The name of the credential type.}
		# description: # The description of the credential type to give more detail about it.
		# kind: ssh|vault|net|scm|cloud|insights
		# inputs: # Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.
		# injectors: # Enter injectors using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.
		# state: #present|absent
		# tower_verify_ssl: yes
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_user "create, update, or destroy Ansible Tower user." b
- name: $1
	tower_user:
		username: ${2:# The username of the user.}
		email: ${3:# Email address of the user.}
		# first_name: # First name of the user.
		# last_name: # Last name of the user.
		# password: # Password of the user.
		# superuser: no
		# auditor: no
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_inventory_source "create, update, or destroy Ansible Tower inventory source." b
- name: $1
	tower_inventory_source:
		name: ${2:# The name to use for the inventory source.}
		inventory: ${3:# The inventory the source is linked to.}
		source: ${4:file|scm|ec2|gce|azure|azure_rm|vmware|satellite6|cloudforms|openstack|rhv|tower|custom}
		# description: # The description to use for the inventory source.
		# credential: # Credential to use to retrieve the inventory from.
		# source_vars: # The source_vars allow to Override variables found in the source config file. For example with Openstack, specifying *private: false* would change the output of the openstack.py script. It has to be YAML or JSON.
		# timeout: # Number in seconds after which the Tower API methods will time out.
		# source_project: # Use a *project* as a source for the *inventory*.
		# source_path: # Path to the file to use as a source in the selected *project*.
		# update_on_project_update: # That parameter will sync the inventory when the project is synced. It can only be used with a SCM source.
		# source_regions: # List of regions for your cloud provider. You can include multiple all regions. Only Hosts associated with the selected regions will be updated. Refer to Ansible Tower documentation for more detail.
		# instance_filters: # Provide a comma-separated list of filter expressions. Hosts are imported when all of the filters match. Refer to Ansible Tower documentation for more detail.
		# group_by: # Specify which groups to create automatically. Group names will be created similar to the options selected. If blank, all groups above are created. Refer to Ansible Tower documentation for more detail.
		# source_script: # The source custom script to use to build the inventory. It needs to exist.
		# overwrite: # If set, any hosts and groups that were previously present on the external source but are now removed will be removed from the Tower inventory. Hosts and groups that were not managed by the inventory source will be promoted to the next manually created group or if there is no manually created group to promote them into, they will be left in the "all" default group for the inventory. When not checked, local child hosts and groups not found on the external source will remain untouched by the inventory update process.
		# overwrite_vars: # If set, all variables for child groups and hosts will be removed and replaced by those found on the external source. When not checked, a merge will be performed, combining local variables with those found on the external source.
		# update_on_launch: # Each time a job runs using this inventory, refresh the inventory from the selected source before executing job tasks.
		# update_cache_timeout: # Time in seconds to consider an inventory sync to be current. During job runs and callbacks the task system will evaluate the timestamp of the latest sync. If it is older than Cache Timeout, it is not considered current, and a new inventory sync will be performed.
		# state: #present|absent
		# tower_verify_ssl: yes
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_organization "create, update, or destroy Ansible Tower organizations" b
- name: $1
	tower_organization:
		name: ${2:# Name to use for the organization.}
		# description: # The description to use for the organization.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_job_list "List Ansible Tower jobs." b
- name: $1
	tower_job_list:
		# status: pending|waiting|running|error|failed|canceled|successful
		# page: # Page number of the results to fetch.
		# all_pages: no
		# query: # Query used to further filter the list of jobs. C({"foo":"bar"}) will be passed at C(?foo=bar)
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_job_launch "Launch an Ansible Job." b
- name: $1
	tower_job_launch:
		job_template: ${2:# Name of the job template to use.}
		# job_explanation: # Job explanation field.
		# job_type: run|check|scan
		# inventory: # Inventory to use for the job, only used if prompt for inventory is set.
		# credential: # Credential to use for job, only used if prompt for credential is set.
		# extra_vars: # Extra_vars to use for the job_template. Prepend C(@) if a file.
		# limit: # Limit to use for the I(job_template).
		# tags: # Specific tags to use for from playbook.
		# use_job_endpoint: no
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_workflow_template "create, update, or destroy Ansible Tower workflow template." b
- name: $1
	tower_workflow_template:
		name: ${2:# The name to use for the workflow.}
		# allow_simultaneous: # If enabled, simultaneous runs of this job template will be allowed.
		# description: # The description to use for the workflow.
		# extra_vars: # Extra variables used by Ansible in YAML or key=value format.

		# organization: # The organization the workflow is linked to.
		# schema: # The schema is a JSON- or YAML-formatted string defining the hierarchy structure that connects the nodes. Refer to Tower documentation for more information.

		# survey_enabled: # Setting that variable will prompt the user for job type on the workflow launch.
		# survey: # The definition of the survey associated to the workflow.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_project "create, update, or destroy Ansible Tower projects" b
- name: $1
	tower_project:
		name: ${2:# Name to use for the project.}
		# description: # Description to use for the project.
		# scm_type: #manual|git|hg|svn
		# scm_url: # URL of SCM resource.
		# local_path: # The server playbook directory for manual projects.
		# scm_branch: # The branch to use for the SCM resource.
		# scm_credential: # Name of the credential to use with this SCM resource.
		# scm_clean: no
		# scm_delete_on_update: no
		# scm_update_on_launch: no
		# organization: # Primary key of organization for project.
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_job_template "create, update, or destroy Ansible Tower job template." b
- name: $1
	tower_job_template:
		name: ${2:# Name to use for the job template.}
		job_type: ${3:run|check|scan}
		project: ${4:# Name of the project to use for the job template.}
		playbook: ${5:# Path to the playbook to use for the job template within the project provided.}
		# description: # Description to use for the job template.
		# inventory: # Name of the inventory to use for the job template.
		# credential: # Name of the credential to use for the job template.
		# vault_credential: # Name of the vault credential to use for the job template.
		# forks: # The number of parallel or simultaneous processes to use while executing the playbook.
		# limit: # A host pattern to further constrain the list of hosts managed or affected by the playbook
		# verbosity: #0|1|2|3|4
		# extra_vars_path: # Path to the C(extra_vars) YAML file.
		# job_tags: # Comma separated list of the tags to use for the job template.
		# force_handlers_enabled: no
		# skip_tags: # Comma separated list of the tags to skip for the job template.
		# start_at_task: # Start the playbook at the task matching this name.
		# fact_caching_enabled: no
		# host_config_key: # Allow provisioning callbacks using this host config key.
		# ask_diff_mode: no
		# ask_extra_vars: no
		# ask_limit: no
		# ask_tags: no
		# ask_skip_tags: no
		# ask_job_type: no
		# ask_verbosity: no
		# ask_inventory: no
		# ask_credential: no
		# survey_enabled: no
		# become_enabled: no
		# concurrent_jobs_enabled: no
		# state: #present|absent
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_settings "Modify Ansible Tower settings." b
- name: $1
	tower_settings:
		# name: # Name of setting to get/modify
		# value: # Value to be modified for given setting.
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet tower_job_wait "Wait for Ansible Tower job to finish." b
- name: $1
	tower_job_wait:
		job_id: ${2:# ID of the job to monitor.}
		# min_interval: 1
		# max_interval: 30
		# timeout: # Maximum time in seconds to wait for a job to finish.
		# tower_host: # URL to your Tower instance.
		# tower_username: # Username for your Tower instance.
		# tower_password: # Password for your Tower instance.
		# tower_verify_ssl: yes
		# tower_config_file: # Path to the Tower config file. See notes.
$0
endsnippet

snippet dellos10_config "Manage Dell EMC Networking OS10 configuration sections" b
- name: $1
	dellos10_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# update: #merge|check
		# save: no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos10_facts "Collect facts from remote devices running Dell EMC Networking OS10" b
- name: $1
	dellos10_facts:
		# gather_subset: ['!config']
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos10_command "Run commands on remote devices running Dell OS10" b
- name: $1
	dellos10_command:
		commands: ${2:# List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet aireos_config "Manage Cisco WLC configurations" b
- name: $1
	aireos_config:
		# lines: # The ordered set of commands that should be configured. The commands must be the exact same commands as found in the device run-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|none
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# save: no
		# save_when: always|#never|changed
		# diff_against: intended|running
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet aireos_command "Run commands on remote devices running Cisco WLC" b
- name: $1
	aireos_command:
		commands: ${2:# List of commands to send to the remote aireos device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet ftd_file_download "Downloads files from Cisco FTD devices over HTTP(S)" b
- name: $1
	ftd_file_download:
		operation: ${2:# The name of the operation to execute.}
		destination: ${3:# Absolute path of where to download the file to.}
		# path_params: # Key-value pairs that should be sent as path parameters in a REST API call.
$0
endsnippet

snippet ftd_file_upload "Uploads files to Cisco FTD devices over HTTP(S)" b
- name: $1
	ftd_file_upload:
		operation: ${2:# The name of the operation to execute.}
		file_to_upload: ${3:# Absolute path to the file that should be uploaded.}
		# register_as: # Specifies Ansible fact name that is used to register received response from the FTD device.
$0
endsnippet

snippet ftd_configuration "Manages configuration on Cisco FTD devices over REST API" b
- name: $1
	ftd_configuration:
		operation: ${2:# The name of the operation to execute. Commonly, the operation starts with 'add', 'edit', 'get', 'upsert' or 'delete' verbs, but can have an arbitrary name too.}
		# data: # Key-value pairs that should be sent as body parameters in a REST API call
		# query_params: # Key-value pairs that should be sent as query parameters in a REST API call.
		# path_params: # Key-value pairs that should be sent as path parameters in a REST API call.
		# register_as: # Specifies Ansible fact name that is used to register received response from the FTD device.
		# filters: # Key-value dict that represents equality filters. Every key is a property name and value is its desired value. If multiple filters are present, they are combined with logical operator AND.
$0
endsnippet

snippet ce_vxlan_gateway "Manages gateway for the VXLAN network on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_gateway:
		# dfs_id: # Specifies the ID of a DFS group. The value must be 1.
		# dfs_source_ip: # Specifies the IPv4 address bound to a DFS group. The value is in dotted decimal notation.
		# dfs_source_vpn: # Specifies the name of a VPN instance bound to a DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# dfs_udp_port: # Specifies the UDP port number of the DFS group. The value is an integer that ranges from 1025 to 65535.
		# dfs_all_active: enable|disable
		# dfs_peer_ip: # Configure the IP address of an all-active gateway peer. The value is in dotted decimal notation.
		# dfs_peer_vpn: # Specifies the name of the VPN instance that is associated with all-active gateway peer. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# vpn_instance: # Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# vpn_vni: # Specifies a VNI ID. Binds a VXLAN network identifier (VNI) to a virtual private network (VPN) instance. The value is an integer ranging from 1 to 16000000.
		# vbdif_name: # Full name of VBDIF interface, i.e. Vbdif100.
		# vbdif_bind_vpn: # Specifies the name of the VPN instance that is associated with the interface. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# vbdif_mac: # Specifies a MAC address for a VBDIF interface. The value is in the format of H-H-H. Each H is a 4-digit hexadecimal number, such as C(00e0) or C(fc01). If an H contains less than four digits, 0s are added ahead. For example,  C(e0) is equal to C(00e0). A MAC address cannot be all 0s or 1s or a multicast MAC address.
		# arp_distribute_gateway: enable|disable
		# arp_direct_route: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_stp "Manages STP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_stp:
		# state: #present|absent
		# stp_mode: stp|rstp|mstp
		# stp_enable: enable|disable
		# stp_converge: fast|normal
		# bpdu_protection: enable|disable
		# tc_protection: enable|disable
		# tc_protection_interval: # Set the time the MSTP device takes to handle the maximum number of TC BPDUs and immediately refresh forwarding entries. The value is an integer ranging from 1 to 600, in seconds.
		# tc_protection_threshold: # Set the maximum number of TC BPDUs that the MSTP can handle. The value is an integer ranging from 1 to 255. The default value is 1 on the switch.
		# interface: # Interface name. If the value is C(all), will apply configuration to all interfaces. if the value is a special name, only support input the full name.
		# edged_port: enable|disable
		# bpdu_filter: enable|disable
		# cost: # Set the path cost of the current port. The default instance is 0.
		# root_protection: enable|disable
		# loop_protection: enable|disable
$0
endsnippet

snippet ce_info_center_debug "Manages information center debug configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_debug:
		# state: #present|absent
		# debug_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
		# module_name: # Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
		# channel_id: # Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# debug_enable: #no_use|true|false
		# debug_level: emergencies|alert|critical|error|warning|notification|informational|debugging
$0
endsnippet

snippet ce_netconf "Run an arbitrary netconf command on HUAWEI CloudEngine switches." b
- name: $1
	ce_netconf:
		rpc: ${2:get|edit-config|execute-action|execute-cli}
		cfg_xml: ${3:# The config xml string.}
$0
endsnippet

snippet ce_snmp_location "Manages SNMP location configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_location:
		location: ${2:# Location information.}
		# state: #present|absent
$0
endsnippet

snippet ce_netstream_export "Manages netstream export on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_export:
		type: ${2:ip|vxlan}
		# source_ip: # Specifies source address which can be IPv6 or IPv4 of the exported NetStream packet.
		# host_ip: # Specifies destination address which can be IPv6 or IPv4 of the exported NetStream packet.
		# host_port: # Specifies the destination UDP port number of the exported packets. The value is an integer that ranges from 1 to 65535.
		# host_vpn: # Specifies the VPN instance of the exported packets carrying flow statistics. Ensure the VPN instance has been created on the device.
		# version: 5|9
		# as_option: origin|peer
		# bgp_nexthop: enable|#disable
		# state: #present|absent
$0
endsnippet

snippet ce_bgp_neighbor "Manages BGP peer configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor:
		vrf_name: ${2:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		peer_addr: ${3:# Connection address of a peer, which can be an IPv4 or IPv6 address.}
		remote_as: ${4:# AS number of a peer. The value is a string of 1 to 11 characters.}
		# state: #present|absent
		# description: # Description of a peer, which can be letters or digits. The value is a string of 1 to 80 characters.
		# fake_as: # Fake AS number that is specified for a local peer. The value is a string of 1 to 11 characters.
		# dual_as: #no_use|true|false
		# conventional: #no_use|true|false
		# route_refresh: #no_use|true|false
		# is_ignore: #no_use|true|false
		# local_if_name: # Name of a source interface that sends BGP packets. The value is a string of 1 to 63 characters.
		# ebgp_max_hop: # Maximum number of hops in an indirect EBGP connection. The value is an ranging from 1 to 255.
		# valid_ttl_hops: # Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. The value is an integer ranging from 1 to 255.
		# connect_mode: # The value can be Connect-only, Listen-only, or Both.
		# is_log_change: #no_use|true|false
		# pswd_type: null|cipher|simple
		# pswd_cipher_text: # The character string in a password identifies the contents of the password, spaces not supported. The value is a string of 1 to 255 characters.
		# keep_alive_time: # Specify the Keepalive time of a peer or peer group. The value is an integer ranging from 0 to 21845. The default value is 60.
		# hold_time: # Specify the Hold time of a peer or peer group. The value is 0 or an integer ranging from 3 to 65535.
		# min_hold_time: # Specify the Min hold time of a peer or peer group.
		# key_chain_name: # Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string of 1 to 47 case-insensitive characters.
		# conn_retry_time: # ConnectRetry interval. The value is an integer ranging from 1 to 65535.
		# tcp_MSS: # Maximum TCP MSS value used for TCP connection establishment for a peer. The value is an integer ranging from 176 to 4096.
		# mpls_local_ifnet_disable: #no_use|true|false
		# prepend_global_as: #no_use|true|false
		# prepend_fake_as: #no_use|true|false
		# is_bfd_block: #no_use|true|false
		# multiplier: # Specify the detection multiplier. The default value is 3. The value is an integer ranging from 3 to 50.
		# is_bfd_enable: #no_use|true|false
		# rx_interval: # Specify the minimum interval at which BFD packets are received. The value is an integer ranging from 50 to 1000, in milliseconds.
		# tx_interval: # Specify the minimum interval at which BFD packets are sent. The value is an integer ranging from 50 to 1000, in milliseconds.
		# is_single_hop: #no_use|true|false
$0
endsnippet

snippet ce_eth_trunk "Manages Eth-Trunk interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_eth_trunk:
		trunk_id: ${2:# Eth-Trunk interface number. The value is an integer. The value range depends on the assign forward eth-trunk mode command. When 256 is specified, the value ranges from 0 to 255. When 512 is specified, the value ranges from 0 to 511. When 1024 is specified, the value ranges from 0 to 1023.}
		# mode: manual|lacp-dynamic|lacp-static
		# min_links: # Specifies the minimum number of Eth-Trunk member links in the Up state. The value is an integer ranging from 1 to the maximum number of interfaces that can be added to a Eth-Trunk interface.
		# hash_type: src-dst-ip|src-dst-mac|enhanced|dst-ip|dst-mac|src-ip|src-mac
		# members: # List of interfaces that will be managed in a given Eth-Trunk. The interface name must be full name.
		# force: no
		# state: #present|absent
$0
endsnippet

snippet ce_aaa_server_host "Manages AAA server host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server_host:
		# state: #present|absent
		# local_user_name: # Name of a local user. The value is a string of 1 to 253 characters.
		# local_password: # Login password of a user. The password can contain letters, numbers, and special characters. The value is a string of 1 to 255 characters.
		# local_service_type: # The type of local user login through, such as ftp ssh snmp telnet.
		# local_ftp_dir: # FTP user directory. The value is a string of 1 to 255 characters.
		# local_user_level: # Login level of a local user. The value is an integer ranging from 0 to 15.
		# local_user_group: # Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
		# radius_group_name: # RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
		# radius_server_type: Authentication|Accounting
		# radius_server_ip: # IPv4 address of configured server. The value is a string of 0 to 255 characters, in dotted decimal notation.
		# radius_server_ipv6: # IPv6 address of configured server. The total length is 128 bits.
		# radius_server_port: # Configured server port for a particular server. The value is an integer ranging from 1 to 65535.
		# radius_server_mode: Secondary-server|Primary-server
		# radius_vpn_name: # Set VPN instance. The value is a string of 1 to 31 case-sensitive characters.
		# radius_server_name: # Hostname of configured server. The value is a string of 0 to 255 case-sensitive characters.
		# hwtacacs_template: # Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
		# hwtacacs_server_ip: # Server IPv4 address. Must be a valid unicast IP address. The value is a string of 0 to 255 characters, in dotted decimal notation.
		# hwtacacs_server_ipv6: # Server IPv6 address. Must be a valid unicast IP address. The total length is 128 bits.
		# hwtacacs_server_type: Authentication|Authorization|Accounting|Common
		# hwtacacs_is_secondary_server: no
		# hwtacacs_vpn_name: # VPN instance name.
		# hwtacacs_is_public_net: no
		# hwtacacs_server_host_name: # Hwtacacs server host name.
$0
endsnippet

snippet ce_static_route "Manages static route configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_static_route:
		prefix: ${2:# Destination ip address of static route.}
		mask: ${3:# Destination ip mask of static route.}
		aftype: ${4:v4|v6}
		# next_hop: # Next hop address of static route.
		# nhp_interface: # Next hop interface full name of static route.
		# vrf: # VPN instance of destination ip address.
		# destvrf: # VPN instance of next hop ip address.
		# tag: # Route tag value (numeric).
		# description: # Name of the route. Used with the name parameter on the CLI.
		# pref: # Preference or administrative difference of route (range 1-255).
		# state: #present|absent
$0
endsnippet

snippet ce_ospf "Manages configuration of an OSPF instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf:
		process_id: ${2:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		# area: # Specifies the area ID. The area with the area-id being 0 is a backbone area. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.
		# addr: # Specifies the address of the network segment where the interface resides. The value is in dotted decimal notation.
		# mask: # IP network wildcard bits in decimal format between 0 and 32.
		# auth_mode: none|hmac-sha256|md5|hmac-md5|simple
		# auth_text_simple: # Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
		# auth_key_id: # Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
		# auth_text_md5: # Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
		# nexthop_addr: # IPv4 address for configure next-hop address's weight. Valid values are a string, formatted as an IP address.
		# nexthop_weight: # Indicates the weight of the next hop. The smaller the value is, the higher the preference of the route is. It is an integer that ranges from 1 to 254.
		# max_load_balance: # The maximum number of paths for forward packets over multiple paths. Valid value is an integer in the range from 1 to 64.
		# state: #present|absent
$0
endsnippet

snippet ce_aaa_server "Manages AAA server global configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_aaa_server:
		# state: #present|absent
		# authen_scheme_name: # Name of an authentication scheme. The value is a string of 1 to 32 characters.
		# first_authen_mode: invalid|local|hwtacacs|radius|none
		# author_scheme_name: # Name of an authorization scheme. The value is a string of 1 to 32 characters.
		# first_author_mode: invalid|local|hwtacacs|if-authenticated|none
		# acct_scheme_name: # Accounting scheme name. The value is a string of 1 to 32 characters.
		# accounting_mode: invalid|hwtacacs|radius|none
		# domain_name: # Name of a domain. The value is a string of 1 to 64 characters.
		# radius_server_group: # RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
		# hwtacas_template: # Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
		# local_user_group: # Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
$0
endsnippet

snippet ce_reboot "Reboot a HUAWEI CloudEngine switches." b
- name: $1
	ce_reboot:
		# confirm: no
		# save_config: no
$0
endsnippet

snippet ce_vxlan_tunnel "Manages VXLAN tunnel configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_tunnel:
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
		# vni_id: # Specifies a VXLAN network identifier (VNI) ID. The value is an integer ranging from 1 to 16000000.
		# nve_name: # Specifies the number of an NVE interface. The value ranges from 1 to 2.
		# nve_mode: mode-l2|mode-l3
		# peer_list_ip: # Specifies the IP address of a remote VXLAN tunnel endpoints (VTEP). The value is in dotted decimal notation.
		# protocol_type: bgp|null
		# source_ip: # Specifies an IP address for a source VTEP. The value is in dotted decimal notation.
		# state: #present|absent
$0
endsnippet

snippet ce_netstream_template "Manages NetStream template configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_template:
		type: ${2:ip|vxlan}
		# state: #present|absent
		# record_name: # Configure the name of netstream record. The value is a string of 1 to 32 case-insensitive characters.
		# match: destination-address|destination-port|tos|protocol|source-address|source-port
		# collect_counter: bytes|packets
		# collect_interface: input|output
		# description: # Configure the description of netstream record. The value is a string of 1 to 80 case-insensitive characters.
$0
endsnippet

snippet ce_evpn_bgp_rr "Manages RR for the VXLAN Network on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp_rr:
		as_number: ${2:# Specifies the number of the AS, in integer format. The value is an integer that ranges from 1 to 4294967295.}
		# bgp_instance: # Specifies the name of a BGP instance. The value of instance-name can be an integer 1 or a string of 1 to 31.
		# bgp_evpn_enable: #enable|disable
		# peer_type: group_name|ipv4_address
		# peer: # Specifies the IPv4 address or the group name of a peer.
		# reflect_client: enable|disable
		# policy_vpn_target: enable|disable
$0
endsnippet

snippet ce_link_status "Get interface link status on HUAWEI CloudEngine switches." b
- name: $1
	ce_link_status:
		interface: ${2:# For the interface parameter, you can enter C(all) to display information about all interface, an interface type such as C(40GE) to display information about interfaces of the specified type, or full name of an interface such as C(40GE1/0/22) or C(vlanif10) to display information about the specific interface.}
$0
endsnippet

snippet ce_info_center_log "Manages information center log configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_log:
		# log_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
		# log_buff_enable: #no_use|true|false
		# log_buff_size: # Specifies the maximum number of logs in the log buffer. The value is an integer that ranges from 0 to 10240. If logbuffer-size is 0, logs are not displayed.
		# module_name: # Specifies the name of a module. The value is a module name in registration logs.
		# channel_id: # Specifies a channel ID. The value is an integer ranging from 0 to 9.
		# log_enable: #no_use|true|false
		# log_level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# state: #present|absent
$0
endsnippet

snippet ce_snmp_traps "Manages SNMP traps configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_traps:
		# feature_name: aaa|arp|bfd|bgp|cfg|configuration|dad|devm|dhcpsnp|dldp|driver|efm|erps|error-down|fcoe|fei|fei_comm|fm|ifnet|info|ipsg|ipv6|isis|l3vpn|lacp|lcs|ldm|ldp|ldt|lldp|mpls_lspm|msdp|mstp|nd|netconf|nqa|nvo3|openflow|ospf|ospfv3|pim|pim-std|qos|radius|rm|rmon|securitytrap|smlktrap|snmp|ssh|stackmng|sysclock|sysom|system|tcp|telnet|trill|trunk|tty|vbst|vfs|virtual-perception|vrrp|vstm|all
		# trap_name: # Alarm trap name.
		# interface_type: Ethernet|Eth-Trunk|Tunnel|NULL|LoopBack|Vlanif|100GE|40GE|MTunnel|10GE|GE|MEth|Vbdif|Nve
		# interface_number: # Interface number.
		# port_number: # Source port number.
$0
endsnippet

snippet ce_snmp_community "Manages SNMP community configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_community:
		# acl_number: # Access control list number.
		# community_name: # Unique name to identify the community.
		# access_right: read|write
		# community_mib_view: # Mib view name.
		# group_name: # Unique name to identify the SNMPv3 group.
		# security_level: noAuthNoPriv|authentication|privacy
		# read_view: # Mib view name for read.
		# write_view: # Mib view name for write.
		# notify_view: # Mib view name for notification.
		# state: #present|absent
$0
endsnippet

snippet ce_netstream_global "Manages global parameters of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_global:
		interface: ${2:# Netstream global interface.}
		# type: #ip|vxlan
		# state: #present|absent
		# sampler_interval: # Specifies the netstream sampler interval, length is 1 - 65535.
		# sampler_direction: inbound|outbound
		# statistics_direction: inbound|outbound
		# statistics_record: # Specifies the flexible netstream statistic record, length is 1 - 32.
		# index_switch: #16|32
$0
endsnippet

snippet ce_vrrp "Manages VRRP interfaces on HUAWEI CloudEngine devices." b
- name: $1
	ce_vrrp:
		# interface: # Name of an interface. The value is a string of 1 to 63 characters.
		# vrid: present
		# virtual_ip: # Virtual IP address. The value is a string of 0 to 255 characters.
		# vrrp_type: normal|member|admin
		# admin_ignore_if_down: no
		# admin_vrid: # Tracked mVRRP ID. The value is an integer ranging from 1 to 255.
		# admin_interface: # Tracked mVRRP interface name. The value is a string of 1 to 63 characters.
		# admin_flowdown: no
		# priority: # Configured VRRP priority. The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.
		# version: v2|v3
		# advertise_interval: # Configured interval between sending advertisements, in milliseconds. Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.
		# preempt_timer_delay: # Preemption delay. The value is an integer ranging from 0 to 3600. The default value is 0.
		# gratuitous_arp_interval: # Interval at which gratuitous ARP packets are sent, in seconds. The value ranges from 30 to 1200.The default value is 300.
		# recover_delay: # Delay in recovering after an interface goes Up. The delay is used for interface flapping suppression. The value is an integer ranging from 0 to 3600. The default value is 0 seconds.
		# holding_multiplier: # The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.
		# auth_mode: simple|md5|none
		# is_plain: no
		# auth_key: # This object is set based on the authentication type. When noAuthentication is specified, the value is empty. When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters in plaintext and displayed as a blank text for security.
		# fast_resume: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_command "Run arbitrary command on HUAWEI CloudEngine devices." b
- name: $1
	ce_command:
		commands: ${2:# The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# match: all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet ce_snmp_user "Manages SNMP user configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_user:
		# acl_number: # Access control list number.
		# usm_user_name: # Unique name to identify the USM user.
		# aaa_local_user: # Unique name to identify the local user.
		# remote_engine_id: # Remote engine id of the USM user.
		# user_group: # Name of the group where user belongs to.
		# auth_protocol: noAuth|md5|sha
		# auth_key: # The authentication password. Password length, 8-255 characters.
		# priv_protocol: noPriv|des56|3des168|aes128|aes192|aes256
		# priv_key: # The encryption password. Password length 8-255 characters.
$0
endsnippet

snippet ce_bfd_session "Manages BFD session configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_session:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# create_type: static|auto
		# addr_type: ipv4
		# out_if_name: # Specifies the type and number of the interface bound to the BFD session.
		# dest_addr: # Specifies the peer IP address bound to the BFD session.
		# src_addr: # Indicates the source IP address carried in BFD packets.
		# vrf_name: # Specifies the name of a Virtual Private Network (VPN) instance that is bound to a BFD session. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value _public_ is reserved and cannot be used as the VPN instance name.
		# use_default_ip: no
		# state: #present|absent
$0
endsnippet

snippet ce_mlag_interface "Manages MLAG interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_interface:
		# eth_trunk_id: # Name of the local M-LAG interface. The value is ranging from 0 to 511.
		# dfs_group_id: present
		# mlag_id: # ID of the M-LAG. The value is an integer that ranges from 1 to 2048.
		# mlag_system_id: # M-LAG global LACP system MAC address. The value is a string of 0 to 255 characters. The default value is the MAC address of the Ethernet port of MPU.
		# mlag_priority_id: # M-LAG global LACP system priority. The value is an integer ranging from 0 to 65535. The default value is 32768.
		# interface: # Name of the interface that enters the Error-Down state when the peer-link fails. The value is a string of 1 to 63 characters.
		# mlag_error_down: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_mtu "Manages MTU settings on HUAWEI CloudEngine switches." b
- name: $1
	ce_mtu:
		# interface: # Full name of interface, i.e. 40GE1/0/22.
		# mtu: # MTU for a specific interface. The value is an integer ranging from 46 to 9600, in bytes.
		# jumbo_max: # Maximum frame size. The default value is 9216. The value is an integer and expressed in bytes. The value range is 1536 to 12224 for the CE12800 and 1536 to 12288 for ToR switches.
		# jumbo_min: # Non-jumbo frame size threshod. The default value is 1518. The value is an integer that ranges from 1518 to jumbo_max, in bytes.
		# state: #present|absent
$0
endsnippet

snippet ce_facts "Gets facts about HUAWEI CloudEngine switches." b
- name: $1
	ce_facts:
		# gather_subset: !config
$0
endsnippet

snippet ce_bfd_view "Manages BFD session view configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_view:
		session_name: ${2:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}
		# local_discr: # Specifies the local discriminator of a BFD session. The value is an integer that ranges from 1 to 16384.
		# remote_discr: # Specifies the remote discriminator of a BFD session. The value is an integer that ranges from 1 to 4294967295.
		# min_tx_interval: # Specifies the minimum interval for receiving BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
		# min_rx_interval: # Specifies the minimum interval for sending BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
		# detect_multi: # Specifies the local detection multiplier of a BFD session. The value is an integer that ranges from 3 to 50.
		# wtr_interval: # Specifies the WTR time of a BFD session. The value is an integer that ranges from 1 to 60, in minutes. The default value is 0.
		# tos_exp: # Specifies a priority for BFD control packets. The value is an integer ranging from 0 to 7. The default value is 7, which is the highest priority.
		# admin_down: no
		# description: # Specifies the description of a BFD session. The value is a string of 1 to 51 case-sensitive characters with spaces.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet ce_evpn_bd_vni "Manages EVPN VXLAN Network Identifier (VNI) on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bd_vni:
		bridge_domain_id: ${2:# Specify an existed bridge domain (BD).The value is an integer ranging from 1 to 16777215.}
		vpn_target_import: ${3:# Add VPN targets to the import VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}
		# evpn: #enable|disable
		# route_distinguisher: # Configures a route distinguisher (RD) for a BD EVPN instance. The format of an RD can be as follows
		# vpn_target_both: # Add VPN targets to both the import and export VPN target lists of a BD EVPN instance. The format is the same as route_distinguisher.
		# vpn_target_export: # Add VPN targets to the export VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.
		# state: #present|absent
$0
endsnippet

snippet ce_evpn_bgp "Manages BGP EVPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_bgp:
		bgp_instance: ${2:# Name of a BGP instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}
		# as_number: # Specifies integral AS number. The value is an integer ranging from 1 to 4294967295.
		# peer_address: # Specifies the IPv4 address of a BGP EVPN peer. The value is in dotted decimal notation.
		# peer_group_name: # Specify the name of a peer group that BGP peers need to join. The value is a string of 1 to 47 case-sensitive characters, spaces not supported.
		# peer_enable: true|false
		# advertise_router_type: arp|irb
		# vpn_name: # Associates a specified VPN instance with the IPv4 address family. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.
		# advertise_l2vpn_evpn: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_acl_advance "Manages advanced ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_advance:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 3000 to 3999 indicates a advance ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# state: #present|absent|delete_acl
		# acl_num: # ACL number. The value is an integer ranging from 3000 to 3999.
		# acl_step: # ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
		# acl_description: # ACL description. The value is a string of 1 to 127 characters.
		# rule_name: # Name of a basic ACL rule. The value is a string of 1 to 32 characters.
		# rule_id: # ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
		# rule_action: permit|deny
		# protocol: ip|icmp|igmp|ipinip|tcp|udp|gre|ospf
		# source_ip: # Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# src_mask: # Source IP address mask. The value is an integer ranging from 1 to 32.
		# src_pool_name: # Name of a source pool. The value is a string of 1 to 32 characters.
		# dest_ip: # Destination IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# dest_mask: # Destination IP address mask. The value is an integer ranging from 1 to 32.
		# dest_pool_name: # Name of a destination pool. The value is a string of 1 to 32 characters.
		# src_port_op: lt|eq|gt|range
		# src_port_begin: # Start port number of the source port. The value is an integer ranging from 0 to 65535.
		# src_port_end: # End port number of the source port. The value is an integer ranging from 0 to 65535.
		# src_port_pool_name: # Name of a source port pool. The value is a string of 1 to 32 characters.
		# dest_port_op: lt|eq|gt|range
		# dest_port_begin: # Start port number of the destination port. The value is an integer ranging from 0 to 65535.
		# dest_port_end: # End port number of the destination port. The value is an integer ranging from 0 to 65535.
		# dest_port_pool_name: # Name of a destination port pool. The value is a string of 1 to 32 characters.
		# frag_type: fragment|clear_fragment
		# precedence: # Data packets can be filtered based on the priority field. The value is an integer ranging from 0 to 7.
		# tos: # ToS value on which data packet filtering is based. The value is an integer ranging from 0 to 15.
		# dscp: # Differentiated Services Code Point. The value is an integer ranging from 0 to 63.
		# icmp_name: unconfiged|echo|echo-reply|fragmentneed-DFset|host-redirect|host-tos-redirect|host-unreachable|information-reply|information-request|net-redirect|net-tos-redirect|net-unreachable|parameter-problem|port-unreachable|protocol-unreachable|reassembly-timeout|source-quench|source-route-failed|timestamp-reply|timestamp-request|ttl-exceeded|address-mask-reply|address-mask-request|custom
		# icmp_type: # ICMP type. This parameter is available only when the packet protocol is ICMP. The value is an integer ranging from 0 to 255.
		# icmp_code: # ICMP message code. Data packets can be filtered based on the ICMP message code. The value is an integer ranging from 0 to 255.
		# ttl_expired: no
		# vrf_name: # VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
		# syn_flag: # TCP flag value. The value is an integer ranging from 0 to 63.
		# tcp_flag_mask: # TCP flag mask value. The value is an integer ranging from 0 to 63.
		# established: no
		# time_range: # Name of a time range in which an ACL rule takes effect.
		# rule_description: # Description about an ACL rule.
		# igmp_type: host-query|mrouter-adver|mrouter-solic|mrouter-termi|mtrace-resp|mtrace-route|v1host-report|v2host-report|v2leave-group|v3host-report
		# log_flag: no
$0
endsnippet

snippet ce_vxlan_global "Manages global attributes of VXLAN and bridge domain on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_global:
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
		# tunnel_mode_vxlan: enable|disable
		# nvo3_prevent_loops: enable|disable
		# nvo3_acl_extend: enable|disable
		# nvo3_gw_enhanced: l2|l3
		# nvo3_service_extend: enable|disable
		# nvo3_eth_trunk_hash: enable|disable
		# nvo3_ecmp_hash: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_startup "Manages a system startup information on HUAWEI CloudEngine switches." b
- name: $1
	ce_startup:
		# cfg_file: present
		# software_file: # File name of the system software that is applied for the next startup. The value is a string of 5 to 255 characters.
		# patch_file: # Name of the patch file that is applied for the next startup.
		# slot: # Position of the device.The value is a string of 1 to 32 characters. The possible value of slot is all, slave-board, or the specific slotID.
		# action: display
$0
endsnippet

snippet ce_netstream_aging "Manages timeout mode of NetStream on HUAWEI CloudEngine switches." b
- name: $1
	ce_netstream_aging:
		# timeout_interval: 30
		# type: ip|vxlan
		# state: #present|absent
		# timeout_type: active|inactive|tcp-session|manual
		# manual_slot: # Specifies the slot number of netstream manual timeout.
$0
endsnippet

snippet ce_vrf_interface "Manages interface specific VPN configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_interface:
		vrf: ${2:# VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_).}
		vpn_interface: ${3:# An interface that can binding VPN instance, i.e. 40GE1/0/22, Vlanif10. Must be fully qualified interface name. Interface types, such as 10GE, 40GE, 100GE, LoopBack, MEth, Tunnel, Vlanif....}
		# state: #present|absent
$0
endsnippet

snippet ce_acl "Manages base ACL configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 2999 indicates a basic ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		# state: #present|absent|delete_acl
		# acl_num: # ACL number. The value is an integer ranging from 2000 to 2999.
		# acl_step: # ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
		# acl_description: # ACL description. The value is a string of 1 to 127 characters.
		# rule_name: # Name of a basic ACL rule. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces or begin with an underscore (_).
		# rule_id: # ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
		# rule_action: permit|deny
		# source_ip: # Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
		# src_mask: # Mask of a source IP address. The value is an integer ranging from 1 to 32.
		# frag_type: fragment|clear_fragment
		# vrf_name: # VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
		# time_range: # Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces. The name must start with an uppercase or lowercase letter. In addition, the word "all" cannot be specified as a time range name.
		# rule_description: # Description about an ACL rule. The value is a string of 1 to 127 characters.
		# log_flag: no
$0
endsnippet

snippet ce_dldp_interface "Manages interface DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp_interface:
		interface: ${2:# Must be fully qualified interface name, i.e. GE1/0/1, 10GE1/0/1, 40GE1/0/22, 100GE1/0/1.}
		# enable: enable|disable
		# mode_enable: enable|disable
		# local_mac: # Set the source MAC address for DLDP packets sent in the DLDP-compatible mode. The value of MAC address is in H-H-H format. H contains 1 to 4 hexadecimal digits.
		# reset: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_vxlan_vap "Manages VXLAN virtual access point on HUAWEI CloudEngine Devices." b
- name: $1
	ce_vxlan_vap:
		# bridge_domain_id: # Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
		# bind_vlan_id: # Specifies the VLAN binding to a BD(Bridge Domain). The value is an integer ranging ranging from 1 to 4094.
		# l2_sub_interface: # Specifies an Sub-Interface full name, i.e. "10GE1/0/41.1". The value is a string of 1 to 63 case-insensitive characters, spaces supported.
		# encapsulation: dot1q|default|untag|qinq|none
		# ce_vid: # When I(encapsulation) is 'dot1q', specifies a VLAN ID in the outer VLAN tag. When I(encapsulation) is 'qinq', specifies an outer VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
		# pe_vid: # When I(encapsulation) is 'qinq', specifies an inner VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
		# state: #present|absent
$0
endsnippet

snippet ce_vxlan_arp "Manages ARP attributes of VXLAN on HUAWEI CloudEngine devices." b
- name: $1
	ce_vxlan_arp:
		# evn_bgp: enable|disable
		# evn_source_ip: # Specifies the source address of an EVN BGP peer. The value is in dotted decimal notation.
		# evn_peer_ip: # Specifies the IP address of an EVN BGP peer. The value is in dotted decimal notation.
		# evn_server: enable|disable
		# evn_reflect_client: enable|disable
		# vbdif_name: # Full name of VBDIF interface, i.e. Vbdif100.
		# arp_collect_host: enable|disable
		# host_collect_protocol: bgp|none
		# bridge_domain_id: # Specifies a BD(bridge domain) ID. The value is an integer ranging from 1 to 16777215.
		# arp_suppress: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_interface "Manages physical attributes of interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_interface:
		# interface: # Full name of interface, i.e. 40GE1/0/10, Tunnel1.
		# interface_type: ge|10ge|25ge|4x10ge|40ge|100ge|vlanif|loopback|meth|eth-trunk|nve|tunnel|ethernet|fcoe-port|fabric-port|stack-port|null
		# admin_state: up|down
		# description: # Specifies an interface description. The value is a string of 1 to 242 case-sensitive characters, spaces supported but question marks (?) not supported.
		# mode: layer2|layer3
		# l2sub: no
		# state: #present|absent|default
$0
endsnippet

snippet ce_rollback "Set a checkpoint or rollback to a checkpoint on HUAWEI CloudEngine switches." b
- name: $1
	ce_rollback:
		action: ${2:rollback|clear|set|display|commit}
		# commit_id: # Specifies the label of the configuration rollback point to which system configurations are expected to roll back. The value is an integer that the system generates automatically.
		# label: # Specifies a user label for a configuration rollback point. The value is a string of 1 to 256 case-sensitive ASCII characters, spaces not supported. The value must start with a letter and cannot be presented in a single hyphen (-).
		# filename: # Specifies a configuration file for configuration rollback. The value is a string of 5 to 64 case-sensitive characters in the format of *.zip, *.cfg, or *.dat, spaces not supported.
		# last: # Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
		# oldest: # Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
$0
endsnippet

snippet ce_snmp_contact "Manages SNMP contact configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_contact:
		contact: ${2:# Contact information.}
		# state: #present|absent
$0
endsnippet

snippet ce_ntp "Manages core NTP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp:
		# server: # Network address of NTP server.
		# peer: # Network address of NTP peer.
		# key_id: # Authentication key identifier to use with given NTP server or peer.
		# is_preferred: enable|disable
		# vpn_name: _public_
		# source_int: # Local source interface from which NTP messages are sent. Must be fully qualified interface name, i.e. C(40GE1/0/22), C(vlanif10). Interface types, such as C(10GE), C(40GE), C(100GE), C(Eth-Trunk), C(LoopBack), C(MEth), C(NULL), C(Tunnel), C(Vlanif).
		# state: #present|absent
$0
endsnippet

snippet ce_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_ip_interface:
		interface: ${2:# Full name of interface, i.e. 40GE1/0/22, vlanif10.}
		# addr: # IPv4 or IPv6 Address.
		# mask: # Subnet mask for IPv4 or IPv6 Address in decimal format.
		# version: #v4|v6
		# ipv4_type: #main|sub
		# state: #present|absent
$0
endsnippet

snippet ce_bgp_af "Manages BGP Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_af:
		vrf_name: ${2:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. The value is a string of 1 to 31 case-sensitive characters.}
		af_type: ${3:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		# state: #present|absent
		# max_load_ibgp_num: # Specify the maximum number of equal-cost IBGP routes. The value is an integer ranging from 1 to 65535.
		# ibgp_ecmp_nexthop_changed: #no_use|true|false
		# max_load_ebgp_num: # Specify the maximum number of equal-cost EBGP routes. The value is an integer ranging from 1 to 65535.
		# ebgp_ecmp_nexthop_changed: #no_use|true|false
		# maximum_load_balance: # Specify the maximum number of equal-cost routes in the BGP routing table. The value is an integer ranging from 1 to 65535.
		# ecmp_nexthop_changed: #no_use|true|false
		# default_local_pref: # Set the Local-Preference attribute. The value is an integer. The value is an integer ranging from 0 to 4294967295.
		# default_med: # Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer ranging from 0 to 4294967295.
		# default_rt_import_enable: #no_use|true|false
		# router_id: # ID of a router that is in IPv4 address format. The value is a string of 0 to 255 characters. The value is in dotted decimal notation.
		# vrf_rid_auto_sel: #no_use|true|false
		# nexthop_third_party: #no_use|true|false
		# summary_automatic: #no_use|true|false
		# auto_frr_enable: #no_use|true|false
		# load_balancing_as_path_ignore: #no_use|true|false
		# rib_only_enable: #no_use|true|false
		# rib_only_policy_name: # Specify the name of a routing policy. The value is a string of 1 to 40 characters.
		# active_route_advertise: #no_use|true|false
		# as_path_neglect: #no_use|true|false
		# med_none_as_maximum: #no_use|true|false
		# router_id_neglect: #no_use|true|false
		# igp_metric_ignore: #no_use|true|false
		# always_compare_med: #no_use|true|false
		# determin_med: #no_use|true|false
		# preference_external: # Set the protocol priority of EBGP routes. The value is an integer ranging from 1 to 255.
		# preference_internal: # Set the protocol priority of IBGP routes. The value is an integer ranging from 1 to 255.
		# preference_local: # Set the protocol priority of a local BGP route. The value is an integer ranging from 1 to 255.
		# prefrence_policy_name: # Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The value is a string of 1 to 40 characters.
		# reflect_between_client: #no_use|true|false
		# reflector_cluster_id: # Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. The value is an integer ranging from 1 to 4294967295.
		# reflector_cluster_ipv4: # Set a cluster ipv4 address. The value is expressed in the format of an IPv4 address.
		# rr_filter_number: # Set the number of the extended community filter supported by an RR group. The value is a string of 1 to 51 characters.
		# policy_vpn_target: #no_use|true|false
		# next_hop_sel_depend_type: #default|dependTunnel|dependIp
		# nhp_relay_route_policy_name: # Specify the name of a route-policy for route iteration. The value is a string of 1 to 40 characters.
		# ebgp_if_sensitive: #no_use|true|false
		# reflect_chg_path: #no_use|true|false
		# add_path_sel_num: # Number of Add-Path routes. The value is an integer ranging from 2 to 64.
		# route_sel_delay: # Route selection delay. The value is an integer ranging from 0 to 3600.
		# allow_invalid_as: #no_use|true|false
		# policy_ext_comm_enable: #no_use|true|false
		# supernet_uni_adv: #no_use|true|false
		# supernet_label_adv: #no_use|true|false
		# ingress_lsp_policy_name: # Ingress lsp policy name.
		# originator_prior: #no_use|true|false
		# lowest_priority: #no_use|true|false
		# relay_delay_enable: #no_use|true|false
		# import_protocol: direct|ospf|isis|static|rip|ospfv3|ripng
		# import_process_id: # Process ID of an imported routing protocol. The value is an integer ranging from 0 to 4294967295.
		# network_address: # Specify the IP address advertised by BGP. The value is a string of 0 to 255 characters.
		# mask_len: # Specify the mask length of an IP address. The value is an integer ranging from 0 to 128.
$0
endsnippet

snippet ce_bgp_neighbor_af "Manages BGP neighbor Address-family configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp_neighbor_af:
		vrf_name: ${2:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
		af_type: ${3:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
		remote_address: ${4:# IPv4 or IPv6 peer connection address.}
		# advertise_irb: #no_use|true|false
		# advertise_arp: #no_use|true|false
		# advertise_remote_nexthop: #no_use|true|false
		# advertise_community: #no_use|true|false
		# advertise_ext_community: #no_use|true|false
		# discard_ext_community: #no_use|true|false
		# allow_as_loop_enable: #no_use|true|false
		# allow_as_loop_limit: # Set the maximum number of repetitive local AS number. The value is an integer ranging from 1 to 10.
		# keep_all_routes: #no_use|true|false
		# nexthop_configure: null|local|invariable
		# preferred_value: # Assign a preferred value for the routes learned from a specified peer. The value is an integer ranging from 0 to 65535.
		# public_as_only: #no_use|true|false
		# public_as_only_force: #no_use|true|false
		# public_as_only_limited: #no_use|true|false
		# public_as_only_replace: #no_use|true|false
		# public_as_only_skip_peer_as: #no_use|true|false
		# route_limit: # Configure the maximum number of routes that can be accepted from a peer. The value is an integer ranging from 1 to 4294967295.
		# route_limit_percent: # Specify the percentage of routes when a router starts to generate an alarm. The value is an integer ranging from 1 to 100.
		# route_limit_type: noparameter|alertOnly|idleForever|idleTimeout
		# route_limit_idle_timeout: # Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold. The value is an integer ranging from 1 to 1200.
		# rt_updt_interval: # Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. The value is an integer ranging from 0 to 600.
		# redirect_ip: #no_use|true|false
		# redirect_ip_vaildation: #no_use|true|false
		# reflect_client: #no_use|true|false
		# substitute_as_enable: #no_use|true|false
		# import_rt_policy_name: # Specify the filtering policy applied to the routes learned from a peer. The value is a string of 1 to 40 characters.
		# export_rt_policy_name: # Specify the filtering policy applied to the routes to be advertised to a peer. The value is a string of 1 to 40 characters.
		# import_pref_filt_name: # Specify the IPv4 filtering policy applied to the routes received from a specified peer. The value is a string of 1 to 169 characters.
		# export_pref_filt_name: # Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. The value is a string of 1 to 169 characters.
		# import_as_path_filter: # Apply an AS_Path-based filtering policy to the routes received from a specified peer. The value is an integer ranging from 1 to 256.
		# export_as_path_filter: # Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The value is an integer ranging from 1 to 256.
		# import_as_path_name_or_num: # A routing strategy based on the AS path list for routing received by a designated peer.
		# export_as_path_name_or_num: # Application of a AS path list based filtering policy to the routing of a specified peer.
		# import_acl_name_or_num: # Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The value is a string of 1 to 32 characters.
		# export_acl_name_or_num: # Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The value is a string of 1 to 32 characters.
		# ipprefix_orf_enable: #no_use|true|false
		# is_nonstd_ipprefix_mod: #no_use|true|false
		# orftype: # ORF Type. The value is an integer ranging from 0 to 65535.
		# orf_mode: null|receive|send|both
		# soostring: # Configure the Site-of-Origin (SoO) extended community attribute. The value is a string of 3 to 21 characters.
		# default_rt_adv_enable: #no_use|true|false
		# default_rt_adv_policy: # Specify the name of a used policy. The value is a string. The value is a string of 1 to 40 characters.
		# default_rt_match_mode: null|matchall|matchany
		# add_path_mode: null|receive|send|both
		# adv_add_path_num: # The number of addPath advertise route. The value is an integer ranging from 2 to 64.
		# origin_as_valid: #no_use|true|false
		# vpls_enable: #no_use|true|false
		# vpls_ad_disable: #no_use|true|false
		# update_pkt_standard_compatible: #no_use|true|false
$0
endsnippet

snippet ce_switchport "Manages Layer 2 switchport interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_switchport:
		interface: ${2:# Full name of the interface, i.e. 40GE1/0/22.}
		# mode: access|trunk
		# access_vlan: # If C(mode=access), used as the access VLAN ID, in the range from 1 to 4094.
		# native_vlan: # If C(mode=trunk), used as the trunk native VLAN ID, in the range from 1 to 4094.
		# trunk_vlans: # If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.
		# state: #present|absent|unconfigured
$0
endsnippet

snippet ce_file_copy "Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches." b
- name: $1
	ce_file_copy:
		local_file: ${2:# Path to local file. Local directory must exist. The maximum length of I(local_file) is C(4096).}
		# remote_file: # Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used. The maximum length of I(remote_file) is C(4096).
		# file_system: flash:
$0
endsnippet

snippet ce_vrf_af "Manages VPN instance address family on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf_af:
		vrf: ${2:# VPN instance.}
		# vrf_aftype: #v4|v6
		# route_distinguisher: # VPN instance route distinguisher,the RD used to distinguish same route prefix from different vpn. The RD must be setted before setting vpn_target_value.
		# vpn_target_state: present|absent
		# vpn_target_type: export_extcommunity|import_extcommunity
		# vpn_target_value: # VPN instance target value. Such as X.X.X.X:number<0-65535> or number<0-65535>:number<0-4294967295> or number<0-65535>.number<0-65535>:number<0-65535> or number<65536-4294967295>:number<0-65535> but not support 0:0 and 0.0:0.
		# evpn: no
		# state: #present|absent
$0
endsnippet

snippet ce_info_center_trap "Manages information center trap configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_trap:
		# state: #present|absent
		# trap_time_stamp: date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond
		# trap_buff_enable: #no_use|true|false
		# trap_buff_size: # Size of a trap buffer. The value is an integer ranging from 0 to 1024. The default value is 256.
		# module_name: # Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
		# channel_id: # Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# trap_enable: #no_use|true|false
		# trap_level: emergencies|alert|critical|error|warning|notification|informational|debugging
$0
endsnippet

snippet ce_acl_interface "Manages applying ACLs to interfaces on HUAWEI CloudEngine switches." b
- name: $1
	ce_acl_interface:
		acl_name: ${2:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 4999. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
		interface: ${3:# Interface name. Only support interface full name, such as "40GE2/0/1".}
		direction: ${4:inbound|outbound}
		# state: #present|absent
$0
endsnippet

snippet ce_info_center_global "Manages outputting logs on HUAWEI CloudEngine switches." b
- name: $1
	ce_info_center_global:
		# info_center_enable: true|false
		# packet_priority: # Set the priority of the syslog packet.The value is an integer ranging from 0 to 7. The default value is 0.
		# suppress_enable: false|true
		# logfile_max_num: # Maximum number of log files of the same type. The default value is 200.
		# logfile_max_size: 4|8|16|32
		# channel_id: # Number for channel. The value is an integer ranging from 0 to 9. The default value is 0.
		# channel_cfg_name: console
		# channel_out_direct: console|monitor|trapbuffer|logbuffer|snmp|logfile
		# filter_feature_name: # Feature name of the filtered log. The value is a string of 1 to 31 case-insensitive characters.
		# filter_log_name: # Name of the filtered log. The value is a string of 1 to 63 case-sensitive characters.
		# ip_type: ipv4|ipv6
		# server_ip: # Log server address, IPv4 or IPv6 type. The value is a string of 0 to 255 characters. The value can be an valid IPv4 or IPv6 address.
		# server_domain: # Server name. The value is a string of 1 to 255 case-sensitive characters.
		# is_default_vpn: no
		# vrf_name: # VPN name on a log server. The value is a string of 1 to 31 case-sensitive characters. The default value is _public_.
		# level: emergencies|alert|critical|error|warning|notification|informational|debugging
		# server_port: # Number of a port sending logs.The value is an integer ranging from 1 to 65535. For UDP, the default value is 514. For TCP, the default value is 601. For TSL, the default value is 6514.
		# facility: local0|local1|local2|local3|local4|local5|local6|local7
		# channel_name: # Channel name. The value is a string of 1 to 30 case-sensitive characters.
		# timestamp: UTC|localtime
		# transport_mode: tcp|udp
		# ssl_policy_name: # SSL policy name. The value is a string of 1 to 23 case-sensitive characters.
		# source_ip: # Log source ip address, IPv4 or IPv6 type. The value is a string of 0 to 255. The value can be an valid IPv4 or IPv6 address.
		# state: #present|absent
$0
endsnippet

snippet ce_dldp "Manages global DLDP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_dldp:
		# enable: enable|disable
		# work_mode: enhance|normal
		# time_internal: # Specifies the interval for sending Advertisement packets. The value is an integer ranging from 1 to 100, in seconds. The default interval for sending Advertisement packets is 5 seconds.
		# auth_mode: md5|simple|sha|hmac-sha256|none
		# auth_pwd: # Specifies authentication password. The value is a string of 1 to 16 case-sensitive plaintexts or 24/32/48/108/128 case-sensitive encrypted characters. The string excludes a question mark (?).
		# reset: enable|disable
$0
endsnippet

snippet ce_bgp "Manages BGP configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_bgp:
		# state: #present|absent
		# as_number: # Local AS number. The value is a string of 1 to 11 characters.
		# graceful_restart: #no_use|true|false
		# time_wait_for_rib: # Period of waiting for the End-Of-RIB flag. The value is an integer ranging from 3 to 3000. The default value is 600.
		# as_path_limit: # Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
		# check_first_as: #no_use|true|false
		# confed_id_number: # Confederation ID. The value is a string of 1 to 11 characters.
		# confed_nonstanded: #no_use|true|false
		# bgp_rid_auto_sel: #no_use|true|false
		# keep_all_routes: #no_use|true|false
		# memory_limit: #no_use|true|false
		# gr_peer_reset: #no_use|true|false
		# is_shutdown: #no_use|true|false
		# suppress_interval: # Suppress interval.
		# hold_interval: # Hold interval.
		# clear_interval: # Clear interval.
		# confed_peer_as_num: # Confederation AS number, in two-byte or four-byte format. The value is a string of 1 to 11 characters.
		# vrf_name: # Name of a BGP instance. The name is a case-sensitive string of characters.
		# vrf_rid_auto_sel: #no_use|true|false
		# router_id: # ID of a router that is in IPv4 address format.
		# keepalive_time: # If the value of a timer changes, the BGP peer relationship between the routers is disconnected. The value is an integer ranging from 0 to 21845. The default value is 60.
		# hold_time: # Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535.
		# min_hold_time: # Min hold time, in seconds. The value of the hold time can be 0 or range from 20 to 65535.
		# conn_retry_time: # ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
		# ebgp_if_sensitive: #no_use|true|false
		# default_af_type: ipv4uni|ipv6uni
$0
endsnippet

snippet ce_config "Manage Huawei CloudEngine configuration sections." b
- name: $1
	ce_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device current-configuration.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# backup: no
		# config: # The module, by default, will connect to the remote device and retrieve the current current-configuration to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current-configuration for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# defaults: no
		# save: no
$0
endsnippet

snippet ce_evpn_global "Manages global configuration of EVPN on HUAWEI CloudEngine switches." b
- name: $1
	ce_evpn_global:
		evpn_overlay_enable: ${2:enable|disable}
$0
endsnippet

snippet ce_sflow "Manages sFlow configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_sflow:
		# agent_ip: # Specifies the IPv4/IPv6 address of an sFlow agent.
		# source_ip: # Specifies the source IPv4/IPv6 address of sFlow packets.
		# collector_id: 1|2
		# collector_ip: # Specifies the IPv4/IPv6 address of the sFlow collector.
		# collector_ip_vpn: # Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
		# collector_datagram_size: # Specifies the maximum length of sFlow packets sent from an sFlow agent to an sFlow collector. The value is an integer, in bytes. It ranges from 1024 to 8100. The default value is 1400.
		# collector_udp_port: # Specifies the UDP destination port number of sFlow packets. The value is an integer that ranges from 1 to 65535. The default value is 6343.
		# collector_meth: meth|enhanced
		# collector_description: # Specifies the description of an sFlow collector. The value is a string of 1 to 255 case-sensitive characters without spaces.
		# sflow_interface: # Full name of interface for Flow Sampling or Counter. It must be a physical interface, Eth-Trunk, or Layer 2 subinterface.
		# sample_collector: # Indicates the ID list of the collector.
		# sample_rate: # Specifies the flow sampling rate in the format 1/rate. The value is an integer and ranges from 1 to 4294967295. The default value is 8192.
		# sample_length: # Specifies the maximum length of sampled packets. The value is an integer and ranges from 18 to 512, in bytes. The default value is 128.
		# sample_direction: inbound|outbound|both
		# counter_collector: # Indicates the ID list of the counter collector.
		# counter_interval: # Indicates the counter sampling interval. The value is an integer that ranges from 10 to 4294967295, in seconds. The default value is 20.
		# export_route: enable|disable
		# rate_limit: # Specifies the rate of sFlow packets sent from a card to the control plane. The value is an integer that ranges from 100 to 1500, in pps.
		# rate_limit_slot: # Specifies the slot where the rate of output sFlow packets is limited. If this parameter is not specified, the rate of sFlow packets sent from all cards to the control plane is limited. The value is an integer or a string of characters.
		# forward_enp_slot: # Enable the Embedded Network Processor (ENP) chip function. The switch uses the ENP chip to perform sFlow sampling, and the maximum sFlow sampling interval is 65535. If you set the sampling interval to be larger than 65535, the switch automatically restores it to 65535. The value is an integer or 'all'.
		# state: #present|absent
$0
endsnippet

snippet ce_snmp_target_host "Manages SNMP target host configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_snmp_target_host:
		# version: none|v1|v2c|v3|v1v2c|v1v3|v2cv3|all
		# connect_port: # Udp port used by SNMP agent to connect the Network management.
		# host_name: # Unique name to identify target host entry.
		# address: # Network Address.
		# notify_type: trap|inform
		# vpn_name: # VPN instance Name.
		# recv_port: # UDP Port number used by network management to receive alarm messages.
		# security_model: v1|v2c|v3
		# security_name: # Security Name.
		# security_name_v3: # Security Name V3.
		# security_level: noAuthNoPriv|authentication|privacy
		# is_public_net: #no_use|true|false
		# interface_name: # Name of the interface to send the trap message.
$0
endsnippet

snippet ce_vlan "Manages VLAN resources and attributes on Huawei CloudEngine switches." b
- name: $1
	ce_vlan:
		# vlan_id: # Single VLAN ID, in the range from 1 to 4094.
		# vlan_range: # Range of VLANs such as C(2-10) or C(2,5,10-15), etc.
		# name: # Name of VLAN, minimum of 1 character, maximum of 31 characters.
		# description: # Specify VLAN description, minimum of 1 character, maximum of 80 characters.
		# state: #present|absent
$0
endsnippet

snippet ce_ospf_vrf "Manages configuration of an OSPF VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_ospf_vrf:
		ospf: ${2:# The ID of the ospf process. Valid values are an integer, 1 - 4294967295, the default value is 1.}
		# route_id: # Specifies the ospf private route id,. Valid values are a string, formatted as an IP address (i.e. "10.1.1.1") the length is 0 - 20.
		# vrf: _public_
		# description: # Specifies the description information of ospf process.
		# bandwidth: # Specifies the reference bandwidth used to assign ospf cost. Valid values are an integer, in Mbps, 1 - 2147483648, the default value is 100.
		# lsaalflag: no
		# lsaainterval: # Specifies the interval of arrive LSA when use the general timer. Valid value is an integer, in millisecond, from 0 to 10000.
		# lsaamaxinterval: # Specifies the max interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 1000.
		# lsaastartinterval: # Specifies the start interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
		# lsaaholdinterval: # Specifies the hold interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
		# lsaointervalflag: no
		# lsaointerval: # Specifies the interval of originate LSA . Valid value is an integer, in second, from 0 to 10, the default value is 5.
		# lsaomaxinterval: # Specifies the max interval of originate LSA . Valid value is an integer, in millisecond, from 1 to 10000, the default value is 5000.
		# lsaostartinterval: # Specifies the start interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 1000, the default value is 500.
		# lsaoholdinterval: # Specifies the hold interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 5000, the default value is 1000.
		# spfintervaltype: #intelligent-timer|timer|millisecond
		# spfinterval: # Specifies the interval to calculate SPF when use second level  timer. Valid value is an integer, in second, from 1 to 10.
		# spfintervalmi: # Specifies the interval to calculate SPF when use millisecond level  timer. Valid value is an integer, in millisecond, from 1 to 10000.
		# spfmaxinterval: # Specifies the max interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 20000, the default value is 5000.
		# spfstartinterval: # Specifies the start interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 1000, the default value is 50.
		# spfholdinterval: # Specifies the hold interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 5000, the default value is 200.
		# state: #present|absent
$0
endsnippet

snippet ce_vrf "Manages VPN instance on HUAWEI CloudEngine switches." b
- name: $1
	ce_vrf:
		vrf: ${2:# VPN instance, the length of vrf name is 1 - 31, i.e. "test", but can not be C(_public_).}
		# description: # Description of the vrf, the string length is 1 - 242 .
		# state: #present|absent
$0
endsnippet

snippet ce_interface_ospf "Manages configuration of an OSPF interface instanceon HUAWEI CloudEngine switches." b
- name: $1
	ce_interface_ospf:
		interface: ${2:# Full name of interface, i.e. 40GE1/0/10.}
		process_id: ${3:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
		area: ${4:# Ospf area associated with this ospf process. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}
		# cost: # The cost associated with this interface. Valid values are an integer in the range from 1 to 65535.
		# hello_interval: # Time between sending successive hello packets. Valid values are an integer in the range from 1 to 65535.
		# dead_interval: # Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer in the range from 1 to 235926000.
		# silent_interface: no
		# auth_mode: none|null|hmac-sha256|md5|hmac-md5|simple
		# auth_text_simple: # Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
		# auth_key_id: # Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
		# auth_text_md5: # Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
		# state: #present|absent
$0
endsnippet

snippet ce_ntp_auth "Manages NTP authentication configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_ntp_auth:
		key_id: ${2:# Authentication key identifier (numeric).}
		# auth_pwd: # Plain text with length of 1 to 255, encrypted text with length of 20 to 392.
		# auth_mode: hmac-sha256|md5
		# auth_type: text|#encrypt
		# trusted_key: enable|#disable
		# authentication: enable|disable
		# state: #present|absent
$0
endsnippet

snippet ce_bfd_global "Manages BFD global configuration on HUAWEI CloudEngine devices." b
- name: $1
	ce_bfd_global:
		# bfd_enable: enable|disable
		# default_ip: # Specifies the default multicast IP address. The value ranges from 224.0.0.107 to 224.0.0.250.
		# tos_exp_dynamic: # Indicates the priority of BFD control packets for dynamic BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
		# tos_exp_static: # Indicates the priority of BFD control packets for static BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
		# damp_init_wait_time: # Specifies an initial flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 2000.
		# damp_max_wait_time: # Specifies a maximum flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 15000.
		# damp_second_wait_time: # Specifies a secondary flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 5000.
		# delay_up_time: # Specifies the delay before a BFD session becomes Up. The value is an integer ranging from 1 to 600, in seconds. The default value is 0, indicating that a BFD session immediately becomes Up.
		# state: #present|absent
$0
endsnippet

snippet ce_mlag_config "Manages MLAG configuration on HUAWEI CloudEngine switches." b
- name: $1
	ce_mlag_config:
		# dfs_group_id: present
		# nickname: # The nickname bound to a DFS group. The value is an integer that ranges from 1 to 65471.
		# pseudo_nickname: # A pseudo nickname of a DFS group. The value is an integer that ranges from 1 to 65471.
		# pseudo_priority: # The priority of a pseudo nickname. The value is an integer that ranges from 128 to 255. The default value is 192. A larger value indicates a higher priority.
		# ip_address: # IP address bound to the DFS group. The value is in dotted decimal notation.
		# vpn_instance_name: # Name of the VPN instance bound to the DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value _public_ is reserved and cannot be used as the VPN instance name.
		# priority_id: # Priority of a DFS group. The value is an integer that ranges from 1 to 254. The default value is 100.
		# eth_trunk_id: # Name of the peer-link interface. The value is in the range from 0 to 511.
		# peer_link_id: # Number of the peer-link interface. The value is 1.
		# state: #present|absent
$0
endsnippet

snippet net_lldp_interface "Manage LLDP interfaces configuration on network devices" b
- name: $1
	net_lldp_interface:
		# name: # Name of the interface LLDP should be configured on.
		# aggregate: # L
		# purge: no
		# state: #present|absent|enabled|disabled
$0
endsnippet

snippet net_interface "Manage Interface on network devices" b
- name: $1
	net_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: # Configure interface link status.
		# speed: # Interface link speed.
		# mtu: # Maximum size of transmit packet.
		# duplex: full|half|#auto
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# delay: 10
		# aggregate: # L
		# purge: no
		# state: #present|absent|up|down
$0
endsnippet

snippet net_linkagg "Manage link aggregation groups on network devices" b
- name: $1
	net_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# mode: on|active|passive
		# min_links: # Minimum members that should be up before bringing up the link aggregation group.
		# aggregate: # L
		# purge: no
		# state: #present|absent|up|down
$0
endsnippet

snippet ipadm_addrprop "Manage IP address properties on Solaris/illumos systems." b
- name: $1
	ipadm_addrprop:
		addrobj: ${2:# Specifies the address object we want to manage.}
		property: ${3:# Specifies the name of the address property we want to manage.}
		# value: # Specifies the value we want to set for the address property.
		# temporary: no
		# state: #present|absent|reset
$0
endsnippet

snippet ipadm_ifprop "Manage IP interface properties on Solaris/illumos systems." b
- name: $1
	ipadm_ifprop:
		interface: ${2:# Specifies the IP interface we want to manage.}
		protocol: ${3:# Specifies the procotol for which we want to manage properties.}
		property: ${4:# Specifies the name of the property we want to manage.}
		# value: # Specifies the value we want to set for the property.
		# temporary: no
		# state: #present|absent|reset
$0
endsnippet

snippet dladm_vlan "Manage VLAN interfaces on Solaris/illumos systems." b
- name: $1
	dladm_vlan:
		name: ${2:# VLAN interface name.}
		link: ${3:# VLAN underlying link name.}
		# temporary: no
		# vlan_id: no
		# state: #present|absent
$0
endsnippet

snippet ipadm_if "Manage IP interfaces  on Solaris/illumos systems." b
- name: $1
	ipadm_if:
		name: ${2:# IP interface name.}
		# temporary: no
		# state: #present|absent|enabled|disabled
$0
endsnippet

snippet dladm_linkprop "Manage link properties on Solaris/illumos systems." b
- name: $1
	dladm_linkprop:
		link: ${2:# Link interface name.}
		property: ${3:# Specifies the name of the property we want to manage.}
		# value: # Specifies the value we want to set for the link property.
		# temporary: no
		# state: #present|absent|reset
$0
endsnippet

snippet dladm_iptun "Manage IP tunnel interfaces on Solaris/illumos systems." b
- name: $1
	dladm_iptun:
		name: ${2:# IP tunnel interface name.}
		# temporary: no
		# type: #ipv4|ipv6|6to4
		# local_address: # Literat IP address or hostname corresponding to the tunnel source.
		# remote_address: # Literal IP address or hostname corresponding to the tunnel destination.
		# state: #present|absent
$0
endsnippet

snippet flowadm "Manage bandwidth resource control and priority for protocols, services and zones on Solaris/illumos systems" b
- name: $1
	flowadm:
		name: ${2:# -}
		# link: # Specifiies a link to configure flow on.
		# local_ip: # Identifies a network flow by the local IP address.
		# remote_ip: # Identifies a network flow by the remote IP address.
		# transport: # -
		# local_port: # Identifies a service specified by the local port.
		# dsfield: # -
		# maxbw: # -
		# priority: low|#medium|high
		# temporary: no
		# state: absent|#present|resetted
$0
endsnippet

snippet dladm_vnic "Manage VNICs on Solaris/illumos systems." b
- name: $1
	dladm_vnic:
		name: ${2:# VNIC name.}
		link: ${3:# VNIC underlying link name.}
		# temporary: no
		# mac: no
		# vlan: no
		# state: #present|absent
$0
endsnippet

snippet ipadm_prop "Manage protocol properties on Solaris/illumos systems." b
- name: $1
	ipadm_prop:
		protocol: ${2:# Specifies the procotol for which we want to manage properties.}
		property: ${3:# Specifies the name of property we want to manage.}
		# value: # Specifies the value we want to set for the property.
		# temporary: no
		# state: #present|absent|reset
$0
endsnippet

snippet ipadm_addr "Manage IP addresses on an interface on Solaris/illumos systems" b
- name: $1
	ipadm_addr:
		addrobj: ${2:# Specifies an unique IP address on the system.}
		# address: # Specifiies an IP address to configure in CIDR notation.
		# addrtype: #static|dhcp|addrconf
		# temporary: no
		# wait: 60
		# state: absent|#present|up|down|enabled|disabled|refreshed
$0
endsnippet

snippet dladm_etherstub "Manage etherstubs on Solaris/illumos systems." b
- name: $1
	dladm_etherstub:
		name: ${2:# Etherstub name.}
		# temporary: no
		# state: #present|absent
$0
endsnippet

snippet enos_command "Run arbitrary commands on Lenovo ENOS devices" b
- name: $1
	enos_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# authorize: no
		# auth_pass: # Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet enos_facts "Collect facts from remote devices running Lenovo ENOS" b
- name: $1
	enos_facts:
		# gather_subset: !config
		# authorize: no
		# auth_pass: # Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet enos_config "Manage Lenovo ENOS configuration sections" b
- name: $1
	enos_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block|config
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# comment: configured by enos_config
		# admin: no
		# authorize: no
		# auth_pass: # Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet netconf_rpc "Execute operations on NETCONF enabled network devices." b
- name: $1
	netconf_rpc:
		# rpc: # This argument specifies the request (name of the operation) to be executed on the remote NETCONF enabled device.
		# xmlns: # NETCONF operations not defined in rfc6241 typically require the appropriate XML namespace to be set. In the case the I(request) option is not already provided in XML format, the namespace can be defined by the I(xmlns) option.
		# content: # This argument specifies the optional request content (all RPC attributes). The I(content) value can either be provided as XML formatted string or as dictionary.
		# display: json|pretty|xml
$0
endsnippet

snippet netconf_get "Fetch configuration/state data from NETCONF enabled network devices." b
- name: $1
	netconf_get:
		# source: running|candidate|startup
		# filter: # This argument specifies the XML string which acts as a filter to restrict the portions of the data to be are retrieved from the remote device. If this option is not specified entire configuration or state data is returned in result depending on the value of C(source) option. The C(filter) value can be either XML string or XPath, if the filter is in XPath format the NETCONF server running on remote host should support xpath capability else it will result in an error.
		# display: json|pretty|xml
		# lock: #never|always|if-supported
$0
endsnippet

snippet netconf_config "netconf device configuration" b
- name: $1
	netconf_config:
		host: ${2:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}
		# content: # The configuration data as defined by the device's data models, the value can be either in xml string format or text format. The format of the configuration should be supported by remote Netconf server
		# target: auto
		# source_datastore: # Name of the configuration datastore to use as the source to copy the configuration to the datastore mentioned by C(target) option. The values can be either I(running), I(candidate), I(startup) or a remote URL
		# format: #xml|text
		# lock: never|#always|if-supported
		# default_operation: merge|replace|none
		# confirm: 0
		# confirm_commit: no
		# error_option: #stop-on-error|continue-on-error|rollback-on-error
		# save: no
		# backup: no
		# delete: no
		# commit: yes
		# validate: no
		# src: # Specifies the source path to the xml file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(xml).
		# port: 830
		# username: # Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.
		# password: # Specifies the password to use to authenticate the connection to the remote device.   This value is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.
		# timeout: 10
		# ssh_keyfile: # Specifies the SSH key to use to authenticate the connection to the remote device.   This value is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.
		# hostkey_verify: yes
		# look_for_keys: yes
$0
endsnippet

snippet opx_cps "CPS operations on networking device running Openswitch (OPX)" b
- name: $1
	opx_cps:
		# module_name: # Yang path to be configured.
		# attr_type: # Attribute Yang type.
		# attr_data: # Attribute Yang path and their corresponding data.
		# operation: delete|#create|set|action|get
		# db: no
		# qualifier: #target|observed|proposed|realtime|registration|running|startup
		# commit_event: no
$0
endsnippet

snippet routeros_command "Run commands on remote devices running MikroTik RouterOS" b
- name: $1
	routeros_command:
		commands: ${2:# List of commands to send to the remote RouterOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet nos_command "Run commands on remote devices running Extreme Networks NOS" b
- name: $1
	nos_command:
		commands: ${2:# List of commands to send to the remote NOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet nos_facts "Collect facts from devices running Extreme NOS" b
- name: $1
	nos_facts:
		# gather_subset: !config
$0
endsnippet

snippet nos_config "Manage Extreme Networks NOS configuration sections" b
- name: $1
	nos_config:
		# lines: # The ordered set of commands that should be configured in the section. The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against. If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made. This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# multiline_delimiter: @
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source. There are times when it is not desirable to have the task get the current running-config for every task in a playbook. The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# diff_against: running|intended
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against. This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against. When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
$0
endsnippet

snippet openvswitch_bridge "Manage Open vSwitch bridges" b
- name: $1
	openvswitch_bridge:
		bridge: ${2:# Name of bridge or fake bridge to manage}
		# parent: # Bridge parent of the fake bridge to manage
		# vlan: # The VLAN id of the fake bridge to manage (must be between 0 and 4095). This parameter is required if I(parent) parameter is set.
		# state: #present|absent
		# timeout: 5
		# external_ids: # A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.
		# fail_mode: secure|standalone
		# set: # Run set command after bridge configuration. This parameter is non-idempotent, play will always return I(changed) state if present
$0
endsnippet

snippet openvswitch_port "Manage Open vSwitch ports" b
- name: $1
	openvswitch_port:
		bridge: ${2:# Name of bridge to manage}
		port: ${3:# Name of port to manage on the bridge}
		# tag: # VLAN tag for this port. Must be a value between 0 and 4095.
		# state: #present|absent
		# timeout: 5
		# external_ids: {}
		# set: # Set a single property on a port.
$0
endsnippet

snippet openvswitch_db "Configure open vswitch database." b
- name: $1
	openvswitch_db:
		table: ${2:# Identifies the table in the database.}
		record: ${3:# Identifies the recoard in the table.}
		col: ${4:# Identifies the column in the record.}
		value: ${5:# Expected value for the table, record, column and key.}
		# state: #present|absent
		# key: # Identifies the key in the record column, when the column is a map type.
		# timeout: 5
$0
endsnippet

snippet avi_controllerproperties "Module for setup of ControllerProperties Avi RESTful Object" b
- name: $1
	avi_controllerproperties:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# allow_ip_forwarding: # Field introduced in 17.1.1.
		# allow_unauthenticated_apis: # Allow unauthenticated access for special apis.
		# allow_unauthenticated_nodes: # Boolean flag to set allow_unauthenticated_nodes.
		# api_idle_timeout: # Allowed values are 0-1440.
		# appviewx_compat_mode: # Export configuration in appviewx compatibility mode.
		# attach_ip_retry_interval: # Number of attach_ip_retry_interval.
		# attach_ip_retry_limit: # Number of attach_ip_retry_limit.
		# bm_use_ansible: # Use ansible for se creation in baremetal.
		# cluster_ip_gratuitous_arp_period: # Number of cluster_ip_gratuitous_arp_period.
		# crashed_se_reboot: # Number of crashed_se_reboot.
		# dead_se_detection_timer: # Number of dead_se_detection_timer.
		# dns_refresh_period: # Number of dns_refresh_period.
		# dummy: # Number of dummy.
		# enable_memory_balancer: # Enable/disable memory balancer.
		# fatal_error_lease_time: # Number of fatal_error_lease_time.
		# max_dead_se_in_grp: # Number of max_dead_se_in_grp.
		# max_pcap_per_tenant: # Maximum number of pcap files stored per tenant.
		# max_seq_attach_ip_failures: # Maximum number of consecutive attach ip failures that halts vs placement.
		# max_seq_vnic_failures: # Number of max_seq_vnic_failures.
		# persistence_key_rotate_period: # Allowed values are 1-1051200.
		# portal_token: # Token used for uploading tech-support to portal.
		# query_host_fail: # Number of query_host_fail.
		# safenet_hsm_version: # Version of the safenet package installed on the controller.
		# se_create_timeout: # Number of se_create_timeout.
		# se_failover_attempt_interval: # Interval between attempting failovers to an se.
		# se_offline_del: # Number of se_offline_del.
		# se_vnic_cooldown: # Number of se_vnic_cooldown.
		# secure_channel_cleanup_timeout: # Number of secure_channel_cleanup_timeout.
		# secure_channel_controller_token_timeout: # Number of secure_channel_controller_token_timeout.
		# secure_channel_se_token_timeout: # Number of secure_channel_se_token_timeout.
		# seupgrade_fabric_pool_size: # Pool size used for all fabric commands during se upgrade.
		# seupgrade_segroup_min_dead_timeout: # Time to wait before marking segroup upgrade as stuck.
		# ssl_certificate_expiry_warning_days: # Number of days for ssl certificate expiry warning.
		# unresponsive_se_reboot: # Number of unresponsive_se_reboot.
		# upgrade_dns_ttl: # Time to account for dns ttl during upgrade.
		# upgrade_lease_time: # Number of upgrade_lease_time.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# vnic_op_fail_time: # Number of vnic_op_fail_time.
		# vs_apic_scaleout_timeout: # Time to wait for the scaled out se to become ready before marking the scaleout done, applies to apic configuration only.
		# vs_awaiting_se_timeout: # Number of vs_awaiting_se_timeout.
		# vs_key_rotate_period: # Allowed values are 1-1051200.
		# vs_se_attach_ip_fail: # Time to wait before marking attach ip operation on an se as failed.
		# vs_se_bootup_fail: # Number of vs_se_bootup_fail.
		# vs_se_create_fail: # Number of vs_se_create_fail.
		# vs_se_ping_fail: # Number of vs_se_ping_fail.
		# vs_se_vnic_fail: # Number of vs_se_vnic_fail.
		# vs_se_vnic_ip_fail: # Number of vs_se_vnic_ip_fail.
		# warmstart_se_reconnect_wait_time: # Number of warmstart_se_reconnect_wait_time.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_ipaddrgroup "Module for setup of IpAddrGroup Avi RESTful Object" b
- name: $1
	avi_ipaddrgroup:
		name: ${2:# Name of the ip address group.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# addrs: # Configure ip address(es).
		# apic_epg_name: # Populate ip addresses from members of this cisco apic epg.
		# country_codes: # Populate the ip address ranges from the geo database for this country.
		# description: # User defined description for the object.
		# ip_ports: # Configure (ip address, port) tuple(s).
		# marathon_app_name: # Populate ip addresses from tasks of this marathon app.
		# marathon_service_port: # Task port associated with marathon service port.
		# prefixes: # Configure ip address prefix(es).
		# ranges: # Configure ip address range(s).
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the ip address group.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_clusterclouddetails "Module for setup of ClusterCloudDetails Avi RESTful Object" b
- name: $1
	avi_clusterclouddetails:
		name: ${2:# Field introduced in 17.2.5.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# azure_info: # Azure info to configure cluster_vip on the controller.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.2.5.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_trafficcloneprofile "Module for setup of TrafficCloneProfile Avi RESTful Object" b
- name: $1
	avi_trafficcloneprofile:
		name: ${2:# Name for the traffic clone profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# clone_servers: # Field introduced in 17.1.1.
		# cloud_ref: # It is a reference to an object of type cloud.
		# preserve_client_ip: # Specifies if client ip needs to be preserved to clone destination.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the traffic clone profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_virtualservice "Module for setup of VirtualService Avi RESTful Object" b
- name: $1
	avi_virtualservice:
		name: ${2:# Name for the virtual service.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# active_standby_se_tag: # This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.
		# analytics_policy: # Determines analytics settings for the application.
		# analytics_profile_ref: # Specifies settings related to analytics.
		# application_profile_ref: # Enable application layer specific features for the virtual service.
		# auto_allocate_floating_ip: # Auto-allocate floating/elastic ip from the cloud infrastructure.
		# auto_allocate_ip: # Auto-allocate vip from the provided subnet.
		# availability_zone: # Availability-zone to place the virtual service.
		# avi_allocated_fip: # (internal-use) fip allocated by avi in the cloud infrastructure.
		# avi_allocated_vip: # (internal-use) vip allocated by avi in the cloud infrastructure.
		# bulk_sync_kvcache: # (this is a beta feature).
		# client_auth: # Http authentication configuration for protected resources.
		# close_client_conn_on_config_update: # Close client connection on vs config update.
		# cloud_config_cksum: # Checksum of cloud configuration for vs.
		# cloud_ref: # It is a reference to an object of type cloud.
		# cloud_type: # Enum options - cloud_none, cloud_vcenter, cloud_openstack, cloud_aws, cloud_vca, cloud_apic, cloud_mesos, cloud_linuxserver, cloud_docker_ucp,
		# connections_rate_limit: # Rate limit the incoming connections to this virtual service.
		# content_rewrite: # Profile used to match and rewrite strings in request and/or response body.
		# created_by: # Creator name.
		# delay_fairness: # Select the algorithm for qos fairness.
		# description: # User defined description for the object.
		# discovered_network_ref: # (internal-use) discovered networks providing reachability for client facing virtual service ip.
		# discovered_networks: # (internal-use) discovered networks providing reachability for client facing virtual service ip.
		# discovered_subnet: # (internal-use) discovered subnets providing reachability for client facing virtual service ip.
		# dns_info: # Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
		# dns_policies: # Dns policies applied on the dns traffic of the virtual service.
		# east_west_placement: # Force placement on all se's in service group (mesos mode only).
		# enable_autogw: # Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.
		# enable_rhi: # Enable route health injection using the bgp config in the vrf context.
		# enable_rhi_snat: # Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.
		# enabled: # Enable or disable the virtual service.
		# error_page_profile_ref: # Error page profile to be used for this virtualservice.this profile is used to send the custom error page to the client generated by the proxy.
		# floating_ip: # Floating ip to associate with this virtual service.
		# floating_subnet_uuid: # If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.
		# flow_dist: # Criteria for flow distribution among ses.
		# flow_label_type: # Criteria for flow labelling.
		# fqdn: # Dns resolvable, fully qualified domain name of the virtualservice.
		# host_name_xlate: # Translate the host name sent to the servers to this value.
		# http_policies: # Http policies applied on the data traffic of the virtual service.
		# ign_pool_net_reach: # Ignore pool servers network reachability constraints for virtual service placement.
		# ip_address: # Ip address of the virtual service.
		# ipam_network_subnet: # Subnet and/or network for allocating virtualservice ip by ipam provider module.
		# l4_policies: # L4 policies applied to the data traffic of the virtual service.
		# limit_doser: # Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.
		# max_cps_per_client: # Maximum connections per second per client ip.
		# microservice_ref: # Microservice representing the virtual service.
		# network_profile_ref: # Determines network settings such as protocol, tcp or udp, and related options for the protocol.
		# network_ref: # Manually override the network on which the virtual service is placed.
		# network_security_policy_ref: # Network security policies for the virtual service.
		# nsx_securitygroup: # A list of nsx service groups representing the clients which can access the virtual ip of the virtual service.
		# performance_limits: # Optional settings that determine performance limits like max connections or bandwdith etc.
		# pool_group_ref: # The pool group is an object that contains pools.
		# pool_ref: # The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.
		# port_uuid: # (internal-use) network port assigned to the virtual service ip address.
		# remove_listening_port_on_vs_down: # Remove listening port if virtualservice is down.
		# requests_rate_limit: # Rate limit the incoming requests to this virtual service.
		# scaleout_ecmp: # Disable re-distribution of flows across service engines for a virtual service.
		# se_group_ref: # The service engine group to use for this virtual service.
		# server_network_profile_ref: # Determines the network settings profile for the server side of tcp proxied connections.
		# service_metadata: # Metadata pertaining to the service provided by this virtual service.
		# service_pool_select: # Select pool based on destination port.
		# services: # List of services defined for this virtual service.
		# sideband_profile: # Sideband configuration to be used for this virtualservice.it can be used for sending traffic to sideband vips for external inspection etc.
		# snat_ip: # Nat'ted floating source ip address(es) for upstream connection to servers.
		# sp_pool_refs: # Gslb pools used to manage site-persistence functionality.
		# ssl_key_and_certificate_refs: # Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.
		# ssl_profile_ref: # Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.
		# ssl_sess_cache_avg_size: # Expected number of ssl session cache entries (may be exceeded).
		# static_dns_records: # List of static dns records applied to this virtual service.
		# subnet: # Subnet providing reachability for client facing virtual service ip.
		# subnet_uuid: # It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.
		# tenant_ref: # It is a reference to an object of type tenant.
		# traffic_clone_profile_ref: # Server network or list of servers for cloning traffic.
		# traffic_enabled: # Knob to enable the virtual service traffic on its assigned service engines.
		# type: # Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.
		# url: # Avi controller URL of the object.
		# use_bridge_ip_as_vip: # Use bridge ip as vip on each host in mesos deployments.
		# use_vip_as_snat: # Use the virtual ip as the snat ip for health monitoring and sending traffic to the backend servers instead of the service engine interface ip.
		# uuid: # Uuid of the virtualservice.
		# vh_domain_name: # The exact name requested from the client's sni-enabled tls hello domain name field.
		# vh_parent_vs_uuid: # Specifies the virtual service acting as virtual hosting (sni) parent.
		# vip: # List of virtual service ips.
		# vrf_context_ref: # Virtual routing context that the virtual service is bound to.
		# vs_datascripts: # Datascripts applied on the data traffic of the virtual service.
		# vsvip_ref: # Mostly used during the creation of shared vs, this field refers to entities that can be shared across virtual services.
		# waf_policy_ref: # Waf policy for the virtual service.
		# weight: # The quality of service weight to assign to traffic transmitted from this virtual service.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_healthmonitor "Module for setup of HealthMonitor Avi RESTful Object" b
- name: $1
	avi_healthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# dns_monitor: # Healthmonitordns settings for healthmonitor.
		# external_monitor: # Healthmonitorexternal settings for healthmonitor.
		# failed_checks: # Number of continuous failed health checks before the server is marked down.
		# http_monitor: # Healthmonitorhttp settings for healthmonitor.
		# https_monitor: # Healthmonitorhttp settings for healthmonitor.
		# is_federated: # This field describes the object's replication scope.
		# monitor_port: # Use this port instead of the port defined for the server in the pool.
		# receive_timeout: # A valid response from the server is expected within the receive timeout window.
		# send_interval: # Frequency, in seconds, that monitors are sent to a server.
		# successful_checks: # Number of continuous successful health checks before server is marked up.
		# tcp_monitor: # Healthmonitortcp settings for healthmonitor.
		# tenant_ref: # It is a reference to an object of type tenant.
		# udp_monitor: # Healthmonitorudp settings for healthmonitor.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the health monitor.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_analyticsprofile "Module for setup of AnalyticsProfile Avi RESTful Object" b
- name: $1
	avi_analyticsprofile:
		name: ${2:# The name of the analytics profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# apdex_response_threshold: # If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.
		# apdex_response_tolerated_factor: # Client tolerated response latency factor.
		# apdex_rtt_threshold: # Satisfactory client to avi round trip time(rtt).
		# apdex_rtt_tolerated_factor: # Tolerated client to avi round trip time(rtt) factor.
		# apdex_rum_threshold: # If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.
		# apdex_rum_tolerated_factor: # Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.
		# apdex_server_response_threshold: # A server http response is considered satisfied if latency is less than the satisfactory latency threshold.
		# apdex_server_response_tolerated_factor: # Server tolerated response latency factor.
		# apdex_server_rtt_threshold: # Satisfactory client to avi round trip time(rtt).
		# apdex_server_rtt_tolerated_factor: # Tolerated client to avi round trip time(rtt) factor.
		# client_log_config: # Configure which logs are sent to the avi controller from ses and how they are processed.
		# client_log_streaming_config: # Configure to stream logs to an external server.
		# conn_lossy_ooo_threshold: # A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.
		# conn_lossy_timeo_rexmt_threshold: # A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.
		# conn_lossy_total_rexmt_threshold: # A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.
		# conn_lossy_zero_win_size_event_threshold: # A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
		# conn_server_lossy_ooo_threshold: # A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.
		# conn_server_lossy_timeo_rexmt_threshold: # A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.
		# conn_server_lossy_total_rexmt_threshold: # A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.
		# conn_server_lossy_zero_win_size_event_threshold: # A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
		# description: # User defined description for the object.
		# disable_se_analytics: # Disable node (service engine) level analytics forvs metrics.
		# disable_server_analytics: # Disable analytics on backend servers.
		# exclude_client_close_before_request_as_error: # Exclude client closed connection before an http request could be completed from being classified as an error.
		# exclude_dns_policy_drop_as_significant: # Exclude dns policy drops from the list of errors.
		# exclude_gs_down_as_error: # Exclude queries to gslb services that are operationally down from the list of errors.
		# exclude_http_error_codes: # List of http status codes to be excluded from being classified as an error.
		# exclude_invalid_dns_domain_as_error: # Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.
		# exclude_invalid_dns_query_as_error: # Exclude invalid dns queries from the list of errors.
		# exclude_no_dns_record_as_error: # Exclude queries to domains that did not have configured services/records from the list of errors.
		# exclude_no_valid_gs_member_as_error: # Exclude queries to gslb services that have no available members from the list of errors.
		# exclude_persistence_change_as_error: # Exclude persistence server changed while load balancing' from the list of errors.
		# exclude_server_dns_error_as_error: # Exclude server dns error response from the list of errors.
		# exclude_server_tcp_reset_as_error: # Exclude server tcp reset from errors.
		# exclude_syn_retransmit_as_error: # Exclude 'server unanswered syns' from the list of errors.
		# exclude_tcp_reset_as_error: # Exclude tcp resets by client from the list of potential errors.
		# exclude_unsupported_dns_query_as_error: # Exclude unsupported dns queries from the list of errors.
		# hs_event_throttle_window: # Time window (in secs) within which only unique health change events should occur.
		# hs_max_anomaly_penalty: # Maximum penalty that may be deducted from health score for anomalies.
		# hs_max_resources_penalty: # Maximum penalty that may be deducted from health score for high resource utilization.
		# hs_max_security_penalty: # Maximum penalty that may be deducted from health score based on security assessment.
		# hs_min_dos_rate: # Dos connection rate below which the dos security assessment will not kick in.
		# hs_performance_boost: # Adds free performance score credits to health score.
		# hs_pscore_traffic_threshold_l4_client: # Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
		# hs_pscore_traffic_threshold_l4_server: # Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
		# hs_security_certscore_expired: # Score assigned when the certificate has expired.
		# hs_security_certscore_gt30d: # Score assigned when the certificate expires in more than 30 days.
		# hs_security_certscore_le07d: # Score assigned when the certificate expires in less than or equal to 7 days.
		# hs_security_certscore_le30d: # Score assigned when the certificate expires in less than or equal to 30 days.
		# hs_security_chain_invalidity_penalty: # Penalty for allowing certificates with invalid chain.
		# hs_security_cipherscore_eq000b: # Score assigned when the minimum cipher strength is 0 bits.
		# hs_security_cipherscore_ge128b: # Score assigned when the minimum cipher strength is greater than equal to 128 bits.
		# hs_security_cipherscore_lt128b: # Score assigned when the minimum cipher strength is less than 128 bits.
		# hs_security_encalgo_score_none: # Score assigned when no algorithm is used for encryption.
		# hs_security_encalgo_score_rc4: # Score assigned when rc4 algorithm is used for encryption.
		# hs_security_hsts_penalty: # Penalty for not enabling hsts.
		# hs_security_nonpfs_penalty: # Penalty for allowing non-pfs handshakes.
		# hs_security_selfsignedcert_penalty: # Deprecated.
		# hs_security_ssl30_score: # Score assigned when supporting ssl3.0 encryption protocol.
		# hs_security_tls10_score: # Score assigned when supporting tls1.0 encryption protocol.
		# hs_security_tls11_score: # Score assigned when supporting tls1.1 encryption protocol.
		# hs_security_tls12_score: # Score assigned when supporting tls1.2 encryption protocol.
		# hs_security_weak_signature_algo_penalty: # Penalty for allowing weak signature algorithm(s).
		# ranges: # List of http status code ranges to be excluded from being classified as an error.
		# resp_code_block: # Block of http response codes to be excluded from being classified as an error.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the analytics profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslb "Module for setup of Gslb Avi RESTful Object" b
- name: $1
	avi_gslb:
		leader_cluster_uuid: ${2:# Mark this site as leader of gslb configuration.}
		name: ${3:# Name for the gslb object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# clear_on_max_retries: # Max retries after which the remote site is treated as a fresh start.
		# client_ip_addr_group: # Group to specify if the client ip addresses are public or private.
		# description: # User defined description for the object.
		# dns_configs: # Sub domain configuration for the gslb.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# maintenance_mode: # This field disables the configuration operations on the leader for all federated objects.
		# send_interval: # Frequency with which group members communicate.
		# sites: # Select avi site member belonging to this gslb.
		# tenant_ref: # It is a reference to an object of type tenant.
		# third_party_sites: # Third party site member belonging to this gslb.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the gslb object.
		# view_id: # The view-id is used in change-leader mode to differentiate partitioned groups while they have the same gslb namespace.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_prioritylabels "Module for setup of PriorityLabels Avi RESTful Object" b
- name: $1
	avi_prioritylabels:
		name: ${2:# The name of the priority labels.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_ref: # It is a reference to an object of type cloud.
		# description: # A description of the priority labels.
		# equivalent_labels: # Equivalent priority labels in descending order.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the priority labels.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_pool "Module for setup of Pool Avi RESTful Object" b
- name: $1
	avi_pool:
		name: ${2:# The name of the pool.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# a_pool: # Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.
		# ab_pool: # A/b pool configuration.
		# ab_priority: # Priority of this pool in a a-b pool pair.
		# apic_epg_name: # Synchronize cisco apic epg members with pool servers.
		# application_persistence_profile_ref: # Persistence will ensure the same user sticks to the same server for a desired duration of time.
		# autoscale_launch_config_ref: # If configured then avi will trigger orchestration of pool server creation and deletion.
		# autoscale_networks: # Network ids for the launch configuration.
		# autoscale_policy_ref: # Reference to server autoscale policy.
		# capacity_estimation: # Inline estimation of capacity of servers.
		# capacity_estimation_ttfb_thresh: # The maximum time-to-first-byte of a server.
		# cloud_config_cksum: # Checksum of cloud configuration for pool.
		# cloud_ref: # It is a reference to an object of type cloud.
		# connection_ramp_duration: # Duration for which new connections will be gradually ramped up to a server recently brought online.
		# created_by: # Creator name.
		# default_server_port: # Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.
		# description: # A description of the pool.
		# domain_name: # Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.
		# east_west: # Inherited config from virtualservice.
		# enabled: # Enable or disable the pool.
		# external_autoscale_groups: # Names of external auto-scale groups for pool servers.
		# fail_action: # Enable an action - close connection, http redirect or local http response - when a pool failure happens.
		# fewest_tasks_feedback_delay: # Periodicity of feedback for fewest tasks server selection algorithm.
		# graceful_disable_timeout: # Used to gracefully disable a server.
		# gslb_sp_enabled: # Indicates if the pool is a site-persistence pool.
		# health_monitor_refs: # Verify server health by applying one or more health monitors.
		# host_check_enabled: # Enable common name check for server certificate.
		# inline_health_monitor: # The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.
		# ipaddrgroup_ref: # Use list of servers from ip address group.
		# lb_algorithm: # The load balancing algorithm will pick a server within the pool's list of available servers.
		# lb_algorithm_consistent_hash_hdr: # Http header name to be used for the hash key.
		# lb_algorithm_core_nonaffinity: # Degree of non-affinity for core afffinity based server selection.
		# lb_algorithm_hash: # Criteria used as a key for determining the hash between the client and  server.
		# lookup_server_by_name: # Allow server lookup by name.
		# max_concurrent_connections_per_server: # The maximum number of concurrent connections allowed to each server within the pool.
		# max_conn_rate_per_server: # Rate limit connections to each server.
		# networks: # (internal-use) networks designated as containing servers for this pool.
		# nsx_securitygroup: # A list of nsx service groups where the servers for the pool are created.
		# pki_profile_ref: # Avi will validate the ssl certificate present by a server against the selected pki profile.
		# placement_networks: # Manually select the networks and subnets used to provide reachability to the pool's servers.
		# prst_hdr_name: # Header name for custom header persistence.
		# request_queue_depth: # Minimum number of requests to be queued when pool is full.
		# request_queue_enabled: # Enable request queue when pool is full.
		# rewrite_host_header_to_server_name: # Rewrite incoming host header to server name of the server to which the request is proxied.
		# rewrite_host_header_to_sni: # If sni server name is specified, rewrite incoming host header to the sni server name.
		# server_auto_scale: # Server autoscale.
		# server_count: # Number of server_count.
		# server_name: # Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.
		# server_reselect: # Server reselect configuration for http requests.
		# servers: # The pool directs load balanced traffic to this list of destination servers.
		# sni_enabled: # Enable tls sni for server connections.
		# ssl_key_and_certificate_ref: # Service engines will present a client ssl certificate to the server.
		# ssl_profile_ref: # When enabled, avi re-encrypts traffic to the backend servers.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# use_service_port: # Do not translate the client's destination port when sending the connection to the server.
		# uuid: # Uuid of the pool.
		# vrf_ref: # Virtual routing context that the pool is bound to.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_snmptrapprofile "Module for setup of SnmpTrapProfile Avi RESTful Object" b
- name: $1
	avi_snmptrapprofile:
		name: ${2:# A user-friendly name of the snmp trap configuration.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# tenant_ref: # It is a reference to an object of type tenant.
		# trap_servers: # The ip address or hostname of the snmp trap destination server.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the snmp trap profile object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_applicationprofile "Module for setup of ApplicationProfile Avi RESTful Object" b
- name: $1
	avi_applicationprofile:
		name: ${2:# The name of the application profile.}
		type: ${3:# Specifies which application layer proxy is enabled for the virtual service.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# dns_service_profile: # Specifies various dns service related controls for virtual service.
		# dos_rl_profile: # Specifies various security related controls for virtual service.
		# http_profile: # Specifies the http application proxy profile parameters.
		# preserve_client_ip: # Specifies if client ip needs to be preserved for backend connection.
		# preserve_client_port: # Specifies if we need to preserve client port while preseving client ip for backend connections.
		# tcp_app_profile: # Specifies the tcp application proxy profile parameters.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the application profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_poolgroup "Module for setup of PoolGroup Avi RESTful Object" b
- name: $1
	avi_poolgroup:
		name: ${2:# The name of the pool group.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_config_cksum: # Checksum of cloud configuration for poolgroup.
		# cloud_ref: # It is a reference to an object of type cloud.
		# created_by: # Name of the user who created the object.
		# deployment_policy_ref: # When setup autoscale manager will automatically promote new pools into production when deployment goals are met.
		# description: # Description of pool group.
		# fail_action: # Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.
		# implicit_priority_labels: # Whether an implicit set of priority labels is generated.
		# members: # List of pool group members object of type poolgroupmember.
		# min_servers: # The minimum number of servers to distribute traffic to.
		# priority_labels_ref: # Uuid of the priority labels.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the pool group.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_vsdatascriptset "Module for setup of VSDataScriptSet Avi RESTful Object" b
- name: $1
	avi_vsdatascriptset:
		name: ${2:# Name for the virtual service datascript collection.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# datascript: # Datascripts to execute.
		# description: # User defined description for the object.
		# ipgroup_refs: # Uuid of ip groups that could be referred by vsdatascriptset objects.
		# pool_group_refs: # Uuid of pool groups that could be referred by vsdatascriptset objects.
		# pool_refs: # Uuid of pools that could be referred by vsdatascriptset objects.
		# string_group_refs: # Uuid of string groups that could be referred by vsdatascriptset objects.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the virtual service datascript collection.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_scheduler "Module for setup of Scheduler Avi RESTful Object" b
- name: $1
	avi_scheduler:
		name: ${2:# Name of scheduler.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# backup_config_ref: # Backup configuration to be executed by this scheduler.
		# enabled: # Boolean flag to set enabled.
		# end_date_time: # Scheduler end date and time.
		# frequency: # Frequency at which custom scheduler will run.
		# frequency_unit: # Unit at which custom scheduler will run.
		# run_mode: # Scheduler run mode.
		# run_script_ref: # Control script to be executed by this scheduler.
		# scheduler_action: # Define scheduler action.
		# start_date_time: # Scheduler start date and time.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_errorpagebody "Module for setup of ErrorPageBody Avi RESTful Object" b
- name: $1
	avi_errorpagebody:
		name: ${2:# Field introduced in 17.2.4.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# error_page_body: # Error page body sent to client when match.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.2.4.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_httppolicyset "Module for setup of HTTPPolicySet Avi RESTful Object" b
- name: $1
	avi_httppolicyset:
		name: ${2:# Name of the http policy set.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_config_cksum: # Checksum of cloud configuration for pool.
		# created_by: # Creator name.
		# description: # User defined description for the object.
		# http_request_policy: # Http request policy for the virtual service.
		# http_response_policy: # Http response policy for the virtual service.
		# http_security_policy: # Http security policy for the virtual service.
		# is_internal_policy: # Boolean flag to set is_internal_policy.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the http policy set.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_alertsyslogconfig "Module for setup of AlertSyslogConfig Avi RESTful Object" b
- name: $1
	avi_alertsyslogconfig:
		name: ${2:# A user-friendly name of the syslog notification.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for alert syslog config.
		# syslog_servers: # The list of syslog servers.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_api_version "Avi API Version Module" b
- name: $1
	avi_api_version:
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_ipamdnsproviderprofile "Module for setup of IpamDnsProviderProfile Avi RESTful Object" b
- name: $1
	avi_ipamdnsproviderprofile:
		name: ${2:# Name for the ipam/dns provider profile.}
		type: ${3:# Provider type for the ipam/dns provider profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# allocate_ip_in_vrf: # If this flag is set, only allocate ip from networks in the virtual service vrf.
		# aws_profile: # Provider details if type is aws.
		# azure_profile: # Provider details if type is microsoft azure.
		# custom_profile: # Provider details if type is custom.
		# gcp_profile: # Provider details if type is google cloud.
		# infoblox_profile: # Provider details if type is infoblox.
		# internal_profile: # Provider details if type is avi.
		# openstack_profile: # Provider details if type is openstack.
		# proxy_configuration: # Field introduced in 17.1.1.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the ipam/dns provider profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_microservicegroup "Module for setup of MicroServiceGroup Avi RESTful Object" b
- name: $1
	avi_microservicegroup:
		name: ${2:# Name of the microservice group.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# description: # User defined description for the object.
		# service_refs: # Configure microservice(es).
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the microservice group.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_errorpageprofile "Module for setup of ErrorPageProfile Avi RESTful Object" b
- name: $1
	avi_errorpageprofile:
		name: ${2:# Field introduced in 17.2.4.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# app_name: # Name of the virtual service which generated the error page.
		# company_name: # Name of the company to show in error page.
		# error_pages: # Defined error pages for http status codes.
		# host_name: # Fully qualified domain name for which the error page is generated.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.2.4.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_seproperties "Module for setup of SeProperties Avi RESTful Object" b
- name: $1
	avi_seproperties:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# se_agent_properties: # Seagentproperties settings for seproperties.
		# se_bootup_properties: # Sebootupproperties settings for seproperties.
		# se_runtime_properties: # Seruntimeproperties settings for seproperties.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslbservice "Module for setup of GslbService Avi RESTful Object" b
- name: $1
	avi_gslbservice:
		name: ${2:# Name for the gslb service.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# application_persistence_profile_ref: # The federated application persistence associated with gslbservice site persistence functionality.
		# controller_health_status_enabled: # Gs member's overall health status is derived based on a combination of controller and datapath health-status inputs.
		# created_by: # Creator name.
		# description: # User defined description for the object.
		# domain_names: # Fully qualified domain name of the gslb service.
		# down_response: # Response to the client query when the gslb service is down.
		# enabled: # Enable or disable the gslb service.
		# groups: # Select list of pools belonging to this gslb service.
		# health_monitor_refs: # Verify vs health by applying one or more health monitors.
		# health_monitor_scope: # Health monitor probe can be executed for all the members or it can be executed only for third-party members.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# min_members: # The minimum number of members to distribute traffic to.
		# num_dns_ip: # Number of ip addresses of this gslb service to be returned by the dns service.
		# pool_algorithm: # The load balancing algorithm will pick a gslb pool within the gslb service list of available pools.
		# site_persistence_enabled: # Enable site-persistence for the gslbservice.
		# tenant_ref: # It is a reference to an object of type tenant.
		# ttl: # Ttl value (in seconds) for records served for this gslb service by the dns service.
		# url: # Avi controller URL of the object.
		# use_edns_client_subnet: # Use the client ip subnet from the edns option as source ipaddress for client geo-location and consistent hash algorithm.
		# uuid: # Uuid of the gslb service.
		# wildcard_match: # Enable wild-card match of fqdn  if an exact match is not found in the dns table, the longest match is chosen by wild-carding the fqdn in the dns
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_backup "Module for setup of Backup Avi RESTful Object" b
- name: $1
	avi_backup:
		file_name: ${2:# The file name of backup.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# backup_config_ref: # Backupconfiguration information.
		# local_file_url: # Url to download the backup file.
		# remote_file_url: # Url to download the backup file.
		# scheduler_ref: # Scheduler information.
		# tenant_ref: # It is a reference to an object of type tenant.
		# timestamp: # Unix timestamp of when the backup file is created.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_customipamdnsprofile "Module for setup of CustomIpamDnsProfile Avi RESTful Object" b
- name: $1
	avi_customipamdnsprofile:
		name: ${2:# Name of the custom ipam dns profile.}
		script_uri: ${3:# Script uri of form controller //ipamdnsscripts/<file-name>.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# script_params: # Parameters that are always passed to the ipam/dns script.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.1.1.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_serviceenginegroup "Module for setup of ServiceEngineGroup Avi RESTful Object" b
- name: $1
	avi_serviceenginegroup:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# active_standby: # Service engines in active/standby mode for ha failover.
		# advertise_backend_networks: # Advertise reach-ability of backend server networks via adc through bgp for default gateway feature.
		# aggressive_failure_detection: # Enable aggressive failover configuration for ha.
		# algo: # In compact placement, virtual services are placed on existing ses until max_vs_per_se limit is reached.
		# allow_burst: # Allow ses to be created using burst license.
		# archive_shm_limit: # Amount of se memory in gb until which shared memory is collected in core archive.
		# async_ssl: # Ssl handshakes will be handled by dedicated ssl threads.
		# async_ssl_threads: # Number of async ssl threads per se_dp.
		# auto_rebalance: # If set, virtual services will be automatically migrated when load on an se is less than minimum or more than maximum thresholds.
		# auto_rebalance_capacity_per_se: # Capacities of se for auto rebalance for each criteria.
		# auto_rebalance_criteria: # Set of criteria for se auto rebalance.
		# auto_rebalance_interval: # Frequency of rebalance, if 'auto rebalance' is enabled.
		# auto_redistribute_active_standby_load: # Redistribution of virtual services from the takeover se to the replacement se can cause momentary traffic loss.
		# buffer_se: # Excess service engine capacity provisioned for ha failover.
		# cloud_ref: # It is a reference to an object of type cloud.
		# connection_memory_percentage: # Percentage of memory for connection state.
		# cpu_reserve: # Boolean flag to set cpu_reserve.
		# cpu_socket_affinity: # Allocate all the cpu cores for the service engine virtual machines  on the same cpu socket.
		# custom_securitygroups_data: # Custom security groups to be associated with data vnics for se instances in openstack and aws clouds.
		# custom_securitygroups_mgmt: # Custom security groups to be associated with management vnic for se instances in openstack and aws clouds.
		# custom_tag: # Custom tag will be used to create the tags for se instance in aws.
		# dedicated_dispatcher_core: # Dedicate the core that handles packet receive/transmit from the network to just the dispatching function.
		# description: # User defined description for the object.
		# disable_csum_offloads: # Stop using tcp/udp and ip checksum offload features of nics.
		# disable_gro: # Disable generic receive offload (gro) in dpdk poll-mode driver packet receive path.
		# disable_tso: # Disable tcp segmentation offload (tso) in dpdk poll-mode driver packet transmit path.
		# disk_per_se: # Amount of disk space for each of the service engine virtual machines.
		# distribute_load_active_standby: # Use both the active and standby service engines for virtual service placement in the legacy active standby ha mode.
		# enable_hsm_priming: # (this is a beta feature).
		# enable_routing: # Enable routing for this serviceenginegroup .
		# enable_vip_on_all_interfaces: # Enable vip on all interfaces of se.
		# enable_vmac: # Use virtual mac address for interfaces on which floating interface ips are placed.
		# extra_config_multiplier: # Multiplier for extra config to support large vs/pool config.
		# extra_shared_config_memory: # Extra config memory to support large geo db configuration.
		# floating_intf_ip: # If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
		# floating_intf_ip_se_2: # If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
		# flow_table_new_syn_max_entries: # Maximum number of flow table entries that have not completed tcp three-way handshake yet.
		# ha_mode: # High availability mode for all the virtual services using this service engine group.
		# hardwaresecuritymodulegroup_ref: # It is a reference to an object of type hardwaresecuritymodulegroup.
		# hm_on_standby: # Enable active health monitoring from the standby se for all placed virtual services.
		# host_attribute_key: # Key of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
		# host_attribute_value: # Value of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
		# host_gateway_monitor: # Enable the host gateway monitor when service engine is deployed as docker container.
		# hypervisor: # Override default hypervisor.
		# ignore_rtt_threshold: # Ignore rtt samples if it is above threshold.
		# ingress_access_data: # Program se security group ingress rules to allow vip data access from remote cidr type.
		# ingress_access_mgmt: # Program se security group ingress rules to allow ssh/icmp management access from remote cidr type.
		# instance_flavor: # Instance/flavor type for se instance.
		# iptables: # Iptable rules.
		# least_load_core_selection: # Select core with least load for new flow.
		# license_tier: # Specifies the license tier which would be used.
		# license_type: # If no license type is specified then default license enforcement for the cloud type is chosen.
		# log_disksz: # Maximum disk capacity (in mb) to be allocated to an se.
		# max_cpu_usage: # When cpu usage on an se exceeds this threshold, virtual services hosted on this se may be rebalanced to other ses to reduce load.
		# max_scaleout_per_vs: # Maximum number of active service engines for the virtual service.
		# max_se: # Maximum number of services engines in this group.
		# max_vs_per_se: # Maximum number of virtual services that can be placed on a single service engine.
		# mem_reserve: # Boolean flag to set mem_reserve.
		# memory_per_se: # Amount of memory for each of the service engine virtual machines.
		# mgmt_network_ref: # Management network to use for avi service engines.
		# mgmt_subnet: # Management subnet to use for avi service engines.
		# min_cpu_usage: # When cpu usage on an se falls below the minimum threshold, virtual services hosted on the se may be consolidated onto other underutilized ses.
		# min_scaleout_per_vs: # Minimum number of active service engines for the virtual service.
		# non_significant_log_throttle: # This setting limits the number of non-significant logs generated per second per core on this se.
		# num_flow_cores_sum_changes_to_ignore: # Number of changes in num flow cores sum to ignore.
		# openstack_availability_zone: # Field deprecated in 17.1.1.
		# openstack_availability_zones: # Field introduced in 17.1.1.
		# openstack_mgmt_network_name: # Avi management network name.
		# openstack_mgmt_network_uuid: # Management network uuid.
		# os_reserved_memory: # Amount of extra memory to be reserved for use by the operating system on a service engine.
		# per_app: # Per-app se mode is designed for deploying dedicated load balancers per app (vs).
		# placement_mode: # If placement mode is 'auto', virtual services are automatically placed on service engines.
		# realtime_se_metrics: # Enable or disable real time se metrics.
		# se_bandwidth_type: # Select the se bandwidth for the bandwidth license.
		# se_deprovision_delay: # Duration to preserve unused service engine virtual machines before deleting them.
		# se_dos_profile: # Dosthresholdprofile settings for serviceenginegroup.
		# se_ipc_udp_port: # Udp port for se_dp ipc in docker bridge mode.
		# se_name_prefix: # Prefix to use for virtual machine name of service engines.
		# se_probe_port: # Tcp port on se where echo service will be run.
		# se_remote_punt_udp_port: # Udp port for punted packets in docker bridge mode.
		# se_sb_dedicated_core: # Sideband traffic will be handled by a dedicated core.
		# se_sb_threads: # Number of sideband threads per se.
		# se_thread_multiplier: # Multiplier for se threads based on vcpu.
		# se_tunnel_mode: # Determines if dsr from secondary se is active or not  0  automatically determine based on hypervisor type.
		# se_tunnel_udp_port: # Udp port for tunneled packets from secondary to primary se in docker bridge mode.
		# se_udp_encap_ipc: # Determines if se-se ipc messages are encapsulated in an udp header  0  automatically determine based on hypervisor type.
		# se_vs_hb_max_pkts_in_batch: # Maximum number of aggregated vs heartbeat packets to send in a batch.
		# se_vs_hb_max_vs_in_pkt: # Maximum number of virtualservices for which heartbeat messages are aggregated in one packet.
		# service_ip_subnets: # Subnets assigned to the se group.
		# significant_log_throttle: # This setting limits the number of significant logs generated per second per core on this se.
		# tenant_ref: # It is a reference to an object of type tenant.
		# udf_log_throttle: # This setting limits the number of udf logs generated per second per core on this se.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# vcenter_clusters: # Vcenterclusters settings for serviceenginegroup.
		# vcenter_datastore_mode: # Enum options - vcenter_datastore_any, vcenter_datastore_local, vcenter_datastore_shared.
		# vcenter_datastores: # List of vcenterdatastore.
		# vcenter_datastores_include: # Boolean flag to set vcenter_datastores_include.
		# vcenter_folder: # Folder to place all the service engine virtual machines in vcenter.
		# vcenter_hosts: # Vcenterhosts settings for serviceenginegroup.
		# vcpus_per_se: # Number of vcpus for each of the service engine virtual machines.
		# vs_host_redundancy: # Ensure primary and secondary service engines are deployed on different physical hosts.
		# vs_scalein_timeout: # Time to wait for the scaled in se to drain existing flows before marking the scalein done.
		# vs_scalein_timeout_for_upgrade: # During se upgrade, time to wait for the scaled-in se to drain existing flows before marking the scalein done.
		# vs_scaleout_timeout: # Time to wait for the scaled out se to become ready before marking the scaleout done.
		# vss_placement: # If set, virtual services will be placed on only a subset of the cores of an se.
		# waf_mempool: # Enable memory pool for waf.
		# waf_mempool_size: # Memory pool size used for waf.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_stringgroup "Module for setup of StringGroup Avi RESTful Object" b
- name: $1
	avi_stringgroup:
		name: ${2:# Name of the string group.}
		type: ${3:# Type of stringgroup.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# kv: # Configure key value in the string group.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the string group.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_networksecuritypolicy "Module for setup of NetworkSecurityPolicy Avi RESTful Object" b
- name: $1
	avi_networksecuritypolicy:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_config_cksum: # Checksum of cloud configuration for network sec policy.
		# created_by: # Creator name.
		# description: # User defined description for the object.
		# name: # Name of the object.
		# rules: # List of networksecurityrule.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_backupconfiguration "Module for setup of BackupConfiguration Avi RESTful Object" b
- name: $1
	avi_backupconfiguration:
		name: ${2:# Name of backup configuration.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# backup_file_prefix: # Prefix of the exported configuration file.
		# backup_passphrase: # Passphrase of backup configuration.
		# maximum_backups_stored: # Rotate the backup files based on this count.
		# remote_directory: # Directory at remote destination with write permission for ssh user.
		# remote_hostname: # Remote destination.
		# save_local: # Local backup.
		# ssh_user_ref: # Access credentials for remote destination.
		# tenant_ref: # It is a reference to an object of type tenant.
		# upload_to_remote_host: # Remote backup.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_cloud "Module for setup of Cloud Avi RESTful Object" b
- name: $1
	avi_cloud:
		name: ${2:# Name of the object.}
		vtype: ${3:# Cloud type.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# apic_configuration: # Apicconfiguration settings for cloud.
		# apic_mode: # Boolean flag to set apic_mode.
		# aws_configuration: # Awsconfiguration settings for cloud.
		# azure_configuration: # Field introduced in 17.2.1.
		# cloudstack_configuration: # Cloudstackconfiguration settings for cloud.
		# custom_tags: # Custom tags for all avi created resources in the cloud infrastructure.
		# dhcp_enabled: # Select the ip address management scheme.
		# dns_provider_ref: # Dns profile for the cloud.
		# docker_configuration: # Dockerconfiguration settings for cloud.
		# east_west_dns_provider_ref: # Dns profile for east-west services.
		# east_west_ipam_provider_ref: # Ipam profile for east-west services.
		# enable_vip_static_routes: # Use static routes for vip side network resolution during virtualservice placement.
		# ipam_provider_ref: # Ipam profile for the cloud.
		# license_tier: # Specifies the default license tier which would be used by new se groups.
		# license_type: # If no license type is specified then default license enforcement for the cloud type is chosen.
		# linuxserver_configuration: # Linuxserverconfiguration settings for cloud.
		# mesos_configuration: # Mesosconfiguration settings for cloud.
		# mtu: # Mtu setting for the cloud.
		# nsx_configuration: # Configuration parameters for nsx manager.
		# obj_name_prefix: # Default prefix for all automatically created objects in this cloud.
		# openstack_configuration: # Openstackconfiguration settings for cloud.
		# oshiftk8s_configuration: # Oshiftk8sconfiguration settings for cloud.
		# prefer_static_routes: # Prefer static routes over interface routes during virtualservice placement.
		# proxy_configuration: # Proxyconfiguration settings for cloud.
		# rancher_configuration: # Rancherconfiguration settings for cloud.
		# state_based_dns_registration: # Dns records for vips are added/deleted based on the operational state of the vips.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# vca_configuration: # Vcloudairconfiguration settings for cloud.
		# vcenter_configuration: # Vcenterconfiguration settings for cloud.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_dnspolicy "Module for setup of DnsPolicy Avi RESTful Object" b
- name: $1
	avi_dnspolicy:
		name: ${2:# Name of the dns policy.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# description: # Field introduced in 17.1.1.
		# rule: # Dns rules.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the dns policy.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_api_session "Avi API Module" b
- name: $1
	avi_api_session:
		http_method: ${2:get|put|post|patch|delete}
		# data: # HTTP body in YAML or JSON format.
		# params: # Query parameters passed to the HTTP API.
		# path: # Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).
		# timeout: 60
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_webhook "Module for setup of Webhook Avi RESTful Object" b
- name: $1
	avi_webhook:
		name: ${2:# The name of the webhook profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# callback_url: # Callback url for the webhook.
		# description: # Field introduced in 17.1.1.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the webhook profile.
		# verification_token: # Verification token sent back with the callback asquery parameters.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_tenant "Module for setup of Tenant Avi RESTful Object" b
- name: $1
	avi_tenant:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# config_settings: # Tenantconfiguration settings for tenant.
		# created_by: # Creator of this tenant.
		# description: # User defined description for the object.
		# local: # Boolean flag to set local.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_alertscriptconfig "Module for setup of AlertScriptConfig Avi RESTful Object" b
- name: $1
	avi_alertscriptconfig:
		name: ${2:# A user-friendly name of the script.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# action_script: # User defined alert action script.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslbhealthmonitor "Module for setup of GslbHealthMonitor Avi RESTful Object" b
- name: $1
	avi_gslbhealthmonitor:
		name: ${2:# A user friendly name for this health monitor.}
		type: ${3:# Type of the health monitor.}
		# state: absent|#present
		# description: # User defined description for the object.
		# dns_monitor: # Healthmonitordns settings for gslbhealthmonitor.
		# external_monitor: # Healthmonitorexternal settings for gslbhealthmonitor.
		# failed_checks: # Number of continuous failed health checks before the server is marked down.
		# http_monitor: # Healthmonitorhttp settings for gslbhealthmonitor.
		# https_monitor: # Healthmonitorhttp settings for gslbhealthmonitor.
		# monitor_port: # Use this port instead of the port defined for the server in the pool.
		# receive_timeout: # A valid response from the server is expected within the receive timeout window.
		# send_interval: # Frequency, in seconds, that monitors are sent to a server.
		# successful_checks: # Number of continuous successful health checks before server is marked up.
		# tcp_monitor: # Healthmonitortcp settings for gslbhealthmonitor.
		# tenant_ref: # It is a reference to an object of type tenant.
		# udp_monitor: # Healthmonitorudp settings for gslbhealthmonitor.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the health monitor.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_applicationpersistenceprofile "Module for setup of ApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_applicationpersistenceprofile:
		name: ${2:# A user-friendly name for the persistence profile.}
		persistence_type: ${3:# Method used to persist clients to the same server for a duration of time or a session.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# app_cookie_persistence_profile: # Specifies the application cookie persistence profile parameters.
		# description: # User defined description for the object.
		# hdr_persistence_profile: # Specifies the custom http header persistence profile parameters.
		# http_cookie_persistence_profile: # Specifies the http cookie persistence profile parameters.
		# ip_persistence_profile: # Specifies the client ip persistence profile parameters.
		# is_federated: # This field describes the object's replication scope.
		# server_hm_down_recovery: # Specifies behavior when a persistent server has been marked down by a health monitor.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the persistence profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_pkiprofile "Module for setup of PKIProfile Avi RESTful Object" b
- name: $1
	avi_pkiprofile:
		name: ${2:# Name of the pki profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# ca_certs: # List of certificate authorities (root and intermediate) trusted that is used for certificate validation.
		# created_by: # Creator name.
		# crl_check: # When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.
		# crls: # Certificate revocation lists.
		# ignore_peer_chain: # When enabled, avi will not trust intermediate and root certs presented by a client.
		# is_federated: # This field describes the object's replication scope.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# validate_only_leaf_crl: # When enabled, avi will only validate the revocation status of the leaf certificate using crl.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_actiongroupconfig "Module for setup of ActionGroupConfig Avi RESTful Object" b
- name: $1
	avi_actiongroupconfig:
		external_only: ${2:# Generate alert only to external destinations.}
		level: ${3:# When an alert is generated, mark its priority via the alert level.}
		name: ${4:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# action_script_config_ref: # Reference of the action script configuration to be used.
		# autoscale_trigger_notification: # Trigger notification to autoscale manager.
		# description: # User defined description for the object.
		# email_config_ref: # Select the email notification configuration to use when sending alerts via email.
		# snmp_trap_profile_ref: # Select the snmp trap notification to use when sending alerts via snmp trap.
		# syslog_config_ref: # Select the syslog notification configuration to use when sending alerts via syslog.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_wafprofile "Module for setup of WafProfile Avi RESTful Object" b
- name: $1
	avi_wafprofile:
		config: ${2:# Config params for waf.}
		name: ${3:# Field introduced in 17.2.1.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # Field introduced in 17.2.1.
		# files: # List of data files used for waf rules.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.2.1.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslbservice_patch_member "Avi API Module" b
- name: $1
	avi_gslbservice_patch_member:
		name: ${2:# Name of the GSLB Service}
		# data: # HTTP body of GSLB Service Member in YAML or JSON format.
		# params: # Query parameters passed to the HTTP API.
		# state: absent|#present
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_vsvip "Module for setup of VsVip Avi RESTful Object" b
- name: $1
	avi_vsvip:
		name: ${2:# Name for the vsvip object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_ref: # It is a reference to an object of type cloud.
		# dns_info: # Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
		# east_west_placement: # Force placement on all service engines in the service engine group (container clouds only).
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the vsvip object.
		# vip: # List of virtual service ips and other shareable entities.
		# vrf_context_ref: # Virtual routing context that the virtual service is bound to.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_cloudconnectoruser "Module for setup of CloudConnectorUser Avi RESTful Object" b
- name: $1
	avi_cloudconnectoruser:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# azure_serviceprincipal: # Field introduced in 17.2.1.
		# azure_userpass: # Field introduced in 17.2.1.
		# private_key: # Private_key of cloudconnectoruser.
		# public_key: # Public_key of cloudconnectoruser.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_networkprofile "Module for setup of NetworkProfile Avi RESTful Object" b
- name: $1
	avi_networkprofile:
		name: ${2:# The name of the network profile.}
		profile: ${3:# Networkprofileunion settings for networkprofile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the network profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_alertconfig "Module for setup of AlertConfig Avi RESTful Object" b
- name: $1
	avi_alertconfig:
		alert_rule: ${2:# List of filters matching on events or client logs used for triggering alerts.}
		category: ${3:# Determines whether an alert is raised immediately when event occurs (realtime) or after specified number of events occurs within rolling time}
		name: ${4:# Name of the alert configuration.}
		source: ${5:# Signifies system events or the type of client logsused in this alert configuration.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# action_group_ref: # The alert config will trigger the selected alert action, which can send notifications and execute a controlscript.
		# autoscale_alert: # This alert config applies to auto scale alerts.
		# description: # A custom description field.
		# enabled: # Enable or disable this alert config from generating new alerts.
		# expiry_time: # An alert is expired and deleted after the expiry time has elapsed.
		# obj_uuid: # Uuid of the resource for which alert was raised.
		# object_type: # The object type to which the alert config is associated with.
		# recommendation: # Recommendation of alertconfig.
		# rolling_window: # Only if the number of events is reached or exceeded within the time window will an alert be generated.
		# summary: # Summary of reason why alert is generated.
		# tenant_ref: # It is a reference to an object of type tenant.
		# threshold: # An alert is created only when the number of events meets or exceeds this number within the chosen time frame.
		# throttle: # Alerts are suppressed (throttled) for this duration of time since the last alert was raised for this alert config.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_serviceengine "Module for setup of ServiceEngine Avi RESTful Object" b
- name: $1
	avi_serviceengine:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# availability_zone: # Availability_zone of serviceengine.
		# cloud_ref: # It is a reference to an object of type cloud.
		# container_mode: # Boolean flag to set container_mode.
		# container_type: # Enum options - container_type_bridge, container_type_host, container_type_host_dpdk.
		# controller_created: # Boolean flag to set controller_created.
		# controller_ip: # Controller_ip of serviceengine.
		# data_vnics: # List of vnic.
		# enable_state: # Inorder to disable se set this field appropriately.
		# flavor: # Flavor of serviceengine.
		# host_ref: # It is a reference to an object of type vimgrhostruntime.
		# hypervisor: # Enum options - default, vmware_esx, kvm, vmware_vsan, xen.
		# mgmt_vnic: # Vnic settings for serviceengine.
		# name: # Name of the object.
		# resources: # Seresources settings for serviceengine.
		# se_group_ref: # It is a reference to an object of type serviceenginegroup.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslbapplicationpersistenceprofile "Module for setup of GslbApplicationPersistenceProfile Avi RESTful Object" b
- name: $1
	avi_gslbapplicationpersistenceprofile:
		name: ${2:# A user-friendly name for the persistence profile.}
		# state: absent|#present
		# description: # Field introduced in 17.1.1.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the persistence profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_useraccount "Avi UserAccount Module" b
- name: $1
	avi_useraccount:
		# old_password: # Old password for update password or default password for bootstrap.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_systemconfiguration "Module for setup of SystemConfiguration Avi RESTful Object" b
- name: $1
	avi_systemconfiguration:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# admin_auth_configuration: # Adminauthconfiguration settings for systemconfiguration.
		# default_license_tier: # Specifies the default license tier which would be used by new clouds.
		# dns_configuration: # Dnsconfiguration settings for systemconfiguration.
		# dns_virtualservice_refs: # Dns virtualservices hosting fqdn records for applications across avi vantage.
		# docker_mode: # Boolean flag to set docker_mode.
		# email_configuration: # Emailconfiguration settings for systemconfiguration.
		# global_tenant_config: # Tenantconfiguration settings for systemconfiguration.
		# linux_configuration: # Linuxconfiguration settings for systemconfiguration.
		# mgmt_ip_access_control: # Configure ip access control for controller to restrict open access.
		# ntp_configuration: # Ntpconfiguration settings for systemconfiguration.
		# portal_configuration: # Portalconfiguration settings for systemconfiguration.
		# proxy_configuration: # Proxyconfiguration settings for systemconfiguration.
		# snmp_configuration: # Snmpconfiguration settings for systemconfiguration.
		# ssh_ciphers: # Allowed ciphers list for ssh to the management interface on the controller and service engines.
		# ssh_hmacs: # Allowed hmac list for ssh to the management interface on the controller and service engines.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_gslbgeodbprofile "Module for setup of GslbGeoDbProfile Avi RESTful Object" b
- name: $1
	avi_gslbgeodbprofile:
		name: ${2:# A user-friendly name for the geodb profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # Field introduced in 17.1.1.
		# entries: # List of geodb entries.
		# is_federated: # This field indicates that this object is replicated across gslb federation.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the geodb profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_useraccountprofile "Module for setup of UserAccountProfile Avi RESTful Object" b
- name: $1
	avi_useraccountprofile:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# account_lock_timeout: # Lock timeout period (in minutes).
		# credentials_timeout_threshold: # The time period after which credentials expire.
		# max_concurrent_sessions: # Maximum number of concurrent sessions allowed.
		# max_login_failure_count: # Number of login attempts before lockout.
		# max_password_history_count: # Maximum number of passwords to be maintained in the password history.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_l4policyset "Module for setup of L4PolicySet Avi RESTful Object" b
- name: $1
	avi_l4policyset:
		name: ${2:# Name of the l4 policy set.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# description: # Field introduced in 17.2.7.
		# is_internal_policy: # Field introduced in 17.2.7.
		# l4_connection_policy: # Policy to apply when a new transport connection is setup.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Id of the l4 policy set.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_role "Module for setup of Role Avi RESTful Object" b
- name: $1
	avi_role:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# privileges: # List of permission.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_alertemailconfig "Module for setup of AlertEmailConfig Avi RESTful Object" b
- name: $1
	avi_alertemailconfig:
		name: ${2:# A user-friendly name of the email notification service.}
		to_emails: ${3:# Alerts are sent to the comma separated list of  email recipients.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cc_emails: # Alerts are copied to the comma separated list of  email recipients.
		# description: # User defined description for the object.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_wafpolicy "Module for setup of WafPolicy Avi RESTful Object" b
- name: $1
	avi_wafpolicy:
		mode: ${2:# Waf policy mode.}
		name: ${3:# Field introduced in 17.2.1.}
		waf_profile_ref: ${4:# Waf profile for waf policy.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# created_by: # Creator name.
		# crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# description: # Field introduced in 17.2.1.
		# paranoia_level: # Waf ruleset paranoia  mode.
		# post_crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# pre_crs_groups: # Waf rules are categorized in to groups based on their characterization.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Field introduced in 17.2.1.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_serverautoscalepolicy "Module for setup of ServerAutoScalePolicy Avi RESTful Object" b
- name: $1
	avi_serverautoscalepolicy:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# intelligent_autoscale: # Use avi intelligent autoscale algorithm where autoscale is performed by comparing load on the pool against estimated capacity of all the servers.
		# intelligent_scalein_margin: # Maximum extra capacity as percentage of load used by the intelligent scheme.
		# intelligent_scaleout_margin: # Minimum extra capacity as percentage of load used by the intelligent scheme.
		# max_scalein_adjustment_step: # Maximum number of servers to scalein simultaneously.
		# max_scaleout_adjustment_step: # Maximum number of servers to scaleout simultaneously.
		# max_size: # Maximum number of servers after scaleout.
		# min_size: # No scale-in happens once number of operationally up servers reach min_servers.
		# scalein_alertconfig_refs: # Trigger scalein when alerts due to any of these alert configurations are raised.
		# scalein_cooldown: # Cooldown period during which no new scalein is triggered to allow previous scalein to successfully complete.
		# scaleout_alertconfig_refs: # Trigger scaleout when alerts due to any of these alert configurations are raised.
		# scaleout_cooldown: # Cooldown period during which no new scaleout is triggered to allow previous scaleout to successfully complete.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# use_predicted_load: # Use predicted load rather than current load.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_sslprofile "Module for setup of SSLProfile Avi RESTful Object" b
- name: $1
	avi_sslprofile:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# accepted_ciphers: # Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).
		# accepted_versions: # Set of versions accepted by the server.
		# cipher_enums: # Enum options - tls_ecdhe_ecdsa_with_aes_128_gcm_sha256, tls_ecdhe_ecdsa_with_aes_256_gcm_sha384, tls_ecdhe_rsa_with_aes_128_gcm_sha256,
		# description: # User defined description for the object.
		# dhparam: # Dh parameters used in ssl.
		# enable_ssl_session_reuse: # Enable ssl session re-use.
		# prefer_client_cipher_ordering: # Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.
		# send_close_notify: # Send 'close notify' alert message for a clean shutdown of the ssl connection.
		# ssl_rating: # Sslrating settings for sslprofile.
		# ssl_session_timeout: # The amount of time before an ssl session expires.
		# tags: # List of tag.
		# tenant_ref: # It is a reference to an object of type tenant.
		# type: # Ssl profile type.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_cloudproperties "Module for setup of CloudProperties Avi RESTful Object" b
- name: $1
	avi_cloudproperties:
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cc_props: # Cloudconnector properties.
		# cc_vtypes: # Cloud types supported by cloudconnector.
		# hyp_props: # Hypervisor properties.
		# info: # Properties specific to a cloud type.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_sslkeyandcertificate "Module for setup of SSLKeyAndCertificate Avi RESTful Object" b
- name: $1
	avi_sslkeyandcertificate:
		certificate: ${2:# Sslcertificate settings for sslkeyandcertificate.}
		name: ${3:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# ca_certs: # Ca certificates in certificate chain.
		# certificate_management_profile_ref: # It is a reference to an object of type certificatemanagementprofile.
		# created_by: # Creator name.
		# dynamic_params: # Dynamic parameters needed for certificate management profile.
		# enckey_base64: # Encrypted private key corresponding to the private key (e.g.
		# enckey_name: # Name of the encrypted private key (e.g.
		# hardwaresecuritymodulegroup_ref: # It is a reference to an object of type hardwaresecuritymodulegroup.
		# key: # Private key.
		# key_params: # Sslkeyparams settings for sslkeyandcertificate.
		# status: # Enum options - ssl_certificate_finished, ssl_certificate_pending.
		# tenant_ref: # It is a reference to an object of type tenant.
		# type: # Enum options - ssl_certificate_type_virtualservice, ssl_certificate_type_system, ssl_certificate_type_ca.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_authprofile "Module for setup of AuthProfile Avi RESTful Object" b
- name: $1
	avi_authprofile:
		name: ${2:# Name of the auth profile.}
		type: ${3:# Type of the auth profile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# http: # Http user authentication params.
		# ldap: # Ldap server and directory settings.
		# saml: # Saml settings.
		# tacacs_plus: # Tacacs+ settings.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the auth profile.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_cluster "Module for setup of Cluster Avi RESTful Object" b
- name: $1
	avi_cluster:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# nodes: # List of clusternode.
		# rejoin_nodes_automatically: # Re-join cluster nodes automatically in the event one of the node is reset to factory.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# virtual_ip: # A virtual ip address.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_hardwaresecuritymodulegroup "Module for setup of HardwareSecurityModuleGroup Avi RESTful Object" b
- name: $1
	avi_hardwaresecuritymodulegroup:
		hsm: ${2:# Hardware security module configuration.}
		name: ${3:# Name of the hsm group configuration object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the hsm group configuration object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_autoscalelaunchconfig "Module for setup of AutoScaleLaunchConfig Avi RESTful Object" b
- name: $1
	avi_autoscalelaunchconfig:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# description: # User defined description for the object.
		# image_id: # Unique id of the amazon machine image (ami)  or openstack vm id.
		# mesos: # Autoscalemesossettings settings for autoscalelaunchconfig.
		# openstack: # Autoscaleopenstacksettings settings for autoscalelaunchconfig.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# use_external_asg: # If set to true, serverautoscalepolicy will use the autoscaling group (external_autoscaling_groups) from pool to perform scale up and scale down.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_vrfcontext "Module for setup of VrfContext Avi RESTful Object" b
- name: $1
	avi_vrfcontext:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# bgp_profile: # Bgp local and peer info.
		# cloud_ref: # It is a reference to an object of type cloud.
		# debugvrfcontext: # Configure debug flags for vrf.
		# description: # User defined description for the object.
		# gateway_mon: # Configure ping based heartbeat check for gateway in service engines of vrf.
		# internal_gateway_monitor: # Configure ping based heartbeat check for all default gateways in service engines of vrf.
		# static_routes: # List of staticroute.
		# system_default: # Boolean flag to set system_default.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_certificatemanagementprofile "Module for setup of CertificateManagementProfile Avi RESTful Object" b
- name: $1
	avi_certificatemanagementprofile:
		name: ${2:# Name of the pki profile.}
		script_path: ${3:# Script_path of certificatemanagementprofile.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# script_params: # List of customparams.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_network "Module for setup of Network Avi RESTful Object" b
- name: $1
	avi_network:
		name: ${2:# Name of the object.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# cloud_ref: # It is a reference to an object of type cloud.
		# configured_subnets: # List of subnet.
		# dhcp_enabled: # Select the ip address management scheme for this network.
		# exclude_discovered_subnets: # When selected, excludes all discovered subnets in this network from consideration for virtual service placement.
		# synced_from_se: # Boolean flag to set synced_from_se.
		# tenant_ref: # It is a reference to an object of type tenant.
		# url: # Avi controller URL of the object.
		# uuid: # Unique object identifier of the object.
		# vcenter_dvs: # Boolean flag to set vcenter_dvs.
		# vimgrnw_ref: # It is a reference to an object of type vimgrnwruntime.
		# vrf_context_ref: # It is a reference to an object of type vrfcontext.
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet avi_poolgroupdeploymentpolicy "Module for setup of PoolGroupDeploymentPolicy Avi RESTful Object" b
- name: $1
	avi_poolgroupdeploymentpolicy:
		name: ${2:# The name of the pool group deployment policy.}
		# state: absent|#present
		# avi_api_update_method: #put|patch
		# avi_api_patch_op: add|replace|delete
		# auto_disable_old_prod_pools: # It will automatically disable old production pools once there is a new production candidate.
		# cloud_ref: # It is a reference to an object of type cloud.
		# description: # User defined description for the object.
		# evaluation_duration: # Duration of evaluation period for automatic deployment.
		# rules: # List of pgdeploymentrule.
		# scheme: # Deployment scheme.
		# target_test_traffic_ratio: # Target traffic ratio before pool is made production.
		# tenant_ref: # It is a reference to an object of type tenant.
		# test_traffic_ratio_rampup: # Ratio of the traffic that is sent to the pool under test.
		# url: # Avi controller URL of the object.
		# uuid: # Uuid of the pool group deployment policy.
		# webhook_ref: # Webhook configured with url that avi controller will pass back information about pool group, old and new pool information and current deployment
		# controller: 
		# username: 
		# password: 
		# tenant: admin
		# tenant_uuid: 
		# api_version: 16.4.4
		# avi_credentials: # Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.
		# api_context: # Avi API context that includes current session ID and CSRF Token.
$0
endsnippet

snippet exos_facts "Collect facts from devices running Extreme EXOS" b
- name: $1
	exos_facts:
		# gather_subset: ['!config']
$0
endsnippet

snippet exos_config "Manage Extreme Networks EXOS configuration sections" b
- name: $1
	exos_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# defaults: no
		# save_when: always|#never|modified|changed
		# diff_against: running|startup|intended
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
$0
endsnippet

snippet exos_command "Run commands on remote devices running Extreme EXOS" b
- name: $1
	exos_command:
		commands: ${2:# List of commands to send to the remote EXOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet ironware_facts "Collect facts from devices running Extreme Ironware" b
- name: $1
	ironware_facts:
		# gather_subset: ['!config', '!mpls']
		# authorize: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet ironware_command "Run arbitrary commands on Extreme IronWare devices" b
- name: $1
	ironware_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# authorize: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet ironware_config "Manage configuration sections on Extreme Ironware devices" b
- name: $1
	ironware_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# update: #merge|check
		# commit: #merge|check
		# backup: no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# save_when: always|#never|modified
		# authorize: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet slxos_l2_interface "Manage Layer-2 interface on Extreme Networks SLX-OS devices." b
- name: $1
	slxos_l2_interface:
		name: ${2:# Full name of the interface excluding any logical unit number, i.e. Ethernet 0/1.}
		# mode: #access|trunk
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# trunk_vlans: # List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
		# aggregate: # List of Layer-2 interface definitions.
		# state: #present|absent|unconfigured
$0
endsnippet

snippet slxos_config "Manage Extreme Networks SLX-OS configuration sections" b
- name: $1
	slxos_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# multiline_delimiter: @
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# defaults: no
		# save_when: always|#never|modified|changed
		# diff_against: running|startup|intended
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
$0
endsnippet

snippet slxos_command "Run commands on remote devices running Extreme Networks SLX-OS" b
- name: $1
	slxos_command:
		commands: ${2:# List of commands to send to the remote SLX-OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet slxos_l3_interface "Manage L3 interfaces on Extreme Networks SLX-OS network devices." b
- name: $1
	slxos_l3_interface:
		# name: # Name of the L3 interface to be configured eg. Ethernet 0/2
		# ipv4: # IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
		# ipv6: # IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
		# aggregate: # List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
		# state: #present|absent
$0
endsnippet

snippet slxos_lldp "Manage LLDP configuration on Extreme Networks SLX-OS network devices." b
- name: $1
	slxos_lldp:
		# state: #present|absent
$0
endsnippet

snippet slxos_interface "Manage Interfaces on Extreme SLX-OS network devices" b
- name: $1
	slxos_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: yes
		# speed: # Interface link speed.
		# mtu: # Maximum size of transmit packet.
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# aggregate: # L
		# delay: 10
		# state: #present|absent|up|down
$0
endsnippet

snippet slxos_facts "Collect facts from devices running Extreme SLX-OS" b
- name: $1
	slxos_facts:
		# gather_subset: ['!config']
$0
endsnippet

snippet slxos_linkagg "Manage link aggregation groups on Extreme Networks SLX-OS network devices" b
- name: $1
	slxos_linkagg:
		# group: # Channel-group number for the port-channel Link aggregation group. Range 1-1024.
		# mode: active|on|passive
		# members: # List of members of the link aggregation group.
		# aggregate: # L
		# state: #present|absent
		# purge: # Purge links not defined in the I(aggregate) parameter.
$0
endsnippet

snippet slxos_vlan "Manage VLANs on Extreme Networks SLX-OS network devices" b
- name: $1
	slxos_vlan:
		vlan_id: ${2:# ID of the VLAN. Range 1-4094.}
		interfaces: ${3:# List of interfaces that should be associated to the VLAN.}
		# name: # Name of the VLAN.
		# delay: 10
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet netscaler_server "Manage server configuration" b
- name: $1
	netscaler_server:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the server.
		# ipaddress: # IPv4 or IPv6 address of the server. If you create an IP address based server, you can specify the name of the server, instead of its IP address, when creating a service. Note: If you do not create a server entry, the server IP address that you enter when you create a service becomes the name of the server.
		# domain: # Domain name of the server. For a domain based configuration, you must create the server first.
		# translationip: # IP address used to transform the server's DNS-resolved IP address.
		# translationmask: # The netmask of the translation ip.
		# domainresolveretry: 5
		# ipv6address: no
		# comment: # Any information about the server.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# graceful: # Shut down gracefully, without accepting any new connections, and disabling each service when all of its connections are closed.
		# delay: # Time, in seconds, after which all the services configured on the server are disabled.
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_servicegroup "Manage service group configuration in Netscaler" b
- name: $1
	netscaler_servicegroup:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# servicegroupname: # Name of the service group. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the name is created.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# cachetype: TRANSPARENT|REVERSE|FORWARD
		# maxclient: # Maximum number of simultaneous open connections for the service group.
		# maxreq: # Maximum number of requests that can be sent on a persistent connection to the service group.
		# cacheable: # Use the transparent cache redirection virtual server to forward the request to the cache server.
		# cip: enabled|disabled
		# cipheader: # Name of the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If client IP insertion is enabled, and the client IP header is not specified, the value of Client IP Header parameter or the value set by the set ns config command is used as client's IP header name.
		# usip: # Use client's IP address as the source IP address when initiating connection to the server. With the NO setting, which is the default, a mapped IP (MIP) address or subnet IP (SNIP) address is used as the source IP address to initiate server side connections.
		# pathmonitor: # Path monitoring for clustering.
		# pathmonitorindv: # Individual Path monitoring decisions.
		# useproxyport: # Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
		# healthmonitor: # Monitor the health of this service. Available settings function as follows:
		# sp: # Enable surge protection for the service group.
		# rtspsessionidremap: # Enable RTSP session ID mapping for the service group.
		# clttimeout: # Time, in seconds, after which to terminate an idle client connection.
		# svrtimeout: # Time, in seconds, after which to terminate an idle server connection.
		# cka: # Enable client keep-alive for the service group.
		# tcpb: # Enable TCP buffering for the service group.
		# cmp: # Enable compression for the specified service.
		# maxbandwidth: # Maximum bandwidth, in Kbps, allocated for all the services in the service group.
		# monthreshold: # Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
		# downstateflush: enabled|disabled
		# tcpprofilename: # Name of the TCP profile that contains TCP configuration settings for the service group.
		# httpprofilename: # Name of the HTTP profile that contains HTTP configuration settings for the service group.
		# comment: # Any information about the service group.
		# appflowlog: enabled|disabled
		# netprofile: # Network profile for the service group.
		# autoscale: DISABLED|DNS|POLICY
		# memberport: # member port.
		# graceful: # Wait for all existing connections to the service to terminate before shutting down the service.
		# servicemembers: # A list of dictionaries describing each service member of the service group.
		# monitorbindings: # A list of monitornames to bind to this service
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_gslb_vserver "Configure gslb vserver entities in Netscaler." b
- name: $1
	netscaler_gslb_vserver:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the GSLB virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE
		# dnsrecordtype: A|AAAA|CNAME|NAPTR
		# lbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD
		# backuplbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD
		# netmask: # IPv4 network mask for use in the SOURCEIPHASH load balancing method.
		# v6netmasklen: # Number of bits to consider, in an IPv6 source IP address, for creating the hash that is required by the C(SOURCEIPHASH) load balancing method.
		# tolerance: # Site selection tolerance, in milliseconds, for implementing the RTT load balancing method. If a site's RTT deviates from the lowest RTT by more than the specified tolerance, the site is not considered when the NetScaler appliance makes a GSLB decision. The appliance implements the round robin method of global server load balancing between sites whose RTT values are within the specified tolerance. If the tolerance is 0 (zero), the appliance always sends clients the IP address of the site with the lowest RTT.
		# persistencetype: SOURCEIP|NONE
		# persistenceid: # The persistence ID for the GSLB virtual server. The ID is a positive integer that enables GSLB sites to identify the GSLB virtual server, and is required if source IP address based or spill over based persistence is enabled on the virtual server.
		# persistmask: # The optional IPv4 network mask applied to IPv4 addresses to establish source IP address based persistence.
		# v6persistmasklen: # Number of bits to consider in an IPv6 source IP address when creating source IP address based persistence sessions.
		# timeout: # Idle time, in minutes, after which a persistence entry is cleared.
		# mir: enabled|disabled
		# disableprimaryondown: enabled|disabled
		# dynamicweight: SERVICECOUNT|SERVICEWEIGHT|DISABLED
		# considereffectivestate: NONE|STATE_ONLY
		# comment: # Any comments that you might want to associate with the GSLB virtual server.
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# sopersistence: enabled|disabled
		# sopersistencetimeout: # Timeout for spillover persistence, in minutes.
		# sothreshold: # Threshold at which spillover occurs. Specify an integer for the CONNECTION spillover method, a bandwidth value in kilobits per second for the BANDWIDTH method (do not enter the units), or a percentage for the HEALTH method (do not enter the percentage symbol).
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# appflowlog: enabled|disabled
		# domain_bindings: # List of bindings for domains for this glsb vserver.
		# service_bindings: # List of bindings for gslb services bound to this gslb virtual server.
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_save_config "Save Netscaler configuration." b
- name: $1
	netscaler_save_config:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
$0
endsnippet

snippet netscaler_gslb_service "Manage gslb service entities in Netscaler." b
- name: $1
	netscaler_gslb_service:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# servicename: # Name for the GSLB service. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the GSLB service is created.
		# cnameentry: # Canonical name of the GSLB service. Used in CNAME-based GSLB.
		# servername: # Name of the server hosting the GSLB service.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE
		# port: # Port on which the load balancing entity represented by this GSLB service listens.
		# publicip: # The public IP address that a NAT device translates to the GSLB service's private IP address. Optional.
		# publicport: # The public port associated with the GSLB service's public IP address. The port is mapped to the service's private port number. Applicable to the local GSLB service. Optional.
		# maxclient: # The maximum number of open connections that the service can support at any given time. A GSLB service whose connection count reaches the maximum is not considered when a GSLB decision is made, until the connection count drops below the maximum.
		# healthmonitor: # Monitor the health of the GSLB service.
		# sitename: # Name of the GSLB site to which the service belongs.
		# cip: enabled|disabled
		# cipheader: # Name for the HTTP header that stores the client's IP address. Used with the Client IP option. If client IP header insertion is enabled on the service and a name is not specified for the header, the NetScaler appliance uses the name specified by the cipHeader parameter in the set ns param command or, in the GUI, the Client IP Header parameter in the Configure HTTP Parameters dialog box.
		# sitepersistence: ConnectionProxy|HTTPRedirect|NONE
		# siteprefix: # The site's prefix string. When the service is bound to a GSLB virtual server, a GSLB site domain is generated internally for each bound service-domain pair by concatenating the site prefix of the service and the name of the domain. If the special string NONE is specified, the site-prefix string is unset. When implementing HTTP redirect site persistence, the NetScaler appliance redirects GSLB requests to GSLB services by using their site domains.
		# clttimeout: # Idle time, in seconds, after which a client connection is terminated. Applicable if connection proxy based site persistence is used.
		# maxbandwidth: # Integer specifying the maximum bandwidth allowed for the service. A GSLB service whose bandwidth reaches the maximum is not considered when a GSLB decision is made, until its bandwidth consumption drops below the maximum.
		# downstateflush: enabled|disabled
		# maxaaausers: # Maximum number of SSL VPN users that can be logged on concurrently to the VPN virtual server that is represented by this GSLB service. A GSLB service whose user count reaches the maximum is not considered when a GSLB decision is made, until the count drops below the maximum.
		# monthreshold: # Monitoring threshold value for the GSLB service. If the sum of the weights of the monitors that are bound to this GSLB service and are in the UP state is not equal to or greater than this threshold value, the service is marked as DOWN.
		# hashid: # Unique hash identifier for the GSLB service, used by hash based load balancing methods.
		# comment: # Any comments that you might want to associate with the GSLB service.
		# appflowlog: enabled|disabled
		# ipaddress: # IP address for the GSLB service. Should represent a load balancing, content switching, or VPN virtual server on the NetScaler appliance, or the IP address of another load balancing device.
		# monitor_bindings: # Bind monitors to this gslb service
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_cs_action "Manage content switching actions" b
- name: $1
	netscaler_cs_action:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the content switching action. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the content switching action is created.
		# targetlbvserver: # Name of the load balancing virtual server to which the content is switched.
		# targetvserver: # Name of the VPN virtual server to which the content is switched.
		# targetvserverexpr: # Information about this content switching action.
		# comment: # Comments associated with this cs action.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_lb_vserver "Manage load balancing vserver configuration" b
- name: $1
	netscaler_lb_vserver:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|DNS|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|RTSP|PUSH|SSL_PUSH|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|TFTP|ORACLE|SMPP|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# ipv46: # IPv4 or IPv6 address to assign to the virtual server.
		# ippattern: # IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
		# ipmask: # IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
		# port: # Port number for the virtual server.
		# range: # Number of IP addresses that the appliance must generate and assign to the virtual server. The virtual server then functions as a network virtual server, accepting traffic on any of the generated IP addresses. The IP addresses are generated automatically, as follows:
		# persistencetype: SOURCEIP|COOKIEINSERT|SSLSESSION|RULE|URLPASSIVE|CUSTOMSERVERID|DESTIP|SRCIPDESTIP|CALLID|RTSPSID|DIAMETER|FIXSESSION|NONE
		# timeout: # Time period for which a persistence session is in effect.
		# persistencebackup: SOURCEIP|NONE
		# backuppersistencetimeout: # Time period for which backup persistence is in effect.
		# lbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|URLHASH|DOMAINHASH|DESTINATIONIPHASH|SOURCEIPHASH|SRCIPDESTIPHASH|LEASTBANDWIDTH|LEASTPACKETS|TOKEN|SRCIPSRCPORTHASH|LRTM|CALLIDHASH|CUSTOMLOAD|LEASTREQUEST|AUDITLOGHASH|STATICPROXIMITY
		# hashlength: # Number of bytes to consider for the hash value used in the URLHASH and DOMAINHASH load balancing methods.
		# netmask: # IPv4 subnet mask to apply to the destination IP address or source IP address when the load balancing method is C(DESTINATIONIPHASH) or C(SOURCEIPHASH).
		# v6netmasklen: # Number of bits to consider in an IPv6 destination or source IP address, for creating the hash that is required by the C(DESTINATIONIPHASH) and C(SOURCEIPHASH) load balancing methods.
		# backuplbmethod: ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|CUSTOMLOAD
		# cookiename: # Use this parameter to specify the cookie name for C(COOKIE) peristence type. It specifies the name of cookie with a maximum of 32 characters. If not specified, cookie name is internally generated.
		# listenpolicy: # Default syntax expression identifying traffic accepted by the virtual server. Can be either an expression (for example, C(CLIENT.IP.DST.IN_SUBNET(192.0.2.0/24)) or the name of a named expression. In the above example, the virtual server accepts all requests whose destination IP address is in the 192.0.2.0/24 subnet.
		# listenpriority: # Integer specifying the priority of the listen policy. A higher number specifies a lower priority. If a request matches the listen policies of more than one virtual server the virtual server whose listen policy has the highest priority (the lowest priority number) accepts the request.
		# resrule: # Default syntax expression specifying which part of a server's response to use for creating rule based persistence sessions (persistence type RULE). Can be either an expression or the name of a named expression.
		# persistmask: # Persistence mask for IP based persistence types, for IPv4 virtual servers.
		# v6persistmasklen: # Persistence mask for IP based persistence types, for IPv6 virtual servers.
		# rtspnat: # Use network address translation (NAT) for RTSP data connections.
		# m: IP|MAC|IPTUNNEL|TOS
		# tosid: # TOS ID of the virtual server. Applicable only when the load balancing redirection mode is set to TOS.
		# datalength: # Length of the token to be extracted from the data segment of an incoming packet, for use in the token method of load balancing. The length of the token, specified in bytes, must not be greater than 24 KB. Applicable to virtual servers of type TCP.
		# dataoffset: # Offset to be considered when extracting a token from the TCP payload. Applicable to virtual servers, of type TCP, using the token method of load balancing. Must be within the first 24 KB of the TCP payload.
		# sessionless: enabled|disabled
		# connfailover: DISABLED|STATEFUL|STATELESS
		# redirurl: # URL to which to redirect traffic if the virtual server becomes unavailable.
		# cacheable: # Route cacheable requests to a cache redirection virtual server. The load balancing virtual server can forward requests only to a transparent cache redirection virtual server that has an IP address and port combination of *:80, so such a cache redirection virtual server must be configured on the appliance.
		# clttimeout: # Idle time, in seconds, after which a client connection is terminated.
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# sopersistence: enabled|disabled
		# sopersistencetimeout: # Timeout for spillover persistence, in minutes.
		# healththreshold: # Threshold in percent of active services below which vserver state is made down. If this threshold is 0, vserver state will be up even if one bound service is up.
		# sothreshold: # Threshold at which spillover occurs. Specify an integer for the C(CONNECTION) spillover method, a bandwidth value in kilobits per second for the C(BANDWIDTH) method (do not enter the units), or a percentage for the C(HEALTH) method (do not enter the percentage symbol).
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# redirectportrewrite: enabled|disabled
		# downstateflush: enabled|disabled
		# disableprimaryondown: enabled|disabled
		# insertvserveripport: OFF|VIPADDR|V6TOV4MAPPING
		# vipheader: # Name for the inserted header. The default name is vip-header.
		# authenticationhost: # Fully qualified domain name (FQDN) of the authentication virtual server to which the user must be redirected for authentication. Make sure that the Authentication parameter is set to C(yes).
		# authentication: # Enable or disable user authentication.
		# authn401: # Enable or disable user authentication with HTTP 401 responses.
		# authnvsname: # Name of an authentication virtual server with which to authenticate users.
		# push: enabled|disabled
		# pushvserver: # Name of the load balancing virtual server, of type PUSH or SSL_PUSH, to which the server pushes updates received on the load balancing virtual server that you are configuring.
		# pushlabel: # Expression for extracting a label from the server's response. Can be either an expression or the name of a named expression.
		# pushmulticlients: # Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
		# tcpprofilename: # Name of the TCP profile whose settings are to be applied to the virtual server.
		# httpprofilename: # Name of the HTTP profile whose settings are to be applied to the virtual server.
		# dbprofilename: # Name of the DB profile whose settings are to be applied to the virtual server.
		# comment: # Any comments that you might want to associate with the virtual server.
		# l2conn: # Use Layer 2 parameters (channel number, MAC address, and VLAN ID) in addition to the 4-tuple (<source IP>:<source port>::<destination IP>:<destination port>) that is used to identify a connection. Allows multiple TCP and non-TCP connections with the same 4-tuple to co-exist on the NetScaler appliance.
		# oracleserverversion: 10G|11G
		# mssqlserverversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# mysqlprotocolversion: # MySQL protocol version that the virtual server advertises to clients.
		# mysqlserverversion: # MySQL server version string that the virtual server advertises to clients.
		# mysqlcharacterset: # Character set that the virtual server advertises to clients.
		# mysqlservercapabilities: # Server capabilities that the virtual server advertises to clients.
		# appflowlog: enabled|disabled
		# netprofile: # Name of the network profile to associate with the virtual server. If you set this parameter, the virtual server uses only the IP addresses in the network profile as source IP addresses when initiating connections with servers.
		# icmpvsrresponse: PASSIVE|ACTIVE
		# rhistate: PASSIVE|ACTIVE
		# newservicerequest: # Number of requests, or percentage of the load on existing services, by which to increase the load on a new service at each interval in slow-start mode. A non-zero value indicates that slow-start is applicable. A zero value indicates that the global RR startup parameter is applied. Changing the value to zero will cause services currently in slow start to take the full traffic as determined by the LB method. Subsequently, any new services added will use the global RR factor.
		# newservicerequestunit: PER_SECOND|PERCENT
		# newservicerequestincrementinterval: # Interval, in seconds, between successive increments in the load on a new service or a service whose state has just changed from DOWN to UP. A value of 0 (zero) specifies manual slow start.
		# minautoscalemembers: # Minimum number of members expected to be present when vserver is used in Autoscale.
		# maxautoscalemembers: # Maximum number of members expected to be present when vserver is used in Autoscale.
		# persistavpno: # Persist AVP number for Diameter Persistency.
		# skippersistency: Bypass|ReLb|None
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# authnprofile: # Name of the authentication profile to be used when authentication is turned on.
		# macmoderetainvlan: enabled|disabled
		# dbslb: enabled|disabled
		# dns64: enabled|disabled
		# bypassaaaa: # If this option is enabled while resolving DNS64 query AAAA queries are not sent to back end dns server.
		# recursionavailable: # When set to YES, this option causes the DNS replies from this vserver to have the RA bit turned on. Typically one would set this option to YES, when the vserver is load balancing a set of DNS servers thatsupport recursive queries.
		# processlocal: enabled|disabled
		# dnsprofilename: # Name of the DNS profile to be associated with the VServer. DNS profile properties will be applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
		# servicebindings: # List of services along with the weights that are load balanced.
		# servicegroupbindings: # List of service groups along with the weights that are load balanced.
		# ssl_certkey: # The name of the ssl certificate that is bound to this service.
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_cs_vserver "Manage content switching vserver" b
- name: $1
	netscaler_cs_vserver:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the content switching virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# servicetype: HTTP|SSL|TCP|FTP|RTSP|SSL_TCP|UDP|DNS|SIP_UDP|SIP_TCP|SIP_SSL|ANY|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|DNS_TCP|ORACLE|SMPP
		# ipv46: # IP address of the content switching virtual server.
		# targettype: GSLB
		# ippattern: # IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
		# ipmask: # IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
		# range: # Number of consecutive IP addresses, starting with the address specified by the IP Address parameter, to include in a range of addresses assigned to this virtual server.
		# port: # Port number for content switching virtual server.
		# stateupdate: enabled|disabled
		# cacheable: # Use this option to specify whether a virtual server, used for load balancing or content switching, routes requests to the cache redirection virtual server before sending it to the configured servers.
		# redirecturl: # URL to which traffic is redirected if the virtual server becomes unavailable. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# clttimeout: # Idle time, in seconds, after which the client connection is terminated. The default values are:
		# precedence: RULE|URL
		# casesensitive: # Consider case in URLs (for policies that use URLs instead of RULES). For example, with the C(on) setting, the URLs /a/1.html and /A/1.HTML are treated differently and can have different targets (set by content switching policies). With the C(off) setting, /a/1.html and /A/1.HTML are switched to the same target.
		# somethod: CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE
		# sopersistence: enabled|disabled
		# sopersistencetimeout: # Time-out value, in minutes, for spillover persistence.
		# sothreshold: # Depending on the spillover method, the maximum number of connections or the maximum total bandwidth (Kbps) that a virtual server can handle before spillover occurs.
		# sobackupaction: DROP|ACCEPT|REDIRECT
		# redirectportrewrite: enabled|disabled
		# downstateflush: enabled|disabled
		# backupvserver: # Name of the backup virtual server that you are configuring. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the backup virtual server is created. You can assign a different backup virtual server or rename the existing virtual server.
		# disableprimaryondown: enabled|disabled
		# insertvserveripport: OFF|VIPADDR|V6TOV4MAPPING
		# vipheader: # Name of virtual server IP and port header, for use with the VServer IP Port Insertion parameter.
		# rtspnat: # Enable network address translation (NAT) for real-time streaming protocol (RTSP) connections.
		# authenticationhost: # FQDN of the authentication virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# authentication: # Authenticate users who request a connection to the content switching virtual server.
		# listenpolicy: # String specifying the listen policy for the content switching virtual server. Can be either the name of an existing expression or an in-line expression.
		# authn401: # Enable HTTP 401-response based authentication.
		# authnvsname: # Name of authentication virtual server that authenticates the incoming user requests to this content switching virtual server. .
		# push: enabled|disabled
		# pushvserver: # Name of the load balancing virtual server, of type C(PUSH) or C(SSL_PUSH), to which the server pushes updates received on the client-facing load balancing virtual server.
		# pushlabel: # Expression for extracting the label from the response received from server. This string can be either an existing rule name or an inline expression. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# pushmulticlients: # Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
		# tcpprofilename: # Name of the TCP profile containing TCP configuration settings for the virtual server.
		# httpprofilename: # Name of the HTTP profile containing HTTP configuration settings for the virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
		# dbprofilename: # Name of the DB profile.
		# oracleserverversion: 10G|11G
		# comment: # Information about this virtual server.
		# mssqlserverversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# l2conn: # Use L2 Parameters to identify a connection.
		# mysqlprotocolversion: # The protocol version returned by the mysql vserver.
		# mysqlserverversion: # The server version string returned by the mysql vserver.
		# mysqlcharacterset: # The character set returned by the mysql vserver.
		# mysqlservercapabilities: # The server capabilities returned by the mysql vserver.
		# appflowlog: enabled|disabled
		# netprofile: # The name of the network profile.
		# icmpvsrresponse: PASSIVE|ACTIVE
		# rhistate: PASSIVE|ACTIVE
		# authnprofile: # Name of the authentication profile to be used when authentication is turned on.
		# dnsprofilename: # Name of the DNS profile to be associated with the VServer. DNS profile properties will applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
		# domainname: # Domain name for which to change the time to live (TTL) and/or backup service IP address.
		# ttl: # .
		# backupip: # .
		# cookiedomain: # .
		# cookietimeout: # .
		# sitedomainttl: # .
		# lbvserver: # The default Load Balancing virtual server.
		# ssl_certkey: # The name of the ssl certificate that is bound to this service.
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_nitro_request "Issue Nitro API requests to a Netscaler instance." b
- name: $1
	netscaler_nitro_request:
		nitro_user: ${2:# The username with which to authenticate to the Netscaler node.}
		nitro_pass: ${3:# The password with which to authenticate to the Netscaler node.}
		expected_nitro_errorcode: ${4:[0]}
		# nsip: # The IP address of the Netscaler or MAS instance where the Nitro API calls will be made.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_auth_token: # The authentication token provided by the C(mas_login) operation. It is required when issuing Nitro API calls through a MAS proxy.
		# resource: # The type of resource we are operating on.
		# name: # The name of the resource we are operating on.
		# attributes: # The attributes of the Nitro object we are operating on.
		# args: # A dictionary which defines the key arguments by which we will select the Nitro object to operate on.
		# filter: # A dictionary which defines the filter with which to refine the Nitro objects returned by the C(get_filtered) I(operation).
		# operation: add|update|get|get_by_args|get_filtered|get_all|delete|delete_by_args|count|mas_login|save_config|action
		# action: # The action to perform when the I(operation) value is set to C(action).
		# instance_ip: # The IP address of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
		# instance_name: # The name of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
		# instance_id: # The id of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
$0
endsnippet

snippet netscaler_cs_policy "Manage content switching policy" b
- name: $1
	netscaler_cs_policy:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# policyname: # Name for the content switching policy. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Cannot be changed after a policy is created.
		# url: # URL string that is matched with the URL of a request. Can contain a wildcard character. Specify the string value in the following format: C([[prefix] [*]] [.suffix]).
		# rule: # Expression, or name of a named expression, against which traffic is evaluated. Written in the classic or default syntax.
		# domain: # The domain name. The string value can range to 63 characters.
		# action: # Content switching action that names the target load balancing virtual server to which the traffic is switched.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_lb_monitor "Manage load balancing monitors" b
- name: $1
	netscaler_lb_monitor:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# monitorname: # Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.
		# type: PING|TCP|HTTP|TCP-ECV|HTTP-ECV|UDP-ECV|DNS|FTP|LDNS-PING|LDNS-TCP|LDNS-DNS|RADIUS|USER|HTTP-INLINE|SIP-UDP|SIP-TCP|LOAD|FTP-EXTENDED|SMTP|SNMP|NNTP|MYSQL|MYSQL-ECV|MSSQL-ECV|ORACLE-ECV|LDAP|POP3|CITRIX-XML-SERVICE|CITRIX-WEB-INTERFACE|DNS-TCP|RTSP|ARP|CITRIX-AG|CITRIX-AAC-LOGINPAGE|CITRIX-AAC-LAS|CITRIX-XD-DDC|ND6|CITRIX-WI-EXTENDED|DIAMETER|RADIUS_ACCOUNTING|STOREFRONT|APPC|SMPP|CITRIX-XNC-ECV|CITRIX-XDM|CITRIX-STA-SERVICE|CITRIX-STA-SERVICE-NHOP
		# action: NONE|LOG|DOWN
		# respcode: # Response codes for which to mark the service as UP. For any other response code, the action performed depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.
		# httprequest: # HTTP request to send to the server (for example, C("HEAD /file.html")).
		# rtsprequest: # RTSP request to send to the server (for example, C("OPTIONS *")).
		# customheaders: # Custom header string to include in the monitoring probes.
		# maxforwards: # Maximum number of hops that the SIP request used for monitoring can traverse to reach the server. Applicable only to monitors of type C(SIP-UDP).
		# sipmethod: OPTIONS|INVITE|REGISTER
		# sipuri: # SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of type C(SIP-UDP).
		# sipreguri: # SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method parameter is set to C(REGISTER).
		# send: # String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
		# recv: # String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
		# query: # Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).
		# querytype: Address|Zone|AAAA
		# scriptname: # Path and name of the script to execute. The script must be available on the NetScaler appliance, in the /nsconfig/monitors/ directory.
		# scriptargs: # String of arguments for the script. The string is copied verbatim into the request.
		# dispatcherip: # IP address of the dispatcher to which to send the probe.
		# dispatcherport: # Port number on which the dispatcher listens for the monitoring probe.
		# username: # User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.
		# password: # Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in conjunction with the user name specified for the C(username) parameter.
		# secondarypassword: # Secondary password that users might have to provide to log on to the Access Gateway server. Applicable to C(CITRIX-AG) monitors.
		# logonpointname: # Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control software. Required if you want to monitor the associated login page or Logon Agent. Applicable to C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.
		# lasversion: # Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS) monitor.
		# radkey: # Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
		# radnasid: # NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).
		# radnasip: # Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
		# radaccounttype: # Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# radframedip: # Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# radapn: # Called Station Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# radmsisdn: # Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# radaccountsession: # Account Session ID to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
		# lrtm: enabled|disabled
		# deviation: # Time value added to the learned average response time in dynamic response time monitoring (DRTM). When a deviation is specified, the appliance learns the average response time of bound services and adds the deviation to the average. The final value is then continually adjusted to accommodate response time variations over time. Specified in milliseconds, seconds, or minutes.
		# units1: SEC|MSEC|MIN
		# interval: # Time interval between two successive probes. Must be greater than the value of Response Time-out.
		# units3: SEC|MSEC|MIN
		# resptimeout: # Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than the value specified for the Interval parameter.
		# units4: SEC|MSEC|MIN
		# resptimeoutthresh: # Response time threshold, specified as a percentage of the Response Time-out parameter. If the response to a monitor probe has not arrived when the threshold is reached, the appliance generates an SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be generated, the "MONITOR-RTO-THRESHOLD" alarm must also be enabled.
		# retries: # Maximum number of probes to send to establish the state of a service for which a monitoring probe failed.
		# failureretries: # Number of retries that must fail, out of the number specified for the Retries parameter, for a service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the service is to be marked as DOWN.
		# alertretries: # Number of consecutive probe failures after which the appliance generates an SNMP trap called monProbeFailed.
		# successretries: # Number of consecutive successful probes required to transition a service's state from DOWN to UP.
		# downtime: # Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in milliseconds, seconds, or minutes.
		# units2: SEC|MSEC|MIN
		# destip: # IP address of the service to which to send probes. If the parameter is set to 0, the IP address of the server to which the monitor is bound is considered the destination IP address.
		# destport: # TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the service to which the monitor is bound is considered the destination port. For a monitor of type C(USER), however, the destination port is the port number that is included in the HTTP request sent to the dispatcher. Does not apply to monitors of type C(PING).
		# state: enabled|disabled
		# reverse: # Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN when probe criteria are not satisfied.
		# transparent: # The monitor is bound to a transparent device such as a firewall or router. The state of a transparent device depends on the responsiveness of the services behind it. If a transparent device is being monitored, a destination IP address must be specified. The probe is sent to the specified IP address by using the MAC address of the transparent device.
		# iptunnel: # Send the monitoring probe to the service through an IP tunnel. A destination IP address must be specified.
		# tos: # Probe the service by encoding the destination IP address in the IP TOS (6) bits.
		# tosid: # The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.
		# secure: # Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure connection by default.
		# validatecred: # Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type C(CITRIX-XD-DDC).
		# domain: # Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers and Web Interface servers, respectively.
		# ipaddress: # Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A or AAAA. Applicable to C(DNS) monitors.
		# group: # Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is found on the server, the service is marked as UP. If the newsgroup does not exist or if the search fails, the service is marked as DOWN. Applicable to NNTP monitors.
		# filename: # Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.
		# basedn: # The base distinguished name of the LDAP service, from where the LDAP server can begin the search for the attributes in the monitoring query. Required for C(LDAP) service monitoring.
		# binddn: # The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server. Optional. Applicable to C(LDAP) monitors.
		# filter: # Filter criteria for the LDAP query. Optional.
		# attribute: # Attribute to evaluate when the LDAP server responds to the query. Success or failure of the monitoring probe depends on whether the attribute exists in the response. Optional.
		# database: # Name of the database to connect to during authentication.
		# oraclesid: # Name of the service identifier that is used to connect to the Oracle database during authentication.
		# sqlquery: # SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server authenticates the connection.
		# evalrule: # Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV monitoring query. Must produce a Boolean result. The result determines the state of the server. If the expression returns TRUE, the probe succeeds.
		# mssqlprotocolversion: 70|2000|2000SP1|2005|2008|2008R2|2012|2014
		# Snmpoid: # SNMP OID for C(SNMP) monitors.
		# snmpcommunity: # Community name for C(SNMP) monitors.
		# snmpthreshold: # Threshold for C(SNMP) monitors.
		# snmpversion: V1|V2
		# metrictable: # Metric table to which to bind metrics.
		# application: # Name of the application used to determine the state of the service. Applicable to monitors of type C(CITRIX-XML-SERVICE).
		# sitepath: # URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE), C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.
		# storename: # Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront service store name. Applicable to C(STOREFRONT) monitors.
		# storefrontacctservice: # Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For multi-tenancy configuration users my skip account service.
		# hostname: # Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.
		# netprofile: # Name of the network profile.
		# originhost: # Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# originrealm: # Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# hostipaddress: # Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP) address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.
		# vendorid: # Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# productname: # Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# firmwarerevision: # Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
		# authapplicationid: # List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring CER message.
		# acctapplicationid: # List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message.
		# inbandsecurityid: NO_INBAND_SECURITY|TLS
		# supportedvendorids: # List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a monitoring message.
		# vendorspecificvendorid: # Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the Vendor-Specific-Application-Id AVPs in a CER monitoring message.
		# vendorspecificauthapplicationids: # List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
		# vendorspecificacctapplicationids: # List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
		# kcdaccount: # KCD Account used by C(MSSQL) monitor.
		# storedb: enabled|disabled
		# storefrontcheckbackendservices: # This option will enable monitoring of services running on storefront server. Storefront services are monitored by probing to a Windows service that runs on the Storefront server and exposes details of which storefront services are running.
		# trofscode: # Code expected when the server is under maintenance.
		# trofsstring: # String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV monitors.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# save_config: yes
$0
endsnippet

snippet netscaler_ssl_certkey "Manage ssl cerificate keys." b
- name: $1
	netscaler_ssl_certkey:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# certkey: # Name for the certificate and private-key pair. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the certificate-key pair is created.
		# cert: # Name of and, optionally, path to the X509 certificate file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
		# key: # Name of and, optionally, path to the private-key file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
		# password: # Passphrase that was used to encrypt the private-key. Use this option to load encrypted private-keys in PEM format.
		# inform: DER|PEM|PFX
		# passplain: # Pass phrase used to encrypt the private-key. Required when adding an encrypted private-key in PEM format.
		# expirymonitor: enabled|disabled
		# notificationperiod: # Time, in number of days, before certificate expiration, at which to generate an alert that the certificate is about to expire.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_gslb_site "Manage gslb site entities in Netscaler." b
- name: $1
	netscaler_gslb_site:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# sitename: # Name for the GSLB site. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the virtual server is created.
		# sitetype: REMOTE|LOCAL
		# siteipaddress: # IP address for the GSLB site. The GSLB site uses this IP address to communicate with other GSLB sites. For a local site, use any IP address that is owned by the appliance (for example, a SNIP or MIP address, or the IP address of the ADNS service).
		# publicip: # Public IP address for the local site. Required only if the appliance is deployed in a private address space and the site has a public IP address hosted on an external firewall or a NAT device.
		# metricexchange: enabled|disabled
		# nwmetricexchange: enabled|disabled
		# sessionexchange: enabled|disabled
		# triggermonitor: ALWAYS|MEPDOWN|MEPDOWN_SVCDOWN
		# parentsite: # Parent site of the GSLB site, in a parent-child topology.
		# clip: # Cluster IP address. Specify this parameter to connect to the remote cluster site for GSLB auto-sync. Note: The cluster IP address is defined when creating the cluster.
		# publicclip: # IP address to be used to globally access the remote cluster when it is deployed behind a NAT. It can be same as the normal cluster IP address.
		# naptrreplacementsuffix: # The naptr replacement suffix configured here will be used to construct the naptr replacement field in NAPTR record.
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet netscaler_service "Manage service configuration in Netscaler" b
- name: $1
	netscaler_service:
		nsip: ${2:# The ip address of the netscaler appliance where the nitro API calls will be made.}
		nitro_user: ${3:# The username with which to authenticate to the netscaler node.}
		nitro_pass: ${4:# The password with which to authenticate to the netscaler node.}
		# name: # Name for the service. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the service has been created.
		# ip: # IP to assign to the service.
		# servername: # Name of the server that hosts the service.
		# servicetype: HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX
		# port: # Port number of the service.
		# cleartextport: # Port to which clear text data must be sent after the appliance decrypts incoming SSL traffic. Applicable to transparent SSL services.
		# cachetype: TRANSPARENT|REVERSE|FORWARD
		# maxclient: # Maximum number of simultaneous open connections to the service.
		# healthmonitor: yes
		# maxreq: # Maximum number of requests that can be sent on a persistent connection to the service.
		# cacheable: no
		# cip: enabled|disabled
		# cipheader: # Name for the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If you set the Client IP parameter, and you do not specify a name for the header, the appliance uses the header name specified for the global Client IP Header parameter (the cipHeader parameter in the set ns param CLI command or the Client IP Header parameter in the Configure HTTP Parameters dialog box at System > Settings > Change HTTP parameters). If the global Client IP Header parameter is not specified, the appliance inserts a header with the name "client-ip.".
		# usip: # Use the client's IP address as the source IP address when initiating a connection to the server. When creating a service, if you do not set this parameter, the service inherits the global Use Source IP setting (available in the enable ns mode and disable ns mode CLI commands, or in the System > Settings > Configure modes > Configure Modes dialog box). However, you can override this setting after you create the service.
		# pathmonitor: # Path monitoring for clustering.
		# pathmonitorindv: # Individual Path monitoring decisions.
		# useproxyport: # Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
		# sp: # Enable surge protection for the service.
		# rtspsessionidremap: no
		# clttimeout: # Time, in seconds, after which to terminate an idle client connection.
		# svrtimeout: # Time, in seconds, after which to terminate an idle server connection.
		# customserverid: # Unique identifier for the service. Used when the persistency type for the virtual server is set to Custom Server ID.
		# serverid: # The identifier for the service. This is used when the persistency type is set to Custom Server ID.
		# cka: # Enable client keep-alive for the service.
		# tcpb: # Enable TCP buffering for the service.
		# cmp: # Enable compression for the service.
		# maxbandwidth: # Maximum bandwidth, in Kbps, allocated to the service.
		# accessdown: no
		# monthreshold: # Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
		# downstateflush: enabled|disabled
		# tcpprofilename: # Name of the TCP profile that contains TCP configuration settings for the service.
		# httpprofilename: # Name of the HTTP profile that contains HTTP configuration settings for the service.
		# hashid: # A numerical identifier that can be used by hash based load balancing methods. Must be unique for each service.
		# comment: # Any information about the service.
		# appflowlog: enabled|disabled
		# netprofile: # Network profile to use for the service.
		# td: # Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
		# processlocal: enabled|disabled
		# dnsprofilename: # Name of the DNS profile to be associated with the service. DNS profile properties will applied to the transactions processed by a service. This parameter is valid only for ADNS and ADNS-TCP services.
		# ipaddress: # The new IP address of the service.
		# graceful: no
		# monitor_bindings: # A list of load balancing monitors to bind to this service.
		# disabled: no
		# nitro_protocol: #http|https
		# validate_certs: yes
		# nitro_timeout: 310
		# state: #present|absent
		# save_config: yes
$0
endsnippet

snippet bcf_switch "Create and remove a bcf switch." b
- name: $1
	bcf_switch:
		name: ${2:# The name of the switch.}
		fabric_role: ${3:spine|leaf}
		mac: ${4:# The MAC address of the switch.}
		controller: ${5:# The controller IP address.}
		# leaf_group: # The leaf group of the switch if the switch is a leaf.
		# state: #present|absent
		# validate_certs: yes
		# access_token: # Big Cloud Fabric access token. If this isn't set then the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
$0
endsnippet

snippet bigmon_policy "Create and remove a bigmon out-of-band policy." b
- name: $1
	bigmon_policy:
		name: ${2:# The name of the policy.}
		controller: ${3:# The controller address.}
		# policy_description: # Description of policy.
		# action: #forward|drop|flow-gen
		# priority: 100
		# duration: 0
		# start_time: ansible_date_time.iso8601
		# delivery_packet_count: 0
		# state: #present|absent
		# validate_certs: yes
		# access_token: # Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
$0
endsnippet

snippet bigmon_chain "Create and remove a bigmon inline service chain." b
- name: $1
	bigmon_chain:
		name: ${2:# The name of the chain.}
		controller: ${3:# The controller IP address.}
		# state: #present|absent
		# validate_certs: yes
		# access_token: # Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
$0
endsnippet

snippet fmgr_script "Add/Edit/Delete and execute scripts" b
- name: $1
	fmgr_script:
		adom: ${2:# The administrative domain (admon) the configuration belongs to}
		host: ${3:# The FortiManager's Address.}
		username: ${4:# The username to log into the FortiManager}
		script_name: ${5:# The name of the script.}
		# vdom: # The virtual domain (vdom) the configuration belongs to
		# password: # The password associated with the username account.
		# state: #present|execute|delete
		# script_type: # The type of script (CLI or TCL).
		# script_target: # The target of the script to be run.
		# script_description: # The description of the script.
		# script_content: # The script content that will be executed.
		# script_scope: # (datasource) The devices that the script will run on, can have both device member and device group member.
		# script_package: # (datasource) Policy package object to run the script against
$0
endsnippet

snippet fmgr_provisioning "Provision devices via FortiMananger" b
- name: $1
	fmgr_provisioning:
		adom: ${2:# The administrative domain (admon) the configuration belongs to}
		host: ${3:# The FortiManager's Address.}
		username: ${4:# The username to log into the FortiManager}
		policy_package: ${5:# The name of the policy package to be assigned to the device.}
		name: ${6:# The name of the device to be provisioned.}
		serial: ${7:# The serial number of the device that will be provisioned.}
		platform: ${8:# The platform of the device, such as model number or VM.}
		os_version: ${9:# The Fortinet OS version to be used for the device, such as 5.0 or 6.0.}
		os_type: ${10:# The Fortinet OS type to be pushed to the device, such as 'FOS' for FortiOS.}
		# vdom: # The virtual domain (vdom) the configuration belongs to
		# password: # The password associated with the username account.
		# group: # The name of the device group the provisioned device can belong to.
		# description: # Description of the device to be provisioned.
		# minor_release: # The minor release number such as 6.X.1, as X being the minor release.
		# patch_release: # The patch release number such as 6.0.X, as X being the patch release.
$0
endsnippet

snippet iosxr_facts "Collect facts from remote devices running IOS XR" b
- name: $1
	iosxr_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_config "Manage Cisco IOS XR configuration sections" b
- name: $1
	iosxr_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block|config
		# force: no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# comment: configured by iosxr_config
		# admin: no
		# label: # Allows a commit label to be specified to be included when the configuration is committed. A valid label must begin with an alphabet and not exceed 30 characters, only alphabets, digits, hyphens and underscores are allowed. If the configuration is not changed or committed, this argument is ignored.
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_system "Manage the system attributes on Cisco IOS XR devices" b
- name: $1
	iosxr_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# vrf: # VRF name for domain services
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# lookup_source: # The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# lookup_enabled: # Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
		# name_servers: # The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_logging "Configuration management of system logging services on network devices" b
- name: $1
	iosxr_logging:
		# dest: host|console|monitor|buffered|file
		# name: # When C(dest) = I(file) name indicates file-name
		# vrf: default
		# size: # Size of buffer when C(dest) = C(buffered). The acceptable value is in the range I(307200 to 125000000 bytes). Default 307200
		# facility: local7
		# hostnameprefix: # To append a hostname prefix to system logging (syslog) messages logged to syslog servers. Optional config for C(dest) = C(host)
		# level: debugging
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_user "Manage the aggregate of local users on Cisco IOS XR device" b
- name: $1
	iosxr_user:
		# aggregate: # The set of username objects to be configured on the remote Cisco IOS XR device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the Cisco IOS XR device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# configured_password: # The password to be configured on the Cisco IOS XR device. The password needs to be provided in clear text. Password is encrypted on the device when used with I(cli) and by Ansible when used with I(netconf) using the same MD5 hash technique with salt size of 3. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# group: # Configures the group for the username in the device running configuration. The argument accepts a string value defining the group name. This argument does not check if the group has been configured on the device.
		# groups: # Configures the groups for the username in the device running configuration. The argument accepts a list of group names. This argument does not check if the group has been configured on the device. It is similar to the aggregrate command for usernames, but lets you configure multiple groups for the user(s).
		# purge: no
		# state: #present|absent
		# public_key: # Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key_contents. If used with multiple users in aggregates, then the same key file is used for all users.
		# public_key_contents: # Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key.If used with multiple users in aggregates, then the same key file is used for all users.
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_banner "Manage multiline banners on Cisco IOS XR devices" b
- name: $1
	iosxr_banner:
		banner: ${2:login|motd}
		# text: # Banner text to be configured. Accepts multiline string, without empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_command "Run commands on remote devices running Cisco IOS XR" b
- name: $1
	iosxr_command:
		commands: ${2:# List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_interface "Manage Interface on Cisco IOS XR network devices" b
- name: $1
	iosxr_interface:
		name: ${2:# Name of the interface to configure in C(type + path) format. e.g. C(GigabitEthernet0/0/0/0)}
		# description: # Description of Interface being configured.
		# enabled: yes
		# active: #active|preconfigure
		# speed: 10|100|1000
		# mtu: # Sets the MTU value for the interface. Range is between 64 and 65535'
		# duplex: full|half
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# aggregate: # List of Interface definitions. Include multiple interface configurations together, one each on a separate line
		# delay: 10
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
$0
endsnippet

snippet iosxr_netconf "Configures NetConf sub-system service on Cisco IOS-XR devices" b
- name: $1
	iosxr_netconf:
		# netconf_port: 830
		# netconf_vrf: default
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet a10_virtual_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' virtual servers." b
- name: $1
	a10_virtual_server:
		virtual_server: ${2:# The SLB (Server Load Balancing) virtual server name.}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		username: ${4:# An account with administrator privileges.}
		password: ${5:# Password for the C(username) account.}
		# state: #present|absent
		# partition: # set active-partition
		# virtual_server_ip: # The SLB virtual server IPv4 address.
		# virtual_server_status: enabled|disabled
		# virtual_server_ports: # A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).
		# validate_certs: yes
		# write_config: no
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet a10_server_axapi3 "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices" b
- name: $1
	a10_server_axapi3:
		server_name: ${2:# The SLB (Server Load Balancer) server name.}
		server_ip: ${3:# The SLB (Server Load Balancer) server IPv4 address.}
		host: ${4:# Hostname or IP of the A10 Networks device.}
		username: ${5:# An account with administrator privileges.}
		password: ${6:# Password for the C(username) account.}
		# server_status: #enable|disable
		# server_ports: # A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).
		# operation: #create|update|remove
		# validate_certs: yes
		# write_config: no
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet a10_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' server object." b
- name: $1
	a10_server:
		server_name: ${2:# The SLB (Server Load Balancer) server name.}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		username: ${4:# An account with administrator privileges.}
		password: ${5:# Password for the C(username) account.}
		# partition: # set active-partition
		# server_ip: # The SLB server IPv4 address.
		# server_status: #enabled|disabled
		# server_ports: # A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).
		# state: #present|absent
		# validate_certs: yes
		# write_config: no
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet a10_service_group "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' service groups." b
- name: $1
	a10_service_group:
		service_group: ${2:# The SLB (Server Load Balancing) service-group name}
		host: ${3:# Hostname or IP of the A10 Networks device.}
		username: ${4:# An account with administrator privileges.}
		password: ${5:# Password for the C(username) account.}
		# state: #present|absent
		# partition: # set active-partition
		# service_group_protocol: #tcp|udp
		# service_group_method: #round-robin|weighted-rr|least-connection|weighted-least-connection|service-least-connection|service-weighted-least-connection|fastest-response|least-request|round-robin-strict|src-ip-only-hash|src-ip-hash
		# servers: # A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.
		# validate_certs: yes
		# write_config: no
		# url: # HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
		# force: no
		# http_agent: ansible-httpget
		# use_proxy: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
$0
endsnippet

snippet bigip_ucs_fetch "Fetches a UCS file from remote nodes" b
- name: $1
	bigip_ucs_fetch:
		dest: ${2:# A directory to save the UCS file into.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# backup: no
		# create_on_missing: yes
		# encryption_password: # Password to use to encrypt the UCS file if desired
		# fail_on_missing: no
		# force: yes
		# src: # The name of the UCS file to create on the remote server for downloading
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_log_publisher "Manages log publishers on a BIG-IP" b
- name: $1
	bigip_log_publisher:
		name: ${2:# Specifies the name of the log publisher.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Specifies a description for the log publisher.
		# destinations: # Specifies log destinations for this log publisher to use.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_management_route "Manage system management routes on a BIG-IP" b
- name: $1
	bigip_management_route:
		name: ${2:# Specifies the name of the management route.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the management route.
		# gateway: # Specifies that the system forwards packets to the destination through the gateway with the specified IP address.
		# network: # The subnet and netmask to be used for the route.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_tcp_echo "Manages F5 BIG-IP LTM tcp echo monitors" b
- name: $1
	bigip_monitor_tcp_echo:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/tcp_echo
		# description: # The description of the monitor.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_ucs "Manage upload, installation and removal of UCS files" b
- name: $1
	bigip_ucs:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# include_chassis_level_config: # During restore of the UCS file, include chassis level configuration that is shared among boot volume sets. For example, cluster default configuration.
		# ucs: # The path to the UCS file to install. The parameter must be provided if the C(state) is either C(installed) or C(activated). When C(state) is C(absent), the full path for this parameter will be ignored and only the filename will be used to select a UCS for removal. Therefore you could specify C(/mickey/mouse/test.ucs) and this module would only look for C(test.ucs).
		# force: no
		# no_license: # Performs a full restore of the UCS file and all the files it contains, with the exception of the license file. The option must be used to restore a UCS on RMA devices (Returned Materials Authorization).
		# no_platform_check: # Bypasses the platform check and allows a UCS that was created using a different platform to be installed. By default (without this option), a UCS created from a different platform is not allowed to be installed.
		# passphrase: # Specifies the passphrase that is necessary to load the specified UCS file.
		# reset_trust: # When specified, the device and trust domain certs and keys are not loaded from the UCS. Instead, a new set is regenerated.
		# state: absent|installed|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_global "Manages global GTM settings" b
- name: $1
	bigip_gtm_global:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# synchronization: # Specifies whether this system is a member of a synchronization group.
		# synchronization_group_name: # Specifies the name of the synchronization group to which the system belongs.
		# synchronize_zone_files: # Specifies that the system synchronizes Domain Name System (DNS) zone files among the synchronization group members.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_https_offload "Manages BIG-IQ HTTPS offload applications" b
- name: $1
	bigiq_application_https_offload:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# redirect_virtual: # Settings to configure the virtual which will receive the connection to be redirected.
		# client_ssl_profile: # Specifies the SSL profile for managing client-side SSL traffic.
		# service_environment: # Specifies the name of service environment or the hostname of the BIG-IP that the application will be deployed to.
		# add_analytics: no
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_configsync_action "Perform different actions related to config-sync" b
- name: $1
	bigip_configsync_action:
		device_group: ${2:# The device group that you want to perform config-sync actions on.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# sync_device_to_group: # Specifies that the system synchronizes configuration data from this device to other members of the device group. In this case, the device will do a "push" to all the other devices in the group. This option is mutually exclusive with the C(sync_group_to_device) option.
		# sync_most_recent_to_device: # Specifies that the system synchronizes configuration data from the device with the most recent configuration. In this case, the device will do a "pull" from the most recently updated device. This option is mutually exclusive with the C(sync_device_to_group) options.
		# overwrite_config: no
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_fasthttp "Manages BIG-IQ FastHTTP applications" b
- name: $1
	bigiq_application_fasthttp:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# service_environment: # Specifies the name of service environment that the application will be deployed to.
		# add_analytics: no
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_vcmp_guest "Manages vCMP guests on a BIG-IP" b
- name: $1
	bigip_vcmp_guest:
		name: ${2:# The name of the vCMP guest to manage.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# vlans: # VLANs that the guest uses to communicate with other guests, the host, and with the external network. The available VLANs in the list are those that are currently configured on the vCMP host.
		# initial_image: # Specifies the base software release ISO image file for installing the TMOS hypervisor instance and any licensed BIG-IP modules onto the guest's virtual disk. When creating a new guest, this parameter is required.
		# mgmt_network: bridged|isolated|host only
		# delete_virtual_disk: no
		# mgmt_address: # Specifies the IP address, and subnet or subnet mask that you use to access the guest when you want to manage a module running within the guest. This parameter is required if the C(mgmt_network) parameter is C(bridged).
		# mgmt_route: # Specifies the gateway address for the C(mgmt_address).
		# state: configured|disabled|provisioned|#present|absent
		# cores_per_slot: # Specifies the number of cores that the system allocates to the guest.
		# partition: Common
		# number_of_slots: # Specifies the number of slots for the system to use for creating the guest.
		# min_number_of_slots: # Specifies the minimum number of slots that the guest must be assigned to in order to deploy.
		# allowed_slots: # Contains those slots that the guest is allowed to be assigned to.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_udp "Manages F5 BIG-IP LTM udp monitors" b
- name: $1
	bigip_monitor_udp:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/udp
		# description: # The description of the monitor.
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(default send string) will be used.
		# receive: # The receive string for the monitor call.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_remote_syslog "Manipulate remote syslog settings on a BIG-IP" b
- name: $1
	bigip_remote_syslog:
		remote_host: ${2:# Specifies the IP address, or hostname, for the remote system to which the system sends log messages.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# remote_port: # Specifies the port that the system uses to send messages to the remote logging server. When creating a remote syslog, if this parameter is not specified, the default value C(514) is used.
		# local_ip: # Specifies the local IP address of the system that is logging. To provide no local IP, specify the value C(none). When creating a remote syslog, if this parameter is not specified, the default value C(none) is used.
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_https "Manages F5 BIG-IP GTM https monitors" b
- name: $1
	bigip_gtm_monitor_https:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/https
		# send: # The send string for the monitor call.
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# interval: # The interval specifying how frequently the monitor instance of this template will run.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
		# partition: Common
		# state: #present|absent
		# probe_timeout: # Specifies the number of seconds after which the system times out the probe request to the system.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# transparent: # Specifies whether the monitor operates in transparent mode.
		# reverse: # Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# update_password: #always|on_create
		# cipher_list: # Specifies the list of ciphers for this monitor.
		# compatibility: # Specifies, when enabled, that the SSL options setting (in OpenSSL) is set to B(all).
		# client_cert: # Specifies a fully-qualified path for a client certificate that the monitor sends to the target SSL server.
		# client_key: # Specifies a key for a client certificate that the monitor sends to the target SSL server.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_httpd "Manage HTTPD related settings on BIG-IP" b
- name: $1
	bigip_device_httpd:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# allow: # Specifies, if you have enabled HTTPD access, the IP address or address range for other systems that can communicate with this system.
		# auth_name: # Sets the BIG-IP authentication realm name.
		# auth_pam_idle_timeout: # Sets the GUI timeout for automatic logout, in seconds.
		# auth_pam_validate_ip: # Sets the authPamValidateIp setting.
		# auth_pam_dashboard_timeout: # Sets whether or not the BIG-IP dashboard will timeout.
		# fast_cgi_timeout: # Sets the timeout of FastCGI.
		# hostname_lookup: # Sets whether or not to display the hostname, if possible.
		# log_level: alert|crit|debug|emerg|error|info|notice|warn
		# max_clients: # Sets the maximum number of clients that can connect to the GUI at once.
		# redirect_http_to_https: # Whether or not to redirect http requests to the GUI to https.
		# ssl_port: # The HTTPS port to listen on.
		# ssl_cipher_suite: # Specifies the ciphers that the system uses.
		# ssl_protocols: # The list of SSL protocols to accept on the management console.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_cli_script "Manage CLI scripts on a BIG-IP" b
- name: $1
	bigip_cli_script:
		name: ${2:# Specifies the name of the script.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# content: # The content of the script.
		# description: # Description of the cli script.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors" b
- name: $1
	bigip_monitor_tcp:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/tcp
		# description: # The description of the monitor.
		# send: # The send string for the monitor call.
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_wait "Wait for a BIG-IP condition before continuing" b
- name: $1
	bigip_wait:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# timeout: 7200
		# delay: 0
		# sleep: 1
		# msg: # This overrides the normal error message from a failure to meet the required conditions.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_http "Manages F5 BIG-IP GTM http monitors" b
- name: $1
	bigip_gtm_monitor_http:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/http
		# send: # The send string for the monitor call.
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # The interval specifying how frequently the monitor instance of this template will run.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
		# partition: Common
		# state: #present|absent
		# probe_timeout: # Specifies the number of seconds after which the system times out the probe request to the system.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# transparent: # Specifies whether the monitor operates in transparent mode.
		# reverse: # Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# update_password: #always|on_create
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_static_route "Manipulate static routes on a BIG-IP" b
- name: $1
	bigip_static_route:
		name: ${2:# Name of the static route.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Descriptive text that identifies the route.
		# destination: # Specifies an IP address for the static entry in the routing table. When creating a new static route, this value is required.
		# netmask: # The netmask for the static route. When creating a new static route, this value is required.
		# gateway_address: # Specifies the router for the system to use when forwarding packets to the destination host or network. Also known as the next-hop router address. This can be either an IPv4 or IPv6 address. When it is an IPv6 address that starts with C(FE80:), the address will be treated as a link-local address. This requires that the C(vlan) parameter also be supplied.
		# vlan: # Specifies the VLAN or Tunnel through which the system forwards packets to the destination. When C(gateway_address) is a link-local IPv6 address, this value is required
		# pool: # Specifies the pool through which the system forwards packets to the destination.
		# reject: # Specifies that the system drops packets sent to the destination.
		# mtu: # Specifies a specific maximum transmission unit (MTU).
		# route_domain: # The route domain id of the system. When creating a new static route, if this value is not specified, a default value of C(0) will be used.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers" b
- name: $1
	bigip_gtm_virtual_server:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# name: # Specifies the name of the virtual server.
		# server_name: # Specifies the name of the server that the virtual server is associated with.
		# address: # Specifies the IP Address of the virtual server.
		# port: # Specifies the service port number for the virtual server or pool member. For example, the HTTP service is typically port 80.
		# translation_address: # Specifies the translation IP address for the virtual server.
		# translation_port: # Specifies the translation port number or service name for the virtual server.
		# availability_requirements: # Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.
		# monitors: # Specifies the health monitors that the system currently uses to monitor this resource.
		# virtual_server_dependencies: # Specifies the virtual servers on which the current virtual server depends.
		# link: # Specifies a link to assign to the server or virtual server.
		# limits: # Specifies resource thresholds or limit requirements at the server level.
		# partition: Common
		# state: #present|absent|enabled|disabled
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_iapp_template "Manages TCL iApp templates on a BIG-IP" b
- name: $1
	bigip_iapp_template:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# force: # Specifies whether or not to force the uploading of an iApp. When C(yes), will force update the iApp even if there are iApp services using it. This will not update the running service though. Use C(bigip_iapp_service) to do that. When C(no), will update the iApp only if there are no iApp services using the template.
		# name: # The name of the iApp template that you want to delete. This option is only available when specifying a C(state) of C(absent) and is provided as a way to delete templates that you may no longer have the source of.
		# content: # Sets the contents of an iApp template directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. C(content) must be provided when creating new templates.
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_utility_license "Manage utility licenses on a BIG-IQ" b
- name: $1
	bigiq_utility_license:
		license_key: ${2:# The license key to install and activate.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# accept_eula: # A key that signifies that you accept the F5 EULA for this license.
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system" b
- name: $1
	bigip_selfip:
		name: ${2:# The self IP to create.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# address: # The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.
		# allow_service: # Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.
		# netmask: # The netmask for the self IP. When creating a new Self IP, this value is required.
		# state: absent|#present
		# traffic_group: # The traffic group for the Self IP addresses in an active-active, redundant load balancer configuration. When creating a new Self IP, if this value is not specified, the default of C(/Common/traffic-group-local-only) will be used.
		# vlan: # The VLAN that the new self IPs will be on. When creating a new Self IP, this value is required.
		# route_domain: # The route domain id of the system. When creating a new Self IP, if this value is not specified, a default value of C(0) will be used.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP" b
- name: $1
	bigip_routedomain:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# name: # The name of the route domain.
		# bwc_policy: # The bandwidth controller for the route domain.
		# connection_limit: # The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.
		# description: # Specifies descriptive text that identifies the route domain.
		# flow_eviction_policy: # The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.
		# id: # The unique identifying integer representing the route domain.
		# parent: # Specifies the route domain the system searches when it cannot find a route in the configured domain.
		# partition: Common
		# routing_protocol: none|BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng
		# service_policy: # Service policy to associate with the route domain.
		# state: #present|absent
		# strict: # Specifies whether the system enforces cross-routing restrictions or not.
		# vlans: # VLANs for the system to use in the route domain.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_server "Manages F5 BIG-IP GTM servers" b
- name: $1
	bigip_gtm_server:
		name: ${2:# The name of the server.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent|enabled|disabled
		# datacenter: # Data center the server belongs to. When creating a new GTM server, this value is required.
		# devices: # Lists the self IP addresses and translations for each device. When creating a new GTM server, this value is required. This list is a complex list that specifies a number of keys.
		# server_type: alteon-ace-director|cisco-css|cisco-server-load-balancer|generic-host|radware-wsd|windows-nt-4.0|bigip|cisco-local-director-v2|extreme|generic-load-balancer|sun-solaris|cacheflow|cisco-local-director-v3|foundry-server-iron|netapp|windows-2000-server
		# link_discovery: enabled|disabled|enabled-no-delete
		# virtual_server_discovery: enabled|disabled|enabled-no-delete
		# partition: Common
		# iquery_options: # Specifies whether the Global Traffic Manager uses this BIG-IP system to conduct a variety of probes before delegating traffic to it.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP" b
- name: $1
	bigip_gtm_datacenter:
		name: ${2:# The name of the data center.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# contact: # The name of the contact for the data center.
		# description: # The description of the data center.
		# location: # The location of the data center.
		# state: #present|absent|enabled|disabled
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_address_list "Manage address lists on BIG-IP AFM" b
- name: $1
	bigip_firewall_address_list:
		name: ${2:# Specifies the name of the address list.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# description: # Description of the address list
		# geo_locations: # List of geolocations specified by their C(country) and C(region).
		# addresses: # Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.
		# address_ranges: # A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# address_lists: # Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# fqdns: # A list of fully qualified domain names (FQDNs).
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_virtual_server "Manage LTM virtual servers on a BIG-IP" b
- name: $1
	bigip_virtual_server:
		name: ${2:# Virtual server name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent|enabled|disabled
		# type: #standard|forwarding-l2|forwarding-ip|performance-http|performance-l4|stateless|reject|dhcp|internal|message-routing
		# destination: # Destination IP of the virtual server.
		# source: # Specifies an IP address or network from which the virtual server accepts traffic.
		# port: # Port of the virtual server. Required when C(state) is C(present) and virtual server does not exist.
		# profiles: # List of profiles (HTTP, ClientSSL, ServerSSL, etc) to apply to both sides of the connection (client-side and server-side).
		# irules: # List of rules to be applied in priority order.
		# enabled_vlans: # List of VLANs to be enabled. When a VLAN named C(all) is used, all VLANs will be allowed. VLANs can be specified with or without the leading partition. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.
		# disabled_vlans: # List of VLANs to be disabled. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.
		# pool: # Default pool for the virtual server.
		# policies: # Specifies the policies for the virtual server.
		# snat: # Source network address policy.
		# default_persistence_profile: # Default Profile which manages the session persistence.
		# description: # Virtual server description.
		# fallback_persistence_profile: # Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.
		# partition: Common
		# metadata: # Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a virtual to me managed by Ansible.
		# address_translation: # Specifies, when C(enabled), that the system translates the address of the virtual server.
		# port_translation: # Specifies, when C(enabled), that the system translates the port of the virtual server.
		# ip_protocol: ah|bna|esp|etherip|gre|icmp|ipencap|ipv6|ipv6-auth|ipv6-crypt|ipv6-icmp|isp-ip|mux|ospf|sctp|tcp|udp|udplite
		# firewall_enforced_policy: # Applies the specify AFM policy to the virtual in an enforcing way.
		# firewall_staged_policy: # Applies the specify AFM policy to the virtual in an enforcing way.
		# security_log_profiles: # Specifies the log profile applied to the virtual server.
		# security_nat_policy: # Specify the Firewall NAT policies for the virtual server.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP" b
- name: $1
	bigip_snat_pool:
		name: ${2:# T}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# members: # List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_bigip "Manages F5 BIG-IP GTM BIG-IP monitors" b
- name: $1
	bigip_gtm_monitor_bigip:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/bigip
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.
		# timeout: # Specifies the number of seconds the target has in which to respond to the monitor request.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# aggregate_dynamic_ratios: none|average-nodes|sum-nodes|average-members|sum-members
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_remote_role "Manage remote roles on a BIG-IP" b
- name: $1
	bigip_remote_role:
		name: ${2:# Specifies the name of the remote role.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# line_order: # Specifies the order of the line in the file C(/config/bigip/auth/remoterole).
		# attribute_string: # Specifies the user account attributes saved in the group, in the format C(cn=, ou=, dc=).
		# remote_access: # Enables or disables remote access for the specified group of remotely authenticated users.
		# assigned_role: # Specifies the authorization (level of access) for the account.
		# partition_access: # Specifies the accessible partitions for the account.
		# terminal_access: # Specifies terminal-based accessibility for remote accounts not already explicitly assigned a user role.
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_external "Manages external LTM monitors on a BIG-IP" b
- name: $1
	bigip_monitor_external:
		name: ${2:# Specifies the name of the monitor.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description of the monitor.
		# parent: /Common/external
		# arguments: # Specifies any command-line arguments that the script requires.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# external_program: # Specifies the name of the file for the monitor to use. In order to reference a file, you must first import it using options on the System > File Management > External Monitor Program File List > Import screen. The BIG-IP system automatically places the file in the proper location on the file system.
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request.
		# variables: # Specifies any variables that the script requires.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables" b
- name: $1
	bigip_sys_db:
		key: ${2:# The database variable to manipulate.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|reset
		# value: # The value to set the key to. At least one of value and state C(reset) are required.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip" b
- name: $1
	bigip_gtm_wide_ip:
		pool_lb_method: ${2:round-robin|ratio|topology|global-availability|global_availability|round_robin}
		name: ${3:# Wide IP name. This name must be formatted as a fully qualified domain name (FQDN). You can also use the alias C(wide_ip) but this is deprecated and will be removed in a future Ansible version.}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# type: a|aaaa|cname|mx|naptr|srv
		# state: #present|absent|disabled|enabled
		# partition: Common
		# pools: # The pools that you want associated with the Wide IP.
		# irules: # List of rules to be applied.
		# aliases: # Specifies alternate domain names for the web site content you are load balancing.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_snmp_dca "Manages BIG-IP SNMP data collecting agent (DCA) monitors" b
- name: $1
	bigip_monitor_snmp_dca:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Specifies descriptive text that identifies the monitor.
		# parent: /Common/snmp_dca
		# interval: # Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown. When creating a new monitor, the default is C(10).
		# timeout: # Specifies the number of seconds the target has in which to respond to the monitor request. When creating a new monitor, the default is C(30) seconds. If the target responds within the set time period, it is considered 'up'. If the target does not respond within the set time period, it is considered 'down'. When this value is set to 0 (zero), the system uses the interval from the parent monitor. Note that C(timeout) and C(time_until_up) combine to control when a resource is set to up.
		# time_until_up: # Specifies the number of seconds to wait after a resource first responds correctly to the monitor before setting the resource to 'up'. During the interval, all responses from the resource must be correct. When the interval expires, the resource is marked 'up'. A value of 0, means that the resource is marked up immediately upon receipt of the first correct response. When creating a new monitor, the default is C(0).
		# community: # Specifies the community name that the system must use to authenticate with the host server through SNMP. When creating a new monitor, the default value is C(public). Note that this value is case sensitive.
		# version: v1|v2c
		# agent_type: UCD|WIN2000|GENERIC
		# cpu_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the CPU threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.5).
		# cpu_threshold: # Specifies the maximum acceptable CPU usage on the target server. When creating a new monitor, the default is C(80) percent.
		# memory_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the memory threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.0).
		# memory_threshold: # Specifies the maximum acceptable memory usage on the target server. When creating a new monitor, the default is C(70) percent.
		# disk_coefficient: # Specifies the coefficient that the system uses to calculate the weight of the disk threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(2.0).
		# disk_threshold: # Specifies the maximum acceptable disk usage on the target server. When creating a new monitor, the default is C(90) percent.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_fastl4_udp "Manages BIG-IQ FastL4 UDP applications" b
- name: $1
	bigiq_application_fastl4_udp:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# service_environment: # Specifies the name of service environment that the application will be deployed to.
		# add_analytics: no
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP" b
- name: $1
	bigip_irule:
		module: ${2:ltm|gtm}
		name: ${3:# The name of the iRule.}
		src: ${4:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}
		password: ${5:# The password for the user account used to connect to the BIG-IP.}
		server: ${6:# The BIG-IP host.}
		user: ${7:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# content: # When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_http_compression "Manage HTTP compression profiles on a BIG-IP" b
- name: $1
	bigip_profile_http_compression:
		name: ${2:# Specifies the name of the compression profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# description: # Description of the HTTP compression profile.
		# buffer_size: # Maximum number of compressed bytes that the system buffers before inserting a Content-Length header (which specifies the compressed size) into the response.
		# gzip_level: 1|2|3|4|5|6|7|8|9
		# gzip_memory_level: 1|2|4|8|16|32|64|128|256
		# gzip_window_size: 1|2|4|8|16|32|64|128
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_provision "Manage BIG-IP module provisioning" b
- name: $1
	bigip_provision:
		module: ${2:am|afm|apm|asm|avr|cgnat|fps|gtm|ilx|lc|ltm|pem|sam|swg|vcmp}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# level: dedicated|#nominal|minimum
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_virtual_address "Manage LTM virtual addresses on a BIG-IP" b
- name: $1
	bigip_virtual_address:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# name: # Name of the virtual address.
		# address: # Virtual address. This value cannot be modified after it is set.
		# netmask: 255.255.255.255
		# connection_limit: # Specifies the number of concurrent connections that the system allows on this virtual address.
		# arp_state: enabled|disabled
		# arp: # Specifies whether the system accepts ARP requests.
		# auto_delete: # Specifies whether the system automatically deletes the virtual address with the deletion of the last associated virtual server. When C(disabled), specifies that the system leaves the virtual address even when all associated virtual servers have been deleted. When creating the virtual address, the default value is C(enabled).
		# icmp_echo: enabled|disabled|selective
		# state: #present|absent|enabled|disabled
		# availability_calculation: always|when_all_available|when_any_available
		# use_route_advertisement: # Specifies whether the system uses route advertisement for this virtual address.
		# route_advertisement: disabled|enabled|always|selective|any|all
		# partition: Common
		# traffic_group: # The traffic group for the virtual address. When creating a new address, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
		# route_domain: # The route domain of the C(address) that you want to use.
		# spanning: # Enables all BIG-IP systems in a device group to listen for and process traffic on the same virtual address.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_pool_member "Manage GTM pool member settings" b
- name: $1
	bigip_gtm_pool_member:
		virtual_server: ${2:# Specifies the name of the GTM virtual server which is assigned to the specified C(server).}
		server_name: ${3:# Specifies the GTM server which contains the C(virtual_server).}
		type: ${4:a|aaaa|cname|mx|naptr|srv}
		pool: ${5:# Name of the GTM pool.}
		password: ${6:# The password for the user account used to connect to the BIG-IP.}
		server: ${7:# The BIG-IP host.}
		user: ${8:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# member_order: # Specifies the order in which the member will appear in the pool.
		# monitor: # Specifies the monitor assigned to this pool member.
		# ratio: # Specifies the weight of the pool member for load balancing purposes.
		# description: # The description of the pool member.
		# limits: # Specifies resource thresholds or limit requirements at the pool member level.
		# state: #present|absent|enabled|disabled
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_fastl4_tcp "Manages BIG-IQ FastL4 TCP applications" b
- name: $1
	bigiq_application_fastl4_tcp:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# service_environment: # Specifies the name of service environment that the application will be deployed to.
		# add_analytics: no
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_snmp_community "Manages SNMP communities on a BIG-IP." b
- name: $1
	bigip_snmp_community:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent
		# version: v1|#v2c|v3
		# name: # Name that identifies the SNMP community.
		# community: # Specifies the community string (password) for access to the MIB.
		# source: # Specifies the source address for access to the MIB.
		# port: # Specifies the port for the trap destination.
		# oid: # Specifies the object identifier (OID) for the record.
		# access: ro|rw|read-only|read-write
		# ip_version: 4|6
		# snmp_username: # Specifies the name of the user for whom you want to grant access to the SNMP v3 MIB.
		# snmp_auth_protocol: md5|sha|none
		# snmp_auth_password: # Specifies the password for the user.
		# snmp_privacy_protocol: aes|des|none
		# snmp_privacy_password: # Specifies the password for the user.
		# update_password: #always|on_create
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_user "Manage user accounts and user attributes on a BIG-IP" b
- name: $1
	bigip_user:
		username_credential: ${2:# Name of the user to create, remove or modify.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# full_name: # Full name of the user.
		# password_credential: # Set the users password to this unencrypted value. C(password_credential) is required when creating a new account.
		# shell: bash|none|tmsh
		# partition_access: # Specifies the administrative partition to which the user has access. C(partition_access) is required when creating a new account. Should be in the form "partition:role". Valid roles include C(acceleration-policy-editor), C(admin), C(application-editor), C(auditor) C(certificate-manager), C(guest), C(irule-manager), C(manager), C(no-access) C(operator), C(resource-admin), C(user-manager), C(web-application-security-administrator), and C(web-application-security-editor). Partition portion of tuple should be an existing partition or the value 'all'.
		# state: #present|absent
		# update_password: #always|on_create
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_facts "Collect facts from F5 BIG-IP devices" b
- name: $1
	bigip_device_facts:
		gather_subset: ${2:all|monitors|profiles|asm-policy-stats|client-ssl-profiles|devices|device-groups|external-monitors|fasthttp-profiles|fastl4-profiles|gateway-icmp-monitors|gtm-pools|gtm-servers|gtm-wide-ips|gtm-a-pools|gtm-a-wide-ips|gtm-aaaa-pools|gtm-aaaa-wide-ips|gtm-cname-pools|gtm-cname-wide-ips|gtm-mx-pools|gtm-mx-wide-ips|gtm-naptr-pools|gtm-naptr-wide-ips|gtm-srv-pools|gtm-srv-wide-ips|http-monitors|https-monitors|http-profiles|iapp-services|iapplx-packages|icmp-monitors|interfaces|internal-data-groups|irules|ltm-pools|nodes|oneconnect-profiles|partitions|provision-info|self-ips|server-ssl-profiles|software-volumes|software-images|software-hotfixes|ssl-certs|ssl-keys|system-db|system-info|tcp-monitors|tcp-half-open-monitors|tcp-profiles|traffic-groups|trunks|udp-profiles|vcmp-guests|virtual-addresses|virtual-servers|vlans|!all|!monitors|!profiles|!asm-policy-stats|!client-ssl-profiles|!devices|!device-groups|!external-monitors|!fasthttp-profiles|!fastl4-profiles|!gateway-icmp-monitors|!gtm-pools|!gtm-servers|!gtm-wide-ips|!gtm-a-pools|!gtm-a-wide-ips|!gtm-aaaa-pools|!gtm-aaaa-wide-ips|!gtm-cname-pools|!gtm-cname-wide-ips|!gtm-mx-pools|!gtm-mx-wide-ips|!gtm-naptr-pools|!gtm-naptr-wide-ips|!gtm-srv-pools|!gtm-srv-wide-ips|!http-monitors|!https-monitors|!http-profiles|!iapp-services|!iapplx-packages|!icmp-monitors|!interfaces|!internal-data-groups|!irules|!ltm-pools|!nodes|!oneconnect-profiles|!partitions|!provision-info|!self-ips|!server-ssl-profiles|!software-volumes|!software-images|!software-hotfixes|!ssl-certs|!ssl-keys|!system-db|!system-info|!tcp-monitors|!tcp-half-open-monitors|!tcp-profiles|!traffic-groups|!trunks|!udp-profiles|!vcmp-guests|!virtual-addresses|!virtual-servers|!vlans}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_external "Manages external GTM monitors on a BIG-IP" b
- name: $1
	bigip_gtm_monitor_external:
		name: ${2:# Specifies the name of the monitor.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/external
		# arguments: # Specifies any command-line arguments that the script requires.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# external_program: # Specifies the name of the file for the monitor to use. In order to reference a file, you must first import it using options on the System > File Management > External Monitor Program File List > Import screen. The BIG-IP system automatically places the file in the proper location on the file system.
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 30. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 120.
		# variables: # Specifies any variables that the script requires.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_policy_rule "Manage LTM policy rules on a BIG-IP" b
- name: $1
	bigip_policy_rule:
		policy: ${2:# The name of the policy that you want to associate this rule with.}
		name: ${3:# The name of the rule.}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the policy rule.
		# actions: # The actions that you want the policy rule to perform.
		# conditions: # A list of attributes that describe the condition.
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP" b
- name: $1
	bigip_ssl_certificate:
		name: ${2:# SSL Certificate Name. This is the cert name used when importing a certificate into the F5. It also determines the filenames of the objects on the LTM.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# content: # Sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or
		# state: #present|absent
		# issuer_cert: # Issuer certificate used for OCSP monitoring.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_log_destination "Manages log destinations on a BIG-IP." b
- name: $1
	bigip_log_destination:
		name: ${2:# Specifies the name of the log destination.}
		type: ${3:remote-high-speed-log|remote-syslog}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description of the log destination.
		# pool_settings: # This parameter is only available when C(type) is C(remote-high-speed-log).
		# syslog_settings: # This parameter is only available when C(type) is C(remote-syslog).
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_tcp "Manage TCP profiles on a BIG-IP" b
- name: $1
	bigip_profile_tcp:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# idle_timeout: # Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.
		# time_wait_recycle: # Specifies that connections in a TIME-WAIT state are reused, if a SYN packet, indicating a request for a new connection, is received.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_asm_policy "Manage BIG-IP ASM policies" b
- name: $1
	bigip_asm_policy:
		name: ${2:# The ASM policy to manage or create.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# active: no
		# state: #present|absent
		# file: # Full path to a policy file to be imported into the BIG-IP ASM.
		# template: ActiveSync v1.0 v2.0 (http)|ActiveSync v1.0 v2.0 (https)|Comprehensive|Drupal|Fundamental|Joomla|LotusDomino 6.5 (http)|LotusDomino 6.5 (https)|OWA Exchange 2003 (http)|OWA Exchange 2003 (https)|OWA Exchange 2003 with ActiveSync (http)|OWA Exchange 2003 with ActiveSync (https)|OWA Exchange 2007 (http)|OWA Exchange 2007 (https)|OWA Exchange 2007 with ActiveSync (http)|OWA Exchange 2007 with ActiveSync (https)|OWA Exchange 2010 (http)|OWA Exchange 2010 (https)|Oracle 10g Portal (http)|Oracle 10g Portal (https)|Oracle Applications 11i (http)|Oracle Applications 11i (https)|PeopleSoft Portal 9 (http)|PeopleSoft Portal 9 (https)|Rapid Deployment Policy|SAP NetWeaver 7 (http)|SAP NetWeaver 7 (https)|SharePoint 2003 (http)|SharePoint 2003 (https)|SharePoint 2007 (http)|SharePoint 2007 (https)|SharePoint 2010 (http)|SharePoint 2010 (https)|Vulnerability Assessment Baseline|Wordpress
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_auth "Manage system authentication on a BIG-IP" b
- name: $1
	bigip_device_auth:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# type: tacacs|local
		# servers: # Specifies a list of the IPv4 addresses for servers using the Terminal Access Controller Access System (TACACS)+ protocol with which the system communicates to obtain authorization data.
		# secret: # Secret key used to encrypt and decrypt packets sent or received from the server.
		# service_name: slip|ppp|arap|shell|tty-daemon|connection|system|firewall
		# protocol_name: lcp|ip|ipx|atalk|vines|lat|xremote|tn3270|telnet|rlogin|pad|vpdn|ftp|http|deccp|osicp|unknown
		# authentication: use-first-server|use-all-servers
		# use_for_auth: # Specifies whether or not this auth source is put in use on the system.
		# state: absent|#present
		# update_secret: #always|on_create
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP" b
- name: $1
	bigip_hostname:
		hostname: ${2:# Hostname of the BIG-IP host.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system" b
- name: $1
	bigip_vlan:
		name: ${2:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description to give to the VLAN.
		# tagged_interfaces: # Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.
		# untagged_interfaces: # Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.
		# state: absent|#present
		# tag: # Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.
		# mtu: # Specifies the maximum transmission unit (MTU) for traffic on this VLAN. When creating a new VLAN, if this parameter is not specified, the default value used will be C(1500).
		# cmp_hash: default|destination-address|source-address|dst-ip|src-ip|dest|destination|source|dst|src
		# dag_tunnel: inner|outer
		# dag_round_robin: # Specifies whether some of the stateless traffic on the VLAN should be disaggregated in a round-robin order instead of using a static hash. The stateless traffic includes non-IP L2 traffic, ICMP, some UDP protocols, and so on.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_data_group "Manage data groups on a BIG-IP" b
- name: $1
	bigip_data_group:
		name: ${2:# Specifies the name of the data group.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# type: address|addr|ip|#string|str|integer|int
		# internal: no
		# external_file_name: # When creating a new data group, this specifies the file name that you want to give an external data group file on the BIG-IP.
		# records: # Specifies the records that you want to add to a data group.
		# records_src: # Path to a file with records in it.
		# separator: :=
		# delete_data_group_file: no
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors" b
- name: $1
	bigip_monitor_http:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/http
		# description: # The description of the monitor.
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\r\n) will be used.
		# receive: # The receive string for the monitor call.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_udp "Manage UDP profiles on a BIG-IP" b
- name: $1
	bigip_profile_udp:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# idle_timeout: # Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.
		# datagram_load_balancing: # Specifies, when C(yes), that the system load balances UDP traffic packet-by-packet.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_cli_alias "Manage CLI aliases on a BIG-IP" b
- name: $1
	bigip_cli_alias:
		name: ${2:# Specifies the name of the alias.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# scope: private|#shared
		# command: # The command to alias.
		# description: # Description of the alias.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes" b
- name: $1
	bigip_node:
		name: ${2:# Specifies the name of the node.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent|enabled|disabled|offline
		# monitor_type: and_list|m_of_n|single
		# quorum: # Monitor quorum value when C(monitor_type) is C(m_of_n).
		# monitors: # Specifies the health monitors that the system currently uses to monitor this node.
		# address: # IP address of the node. This can be either IPv4 or IPv6. When creating a new node, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.
		# fqdn: # FQDN name of the node. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").
		# fqdn_address_type: ipv4|ipv6|all
		# fqdn_auto_populate: # Specifies whether the system automatically creates ephemeral nodes using the IP addresses returned by the resolution of a DNS query for a node defined by an FQDN.
		# fqdn_up_interval: # Specifies the interval in which a query occurs, when the DNS server is up. The associated monitor attempts to probe three times, and marks the server down if it there is no response within the span of three times the interval value, in seconds.
		# fqdn_down_interval: # Specifies the interval in which a query occurs, when the DNS server is down. The associated monitor continues polling as long as the DNS server is down.
		# description: # Specifies descriptive text that identifies the node.
		# connection_limit: # Node connection limit. Setting this to 0 disables the limit.
		# rate_limit: # Node rate limit (connections-per-second). Setting this to 0 disables the limit.
		# ratio: # Node ratio weight. Valid values range from 1 through 100.
		# dynamic_ratio: # The dynamic ratio number for the node. Used for dynamic ratio load balancing.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_regkey_pool "Manages registration key pools on BIG-IQ" b
- name: $1
	bigiq_regkey_pool:
		name: ${2:# Specifies the name of the registration key pool.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # A description to attach to the pool.
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP" b
- name: $1
	bigip_device_ntp:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# ntp_servers: # A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required.
		# state: absent|#present
		# timezone: # The timezone to set for NTP lookups. At least one of C(ntp_servers) or C(timezone) is required.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_dos_profile "Manage AFM DoS profiles on a BIG-IP" b
- name: $1
	bigip_firewall_dos_profile:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description of the DoS profile.
		# default_whitelist: # The default whitelist address list for the system to use to determine which IP addresses are legitimate.
		# threshold_sensitivity: low|medium|high
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_rule "Manage AFM Firewall rules" b
- name: $1
	bigip_firewall_rule:
		name: ${2:# Specifies the name of the rule.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent_policy: # The policy which contains the rule to be managed.
		# parent_rule_list: # The rule list which contains the rule to be managed.
		# action: accept|drop|reject|accept-decisively
		# status: enabled|disabled|scheduled
		# schedule: # Specifies a schedule for the firewall rule.
		# description: # The rule description.
		# irule: # Specifies an iRule that is applied to the rule.
		# protocol: # Specifies the protocol to which the rule applies.
		# source: # Specifies packet sources to which the rule applies.
		# destination: # Specifies packet destinations to which the rule applies.
		# logging: # Specifies whether logging is enabled or disabled for the firewall rule.
		# rule_list: # Specifies an existing rule list to use in the rule.
		# icmp_message: # Specifies the Internet Control Message Protocol (ICMP) or ICMPv6 message C(type) and C(code) that the rule uses.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_ssl_key "Import/Delete SSL keys from BIG-IP" b
- name: $1
	bigip_ssl_key:
		name: ${2:# The name of the key.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# content: # Sets the contents of a key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. This must be provided when C(state) is C(present).
		# state: #present|absent
		# passphrase: # Passphrase on key.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_appsvcs_extension "Manage application service deployments" b
- name: $1
	bigip_appsvcs_extension:
		content: ${2:# Declaration of tenants configured on the system.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# tenants: # A list of tenants that you want to remove.
		# force: no
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_software_install "Install software images on a BIG-IP" b
- name: $1
	bigip_software_install:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# image: # Image to install on the remote device.
		# volume: # The volume to install the software image to.
		# state: #activated|installed
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_https_waf "Manages BIG-IQ HTTPS WAF applications" b
- name: $1
	bigiq_application_https_waf:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# redirect_virtual: # Settings to configure the virtual which will receive the connection to be redirected.
		# client_ssl_profile: # Specifies the SSL profile for managing client-side SSL traffic.
		# service_environment: # Specifies the name of service environment that the application will be deployed to.
		# add_analytics: no
		# domain_names: # Specifies host names that are used to access the web application that this security policy protects.
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools" b
- name: $1
	bigip_pool:
		name: ${2:# Pool name}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Specifies descriptive text that identifies the pool.
		# lb_method: dynamic-ratio-member|dynamic-ratio-node|fastest-app-response|fastest-node|least-connections-member|least-connections-node|least-sessions|observed-member|observed-node|predictive-member|predictive-node|ratio-least-connections-member|ratio-least-connections-node|ratio-member|ratio-node|ratio-session|round-robin|weighted-least-connections-member|weighted-least-connections-node
		# monitor_type: and_list|m_of_n|single
		# quorum: # Monitor quorum value when C(monitor_type) is C(m_of_n).
		# monitors: # Monitor template name list. If the partition is not provided as part of the monitor name, then the C(partition) option will be used instead.
		# slow_ramp_time: # Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members.
		# reselect_tries: # Sets the number of times the system tries to contact a pool member after a passive failure.
		# service_down_action: none|reset|drop|reselect
		# partition: Common
		# state: absent|#present
		# metadata: # Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a pool to me managed by Ansible.
		# priority_group_activation: # Specifies whether the system load balances traffic according to the priority number assigned to the pool member.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_service_policy "Manages service policies on a BIG-IP." b
- name: $1
	bigip_service_policy:
		name: ${2:# Name of the service policy.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the service policy.
		# timer_policy: # The timer policy to attach to the service policy.
		# port_misuse_policy: # The port misuse policy to attach to the service policy.
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_port_list "Manage port lists on BIG-IP AFM" b
- name: $1
	bigip_firewall_port_list:
		name: ${2:# Specifies the name of the port list.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# description: # Description of the port list
		# ports: # Simple list of port values to add to the list
		# port_ranges: # A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# port_lists: # Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_license "Manage license installation and activation on BIG-IP devices" b
- name: $1
	bigip_device_license:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# license_key: # The registration key to use to license the BIG-IP.
		# license_server: activate.f5.com
		# state: absent|#present
		# accept_eula: # Declares whether you accept the BIG-IP EULA or not. By default, this value is C(no). You must specifically declare that you have viewed and accepted the license. This module will not present you with that EULA though, so it is incumbent on you to read it.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_tunnel "Manage tunnels on a BIG-IP" b
- name: $1
	bigip_tunnel:
		name: ${2:# Specifies the name of the tunnel.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the tunnel.
		# profile: # Specifies the profile to associate with the tunnel for handling traffic.
		# key: # When applied to a GRE tunnel, this value specifies an optional field in the GRE header, used to authenticate the source of the packet.
		# local_address: # Specifies the IP address of the local endpoint of the tunnel.
		# remote_address: # Specifies the IP address of the remote endpoint of the tunnel.
		# secondary_address: # Specifies a non-floating IP address for the tunnel, to be used with host-initiated traffic.
		# mtu: # Specifies the maximum transmission unit (MTU) of the tunnel.
		# use_pmtu: # Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages.
		# tos: # Specifies the Type of Service (TOS) value to insert in the encapsulating header of transmitted packets.
		# auto_last_hop: default|enabled|disabled
		# traffic_group: # Specifies the traffic group to associate with the tunnel.
		# mode: bidirectional|inbound|outbound
		# transparent: # Specifies that the tunnel operates in transparent mode.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_client_ssl "Manages client SSL profiles on a BIG-IP" b
- name: $1
	bigip_profile_client_ssl:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/clientssl
		# ciphers: # Specifies the list of ciphers that the system supports. When creating a new profile, the default cipher list is provided by the parent profile.
		# cert_key_chain: # One or more certificates and keys to associate with the SSL profile. This option is always a list. The keys in the list dictate the details of the client/key/chain combination. Note that BIG-IPs can only have one of each type of each certificate/key type. This means that you can only have one RSA, one DSA, and one ECDSA per profile. If you attempt to assign two RSA, DSA, or ECDSA certificate/key combo, the device will reject this.
		# partition: Common
		# options: netscape-reuse-cipher-change-bug|microsoft-big-sslv3-buffer|msie-sslv2-rsa-padding|ssleay-080-client-dh-bug|tls-d5-bug|tls-block-padding-bug|dont-insert-empty-fragments|no-ssl|no-dtls|no-session-resumption-on-renegotiation|no-tlsv1.1|no-tlsv1.2|single-dh-use|ephemeral-rsa|cipher-server-preference|tls-rollback-bug|no-sslv2|no-sslv3|no-tls|no-tlsv1|pkcs1-check-1|pkcs1-check-2|netscape-ca-dn-bug|netscape-demo-cipher-change-bug
		# secure_renegotiation: require|require-strict|request
		# allow_non_ssl: # Enables or disables acceptance of non-SSL connections.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_dns "Manage DNS monitors on a BIG-IP" b
- name: $1
	bigip_monitor_dns:
		name: ${2:# Specifies the name of the monitor.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/dns
		# description: # The description of the monitor.
		# interval: # The interval specifying how frequently the monitor instance of this template will run.
		# up_interval: # Specifies the interval for the system to use to perform the health check when a resource is up.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request.
		# transparent: # Specifies whether the monitor operates in transparent mode.
		# reverse: # Specifies whether the monitor operates in reverse mode.
		# receive: # Specifies the IP address that the monitor uses from the resource record sections of the DNS response.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up.
		# manual_resume: # Specifies whether the system automatically changes the status of a resource to B(enabled) at the next successful monitor check.
		# ip: # IP address part of the IP/port definition.
		# port: # Port address part of the IP/port definition.
		# query_name: # Specifies a query name for the monitor to use in a DNS query.
		# query_type: a|aaaa
		# answer_section_contains: any-type|anything|query-type
		# accept_rcode: no-error|anything
		# adaptive: # Specifies whether adaptive response time monitoring is enabled for this monitor.
		# allowed_divergence_type: relative|absolute
		# allowed_divergence_value: # When specifying a new monitor, if C(adaptive) is C(yes), and C(type) is C(relative), the default is C(25) percent.
		# adaptive_limit: # Specifies the absolute number of milliseconds that may not be exceeded by a monitor probe, regardless of C(allowed_divergence) setting, for a probe to be considered successful.
		# sampling_timespan: # Specifies the length, in seconds, of the probe history window that the system uses to calculate the mean latency and standard deviation of a monitor probe.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_port_list "Manage port lists on BIG-IP AFM" b
- name: $1
	bigip_firewall_port_list:
		name: ${2:# Specifies the name of the port list.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# description: # Description of the port list
		# ports: # Simple list of port values to add to the list
		# port_ranges: # A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# port_lists: # Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_rule_list "Manage AFM security firewall policies on a BIG-IP" b
- name: $1
	bigip_firewall_rule_list:
		name: ${2:# The name of the policy to create.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description to attach to the policy.
		# state: #present|absent
		# rules: # Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members" b
- name: $1
	bigip_pool_member:
		state: ${2:#present|absent|enabled|disabled|forced_offline}
		pool: ${3:# Pool name. This pool must exist.}
		port: ${4:# Pool member port.}
		password: ${5:# The password for the user account used to connect to the BIG-IP.}
		server: ${6:# The BIG-IP host.}
		user: ${7:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# name: # Name of the node to create, or re-use, when creating a new pool member.
		# partition: Common
		# address: # IP address of the pool member. This can be either IPv4 or IPv6. When creating a new pool member, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.
		# fqdn: # FQDN name of the pool member. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").
		# connection_limit: # Pool member connection limit. Setting this to 0 disables the limit.
		# description: # Pool member description.
		# rate_limit: # Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.
		# ratio: # Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.
		# preserve_node: # When state is C(absent) attempts to remove the node that the pool member references.
		# priority_group: # Specifies a number representing the priority group for the pool member.
		# fqdn_auto_populate: # Specifies whether the system automatically creates ephemeral nodes using the IP addresses returned by the resolution of a DNS query for a node defined by an FQDN.
		# reuse_nodes: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_iapp_service "Manages TCL iApp services on a BIG-IP" b
- name: $1
	bigip_iapp_service:
		name: ${2:# The name of the iApp service that you want to deploy.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# template: # The iApp template from which to instantiate a new service. This template must exist on your BIG-IP before you can successfully create a service.
		# parameters: # A hash of all the required template variables for the iApp template. If your parameters are stored in a file (the more common scenario) it is recommended you use either the C(file) or C(template) lookups to supply the expected parameters.
		# force: no
		# state: #present|absent
		# partition: Common
		# strict_updates: yes
		# traffic_group: # The traffic group for the iApp service. When creating a new service, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
		# metadata: # Metadata associated with the iApp service.
		# description: # Description of the iApp service.
		# device_group: # The device group for the iApp service.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_persistence_src_addr "Manage source address persistence profiles" b
- name: $1
	bigip_profile_persistence_src_addr:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# match_across_services: # When C(yes), specifies that all persistent connections from a client IP address that go to the same virtual IP address also go to the same node.
		# match_across_virtuals: # When C(yes), specifies that all persistent connections from the same client IP address go to the same node.
		# match_across_pools: # When C(yes), specifies that the system can use any pool that contains this persistence record.
		# hash_algorithm: default|carp
		# entry_timeout: # Specifies the duration of the persistence entries.
		# override_connection_limit: # When C(yes), specifies that the system allows you to specify that pool member connection limits will be overridden for persisted clients.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_policy "Manage general policy configuration on a BIG-IP" b
- name: $1
	bigip_policy:
		name: ${2:# The name of the policy to create.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description to attach to the policy.
		# state: #present|absent|draft
		# strategy: first|all|best
		# rules: # Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_group_member "Manages members in a device group" b
- name: $1
	bigip_device_group_member:
		name: ${2:# Specifies the name of the device that you want to add to the device group. Often this will be the hostname of the device. This member must be trusted by the device already. Trusting can be done with the C(bigip_device_trust) module and the C(peer_hostname) option to that module.}
		device_group: ${3:# The device group that you want to add the member to.}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_pool "Manages F5 BIG-IP GTM pools" b
- name: $1
	bigip_gtm_pool:
		name: ${2:# Name of the GTM pool.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# state: #present|absent|enabled|disabled
		# preferred_lb_method: round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score
		# alternate_lb_method: round-robin|return-to-dns|none|ratio|topology|static-persistence|global-availability|virtual-server-capacity|packet-rate|drop-packet|fallback-ip|virtual-server-score
		# fallback_lb_method: round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score|none
		# fallback_ip: # Specifies the IPv4, or IPv6 address of the server to which the system directs requests when it cannot use one of its pools to do so. Note that the system uses the fallback IP only if you select the C(fallback_ip) load balancing method.
		# type: a|aaaa|cname|mx|naptr|srv
		# partition: Common
		# members: # Members to assign to the pool.
		# monitors: # Specifies the health monitors that the system currently uses to monitor this resource.
		# availability_requirements: # Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_snmp_trap "Manipulate SNMP trap information on a BIG-IP" b
- name: $1
	bigip_snmp_trap:
		name: ${2:# Name of the SNMP configuration endpoint.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# snmp_version: 1|2c
		# community: # Specifies the community name for the trap destination.
		# destination: # Specifies the address for the trap destination. This can be either an IP address or a hostname.
		# port: # Specifies the port for the trap destination.
		# network: other|management|default
		# state: #present|absent
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_software_update "Manage the software update settings of a BIG-IP" b
- name: $1
	bigip_software_update:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# auto_check: # Specifies whether to automatically check for updates on the F5 Networks downloads server.
		# auto_phone_home: # Specifies whether to automatically send phone home data to the F5 Networks PhoneHome server.
		# frequency: daily|monthly|weekly
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_qkview "Manage qkviews on the device" b
- name: $1
	bigip_qkview:
		dest: ${2:# Destination on your local filesystem when you want to save the qkview.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# filename: localhost.localdomain.qkview
		# asm_request_log: no
		# max_file_size: 0
		# complete_information: no
		# exclude_core: no
		# exclude: all|audit|secure|bash_history
		# force: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_tcp_half_open "Manages F5 BIG-IP LTM tcp half-open monitors" b
- name: $1
	bigip_monitor_tcp_half_open:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/tcp_half_open
		# description: # The description of the monitor.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_regkey_license_assignment "Manage regkey license assignment on BIG-IPs from a BIG-IQ" b
- name: $1
	bigiq_regkey_license_assignment:
		pool: ${2:# The registration key pool to use.}
		key: ${3:# The registration key that you want to assign from the pool.}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# device: # When C(managed) is C(no), specifies the address, or hostname, where the BIG-IQ can reach the remote device to register.
		# managed: # Whether the specified device is a managed or un-managed device.
		# device_port: 443
		# device_username: # The username used to connect to the remote device.
		# device_password: # The password of the C(device_username).
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_connectivity "Manages device IP configuration settings for HA on a BIG-IP" b
- name: $1
	bigip_device_connectivity:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# config_sync_ip: # Local IP address that the system uses for ConfigSync operations.
		# mirror_primary_address: # Specifies the primary IP address for the system to use to mirror connections.
		# mirror_secondary_address: # Specifies the secondary IP address for the system to use to mirror connections.
		# unicast_failover: # Desired addresses to use for failover operations. Options C(address) and C(port) are supported with dictionary structure where C(address) is the local IP address that the system uses for failover operations. Port specifies the port that the system uses for failover operations. If C(port) is not specified, the default value C(1026) will be used.  If you are specifying the (recommended) management IP address, use 'management-ip' in the address field.
		# failover_multicast: # When C(yes), ensures that the Failover Multicast configuration is enabled and if no further multicast configuration is provided, ensures that C(multicast_interface), C(multicast_address) and C(multicast_port) are the defaults specified in each option's description. When C(no), ensures that Failover Multicast configuration is disabled.
		# multicast_interface: # Interface over which the system sends multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(eth0) will be used.
		# multicast_address: # IP address for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(224.0.0.245) will be used.
		# multicast_port: # Port for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(62960) will be used. This value must be between 0 and 65535.
		# cluster_mirroring: between-clusters|within-cluster
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_software_image "Manage software images on a BIG-IP" b
- name: $1
	bigip_software_image:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# force: no
		# state: absent|#present
		# image: # The image to put on the remote device.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings" b
- name: $1
	bigip_device_dns:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# cache: enabled|disabled|enable|disable
		# name_servers: # A list of name servers that the system uses to validate DNS lookups
		# search: # A list of domains that the system searches for local domain lookups, to resolve local host names.
		# ip_version: 4|6
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_dns "Manage DNS profiles on a BIG-IP" b
- name: $1
	bigip_profile_dns:
		name: ${2:# Specifies the name of the DNS profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# enable_dns_express: # Specifies whether the DNS Express engine is enabled.
		# enable_zone_transfer: # Specifies whether the system answers zone transfer requests for a DNS zone created on the system.
		# enable_dnssec: # Specifies whether the system signs responses with DNSSEC keys and replies to DNSSEC specific queries (e.g., DNSKEY query type).
		# enable_gtm: # Specifies whether the system uses Global Traffic Manager to manage the response.
		# process_recursion_desired: # Specifies whether to process client-side DNS packets with Recursion Desired set in the header.
		# use_local_bind: # Specifies whether the system forwards non-wide IP queries to the local BIND server on the BIG-IP system.
		# enable_dns_firewall: # Specifies whether DNS firewall capability is enabled.
		# enable_cache: # Specifies whether the system caches DNS responses.
		# cache_name: # Specifies the user-created cache that the system uses to cache DNS responses.
		# unhandled_query_action: allow|drop|reject|hint|no-error
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_address_list "Manage address lists on BIG-IP AFM" b
- name: $1
	bigip_firewall_address_list:
		name: ${2:# Specifies the name of the address list.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# description: # Description of the address list
		# geo_locations: # List of geolocations specified by their C(country) and C(region).
		# addresses: # Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.
		# address_ranges: # A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
		# address_lists: # Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
		# fqdns: # A list of fully qualified domain names (FQDNs).
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_timer_policy "Manage timer policies on a BIG-IP" b
- name: $1
	bigip_timer_policy:
		name: ${2:# Specifies the name of the timer policy.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Specifies descriptive text that identifies the timer policy.
		# rules: # Rules that you want assigned to the timer policy
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_command "Run arbitrary command on F5 devices" b
- name: $1
	bigip_command:
		commands: ${2:# The commands to send to the remote BIG-IP device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries as expired.}
		transport: ${3:#rest|cli}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# warn: yes
		# chdir: # Change into this directory before running the command.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_utility_license_assignment "Manage utility license assignment on BIG-IPs from a BIG-IQ" b
- name: $1
	bigiq_utility_license_assignment:
		key: ${2:# The registration key that you want choose an offering from.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# unit_of_measure: #hourly|daily|monthly|yearly
		# offering: # Name of the license offering to assign to the device.
		# device: # When C(managed) is C(no), specifies the address, or hostname, where the BIG-IQ can reach the remote device to register.
		# managed: # Whether the specified device is a managed or un-managed device.
		# device_port: 443
		# device_username: # The username used to connect to the remote device.
		# device_password: # The password of the C(device_username).
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_tcp "Manages F5 BIG-IP GTM tcp monitors" b
- name: $1
	bigip_gtm_monitor_tcp:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/tcp
		# send: # The send string for the monitor call.
		# receive: # The receive string for the monitor call.
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # The interval specifying how frequently the monitor instance of this template will run.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
		# partition: Common
		# state: #present|absent
		# probe_timeout: # Specifies the number of seconds after which the system times out the probe request to the system.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# transparent: # Specifies whether the monitor operates in transparent mode.
		# reverse: # Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_oneconnect "Manage OneConnect profiles on a BIG-IP" b
- name: $1
	bigip_profile_oneconnect:
		name: ${2:# Specifies the name of the OneConnect profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: # Specifies the profile from which this profile inherits settings.
		# source_mask: # Specifies a value that the system applies to the source address to determine its eligibility for reuse.
		# description: # Description of the profile.
		# maximum_size: # Specifies the maximum number of connections that the system holds in the connection reuse pool.
		# maximum_age: # Specifies the maximum number of seconds allowed for a connection in the connection reuse pool.
		# maximum_reuse: # Specifies the maximum number of times that a server-side connection can be reused.
		# idle_timeout_override: # Specifies the number of seconds that a connection is idle before the connection flow is eligible for deletion.
		# limit_type: none|idle|strict
		# share_pools: # Indicates that connections may be shared not only within a virtual server, but also among similar virtual servers
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_monitor_https "Manages F5 BIG-IP LTM https monitors" b
- name: $1
	bigip_monitor_https:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description of the monitor.
		# parent: /Common/https
		# send: # The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\\r\\n) will be used.
		# receive: # The receive string for the monitor call.
		# receive_disable: # This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.
		# time_until_up: # Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_trust "Manage the trust relationships between BIG-IPs" b
- name: $1
	bigip_device_trust:
		peer_server: ${2:# The peer address to connect to and trust for synchronizing configuration. This is typically the management address of the remote device, but may also be a Self IP.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# peer_hostname: # The hostname that you want to associate with the device. This value will be used to easily distinguish this device in BIG-IP configuration.
		# peer_user: # The API username of the remote peer device that you are trusting. Note that the CLI user cannot be used unless it too has an API account. If this value is not specified, then the value of C(user), or the environment variable C(F5_USER) will be used.
		# peer_password: # The password of the API username of the remote peer device that you are trusting. If this value is not specified, then the value of C(password), or the environment variable C(F5_PASSWORD) will be used.
		# type: #peer|subordinate
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_regkey_license "Manages licenses in a BIG-IQ registration key pool" b
- name: $1
	bigiq_regkey_license:
		regkey_pool: ${2:# The registration key pool that you want to place the license in.}
		license_key: ${3:# The license key to put in the pool.}
		password: ${4:# The password for the user account used to connect to the BIG-IP.}
		server: ${5:# The BIG-IP host.}
		user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the license.
		# accept_eula: # A key that signifies that you accept the F5 EULA for this license.
		# state: absent|#present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_traffic_group "Manages traffic groups on BIG-IP" b
- name: $1
	bigip_traffic_group:
		name: ${2:# The name of the traffic group.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# state: #present|absent
		# mac_address: # Specifies the floating Media Access Control (MAC) address associated with the floating IP addresses defined for a traffic group.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_snmp "Manipulate general SNMP settings on a BIG-IP" b
- name: $1
	bigip_snmp:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# allowed_addresses: # Configures the IP addresses of the SNMP clients from which the snmpd daemon accepts requests.
		# contact: # Specifies the name of the person who administers the SNMP service for this system.
		# agent_status_traps: enabled|disabled
		# agent_authentication_traps: enabled|disabled
		# device_warning_traps: enabled|disabled
		# location: # Specifies the description of this system's physical location.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_firewall_policy "Manage AFM security firewall policies on a BIG-IP" b
- name: $1
	bigip_firewall_policy:
		name: ${2:# The name of the policy to create.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description to attach to the policy.
		# state: #present|absent
		# rules: # Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
		# partition: Common
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_trunk "Manage trunks on a BIG-IP" b
- name: $1
	bigip_trunk:
		name: ${2:# Specifies the name of the trunk.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# interfaces: # The interfaces that are part of the trunk.
		# description: # Description of the trunk.
		# link_selection_policy: auto|maximum-bandwidth
		# frame_distribution_hash: destination-mac|source-destination-ip|source-destination-mac
		# lacp_enabled: # When C(yes), specifies that the system supports the link aggregation control protocol (LACP), which monitors the trunk by exchanging control packets over the member links to determine the health of the links.
		# lacp_mode: active|passive
		# lacp_timeout: long|short
		# qinq_ethertype: # Specifies the ether-type value used for the packets handled on this trunk when it is a member in a QinQ vlan.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_profile_http "Manage HTTP profiles on a BIG-IP" b
- name: $1
	bigip_profile_http:
		name: ${2:# Specifies the name of the profile.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/http
		# description: # Description of the profile.
		# proxy_type: reverse|transparent|explicit
		# dns_resolver: # Specifies the name of a configured DNS resolver, this option is mandatory when C(proxy_type) is set to C(explicit).
		# insert_xforwarded_for: # When specified system inserts an X-Forwarded-For header in an HTTP request with the client IP address, to use with connection pooling.
		# redirect_rewrite: none|all|matching|nodes
		# encrypt_cookies: # Cookie names for the system to encrypt.
		# encrypt_cookie_secret: # Passphrase for cookie encryption.
		# update_password: #always|on_create
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_tcp_half_open "Manages F5 BIG-IP GTM tcp half-open monitors" b
- name: $1
	bigip_gtm_monitor_tcp_half_open:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/tcp_half_open
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
		# interval: # Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.
		# timeout: # Specifies the number of seconds the target has in which to respond to the monitor request.
		# probe_interval: # Specifies the number of seconds the big3d process waits before sending out a subsequent probe attempt when a probe fails and multiple probe attempts have been requested.
		# probe_timeout: # Specifies the number of seconds after which the system times out the probe request to the system.
		# probe_attempts: # Specifies the number of times the system attempts to probe the host server, after which the system considers the host server down or unavailable.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# transparent: # Specifies whether the monitor operates in transparent mode.
		# partition: Common
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_config "Manage BIG-IP configuration sections" b
- name: $1
	bigip_config:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# save: yes
		# reset: no
		# merge_content: # Loads the specified configuration that you want to merge into the running configuration. This is equivalent to using the C(tmsh) command C(load sys config from-terminal merge).
		# verify: no
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP" b
- name: $1
	bigip_device_sshd:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# allow: # Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system.
		# banner: enabled|disabled
		# banner_text: # Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.
		# inactivity_timeout: # Specifies the number of seconds before inactivity causes an SSH session to log out.
		# log_level: debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose
		# login: enabled|disabled
		# port: # Port that you want the SSH daemon to run on.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_gtm_monitor_firepass "Manages F5 BIG-IP GTM FirePass monitors" b
- name: $1
	bigip_gtm_monitor_firepass:
		name: ${2:# Monitor name.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# parent: /Common/firepass_gtm
		# ip: # IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
		# port: # Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
		# interval: # The interval specifying how frequently the monitor instance of this template will run.
		# timeout: # The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
		# partition: Common
		# state: #present|absent
		# probe_timeout: # Specifies the number of seconds after which the system times out the probe request to the system.
		# ignore_down_response: # Specifies that the monitor allows more than one probe attempt per interval.
		# target_username: # Specifies the user name, if the monitored target requires authentication.
		# target_password: # Specifies the password, if the monitored target requires authentication.
		# update_password: #always|on_create
		# cipher_list: # Specifies the list of ciphers for this monitor.
		# max_load_average: # Specifies the number that the monitor uses to mark the Secure Access Manager system up or down.
		# concurrency_limit: # Specifies the maximum percentage of licensed connections currently in use under which the monitor marks the Secure Access Manager system up.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_smtp "Manages SMTP settings on the BIG-IP" b
- name: $1
	bigip_smtp:
		name: ${2:# Specifies the name of the SMTP server configuration.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# partition: Common
		# smtp_server: # SMTP server host name in the format of a fully qualified domain name.
		# smtp_server_port: # Specifies the SMTP port number.
		# local_host_name: # Host name used in SMTP headers in the format of a fully qualified domain name. This setting does not refer to the BIG-IP system's hostname.
		# from_address: # Email address that the email is being sent from. This is the "Reply-to" address that the recipient sees.
		# encryption: none|ssl|tls
		# authentication: # Credentials can be set on an SMTP server's configuration even if that authentication is not used (think staging configs or emergency changes). This parameter acts as a switch to make the specified C(smtp_server_username) and C(smtp_server_password) parameters active or not.
		# smtp_server_username: # User name that the SMTP server requires when validating a user.
		# smtp_server_password: # Password that the SMTP server requires when validating a user.
		# state: #present|absent
		# update_password: #always|on_create
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_device_group "Manage device groups on a BIG-IP" b
- name: $1
	bigip_device_group:
		name: ${2:# Specifies the name of the device group.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# type: sync-failover|sync-only
		# description: # Description of the device group.
		# auto_sync: # Indicates whether configuration synchronization occurs manually or automatically.
		# save_on_auto_sync: # When performing an auto-sync, specifies whether the configuration will be saved or not.
		# full_sync: # Specifies whether the system synchronizes the entire configuration during synchronization operations.
		# max_incremental_sync_size: # Specifies the size of the changes cache for incremental sync.
		# state: #present|absent
		# network_failover: # Indicates whether failover occurs over the network or is hard-wired.
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_partition "Manage BIG-IP partitions" b
- name: $1
	bigip_partition:
		name: ${2:# Name of the partition}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # The description to attach to the Partition.
		# route_domain: # The default Route Domain to assign to the Partition. If no route domain is specified, then the default route domain for the system (typically zero) will be used only when creating a new partition.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigiq_application_http "Manages BIG-IQ HTTP applications" b
- name: $1
	bigiq_application_http:
		name: ${2:# Name of the new application.}
		password: ${3:# The password for the user account used to connect to the BIG-IP.}
		server: ${4:# The BIG-IP host.}
		user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# description: # Description of the application.
		# servers: # A list of servers that the application is hosted on.
		# inbound_virtual: # Settings to configure the virtual which will receive the inbound connection.
		# service_environment: # Specifies the name of service environment that the application will be deployed to.
		# add_analytics: no
		# state: absent|#present
		# wait: yes
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings" b
- name: $1
	bigip_sys_global:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# banner_text: # Specifies the text to present in the advisory banner.
		# console_timeout: # Specifies the number of seconds of inactivity before the system logs off a user that is logged on.
		# gui_setup: # C(enable) or C(disabled) the Setup utility in the browser-based Configuration utility.
		# lcd_display: # Specifies, when C(enabled), that the system menu displays on the LCD screen on the front of the unit. This setting has no effect when used on the VE platform.
		# mgmt_dhcp: # Specifies whether or not to enable DHCP client on the management interface
		# net_reboot: # Specifies, when C(enabled), that the next time you reboot the system, the system boots to an ISO image on the network, rather than an internal media drive.
		# quiet_boot: # Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.
		# security_banner: # Specifies whether the system displays an advisory message on the login screen.
		# state: #present
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet bigip_iapplx_package "Manages Javascript iApp packages on a BIG-IP" b
- name: $1
	bigip_iapplx_package:
		password: ${2:# The password for the user account used to connect to the BIG-IP.}
		server: ${3:# The BIG-IP host.}
		user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device.}
		# package: # The iAppLX package that you want to upload or remove. When C(state) is C(present), and you intend to use this module in a C(role), it is recommended that you use the C({{ role_path }}) variable. An example is provided in the C(EXAMPLES) section.
		# state: #present|absent
		# server_port: 443
		# validate_certs: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nxos_l3_interface "Manage L3 interfaces on Cisco NXOS network devices" b
- name: $1
	nxos_l3_interface:
		# name: # Name of the L3 interface.
		# ipv4: # IPv4 of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_udld "Manages UDLD global configuration params." b
- name: $1
	nxos_udld:
		# aggressive: enabled|disabled
		# msg_time: # Message time in seconds for UDLD packets or keyword 'default'.
		# reset: no
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_igmp "Manages IGMP global configuration." b
- name: $1
	nxos_igmp:
		# flush_routes: # Removes routes when the IGMP process is restarted. By default, routes are not flushed.
		# enforce_rtr_alert: # Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.
		# restart: # Restarts the igmp process (using an exec config command).
		# state: #present|default
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_overlay_global "Configures anycast gateway MAC of the switch." b
- name: $1
	nxos_overlay_global:
		anycast_gateway_mac: ${2:# Anycast gateway mac of the switch.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp_auth "Manages NTP authentication." b
- name: $1
	nxos_ntp_auth:
		# key_id: # Authentication key identifier (numeric).
		# md5string: # MD5 String.
		# auth_type: #text|encrypt
		# trusted_key: #false|true
		# authentication: on|off
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_install_os "Set boot options like boot, kickstart image and issu." b
- name: $1
	nxos_install_os:
		system_image_file: ${2:# Name of the system (or combined) image file on flash.}
		# kickstart_image_file: # Name of the kickstart image file on flash. (Not required on all Nexus platforms)
		# issu: required|desired|yes|#no
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_acl_interface "Manages applying ACLs to interfaces." b
- name: $1
	nxos_acl_interface:
		name: ${2:# Case sensitive name of the access list (ACL).}
		interface: ${3:# Full name of interface, e.g. I(Ethernet1/1).}
		direction: ${4:ingress|egress}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_igmp_snooping "Manages IGMP snooping global configuration." b
- name: $1
	nxos_igmp_snooping:
		# snooping: # Enables/disables IGMP snooping on the switch.
		# group_timeout: # Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).
		# link_local_grp_supp: # Global link-local groups suppression.
		# report_supp: # Global IGMPv1/IGMPv2 Report Suppression.
		# v3_report_supp: # Global IGMPv3 Report Suppression and Proxy Reporting.
		# state: #present|default
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_igmp_interface "Manages IGMP interface configuration." b
- name: $1
	nxos_igmp_interface:
		interface: ${2:# The full interface name for IGMP configuration. e.g. I(Ethernet1/2).}
		# version: 2|3|default
		# startup_query_interval: # Query interval used when the IGMP process starts up. The range is from 1 to 18000 or keyword 'default'. The default is 31.
		# startup_query_count: # Query count used when the IGMP process starts up. The range is from 1 to 10 or keyword 'default'. The default is 2.
		# robustness: # Sets the robustness variable. Values can range from 1 to 7 or keyword 'default'. The default is 2.
		# querier_timeout: # Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds or keyword 'default'. The default is 255 seconds.
		# query_mrt: # Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds or keyword 'default'. The default is 10 seconds.
		# query_interval: # Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds or keyword 'default'. The default is 125 seconds.
		# last_member_qrt: # Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds or keyword 'default'. The default is 1 second.
		# last_member_query_count: # Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5 or keyword 'default'. The default is 2.
		# group_timeout: # Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds or keyword 'default'. The default is 260 seconds.
		# report_llg: # Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.
		# immediate_leave: # Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group-specific queries. The default is disabled.
		# oif_routemap: # Configure a routemap for static outgoing interface (OIF) or keyword 'default'.
		# oif_prefix: # This argument is deprecated, please use oif_ps instead. Configure a prefix for static outgoing interface (OIF).
		# oif_source: # This argument is deprecated, please use oif_ps instead. Configure a source for static outgoing interface (OIF).
		# oif_ps: # Configure prefixes and sources for static outgoing interface (OIF). This is a list of dict where each dict has source and prefix defined or just prefix if source is not needed. The specified values will be configured on the device and if any previous prefix/sources exist, they will be removed. Keyword 'default' is also accpted which removes all existing prefix/sources.
		# restart: no
		# state: #present|absent|default
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_acl "Manages access list entries for ACLs." b
- name: $1
	nxos_acl:
		name: ${2:# Case sensitive name of the access list (ACL).}
		# seq: # Sequence number of the entry (ACE).
		# action: permit|deny|remark
		# remark: # If action is set to remark, this is the description.
		# proto: # Port number or protocol (as supported by the switch).
		# src: # Source ip and mask using IP/MASK notation and supports keyword 'any'.
		# src_port_op: any|eq|gt|lt|neq|range
		# src_port1: # Port/protocol and also first (lower) port when using range operand.
		# src_port2: # Second (end) port when using range operand.
		# dest: # Destination ip and mask using IP/MASK notation and supports the keyword 'any'.
		# dest_port_op: any|eq|gt|lt|neq|range
		# dest_port1: # Port/protocol and also first (lower) port when using range operand.
		# dest_port2: # Second (end) port when using range operand.
		# log: enable
		# urg: enable
		# ack: enable
		# psh: enable
		# rst: enable
		# syn: enable
		# fin: enable
		# established: enable
		# fragments: enable
		# time_range: # Name of time-range to apply.
		# precedence: critical|flash|flash-override|immediate|internet|network|priority|routine
		# dscp: af11|af12|af13|af21|af22|af23|af31|af32|af33|af41|af42|af43|cs1|cs2|cs3|cs4|cs5|cs6|cs7|default|ef
		# state: #present|absent|delete_acl
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_aaa_server_host "Manages AAA server host-specific configuration." b
- name: $1
	nxos_aaa_server_host:
		server_type: ${2:radius|tacacs}
		address: ${3:# Address or name of the radius or tacacs host.}
		# key: # Shared secret for the specified host or keyword 'default'.
		# encrypt_type: 0|7
		# host_timeout: # Timeout period for specified host, in seconds or keyword 'default. Range is 1-60.
		# auth_port: # Alternate UDP port for RADIUS authentication or keyword 'default'.
		# acct_port: # Alternate UDP port for RADIUS accounting or keyword 'default'.
		# tacacs_port: # Alternate TCP port TACACS Server or keyword 'default'.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_l2_interface "Manage Layer-2 interface on Cisco NXOS devices." b
- name: $1
	nxos_l2_interface:
		name: ${2:# Full name of the interface excluding any logical unit number, i.e. Ethernet1/1.}
		# mode: access|trunk
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# trunk_vlans: # List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
		# aggregate: # List of Layer-2 interface definitions.
		# state: #present|absent|unconfigured
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_feature "Manage features in NX-OS switches." b
- name: $1
	nxos_feature:
		feature: ${2:# Name of feature.}
		# state: #enabled|disabled
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ospf_vrf "Manages a VRF for an OSPF router." b
- name: $1
	nxos_ospf_vrf:
		ospf: ${2:# Name of the OSPF instance.}
		# vrf: default
		# router_id: # Router Identifier (ID) of the OSPF router VRF instance.
		# default_metric: # Specify the default Metric value. Valid values are an integer or the keyword 'default'.
		# log_adjacency: log|detail|default
		# timer_throttle_lsa_start: # Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_lsa_hold: # Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_lsa_max: # Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_spf_start: # Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_spf_hold: # Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# timer_throttle_spf_max: # Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
		# auto_cost: # Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.
		# passive_interface: # Setting to C(yes) will suppress routing update on interface.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vtp_password "Manages VTP password configuration." b
- name: $1
	nxos_vtp_password:
		# vtp_password: # VTP password
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_reboot "Reboot a network device." b
- name: $1
	nxos_reboot:
		# confirm: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp_neighbor "Manages BGP neighbors configurations." b
- name: $1
	nxos_bgp_neighbor:
		asn: ${2:# BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${3:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		# vrf: default
		# description: # Description of the neighbor.
		# connected_check: # Configure whether or not to check for directly connected peer.
		# capability_negotiation: # Configure whether or not to negotiate capability with this neighbor.
		# dynamic_capability: # Configure whether or not to enable dynamic capability.
		# ebgp_multihop: # Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.
		# local_as: # Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
		# log_neighbor_changes: enable|disable|inherit
		# low_memory_exempt: # Specify whether or not to shut down this neighbor under memory pressure.
		# maximum_peers: # Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit. Note that this parameter is accepted only on neighbors with address/prefix.
		# pwd: # Specify the password for neighbor. Valid value is string.
		# pwd_type: 3des|cisco_type_7|default
		# remote_as: # Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
		# remove_private_as: enable|disable|all|replace-as
		# shutdown: # Configure to administratively shutdown this neighbor.
		# suppress_4_byte_as: # Configure to suppress 4-byte AS Capability.
		# timers_keepalive: # Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.
		# timers_holdtime: # Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.
		# transport_passive_only: # Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length.
		# update_source: # Specify source interface of BGP session and updates.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_rpm "Install patch or feature rpms on Cisco NX-OS devices." b
- name: $1
	nxos_rpm:
		pkg: ${2:# Name of the RPM package.}
		# file_system: bootflash
		# aggregate: # List of RPM/patch definitions.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_evpn_vni "Manages Cisco EVPN VXLAN Network Identifier (VNI)." b
- name: $1
	nxos_evpn_vni:
		vni: ${2:# The EVPN VXLAN Network Identifier.}
		route_distinguisher: ${3:# The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.}
		# route_target_both: # Enables/Disables route-target settings for both import and export target communities using a single property.
		# route_target_import: # Sets the route-target 'import' extended communities.
		# route_target_export: # Sets the route-target 'export' extended communities.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_user "Manage the collection of local users on Nexus devices" b
- name: $1
	nxos_user:
		# aggregate: # The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the remote Cisco Nexus device.  This argument accepts a string value and is mutually exclusive with the C(aggregate) argument.
		# configured_password: # The password to be configured on the network device. The password needs to be provided in cleartext and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# role: # The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.
		# sshkey: # The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.
		# purge: no
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_gir "Trigger a graceful removal or insertion (GIR) of the switch." b
- name: $1
	nxos_gir:
		state: ${2:#present|absent}
		# system_mode_maintenance: # When C(system_mode_maintenance=true) it puts all enabled protocols in maintenance mode (using the isolate command). When C(system_mode_maintenance=false) it puts all enabled protocols in normal mode (using the no isolate command).
		# system_mode_maintenance_dont_generate_profile: # When C(system_mode_maintenance_dont_generate_profile=true) it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When C(system_mode_maintenance_dont_generate_profile=false) it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal-mode profile that you have created.
		# system_mode_maintenance_timeout: # Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.
		# system_mode_maintenance_shutdown: # Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while C(system_mode_maintenance) (which uses the isolate command) is not.
		# system_mode_maintenance_on_reload_reset_reason: hw_error|svc_failure|kern_failure|wdog_timeout|fatal_error|lc_failure|match_any|manual_reload|any_other|maintenance
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_logging "Manage logging on network devices" b
- name: $1
	nxos_logging:
		# dest: console|logfile|module|monitor|server
		# remote_server: # Hostname or IP Address for remote logging (when dest is 'server').
		# use_vrf: # VRF to be used while configuring remote logging (when dest is 'server').
		# interface: # Interface to be used while configuring source-interface for logging (e.g., 'Ethernet1/2', 'mgmt0')
		# name: # If value of C(dest) is I(logfile) it indicates file-name.
		# facility: # Facility name for logging.
		# dest_level: # Set logging severity levels.
		# facility_level: # Set logging serverity levels for facility based log messages.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_interface_ospf "Manages configuration of an OSPF interface instance." b
- name: $1
	nxos_interface_ospf:
		interface: ${2:# Name of this cisco_interface resource. Valid value is a string.}
		ospf: ${3:# Name of the ospf instance.}
		area: ${4:# Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.}
		# cost: # The cost associated with this cisco_interface_ospf instance.
		# hello_interval: # Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.
		# dead_interval: # Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.
		# passive_interface: # Setting to true will prevent this interface from receiving HELLO packets.
		# message_digest: # Enables or disables the usage of message digest authentication.
		# message_digest_key_id: # Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.
		# message_digest_algorithm_type: md5|default
		# message_digest_encryption_type: cisco_type_7|3des|default
		# message_digest_password: # Specifies the message_digest password. Valid value is a string.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_aaa_server "Manages AAA server global configuration." b
- name: $1
	nxos_aaa_server:
		server_type: ${2:radius|tacacs}
		# global_key: # Global AAA shared secret or keyword 'default'.
		# encrypt_type: 0|7
		# deadtime: # Duration for which a non-reachable AAA server is skipped, in minutes or keyword 'default. Range is 1-1440. Device default is 0.
		# server_timeout: # Global AAA server timeout period, in seconds or keyword 'default. Range is 1-60. Device default is 5.
		# directed_request: enabled|disabled
		# state: #present|default
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_rollback "Set a checkpoint or rollback to a checkpoint." b
- name: $1
	nxos_rollback:
		# checkpoint_file: # Name of checkpoint file to create. Mutually exclusive with rollback_to.
		# rollback_to: # Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_pim "Manages configuration of a PIM instance." b
- name: $1
	nxos_pim:
		ssm_range: ${2:# Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword C(none) or keyword C(default). C(none) removes all SSM group ranges. C(default) will set ssm_range to the default multicast address. If you set multicast address, please ensure that it is not the same as the C(default), otherwise use the C(default) option.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_interface "Manages physical attributes of interfaces." b
- name: $1
	nxos_interface:
		name: ${2:# Full name of interface, i.e. Ethernet1/1, port-channel10.}
		# interface_type: loopback|portchannel|svi|nve
		# speed: # Interface link speed. Applicable for ethernet interface only.
		# admin_state: #up|down
		# description: # Interface description.
		# mode: layer2|layer3
		# mtu: # MTU for a specific interface. Must be an even number between 576 and 9216. Applicable for ethernet interface only.
		# ip_forward: enable|disable
		# fabric_forwarding_anycast_gateway: # Associate SVI with anycast gateway under VLAN configuration mode. Applicable for SVI interface only.
		# duplex: full|half|#auto
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# aggregate: # L
		# state: #present|absent|default
		# delay: 10
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_file_copy "Copy a file to a remote NXOS device." b
- name: $1
	nxos_file_copy:
		# local_file: # When (file_pull is False) this is the path to the local file on the Ansible controller. The local directory must exist.
		# remote_file: # When (file_pull is False) this is the remote file path on the NXOS device. If omitted, the name of the local file will be used. The remote directory must exist.
		# file_system: bootflash:
		# connect_ssh_port: 22
		# file_pull: no
		# local_file_directory: # When (file_pull is True) file is copied from a remote SCP server to the NXOS device, and written to this directory on the NXOS device. If the directory does not exist, it will be created under the file_system. This is an optional parameter.
		# file_pull_timeout: 300
		# remote_scp_server: # The remote scp server address which is used to pull the file. This is required if file_pull is True.
		# remote_scp_server_user: # The remote scp server username which is used to pull the file. This is required if file_pull is True.
		# remote_scp_server_password: # The remote scp server password which is used to pull the file. This is required if file_pull is True.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_gir_profile_management "Create a maintenance-mode or normal-mode profile for GIR." b
- name: $1
	nxos_gir_profile_management:
		mode: ${2:maintenance|normal}
		# commands: # List of commands to be included into the profile.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_static_route "Manages static route configuration" b
- name: $1
	nxos_static_route:
		prefix: ${2:# Destination prefix of static route.}
		next_hop: ${3:# Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.}
		# vrf: default
		# tag: # Route tag value (numeric) or keyword 'default'.
		# route_name: # Name of the route or keyword 'default'. Used with the name parameter on the CLI.
		# pref: # Preference or administrative difference of route (range 1-255) or keyword 'default'.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vlan "Manages VLAN resources and attributes." b
- name: $1
	nxos_vlan:
		# vlan_id: # Single VLAN ID.
		# vlan_range: # Range of VLANs such as 2-10 or 2,5,10-15, etc.
		# name: # Name of VLAN or keyword 'default'.
		# interfaces: # List of interfaces that should be associated to the VLAN or keyword 'default'.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# vlan_state: #active|suspend
		# admin_state: #up|down
		# mapped_vni: # The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'. Range 4096-16773119.
		# state: #present|absent
		# mode: ce|fabricpath
		# aggregate: # L
		# purge: no
		# delay: 10
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_traps "Manages SNMP traps." b
- name: $1
	nxos_snmp_traps:
		group: ${2:aaa|bfd|bgp|bridge|callhome|cfs|config|eigrp|entity|feature-control|generic|hsrp|license|link|lldp|mmode|ospf|pim|rf|rmon|snmp|storm-control|stpx|switchfabric|syslog|sysmgr|system|upgrade|vtp|all}
		# state: #enabled|disabled
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_command "Run arbitrary command on Cisco NXOS devices" b
- name: $1
	nxos_command:
		commands: ${2:# The commands to send to the remote NXOS device.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# match: all
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_banner "Manage multiline banners on Cisco NXOS devices" b
- name: $1
	nxos_banner:
		banner: ${2:exec|motd}
		# text: # The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vpc "Manages global VPC configuration" b
- name: $1
	nxos_vpc:
		domain: ${2:# VPC domain}
		state: ${3:present|absent}
		# role_priority: # Role priority for device. Remember lower is better.
		# system_priority: # System priority device.  Remember they must match between peers.
		# pkl_src: # Source IP address used for peer keepalive link
		# pkl_dest: # Destination (remote) IP address used for peer keepalive link
		# pkl_vrf: management
		# peer_gw: # Enables/Disables peer gateway
		# auto_recovery: # Enables/Disables auto recovery
		# delay_restore: # manages delay restore command and config value in seconds
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vtp_domain "Manages VTP domain configuration." b
- name: $1
	nxos_vtp_domain:
		domain: ${2:# VTP domain name.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp_af "Manages BGP Address-family configuration." b
- name: $1
	nxos_bgp_af:
		asn: ${2:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		vrf: ${3:# Name of the VRF. The name 'default' is a valid VRF representing the global bgp.}
		afi: ${4:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${5:unicast|multicast|evpn}
		# additional_paths_install: # Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE-CE link failure.
		# additional_paths_receive: # Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
		# additional_paths_selection: # Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.
		# additional_paths_send: # Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
		# advertise_l2vpn_evpn: # Advertise evpn routes.
		# client_to_client: # Configure client-to-client route reflection.
		# dampen_igp_metric: # Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.
		# dampening_state: # Enable/disable route-flap dampening.
		# dampening_half_time: # Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.
		# dampening_max_suppress_time: # Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.
		# dampening_reuse_time: # Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.
		# dampening_routemap: # Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.
		# dampening_suppress_time: # Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.
		# default_information_originate: # Default information originate.
		# default_metric: # Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'
		# distance_ebgp: # Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.
		# distance_ibgp: # Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.
		# distance_local: # Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.
		# inject_map: # An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].
		# maximum_paths: # Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
		# maximum_paths_ibgp: # Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
		# networks: # Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']].
		# next_hop_route_map: # Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.
		# redistribute: # A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].
		# suppress_inactive: # Advertises only active routes to peers.
		# table_map: # Apply table-map to filter routes downloaded into URIB. Valid values are a string.
		# table_map_filter: # Filters routes rejected by the route-map and does not download them to the RIB.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_system "Manage the system attributes on Cisco NXOS devices" b
- name: $1
	nxos_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value or keyword 'default'
		# domain_name: # Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.
		# domain_lookup: # Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.
		# domain_search: # Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name or keyword 'default'. See examples.
		# system_mtu: # Specifies the mtu, must be an integer or keyword 'default'.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vrf_af "Manages VRF AF." b
- name: $1
	nxos_vrf_af:
		vrf: ${2:# Name of the VRF.}
		afi: ${3:ipv4|ipv6}
		safi: ${4:unicast|multicast}
		# route_target_both_auto_evpn: # Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vxlan_vtep "Manages VXLAN Network Virtualization Endpoint (NVE)." b
- name: $1
	nxos_vxlan_vtep:
		interface: ${2:# Interface name for the VXLAN Network Virtualization Endpoint.}
		# description: # Description of the NVE interface.
		# host_reachability: # Specify mechanism for host reachability advertisement.
		# shutdown: # Administratively shutdown the NVE interface.
		# source_interface: # Specify the loopback interface whose IP address should be used for the NVE interface.
		# source_interface_hold_down_time: # Suppresses advertisement of the NVE loopback address until the overlay has converged.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ospf "Manages configuration of an ospf instance." b
- name: $1
	nxos_ospf:
		ospf: ${2:# Name of the ospf instance.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_facts "Gets facts about NX-OS switches" b
- name: $1
	nxos_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp_neighbor_af "Manages BGP address-family's neighbors configuration." b
- name: $1
	nxos_bgp_neighbor_af:
		asn: ${2:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		neighbor: ${3:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
		afi: ${4:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
		safi: ${5:unicast|multicast|evpn}
		# vrf: default
		# additional_paths_receive: enable|disable|inherit
		# additional_paths_send: enable|disable|inherit
		# advertise_map_exist: # Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.
		# advertise_map_non_exist: # Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.
		# allowas_in: # Activate allowas-in property
		# allowas_in_max: # Max-occurrences value for allowas_in. Valid values are an integer value or 'default'. This is mutually exclusive with allowas_in.
		# as_override: # Activate the as-override feature.
		# default_originate: # Activate the default-originate feature.
		# default_originate_route_map: # Route-map for the default_originate property. Valid values are a string defining a route-map name, or 'default'. This is mutually exclusive with default_originate.
		# disable_peer_as_check: # Disable checking of peer AS-number while advertising
		# filter_list_in: # Valid values are a string defining a filter-list name, or 'default'.
		# filter_list_out: # Valid values are a string defining a filter-list name, or 'default'.
		# max_prefix_limit: # maximum-prefix limit value. Valid values are an integer value or 'default'.
		# max_prefix_interval: # Optional restart interval. Valid values are an integer. Requires max_prefix_limit. May not be combined with max_prefix_warning.
		# max_prefix_threshold: # Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.
		# max_prefix_warning: # Optional warning-only keyword. Requires max_prefix_limit. May not be combined with max_prefix_interval.
		# next_hop_self: # Activate the next-hop-self feature.
		# next_hop_third_party: # Activate the next-hop-third-party feature.
		# prefix_list_in: # Valid values are a string defining a prefix-list name, or 'default'.
		# prefix_list_out: # Valid values are a string defining a prefix-list name, or 'default'.
		# route_map_in: # Valid values are a string defining a route-map name, or 'default'.
		# route_map_out: # Valid values are a string defining a route-map name, or 'default'.
		# route_reflector_client: # Router reflector client.
		# send_community: none|both|extended|standard|default
		# soft_reconfiguration_in: enable|always|inherit
		# soo: # Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.
		# suppress_inactive: # suppress-inactive feature.
		# unsuppress_map: # unsuppress-map. Valid values are a string defining a route-map name or 'default'.
		# weight: # Weight value. Valid values are an integer value or 'default'.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_hsrp "Manages HSRP configuration on NX-OS switches." b
- name: $1
	nxos_hsrp:
		group: ${2:# HSRP group number.}
		interface: ${3:# Full name of interface that is being managed for HSRP.}
		# version: 1|2
		# priority: # HSRP priority or keyword 'default'.
		# preempt: enabled|disabled
		# vip: # HSRP virtual IP address or keyword 'default'
		# auth_string: # Authentication string. If this needs to be hidden(for md5 type), the string should be 7 followed by the key string. Otherwise, it can be 0 followed by key string or just key string (for backward compatibility). For text type, this should be just be a key string. if this is 'default', authentication is removed.
		# auth_type: text|md5
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_user "Manages SNMP users for monitoring." b
- name: $1
	nxos_snmp_user:
		user: ${2:# Name of the user.}
		# group: # Group to which the user will belong to. If state = present, and the user is existing, the group is added to the user. If the user is not existing, user entry is created with this group argument. If state = absent, only the group is removed from the user entry. However, to maintain backward compatibility, if the existing user belongs to only one group, and if group argument is same as the existing user's group, then the user entry also is deleted.
		# authentication: md5|sha
		# pwd: # Authentication password when using md5 or sha. This is not idempotent
		# privacy: # Privacy password for the user. This is not idempotent
		# encrypt: # Enables AES-128 bit encryption when using privacy password.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vxlan_vtep_vni "Creates a Virtual Network Identifier member (VNI)" b
- name: $1
	nxos_vxlan_vtep_vni:
		interface: ${2:# Interface name for the VXLAN Network Virtualization Endpoint.}
		vni: ${3:# ID of the Virtual Network Identifier.}
		# assoc_vrf: # This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.
		# ingress_replication: bgp|static|default
		# multicast_group: # The multicast group (range) of the VNI. Valid values are string and keyword 'default'.
		# peer_list: # Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.
		# suppress_arp: # Suppress arp under layer 2 VNI.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_smu "Perform SMUs on Cisco NX-OS devices." b
- name: $1
	nxos_smu:
		pkg: ${2:# Name of the remote package.}
		# file_system: # The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_udld_interface "Manages UDLD interface configuration params." b
- name: $1
	nxos_udld_interface:
		mode: ${2:enabled|disabled|aggressive}
		interface: ${3:# FULL name of the interface, i.e. Ethernet1/1-}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_location "Manages SNMP location information." b
- name: $1
	nxos_snmp_location:
		location: ${2:# Location information.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ping "Tests reachability using ping from Nexus switch." b
- name: $1
	nxos_ping:
		dest: ${2:# IP address or hostname (resolvable by switch) of remote node.}
		# count: 5
		# source: # Source IP Address or hostname (resolvable by switch)
		# vrf: # Outgoing VRF.
		# state: absent|#present
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_config "Manage Cisco NXOS configuration sections" b
- name: $1
	nxos_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
		# replace_src: # The I(replace_src) argument provides path to the configuration file to load into the remote system. This argument is used to replace the entire config with a flat-file. This is used with argument I(replace) with value I(config). This is mutually exclusive with the I(lines) and I(src) arguments. This argument is supported on Nexus 9K device. Use I(nxos_file_copy) module to copy the flat file to remote device and then use the path with this argument.
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block|config
		# force: no
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# defaults: no
		# save: no
		# save_when: always|#never|modified|changed
		# diff_against: #startup|intended|running
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_linkagg "Manage link aggregation groups on Cisco NXOS devices." b
- name: $1
	nxos_linkagg:
		group: ${2:# Channel-group number for the port-channel Link aggregation group.}
		# mode: active|#on|passive
		# min_links: # Minimum number of ports required up before bringing up the link aggregation group.
		# members: # List of interfaces that will be managed in the link aggregation group.
		# force: no
		# aggregate: # L
		# state: #present|absent
		# purge: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vrf "Manages global VRF configuration." b
- name: $1
	nxos_vrf:
		name: ${2:# Name of VRF to be managed.}
		# admin_state: #up|down
		# vni: # Specify virtual network identifier. Valid values are Integer or keyword 'default'.
		# rd: # VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.
		# interfaces: # List of interfaces to check the VRF has been configured correctly or keyword 'default'.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# aggregate: # L
		# purge: no
		# state: #present|absent
		# description: # Description of the VRF or keyword 'default'.
		# delay: 10
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_nxapi "Manage NXAPI configuration on an NXOS device." b
- name: $1
	nxos_nxapi:
		# http_port: 80
		# http: yes
		# https_port: 443
		# https: no
		# sandbox: no
		# state: #present|absent
		# ssl_strong_ciphers: no
		# tlsv1_0: yes
		# tlsv1_1: no
		# tlsv1_2: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vrf_interface "Manages interface specific VRF configuration." b
- name: $1
	nxos_vrf_interface:
		vrf: ${2:# Name of VRF to be managed.}
		interface: ${3:# Full name of interface to be managed, i.e. Ethernet1/1.}
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp_options "Manages NTP options." b
- name: $1
	nxos_ntp_options:
		# master: # Sets whether the device is an authoritative NTP server.
		# stratum: # If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.
		# logging: # Sets whether NTP logging is enabled on the device.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_bgp "Manages BGP configuration." b
- name: $1
	nxos_bgp:
		asn: ${2:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
		# vrf: # Name of the VRF. The name 'default' is a valid VRF representing the global BGP.
		# bestpath_always_compare_med: # Enable/Disable MED comparison on paths from different autonomous systems.
		# bestpath_aspath_multipath_relax: # Enable/Disable load sharing across the providers with different (but equal-length) AS paths.
		# bestpath_compare_routerid: # Enable/Disable comparison of router IDs for identical eBGP paths.
		# bestpath_compare_neighborid: # Enable/Disable neighborid. Use this when more paths available than max path config.
		# bestpath_cost_community_ignore: # Enable/Disable Ignores the cost community for BGP best-path calculations.
		# bestpath_med_confed: # Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.
		# bestpath_med_missing_as_worst: # Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.
		# bestpath_med_non_deterministic: # Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.
		# cluster_id: # Route Reflector Cluster-ID.
		# confederation_id: # Routing domain confederation AS.
		# confederation_peers: # AS confederation parameters.
		# disable_policy_batching: # Enable/Disable the batching evaluation of prefix advertisement to all peers.
		# disable_policy_batching_ipv4_prefix_list: # Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
		# disable_policy_batching_ipv6_prefix_list: # Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
		# enforce_first_as: # Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX-OS, this property is only supported in the global BGP context.
		# event_history_cli: size_small|size_medium|size_large|size_disable|default
		# event_history_detail: size_small|size_medium|size_large|size_disable|default
		# event_history_events: size_small|size_medium|size_large|size_disable|default
		# event_history_periodic: size_small|size_medium|size_large|size_disable|default
		# fast_external_fallover: # Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down.  Only supported in the global BGP context.
		# flush_routes: # Enable/Disable flush routes in RIB upon controlled restart. On NX-OS, this property is only supported in the global BGP context.
		# graceful_restart: # Enable/Disable graceful restart.
		# graceful_restart_helper: # Enable/Disable graceful restart helper mode.
		# graceful_restart_timers_restart: # Set maximum time for a restart sent to the BGP peer.
		# graceful_restart_timers_stalepath_time: # Set maximum time that BGP keeps the stale routes from the restarting BGP peer.
		# isolate: # Enable/Disable isolate this router from BGP perspective.
		# local_as: # Local AS number to be used within a VRF instance.
		# log_neighbor_changes: # Enable/Disable message logging for neighbor up/down event.
		# maxas_limit: # Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.
		# neighbor_down_fib_accelerate: # Enable/Disable handle BGP neighbor down event, due to various reasons.
		# reconnect_interval: # The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.
		# router_id: # Router Identifier (ID) of the BGP router VRF instance.
		# shutdown: # Administratively shutdown the BGP protocol.
		# suppress_fib_pending: # Enable/Disable advertise only routes programmed in hardware to peers.
		# timer_bestpath_limit: # Specify timeout for the first best path after a restart, in seconds.
		# timer_bgp_hold: # Set BGP hold timer.
		# timer_bgp_keepalive: # Set BGP keepalive timer.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_pim_interface "Manages PIM interface configuration." b
- name: $1
	nxos_pim_interface:
		interface: ${2:# Full name of the interface such as Ethernet1/33.}
		# sparse: no
		# dr_prio: # Configures priority for PIM DR election on interface.
		# hello_auth_key: # Authentication for hellos on this interface.
		# hello_interval: # Hello interval in milliseconds for this interface.
		# jp_policy_out: # Policy for join-prune messages (outbound).
		# jp_policy_in: # Policy for join-prune messages (inbound).
		# jp_type_out: prefix|routemap
		# jp_type_in: prefix|routemap
		# border: no
		# neighbor_policy: # Configures a neighbor policy for filtering adjacencies.
		# neighbor_type: prefix|routemap
		# state: #present|default
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_contact "Manages SNMP contact info." b
- name: $1
	nxos_snmp_contact:
		contact: ${2:# Contact information.}
		state: ${3:#present|absent}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_lldp "Manage LLDP configuration on Cisco NXOS network devices." b
- name: $1
	nxos_lldp:
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_evpn_global "Handles the EVPN control plane for VXLAN." b
- name: $1
	nxos_evpn_global:
		nv_overlay_evpn: ${2:# EVPN control plane.}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_ntp "Manages core NTP configuration." b
- name: $1
	nxos_ntp:
		# server: # Network address of NTP server.
		# peer: # Network address of NTP peer.
		# key_id: # Authentication key identifier to use with given NTP server or peer or keyword 'default'.
		# prefer: enabled|disabled
		# vrf_name: # Makes the device communicate with the given NTP server or peer over a specific VRF or keyword 'default'.
		# source_addr: # Local source address from which NTP messages are sent or keyword 'default'
		# source_int: # Local source interface from which NTP messages are sent. Must be fully qualified interface name or keyword 'default'
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_host "Manages SNMP host configuration." b
- name: $1
	nxos_snmp_host:
		snmp_host: ${2:# IP address of hostname of target host.}
		# version: v1|v2c|v3
		# v3: noauth|auth|priv
		# community: # Community string or v3 username.
		# udp: 162
		# snmp_type: trap|inform
		# vrf: # VRF to use to source traffic to source. If state = absent, the vrf is removed.
		# vrf_filter: # Name of VRF to filter. If state = absent, the vrf is removed from the filter.
		# src_intf: # Source interface. Must be fully qualified interface name. If state = absent, the interface is removed.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vrrp "Manages VRRP configuration on NX-OS switches." b
- name: $1
	nxos_vrrp:
		group: ${2:# VRRP group number.}
		interface: ${3:# Full name of interface that is being managed for VRRP.}
		# interval: 1
		# priority: 100
		# preempt: yes
		# vip: # VRRP virtual IP address or 'default' keyword
		# authentication: # Clear text authentication string or 'default' keyword
		# admin_state: #shutdown|no shutdown|default
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_pim_rp_address "Manages configuration of an PIM static RP address instance." b
- name: $1
	nxos_pim_rp_address:
		rp_address: ${2:# Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.}
		state: ${3:#present|absent|default}
		# group_list: # Group range for static RP. Valid values are multicast addresses.
		# prefix_list: # Prefix list policy for static RP. Valid values are prefix-list policy names.
		# route_map: # Route map policy for static RP. Valid values are route-map policy names.
		# bidir: # Group range is treated in PIM bidirectional mode.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vpc_interface "Manages interface VPC configuration" b
- name: $1
	nxos_vpc_interface:
		portchannel: ${2:# Group number of the portchannel that will be configured.}
		state: ${3:#present|absent}
		# vpc: # VPC group/id that will be configured on associated portchannel.
		# peer_link: # Set to true/false for peer link config on associated portchannel.
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_vtp_version "Manages VTP version configuration." b
- name: $1
	nxos_vtp_version:
		version: ${2:1|2}
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snapshot "Manage snapshots of the running states of selected features." b
- name: $1
	nxos_snapshot:
		action: ${2:add|compare|create|delete|delete_all}
		# snapshot_name: # Snapshot name, to be used when C(action=create) or C(action=delete).
		# description: # Snapshot description to be used when C(action=create).
		# snapshot1: # First snapshot to be used when C(action=compare).
		# snapshot2: # Second snapshot to be used when C(action=compare).
		# comparison_results_file: # Name of the file where snapshots comparison will be stored when C(action=compare).
		# compare_option: summary|ipv4routes|ipv6routes
		# section: # Used to name the show command output, to be used when C(action=add).
		# show_command: # Specify a new show command, to be used when C(action=add).
		# row_id: # Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).
		# element_key1: # Specify the tags used to distinguish among row entries, to be used when C(action=add).
		# element_key2: # Specify the tags used to distinguish among row entries, to be used when C(action=add).
		# save_snapshot_locally: no
		# path: ./
		# provider: # B(Deprecated)
$0
endsnippet

snippet nxos_snmp_community "Manages SNMP community configs." b
- name: $1
	nxos_snmp_community:
		community: ${2:# Case-sensitive community string.}
		# access: ro|rw
		# group: # Group to which the community belongs.
		# acl: # ACL name to filter snmp requests or keyword 'default'.
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet nuage_vspk "Manage Nuage VSP environments" b
- name: $1
	nuage_vspk:
		auth: ${2:# Dict with the authentication information required to connect to a Nuage VSP environment.}
		type: ${3:# The type of entity you want to work on (example Enterprise).}
		# id: # The ID of the entity you want to work on.
		# parent_id: # The ID of the parent of the entity you want to work on.
		# parent_type: # The type of parent the ID is specified for (example Enterprise).
		# state: present|absent
		# command: find|change_password|wait_for_job|get_csp_enterprise
		# match_filter: # A filter used when looking (both in I(command) and I(state) for entities, in the format the Nuage VSP API expects.
		# properties: # Properties are the key, value pairs of the different properties an entity has.
		# children: # Can be used to specify a set of child entities.
$0
endsnippet

snippet netact_cm_command "Manage network configuration data in Nokia Core and Radio networks" b
- name: $1
	netact_cm_command:
		operation: ${2:upload|provision|import|export|Provision_Mass_Modification}
		# opsName: # user specified operation name
		# DN: # S
		# WS: # S
		# MR: # S
		# planName: # Specifies a plan name.
		# typeOption: plan|actual|reference|template|siteTemplate
		# fileFormat: RAML2|CSV|XLSX
		# fileName: # Specifies a file name. Valid for Import and Export operations.
		# inputFile: # S
		# createBackupPlan: # Specifies if backup plan generation is enabled.
		# backupPlanName: # Specifies a backup plan name
		# verbose: # N
		# extra_opts: # E
$0
endsnippet

snippet nso_show "Displays data from Cisco NSO." b
- name: $1
	nso_show:
		path: ${2:# P}
		url: ${3:# N}
		username: ${4:# N}
		password: ${5:# N}
		# operational: no
		# timeout: 300
$0
endsnippet

snippet nso_config "Manage Cisco NSO configuration and service synchronization." b
- name: $1
	nso_config:
		data: ${2:# N}
		url: ${3:# N}
		username: ${4:# N}
		password: ${5:# N}
		# timeout: 300
$0
endsnippet

snippet nso_action "Executes Cisco NSO actions and verifies output." b
- name: $1
	nso_action:
		path: ${2:# P}
		url: ${3:# N}
		username: ${4:# N}
		password: ${5:# N}
		# input: # N
		# output_required: # R
		# output_invalid: # L
		# validate_strict: # I
		# timeout: 300
$0
endsnippet

snippet nso_query "Query data from Cisco NSO." b
- name: $1
	nso_query:
		xpath: ${2:# X}
		fields: ${3:# L}
		url: ${4:# N}
		username: ${5:# N}
		password: ${6:# N}
		# timeout: 300
$0
endsnippet

snippet nso_verify "Verifies Cisco NSO configuration." b
- name: $1
	nso_verify:
		data: ${2:# N}
		url: ${3:# N}
		username: ${4:# N}
		password: ${5:# N}
		# timeout: 300
$0
endsnippet

snippet sros_config "Manage Nokia SR OS device configuration" b
- name: $1
	sros_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.  The I(lines) argument only supports current context lines.  See EXAMPLES
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# force: # The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
		# backup: no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# defaults: no
		# save: no
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet sros_command "Run commands on remote devices running Nokia SR OS" b
- name: $1
	sros_command:
		commands: ${2:# List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet sros_rollback "Configure Nokia SR OS rollback" b
- name: $1
	sros_rollback:
		# rollback_location: # The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS
		# remote_max_checkpoints: # The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50
		# local_max_checkpoints: # The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50
		# rescue_location: # The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet net_lldp "Manage LLDP service configuration on network devices" b
- name: $1
	net_lldp:
		# state: #present|absent
$0
endsnippet

snippet aci_vlan_pool "Manage VLAN pools (fvns:VlanInstP)" b
- name: $1
	aci_vlan_pool:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# pool_allocation_mode: dynamic|static
		# description: # Description for the C(pool).
		# pool: # The name of the pool.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_domain_to_encap_pool "Bind Domain to Encap Pools (infra:RsVlanNs)" b
- name: $1
	aci_domain_to_encap_pool:
		pool_type: ${2:vlan|vsan|vxlan}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# domain: # Name of the domain being associated with the Encap Pool.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# pool: # The name of the pool.
		# pool_allocation_mode: dynamic|static
		# state: absent|#present|query
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant_span_src_group_to_dst_group "Bind SPAN source groups to destination groups (span:SpanLbl)" b
- name: $1
	aci_tenant_span_src_group_to_dst_group:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for Span source group to destination group binding.
		# dst_group: # The Span destination group to associate with the source group.
		# src_group: # The name of the Span source group.
		# state: absent|#present|query
		# tenant: # The name of the Tenant.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_domain_to_vlan_pool "Bind Domain to VLAN Pools (infra:RsVlanNs)" b
- name: $1
	aci_domain_to_vlan_pool:
		pool_allocation_mode: ${2:dynamic|static}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# domain: # Name of the domain being associated with the VLAN Pool.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# pool: # The name of the pool.
		# state: absent|#present|query
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_epg "Manage End Point Groups (EPG) objects (fv:AEPg)" b
- name: $1
	aci_epg:
		ap: ${2:# Name of an existing application network profile, that will contain the EPGs.}
		epg: ${3:# Name of the end point group.}
		bd: ${4:# Name of the bridge domain being associated with the EPG.}
		host: ${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${6:# The password to use for authentication.}
		private_key: ${7:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# tenant: # Name of an existing tenant.
		# priority: level1|level2|level3|unspecified
		# intra_epg_isolation: enforced|unenforced
		# description: # Description for the EPG.
		# fwd_control: none|proxy-arp
		# preferred_group: # Whether ot not the EPG is part of the Preferred Group and can communicate without contracts.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_aep_to_domain "Bind AEPs to Physical or Virtual Domains (infra:RsDomP)" b
- name: $1
	aci_aep_to_domain:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# aep: # The name of the Attachable Access Entity Profile.
		# domain: # Name of the physical or virtual domain being associated with the AEP.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# state: absent|#present|query
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_aaa_user_certificate "Manage AAA user certificates (aaa:UserCert)" b
- name: $1
	aci_aaa_user_certificate:
		aaa_user: ${2:# The name of the user to add a certificate to.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# aaa_user_type: appuser|#user
		# certificate: # The PEM format public key extracted from the X.509 certificate.
		# certificate_name: # The name of the user certificate entry in ACI.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_filter "Manages top level filter objects (vz:Filter)" b
- name: $1
	aci_filter:
		filter: ${2:# The name of the filter.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the filter.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_config_snapshot "Manage Config Snapshots (config:Snapshot, config:ExportP)" b
- name: $1
	aci_config_snapshot:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the Config Export Policy.
		# export_policy: # The name of the Export Policy to use for Config Snapshots.
		# format: json|xml
		# include_secure: # Determines if secure information should be included in the backup.
		# max_count: # Determines how many snapshots can exist for the Export Policy before the APIC starts to rollover.
		# snapshot: # The name of the snapshot to delete.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
- name: $1
	aci_interface_policy_lldp:
		lldp_policy: ${2:# The LLDP interface policy name.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the LLDP interface policy name.
		# receive_state: # Enable or disable Receive state.
		# transmit_state: # Enable or Disable Transmit state.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
- name: $1
	aci_interface_policy_port_security:
		port_security: ${2:# The name of the port security.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the contract.
		# max_end_points: # Maximum number of end points.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant_span_src_group "Manage SPAN source groups (span:SrcGrp)" b
- name: $1
	aci_tenant_span_src_group:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# admin_state: # Enable or disable the span sources.
		# description: # The description for Span source group.
		# dst_group: # The Span destination group to associate with the source group.
		# src_group: # The name of the Span source group.
		# state: absent|#present|query
		# tenant: # The name of the Tenant.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_static_binding_to_epg "Bind static paths to EPGs (fv:RsPathAtt)" b
- name: $1
	aci_static_binding_to_epg:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# tenant: # Name of an existing tenant.
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# epg: # The name of the end point group.
		# description: # Description for the static path to EPG binding.
		# encap_id: # The encapsulation ID associating the C(epg) with the interface path.
		# primary_encap_id: # Determines the primary encapsulation ID associating the C(epg) with the interface path when using micro-segmentation.
		# deploy_immediacy: immediate|lazy
		# interface_mode: 802.1p|access|native|regular|tagged|trunk|untagged
		# interface_type: fex|port_channel|#switch_port|vpc
		# pod_id: # The pod number part of the tDn.
		# leafs: # The switch ID(s) that the C(interface) belongs to.
		# interface: # The C(interface) string value part of the tDn.
		# extpaths: # The C(extpaths) integer value part of the tDn.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_contract_subject "Manage initial Contract Subjects (vz:Subj)" b
- name: $1
	aci_contract_subject:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# tenant: # The name of the tenant.
		# subject: # The contract subject name.
		# contract: # The name of the Contract.
		# reverse_filter: # Determines if the APIC should reverse the src and dst ports to allow the return traffic back, since ACI is stateless filter.
		# priority: level1|level2|level3|unspecified
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified
		# description: # Description for the contract subject.
		# consumer_match: all|at_least_one|at_most_one|none
		# provider_match: all|at_least_one|at_most_one|none
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
- name: $1
	aci_interface_policy_l2:
		l2_policy: ${2:# The name of the Layer 2 interface policy.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description of the Layer 2 interface policy.
		# qinq: core|disabled|edge
		# vepa: # Determines if Virtual Ethernet Port Aggregator is disabled or enabled.
		# vlan_scope: global|portlocal
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
- name: $1
	aci_interface_policy_l2:
		l2_policy: ${2:# The name of the Layer 2 interface policy.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description of the Layer 2 interface policy.
		# qinq: core|disabled|edge
		# vepa: # Determines if Virtual Ethernet Port Aggregator is disabled or enabled.
		# vlan_scope: global|portlocal
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_filter_entry "Manage filter entries (vz:Entry)" b
- name: $1
	aci_filter_entry:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# arp_flag: arp_reply|arp_request|unspecified
		# description: # Description for the Filter Entry.
		# dst_port: # Used to set both destination start and end ports to the same value when ip_protocol is tcp or udp.
		# dst_port_end: # Used to set the destination end port when ip_protocol is tcp or udp.
		# dst_port_start: # Used to set the destination start port when ip_protocol is tcp or udp.
		# entry: # Then name of the Filter Entry.
		# ether_type: arp|fcoe|ip|mac_security|mpls_ucast|trill|unspecified
		# filter: # T
		# icmp_msg_type: dst_unreachable|echo|echo_reply|src_quench|time_exceeded|unspecified
		# icmp6_msg_type: dst_unreachable|echo_request|echo_reply|neighbor_advertisement|neighbor_solicitation|redirect|time_exceeded|unspecified
		# ip_protocol: eigrp|egp|icmp|icmpv6|igmp|igp|l2tp|ospfigp|pim|tcp|udp|unspecified
		# state: absent|#present|query
		# stateful: # Determines the statefulness of the filter entry.
		# tenant: # The name of the tenant.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_vrf "Manage contexts or VRFs (fv:Ctx)" b
- name: $1
	aci_vrf:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# tenant: # The name of the Tenant the VRF should belong to.
		# vrf: # The name of the VRF.
		# policy_control_direction: egress|ingress
		# policy_control_preference: enforced|unenforced
		# description: # The description for the VRF.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_leaf_profile "Manage fabric interface policy leaf profiles (infra:AccPortP)" b
- name: $1
	aci_interface_policy_leaf_profile:
		leaf_interface_profile: ${2:# The name of the Fabric access policy leaf interface profile.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the Fabric access policy leaf interface profile.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_l3out "Manage Layer 3 Outside (L3Out) objects (l3ext:Out)" b
- name: $1
	aci_l3out:
		tenant: ${2:# Name of an existing tenant.}
		l3out: ${3:# Name of L3Out being created.}
		vrf: ${4:# Name of the VRF being associated with the L3Out.}
		domain: ${5:# Name of the external L3 domain being associated with the L3Out.}
		host: ${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${7:# The password to use for authentication.}
		private_key: ${8:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified
		# route_control: export|import
		# l3protocol: static|bgp|ospf|pim
		# description: # Description for the L3Out.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
- name: $1
	aci_interface_policy_fc:
		fc_policy: ${2:# The name of the Fiber Channel interface policy.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description of the Fiber Channel interface policy.
		# port_mode: f|np
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
- name: $1
	aci_interface_policy_fc:
		fc_policy: ${2:# The name of the Fiber Channel interface policy.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description of the Fiber Channel interface policy.
		# port_mode: f|np
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_switch_policy_vpc_protection_group "Manage switch policy explicit vPC protection groups (fabric:ExplicitGEp, fabric:NodePEp)." b
- name: $1
	aci_switch_policy_vpc_protection_group:
		protection_group: ${2:# The name of the Explicit vPC Protection Group.}
		protection_group_id: ${3:# The Explicit vPC Protection Group ID.}
		switch_1_id: ${4:# The ID of the first Leaf Switch for the Explicit vPC Protection Group.}
		switch_2_id: ${5:# The ID of the Second Leaf Switch for the Explicit vPC Protection Group.}
		host: ${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${7:# The password to use for authentication.}
		private_key: ${8:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# vpc_domain_policy: # The vPC domain policy to be associated with the Explicit vPC Protection Group.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant_action_rule_profile "Manage action rule profiles (rtctrl:AttrP)" b
- name: $1
	aci_tenant_action_rule_profile:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# action_rule: # The name of the action rule profile.
		# description: # The description for the action rule profile.
		# tenant: # The name of the tenant.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
- name: $1
	aci_interface_policy_mcp:
		mcp: ${2:# The name of the MCP interface.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the MCP interface.
		# admin_state: # Enable or disable admin state.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_ap "Manage top level Application Profile (AP) objects (fv:Ap)" b
- name: $1
	aci_ap:
		tenant: ${2:# The name of an existing tenant.}
		ap: ${3:# The name of the application network profile.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the AP.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant_span_dst_group "Manage SPAN destination groups (span:DestGrp)" b
- name: $1
	aci_tenant_span_dst_group:
		dst_group: ${2:# The name of the SPAN destination group.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description of the SPAN destination group.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
- name: $1
	aci_interface_policy_port_security:
		port_security: ${2:# The name of the port security.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the contract.
		# max_end_points: # Maximum number of end points.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_taboo_contract "Manage taboo contracts (vz:BrCP)" b
- name: $1
	aci_taboo_contract:
		taboo_contract: ${2:# The name of the Taboo Contract.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the Taboo Contract.
		# scope: application-profile|context|global|tenant
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_contract "Manage contract resources (vz:BrCP)" b
- name: $1
	aci_contract:
		contract: ${2:# The name of the contract.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the contract.
		# scope: application-profile|context|global|tenant
		# priority: level1|level2|level3|unspecified
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_fabric_node "Manage Fabric Node Members (fabric:NodeIdentP)" b
- name: $1
	aci_fabric_node:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# pod_id: # The pod id of the new Fabric Node Member.
		# serial: # Serial Number for the new Fabric Node Member.
		# node_id: # Node ID Number for the new Fabric Node Member.
		# switch: # Switch Name for the new Fabric Node Member.
		# description: # Description for the new Fabric Node Member.
		# role: leaf|spine|unspecified
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_ospf "Manage OSPF interface policies (ospf:IfPol)" b
- name: $1
	aci_interface_policy_ospf:
		tenant: ${2:# The name of the Tenant the OSPF interface policy should belong to.}
		ospf: ${3:# The OSPF interface policy name.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the OSPF interface.
		# network_type: bcast|p2p
		# cost: # The OSPF cost of the interface.
		# controls: advert-subnet|bfd|mtu-ignore|passive
		# dead_interval: # The interval between hello packets from a neighbor before the router declares the neighbor as down.
		# hello_interval: # The interval between hello packets that OSPF sends on the interface.
		# prefix_suppression: # Whether prefix suppressions is enabled or disabled.
		# priority: # The priority for the OSPF interface profile.
		# retransmit_interval: # The interval between LSA retransmissions.
		# transmit_delay: # The delay time needed to send an LSA update packet.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_epg_to_contract "Bind EPGs to Contracts (fv:RsCons, fv:RsProv)" b
- name: $1
	aci_epg_to_contract:
		contract_type: ${2:consumer|provider}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# contract: # The name of the contract.
		# epg: # The name of the end point group.
		# priority: level1|level2|level3|unspecified
		# provider_match: all|at_least_one|at_most_one|none
		# state: absent|#present|query
		# tenant: # Name of an existing tenant.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_encap_pool_range "Manage encap ranges assigned to pools (fvns:EncapBlk, fvns:VsanEncapBlk)" b
- name: $1
	aci_encap_pool_range:
		pool_type: ${2:vlan|vxlan|vsan}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# allocation_mode: dynamic|inherit|static
		# description: # Description for the pool range.
		# pool: # The name of the pool that the range should be assigned to.
		# pool_allocation_mode: dynamic|static
		# range_end: # The end of encap range.
		# range_name: # The name to give to the encap range.
		# range_start: # The start of the encap range.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
- name: $1
	aci_interface_policy_port_channel:
		port_channel: ${2:# Name of the port channel.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the port channel.
		# max_links: # Maximum links.
		# min_links: # Minimum links.
		# mode: active|mac-pin|mac-pin-nicload|off|passive
		# fast_select: # Determines if Fast Select is enabled for Hot Standby Ports.
		# graceful_convergence: # Determines if Graceful Convergence is enabled.
		# load_defer: # Determines if Load Defer is enabled.
		# suspend_individual: # Determines if Suspend Individual is enabled.
		# symmetric_hash: # Determines if Symmetric Hashing is enabled.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_switch_policy_leaf_profile "Manage switch policy leaf profiles (infra:NodeP)" b
- name: $1
	aci_switch_policy_leaf_profile:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# leaf_profile: # The name of the Leaf Profile.
		# description: # Description for the Leaf Profile.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_vlan_pool_encap_block "Manage encap blocks assigned to VLAN pools (fvns:EncapBlk)" b
- name: $1
	aci_vlan_pool_encap_block:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# allocation_mode: dynamic|inherit|static
		# description: # Description for the pool encap block.
		# pool: # The name of the pool that the encap block should be assigned to.
		# pool_allocation_mode: dynamic|static
		# block_end: # The end of encap block.
		# block_name: # The name to give to the encap block.
		# block_start: # The start of the encap block.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_selector_to_switch_policy_leaf_profile "Bind interface selector profiles to switch policy leaf profiles (infra:RsAccPortP)" b
- name: $1
	aci_interface_selector_to_switch_policy_leaf_profile:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# leaf_profile: # Name of the Leaf Profile to which we add a Selector.
		# interface_selector: # Name of Interface Profile Selector to be added and associated with the Leaf Profile.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_bd_subnet "Manage Subnets (fv:Subnet)" b
- name: $1
	aci_bd_subnet:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# bd: # The name of the Bridge Domain.
		# description: # The description for the Subnet.
		# enable_vip: # Determines if the Subnet should be treated as a VIP; used when the BD is extended to multiple sites.
		# gateway: # The IPv4 or IPv6 gateway address for the Subnet.
		# mask: # The subnet mask for the Subnet.
		# nd_prefix_policy: # The IPv6 Neighbor Discovery Prefix Policy to associate with the Subnet.
		# preferred: # Determines if the Subnet is preferred over all available Subnets. Only one Subnet per Address Family (IPv4/IPv6). can be preferred in the Bridge Domain.
		# route_profile: # The Route Profile to the associate with the Subnet.
		# route_profile_l3_out: # The L3 Out that contains the assocated Route Profile.
		# scope: private|public|shared
		# subnet_control: nd_ra|no_gw|querier_ip|unspecified
		# subnet_name: # The name of the Subnet.
		# tenant: # The name of the Tenant.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_encap_pool "Manage encap pools (fvns:VlanInstP, fvns:VxlanInstP, fvns:VsanInstP)" b
- name: $1
	aci_encap_pool:
		pool_type: ${2:vlan|vxlan|vsan}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the C(pool).
		# pool: # The name of the pool.
		# pool_allocation_mode: dynamic|static
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_contract_subject_to_filter "Bind Contract Subjects to Filters (vz:RsSubjFiltAtt)" b
- name: $1
	aci_contract_subject_to_filter:
		tenant: ${2:# The name of the tenant.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# contract: # The name of the contract.
		# filter: # The name of the Filter to bind to the Subject.
		# log: log|none
		# subject: # The name of the Contract Subject.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_domain "Manage physical, virtual, bridged, routed or FC domain profiles (phys:DomP, vmm:DomP, l2ext:DomP, l3ext:DomP, fc:DomP)" b
- name: $1
	aci_domain:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# domain: # Name of the physical, virtual, bridged routed or FC domain profile.
		# domain_type: fc|l2dom|l3dom|phys|vmm
		# dscp: AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified
		# encap_mode: unknown|vlan|vxlan
		# multicast_address: # The muticast IP address to use for the virtual switch.
		# state: absent|#present|query
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# vswitch: avs|default|dvs|unknown
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_access_port_to_interface_policy_leaf_profile "Manage Fabric interface policy leaf profile interface selectors (infra:HPortS, infra:RsAccBaseGrp, infra:PortBlk)" b
- name: $1
	aci_access_port_to_interface_policy_leaf_profile:
		leaf_interface_profile: ${2:# The name of the Fabric access policy leaf interface profile.}
		access_port_selector: ${3:# The name of the Fabric access policy leaf interface profile access port selector.}
		leaf_port_blk: ${4:# The name of the Fabric access policy leaf interface profile access port block.}
		from_port: ${5:# The beginning (from-range) of the port range block for the leaf access port block.}
		to_port: ${6:# The end (to-range) of the port range block for the leaf access port block.}
		host: ${7:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${8:# The password to use for authentication.}
		private_key: ${9:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description to assign to the C(access_port_selector)
		# leaf_port_blk_description: # The description to assign to the C(leaf_port_blk)
		# from_card: # The beginning (from-range) of the card range block for the leaf access port block.
		# to_card: # The end (to-range) of the card range block for the leaf access port block.
		# policy_group: # The name of the fabric access policy group to be associated with the leaf interface profile interface selector.
		# interface_type: fex|port_channel|#switch_port|vpc
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_config_rollback "Provides rollback and rollback preview functionality (config:ImportP)" b
- name: $1
	aci_config_rollback:
		export_policy: ${2:# The export policy that the C(snapshot) is associated to.}
		snapshot: ${3:# The name of the snapshot to rollback to, or the base snapshot to use for comparison.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# compare_export_policy: # The export policy that the C(compare_snapshot) is associated to.
		# compare_snapshot: # The name of the snapshot to compare with C(snapshot).
		# description: # The description for the Import Policy.
		# fail_on_decrypt: # Determines if the APIC should fail the rollback if unable to decrypt secured data.
		# import_mode: atomic|best-effort
		# import_policy: # The name of the Import Policy to use for config rollback.
		# import_type: merge|replace
		# state: preview|#rollback
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant_ep_retention_policy "Manage End Point (EP) retention protocol policies (fv:EpRetPol)" b
- name: $1
	aci_tenant_ep_retention_policy:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# tenant: # The name of an existing tenant.
		# epr_policy: # The name of the end point retention policy.
		# bounce_age: # Bounce entry aging interval in seconds.
		# bounce_trigger: coop|flood
		# hold_interval: # Hold interval in seconds.
		# local_ep_interval: # Local end point aging interval in seconds.
		# remote_ep_interval: # Remote end point aging interval in seconds.
		# move_frequency: # Move frequency per second.
		# description: # Description for the End point rentention policy.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_bd_to_l3out "Bind Bridge Domain to L3 Out (fv:RsBDToOut)" b
- name: $1
	aci_bd_to_l3out:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# bd: # The name of the Bridge Domain.
		# l3out: # The name of the l3out to associate with th Bridge Domain.
		# tenant: # The name of the Tenant.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_rest "Direct access to the Cisco APIC REST API" b
- name: $1
	aci_rest:
		path: ${2:# URI being used to execute API calls.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# method: delete|#get|post
		# content: # When used instead of C(src), sets the payload of the API request directly.
		# src: # Name of the absolute path of the filname that includes the body of the HTTP request being sent to the ACI fabric.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_tenant "Manage tenants (fv:Tenant)" b
- name: $1
	aci_tenant:
		tenant: ${2:# The name of the tenant.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the tenant.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_leaf_policy_group "Manage fabric interface policy leaf policy groups (infra:AccBndlGrp, infra:AccPortGrp)" b
- name: $1
	aci_interface_policy_leaf_policy_group:
		lag_type: ${2:leaf|link|node}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# policy_group: # Name of the leaf policy group to be added/deleted.
		# description: # Description for the leaf policy group to be created.
		# link_level_policy: # Choice of link_level_policy to be used as part of the leaf policy group to be created.
		# cdp_policy: # Choice of cdp_policy to be used as part of the leaf policy group to be created.
		# mcp_policy: # Choice of mcp_policy to be used as part of the leaf policy group to be created.
		# lldp_policy: # Choice of lldp_policy to be used as part of the leaf policy group to be created.
		# stp_interface_policy: # Choice of stp_interface_policy to be used as part of the leaf policy group to be created.
		# egress_data_plane_policing_policy: # Choice of egress_data_plane_policing_policy to be used as part of the leaf policy group to be created.
		# ingress_data_plane_policing_policy: # Choice of ingress_data_plane_policing_policy to be used as part of the leaf policy group to be created.
		# priority_flow_control_policy: # Choice of priority_flow_control_policy to be used as part of the leaf policy group to be created.
		# fibre_channel_interface_policy: # Choice of fibre_channel_interface_policy to be used as part of the leaf policy group to be created.
		# slow_drain_policy: # Choice of slow_drain_policy to be used as part of the leaf policy group to be created.
		# port_channel_policy: # Choice of port_channel_policy to be used as part of the leaf policy group to be created.
		# monitoring_policy: # Choice of monitoring_policy to be used as part of the leaf policy group to be created.
		# storm_control_interface_policy: # Choice of storm_control_interface_policy to be used as part of the leaf policy group to be created.
		# l2_interface_policy: # Choice of l2_interface_policy to be used as part of the leaf policy group to be created.
		# port_security_policy: # Choice of port_security_policy to be used as part of the leaf policy group to be created.
		# aep: # Choice of attached_entity_profile (AEP) to be used as part of the leaf policy group to be created.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_aaa_user "Manage AAA users (aaa:User)" b
- name: $1
	aci_aaa_user:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# aaa_password: # The password of the locally-authenticated user.
		# aaa_password_lifetime: # The lifetime of the locally-authenticated user password.
		# aaa_password_update_required: # Whether this account needs password update.
		# aaa_user: # The name of the locally-authenticated user user to add.
		# clear_password_history: # Whether to clear the password history of a locally-authenticated user.
		# description: # Description for the AAA user.
		# email: # The email address of the locally-authenticated user.
		# enabled: # The status of the locally-authenticated user account.
		# expiration: # The expiration date of the locally-authenticated user account.
		# expires: # Whether to enable an expiration date for the locally-authenticated user account.
		# first_name: # The first name of the locally-authenticated user.
		# last_name: # The last name of the locally-authenticated user.
		# phone: # The phone number of the locally-authenticated user.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_aep "Manage attachable Access Entity Profile (AEP) objects (infra:AttEntityP, infra:ProvAcc)" b
- name: $1
	aci_aep:
		aep: ${2:# The name of the Attachable Access Entity Profile.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the AEP.
		# infra_vlan: no
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_epg_monitoring_policy "Manage monitoring policies (mon:EPGPol)" b
- name: $1
	aci_epg_monitoring_policy:
		monitoring_policy: ${2:# The name of the monitoring policy.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # Description for the monitoring policy.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
- name: $1
	aci_interface_policy_port_channel:
		port_channel: ${2:# Name of the port channel.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the port channel.
		# max_links: # Maximum links.
		# min_links: # Minimum links.
		# mode: active|mac-pin|mac-pin-nicload|off|passive
		# fast_select: # Determines if Fast Select is enabled for Hot Standby Ports.
		# graceful_convergence: # Determines if Graceful Convergence is enabled.
		# load_defer: # Determines if Load Defer is enabled.
		# suspend_individual: # Determines if Suspend Individual is enabled.
		# symmetric_hash: # Determines if Symmetric Hashing is enabled.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_l3out_route_tag_policy "Manage route tag policies (l3ext:RouteTagPol)" b
- name: $1
	aci_l3out_route_tag_policy:
		rtp: ${2:# The name of the route tag policy.}
		tenant: ${3:# The name of the tenant.}
		host: ${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${5:# The password to use for authentication.}
		private_key: ${6:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the route tag policy.
		# tag: # The value of the route tag.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_epg_to_domain "Bind EPGs to Domains (fv:RsDomAtt)" b
- name: $1
	aci_epg_to_domain:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# allow_useg: encap|useg
		# ap: # Name of an existing application network profile, that will contain the EPGs.
		# deploy_immediacy: immediate|lazy
		# domain: # Name of the physical or virtual domain being associated with the EPG.
		# domain_type: phys|vmm
		# encap: # The VLAN encapsulation for the EPG when binding a VMM Domain with static encap_mode.
		# encap_mode: auto|vlan|vxlan
		# epg: # Name of the end point group.
		# netflow: # Determines if netflow should be enabled.
		# primary_encap: # Determines the primary VLAN ID when using useg.
		# resolution_immediacy: immediate|lazy|pre-provision
		# state: absent|#present|query
		# tenant: # Name of an existing tenant.
		# vm_provider: cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_bd "Manage Bridge Domains (BD) objects (fv:BD)" b
- name: $1
	aci_bd:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# arp_flooding: # Determines if the Bridge Domain should flood ARP traffic.
		# bd: # The name of the Bridge Domain.
		# bd_type: ethernet|fc
		# description: # Description for the Bridge Domain.
		# enable_multicast: # Determines if PIM is enabled.
		# enable_routing: # Determines if IP forwarding should be allowed.
		# endpoint_clear: # Clears all End Points in all Leaves when C(yes).
		# endpoint_move_detect: default|garp
		# endpoint_retention_action: inherit|resolve
		# endpoint_retention_policy: # The name of the End Point Retention Policy the Bridge Domain should use when overriding the default End Point Retention Policy.
		# igmp_snoop_policy: # The name of the IGMP Snooping Policy the Bridge Domain should use when overriding the default IGMP Snooping Policy.
		# ip_learning: # Determines if the Bridge Domain should learn End Point IPs.
		# ipv6_nd_policy: # The name of the IPv6 Neighbor Discovery Policy the Bridge Domain should use when overridding the default IPV6 ND Policy.
		# l2_unknown_unicast: proxy|flood
		# l3_unknown_multicast: flood|opt-flood
		# limit_ip_learn: # Determines if the BD should limit IP learning to only subnets owned by the Bridge Domain.
		# mac_address: # The MAC Address to assign to the C(bd) instead of using the default.
		# multi_dest: bd-flood|drop|encap-flood
		# state: absent|#present|query
		# tenant: # The name of the Tenant.
		# vrf: # The name of the VRF.
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
- name: $1
	aci_interface_policy_lldp:
		lldp_policy: ${2:# The LLDP interface policy name.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the LLDP interface policy name.
		# receive_state: # Enable or disable Receive state.
		# transmit_state: # Enable or Disable Transmit state.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
- name: $1
	aci_interface_policy_mcp:
		mcp: ${2:# The name of the MCP interface.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description for the MCP interface.
		# admin_state: # Enable or disable admin state.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_firmware_source "Manage firmware image sources (firmware:OSource)" b
- name: $1
	aci_firmware_source:
		source: ${2:# The identifying name for the outside source of images, such as an HTTP or SCP server.}
		host: ${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${4:# The password to use for authentication.}
		private_key: ${5:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# polling_interval: # Polling interval in minutes.
		# url_protocol: http|local|#scp|usbkey
		# url: # T
		# url_password: # T
		# url_username: # T
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet aci_switch_leaf_selector "Bind leaf selectors to switch policy leaf profiles (infra:LeafS, infra:NodeBlk, infra:RsAccNodePGrep)" b
- name: $1
	aci_switch_leaf_selector:
		host: ${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
		password: ${3:# The password to use for authentication.}
		private_key: ${4:# PEM formatted file that contains your private key to be used for signature-based authentication.}
		# description: # The description to assign to the C(leaf).
		# leaf_profile: # Name of the Leaf Profile to which we add a Selector.
		# leaf: # Name of Leaf Selector.
		# leaf_node_blk: # Name of Node Block range to be added to Leaf Selector of given Leaf Profile.
		# leaf_node_blk_description: # The description to assign to the C(leaf_node_blk)
		# from: # Start of Node Block range.
		# to: # Start of Node Block range.
		# policy_group: # Name of the Policy Group to be added to Leaf Selector of given Leaf Profile.
		# state: absent|#present|query
		# port: # Port number to be used for REST connection.
		# username: admin
		# certificate_name: # The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.
		# output_level: debug|info|#normal
		# timeout: 30
		# use_proxy: yes
		# use_ssl: yes
		# validate_certs: yes
$0
endsnippet

snippet cli_config "Push text based configuration to network devices over network_cli" b
- name: $1
	cli_config:
		# config: # The config to be pushed to the network device. This argument is mutually exclusive with C(rollback) and either one of the option should be given as input. The config should have indentation that the device uses.
		# commit: # The C(commit) argument instructs the module to push the configuration to the device. This is mapped to module check mode.
		# replace: # If the C(replace) argument is set to C(yes), it will replace the entire running-config of the device with the C(config) argument value. For NXOS devices, C(replace) argument takes path to the file on the device that will be used for replacing the entire running-config. Nexus 9K devices only support replace. Use I(net_put) or I(nxos_file_copy) module to copy the flat file to remote device and then use set the fullpath to this argument.
		# rollback: # The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail. To rollback to the most recent commit, set the C(rollback) argument to 0. This option is mutually exclusive with C(config).
		# commit_comment: # The C(commit_comment) argument specifies a text string to be used when committing the configuration. If the C(commit) argument is set to False, this argument is silently ignored. This argument is only valid for the platforms that support commit operation with comment.
		# defaults: no
		# multiline_delimiter: # This argument is used when pushing a multiline configuration element to the device. It specifies the character to use as the delimiting character. This only applies to the configuration action.
		# diff_replace: line|block|config
		# diff_match: line|strict|exact|none
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches. Note that this parameter will be ignored if the platform has onbox diff support.
$0
endsnippet

snippet cli_command "Run a cli command on cli-based network devices" b
- name: $1
	cli_command:
		command: ${2:# The command to send to the remote network device.  The resulting output from the command is returned, unless I(sendonly) is set.}
		# prompt: # A single regex pattern or a sequence of patterns to evaluate the expected prompt from I(command).
		# answer: # The answer to reply with if I(prompt) is matched. The value can be a single answer or a list of answer for multiple prompts. In case the command execution results in multiple prompts the sequence of the prompt and excepted answer should be in same order.
		# sendonly: no
		# check_all: no
$0
endsnippet

snippet ios_system "Manage the system attributes on Cisco IOS devices" b
- name: $1
	ios_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# lookup_enabled: # Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_logging "Manage logging on network devices" b
- name: $1
	ios_logging:
		# dest: on|host|console|monitor|buffered
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# size: 4096
		# facility: # Set logging facility.
		# level: # Set logging severity levels.
		# aggregate: # L
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_l2_interface "Manage Layer-2 interface on Cisco IOS devices." b
- name: $1
	ios_l2_interface:
		name: ${2:# Full name of the interface excluding any logical unit number, i.e. GigabitEthernet0/1.}
		# mode: #access|trunk
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# trunk_vlans: # List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
		# aggregate: # List of Layer-2 interface definitions.
		# state: #present|absent|unconfigured
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_command "Run commands on remote devices running Cisco IOS" b
- name: $1
	ios_command:
		commands: ${2:# List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_vrf "Manage the collection of VRF definitions on Cisco IOS devices" b
- name: $1
	ios_vrf:
		# vrfs: # The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
		# name: # The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument
		# description: # Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
		# rd: # The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# delay: 10
		# purge: no
		# state: #present|absent
		# route_both: # Adds an export and import list of extended route target communities to the VRF.
		# route_export: # Adds an export list of extended route target communities to the VRF.
		# route_import: # Adds an import list of extended route target communities to the VRF.
		# route_both_ipv4: # Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.
		# route_export_ipv4: # Adds an export list of extended route target communities in address-family configuration submode to the VRF.
		# route_import_ipv4: # Adds an import list of extended route target communities in address-family configuration submode to the VRF.
		# route_both_ipv6: # Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.
		# route_export_ipv6: # Adds an export list of extended route target communities in address-family configuration submode to the VRF.
		# route_import_ipv6: # Adds an import list of extended route target communities in address-family configuration submode to the VRF.
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_ping "Tests reachability using ping from Cisco IOS network devices" b
- name: $1
	ios_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# count: 5
		# source: # The source IP Address.
		# state: absent|#present
		# vrf: default
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_config "Manage Cisco IOS configuration sections" b
- name: $1
	ios_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# multiline_delimiter: @
		# force: no
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# defaults: no
		# save: no
		# save_when: always|#never|modified|changed
		# diff_against: running|startup|intended
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_l3_interface "Manage Layer-3 interfaces on Cisco IOS network devices." b
- name: $1
	ios_l3_interface:
		# name: # Name of the Layer-3 interface to be configured eg. GigabitEthernet0/2
		# ipv4: # IPv4 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
		# ipv6: # IPv6 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
		# aggregate: # List of Layer-3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_static_route "Manage static IP routes on Cisco IOS network devices" b
- name: $1
	ios_static_route:
		# prefix: # Network prefix of the static route.
		# mask: # Network prefix mask of the static route.
		# next_hop: # Next hop IP of the static route.
		# admin_distance: # Admin distance of the static route.
		# aggregate: # L
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_lldp "Manage LLDP configuration on Cisco IOS network devices." b
- name: $1
	ios_lldp:
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_user "Manage the aggregate of local users on Cisco IOS device" b
- name: $1
	ios_user:
		# aggregate: # The set of username objects to be configured on the remote Cisco IOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the Cisco IOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# configured_password: # The password to be configured on the Cisco IOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.
		# view: # Configures the view for the username in the device running configuration. The argument accepts a string value defining the view name. This argument does not check if the view has been configured on the device.
		# sshkey: # Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.
		# nopassword: # Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.
		# purge: no
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_facts "Collect facts from remote devices running Cisco IOS" b
- name: $1
	ios_facts:
		# gather_subset: !config
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_linkagg "Manage link aggregation groups on Cisco IOS network devices" b
- name: $1
	ios_linkagg:
		# group: # Channel-group number for the port-channel Link aggregation group. Range 1-255.
		# mode: active|on|passive|auto|desirable
		# members: # List of members of the link aggregation group.
		# aggregate: # L
		# state: #present|absent
		# purge: no
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_interface "Manage Interface on Cisco IOS network devices" b
- name: $1
	ios_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: # Interface link status.
		# speed: # Interface link speed.
		# mtu: # Maximum size of transmit packet.
		# duplex: full|half|#auto
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# neighbors: # Check the operational state of given interface C(name) for CDP/LLDP neighbor.
		# aggregate: # L
		# delay: 10
		# state: #present|absent|up|down
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_vlan "Manage VLANs on IOS network devices" b
- name: $1
	ios_vlan:
		vlan_id: ${2:# ID of the VLAN. Range 1-4094.}
		interfaces: ${3:# List of interfaces that should be associated to the VLAN.}
		# name: # Name of the VLAN.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# delay: 10
		# aggregate: # L
		# purge: no
		# state: #present|absent|active|suspend
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet ios_banner "Manage multiline banners on Cisco IOS devices" b
- name: $1
	ios_banner:
		banner: ${2:login|motd|exec|incoming|slip-ppp}
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet cv_server_provision "Provision server port by applying or removing template configuration to an Arista CloudVision Portal configlet that is applied to a switch." b
- name: $1
	cv_server_provision:
		host: ${2:# The hostname or IP address of the CVP node being connected to.}
		username: ${3:# The user that will be used to connect to CVP for making API calls.}
		password: ${4:# The password of the user that will be used to connect to CVP for API calls.}
		server_name: ${5:# The hostname or identifier for the server that is having it's switch port provisioned.}
		switch_name: ${6:# The hostname of the switch is being configured for the server being provisioned.}
		switch_port: ${7:# The physical port number on the switch that the new server is connected to.}
		template: ${8:# A path to a Jinja formatted template file that contains the configuration block that will be applied to the specified switch port. This template will have variable fields replaced by the module before being applied to the switch configuration.}
		# port: # The port number to use when making API calls to the CVP node. This will default to the default port for the specified protocol. Port 80 for http and port 443 for https.
		# protocol: #https|http
		# port_vlan: # The vlan that should be applied to the port for this server. This parameter is dependent on a proper template that supports single vlan provisioning with it. If a port vlan is specified by the template specified does not support this the module will exit out with no changes. If a template is specified that requires a port vlan but no port vlan is specified the module will exit out with no changes.
		# action: #show|add|remove
		# auto_run: no
$0
endsnippet

snippet vdirect_commit "Commits pending configuration changes on Radware devices" b
- name: $1
	vdirect_commit:
		vdirect_ip: ${2:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
		vdirect_user: ${3:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
		vdirect_password: ${4:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
		devices: ${5:# List of Radware Alteon device names for commit operations.}
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
		# vdirect_wait: yes
		# vdirect_https_port: 2189
		# vdirect_http_port: 2188
		# vdirect_timeout: 60
		# vdirect_use_ssl: yes
		# vdirect_validate_certs: yes
		# apply: yes
		# save: yes
		# sync: yes
$0
endsnippet

snippet vdirect_file "Uploads a new or updates an existing runnable file into Radware vDirect server" b
- name: $1
	vdirect_file:
		vdirect_ip: ${2:# Primary vDirect server IP address, may be set as VDIRECT_IP environment variable.}
		vdirect_user: ${3:# vDirect server username, may be set as VDIRECT_USER environment variable.}
		vdirect_password: ${4:# vDirect server password, may be set as VDIRECT_PASSWORD environment variable.}
		file_name: ${5:# vDirect runnable file name to be uploaded.}
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as VDIRECT_SECONDARY_IP environment variable.
		# vdirect_wait: yes
		# vdirect_https_port: 2189
		# vdirect_http_port: 2188
		# vdirect_timeout: 60
		# vdirect_use_ssl: yes
		# vdirect_validate_certs: yes
$0
endsnippet

snippet vdirect_runnable "Runs templates and workflow actions in Radware vDirect server" b
- name: $1
	vdirect_runnable:
		vdirect_ip: ${2:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
		vdirect_user: ${3:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
		vdirect_password: ${4:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
		runnable_type: ${5:ConfigurationTemplate|Workflow|WorkflowTemplate}
		runnable_name: ${6:# vDirect runnable name to run.}
		# vdirect_secondary_ip: # Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
		# vdirect_wait: yes
		# vdirect_https_port: 2189
		# vdirect_http_port: 2188
		# vdirect_timeout: 60
		# vdirect_use_ssl: yes
		# vdirect_validate_certs: yes
		# action_name: # Workflow action name to run.
		# parameters: # Action parameters dictionary. In case of C(ConfigurationTemplate) runnable type,
$0
endsnippet

snippet onyx_l2_interface "Manage Layer-2 interface on Mellanox ONYX network devices" b
- name: $1
	onyx_l2_interface:
		# name: # Name of the interface.
		# aggregate: # List of Layer-2 interface definitions.
		# mode: #access|trunk|hybrid
		# access_vlan: # Configure given VLAN in access port.
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port.
		# state: #present|absent
$0
endsnippet

snippet onyx_mlag_vip "Configures MLAG VIP on Mellanox ONYX network devices" b
- name: $1
	onyx_mlag_vip:
		# ipaddress: # Virtual IP address of the MLAG. Required if I(state=present).
		# group_name: # MLAG group name. Required if I(state=present).
		# mac_address: # MLAG system MAC address. Required if I(state=present).
		# state: present|absent
		# delay: 12
$0
endsnippet

snippet onyx_ospf "Manage OSPF protocol on Mellanox ONYX network devices" b
- name: $1
	onyx_ospf:
		ospf: ${2:# OSPF instance number 1-65535}
		# router_id: # OSPF router ID. Required if I(state=present).
		# interfaces: # List of interfaces and areas. Required if I(state=present).
		# state: #present|absent
$0
endsnippet

snippet onyx_linkagg "Manage link aggregation groups on Mellanox ONYX network devices" b
- name: $1
	onyx_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# mode: on|active|passive
		# aggregate: # L
		# purge: no
		# state: #present|absent|up|down
$0
endsnippet

snippet onyx_l3_interface "Manage L3 interfaces on Mellanox ONYX network devices" b
- name: $1
	onyx_l3_interface:
		# name: # Name of the L3 interface.
		# ipv4: # IPv4 of the L3 interface.
		# ipv6: # IPv6 of the L3 interface (not supported for now).
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet onyx_magp "Manage MAGP protocol on Mellanox ONYX network devices" b
- name: $1
	onyx_magp:
		magp_id: ${2:# MAGP instance number 1-255}
		interface: ${3:# VLAN Interface name.}
		# state: #present|absent|enabled|disabled
		# router_ip: # MAGP router IP address.
		# router_mac: # MAGP router MAC address.
$0
endsnippet

snippet onyx_protocol "Enables/Disables protocols on Mellanox ONYX network devices" b
- name: $1
	onyx_protocol:
		# mlag: enabled|disabled
		# magp: enabled|disabled
		# spanning_tree: enabled|disabled
		# dcb_pfc: enabled|disabled
		# igmp_snooping: enabled|disabled
		# lacp: enabled|disabled
		# ip_l3: enabled|disabled
		# ip_routing: enabled|disabled
		# lldp: enabled|disabled
		# bgp: enabled|disabled
		# ospf: enabled|disabled
$0
endsnippet

snippet onyx_lldp "Manage LLDP configuration on Mellanox ONYX network devices" b
- name: $1
	onyx_lldp:
		# state: #present|absent
$0
endsnippet

snippet onyx_igmp "Configures IGMP globl parameters" b
- name: $1
	onyx_igmp:
		state: ${2:enabled|disabled}
		# last_member_query_interval: # Configure the last member query interval, range 1-25
		# mrouter_timeout: # Configure the mrouter timeout, range 60-600
		# port_purge_timeout: # Configure the host port purge timeout, range 130-1225
		# proxy_reporting: enabled|disabled
		# report_suppression_interval: # Configure the report suppression interval, range 1-25
		# unregistered_multicast: flood|forward-to-mrouter-ports
		# default_version: V2|V3
$0
endsnippet

snippet onyx_bgp "Configures BGP on Mellanox ONYX network devices" b
- name: $1
	onyx_bgp:
		as_number: ${2:# Local AS number.}
		# router_id: # Router IP address. Required if I(state=present).
		# neighbors: # List of neighbors. Required if I(state=present).
		# networks: # List of advertised networks.
		# state: #present|absent
$0
endsnippet

snippet onyx_config "Manage Mellanox ONYX configuration sections" b
- name: $1
	onyx_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# backup: no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# save: no
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet onyx_mlag_ipl "Manage IPL (inter-peer link) on Mellanox ONYX network devices" b
- name: $1
	onyx_mlag_ipl:
		name: ${2:# Name of the interface (port-channel) IPL should be configured on.}
		# vlan_interface: # Name of the IPL vlan interface.
		# state: #present|absent
		# peer_address: # IPL peer IP address.
$0
endsnippet

snippet onyx_pfc_interface "Manage priority flow control on ONYX network devices" b
- name: $1
	onyx_pfc_interface:
		# name: # Name of the interface PFC should be configured on.
		# aggregate: # L
		# purge: no
		# state: #enabled|disabled
$0
endsnippet

snippet onyx_lldp_interface "Manage LLDP interfaces configuration on Mellanox ONYX network devices" b
- name: $1
	onyx_lldp_interface:
		# name: # Name of the interface LLDP should be configured on.
		# aggregate: # L
		# purge: no
		# state: #present|absent|enabled|disabled
$0
endsnippet

snippet onyx_facts "Collect facts from Mellanox ONYX network devices" b
- name: $1
	onyx_facts:
		# gather_subset: version
$0
endsnippet

snippet onyx_command "Run commands on remote devices running Mellanox ONYX" b
- name: $1
	onyx_command:
		commands: ${2:# List of commands to send to the remote Mellanox ONYX network device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet onyx_interface "Manage Interfaces on Mellanox ONYX network devices" b
- name: $1
	onyx_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: # Interface link status.
		# speed: 1G|10G|25G|40G|50G|56G|100G
		# mtu: # Maximum size of transmit packet.
		# aggregate: # L
		# duplex: full|half|#auto
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# delay: 10
		# purge: no
		# state: #present|absent|up|down
$0
endsnippet

snippet onyx_vlan "Manage VLANs on Mellanox ONYX network devices" b
- name: $1
	onyx_vlan:
		# name: # Name of the VLAN.
		# vlan_id: # ID of the VLAN.
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet net_banner "Manage multiline banners on network devices" b
- name: $1
	net_banner:
		banner: ${2:login|motd}
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
$0
endsnippet

snippet net_logging "Manage logging on network devices" b
- name: $1
	net_logging:
		# dest: console|host
		# name: # If value of C(dest) is I(host) it indicates file-name the host name to be notified.
		# facility: # Set logging facility.
		# level: # Set logging severity levels.
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet net_user "Manage the aggregate of local users on network device" b
- name: $1
	net_user:
		# aggregate: # The set of username objects to be configured on the remote network device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the remote network device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# configured_password: # The password to be configured on the remote network device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.
		# role: # Configures the role for the username in the device running configuration. The argument accepts a string value defining the role name. This argument does not check if the role has been configured on the device.
		# sshkey: # Specifies the SSH public key to configure for the given username. This argument accepts a valid SSH key value.
		# nopassword: # Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet net_ping "Tests reachability using ping from a network device" b
- name: $1
	net_ping:
		dest: ${2:# The IP Address or hostname (resolvable by switch) of the remote node.}
		# count: 5
		# source: # The source IP Address.
		# state: absent|#present
		# vrf: default
$0
endsnippet

snippet net_system "Manage the system attributes on network devices" b
- name: $1
	net_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# state: #present|absent
$0
endsnippet

snippet vyos_command "Run one or more commands on VyOS devices" b
- name: $1
	vyos_command:
		commands: ${2:# The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_config "Manage VyOS configuration on remote device" b
- name: $1
	vyos_config:
		# lines: # The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
		# src: # The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.
		# match: #line|none
		# backup: no
		# comment: configured by vyos_config
		# config: # The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
		# save: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_system "Run `set system` commands on VyOS devices" b
- name: $1
	vyos_system:
		# host_name: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # The new domain name to apply to the device.
		# name_servers: # A list of name servers to use with the device. Mutually exclusive with I(domain_search)
		# domain_search: # A list of domain names to search. Mutually exclusive with I(name_server)
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_logging "Manage logging on network devices" b
- name: $1
	vyos_logging:
		# dest: console|file|global|host|user
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# facility: # Set logging facility.
		# level: # Set logging severity levels.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_lldp_interface "Manage LLDP interfaces configuration on VyOS network devices" b
- name: $1
	vyos_lldp_interface:
		# name: # Name of the interface LLDP should be configured on.
		# aggregate: # L
		# state: #present|absent|enabled|disabled
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_lldp "Manage LLDP configuration on VyOS network devices" b
- name: $1
	vyos_lldp:
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_static_route "Manage static IP routes on Vyatta VyOS network devices" b
- name: $1
	vyos_static_route:
		# prefix: # Network prefix of the static route. C(mask) param should be ignored if C(prefix) is provided with C(mask) value C(prefix/mask).
		# mask: # Network prefix mask of the static route.
		# next_hop: # Next hop IP of the static route.
		# admin_distance: # Admin distance of the static route.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_interface "Manage Interface on VyOS network devices" b
- name: $1
	vyos_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: # Interface link status.
		# speed: # Interface link speed.
		# mtu: # Maximum size of transmit packet.
		# duplex: full|half|#auto
		# delay: 10
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# aggregate: # L
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_user "Manage the collection of local users on VyOS device" b
- name: $1
	vyos_user:
		# aggregate: # The set of username objects to be configured on the remote VyOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
		# name: # The username to be configured on the VyOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# full_name: # The C(full_name) argument provides the full name of the user account to be created on the remote device. This argument accepts any text string value.
		# configured_password: # The password to be configured on the VyOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# level: # The C(level) argument configures the level of the user when logged into the system. This argument accepts string values admin or operator.
		# purge: no
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_facts "Collect facts from remote devices running VyOS" b
- name: $1
	vyos_facts:
		# gather_subset: !config
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_linkagg "Manage link aggregation groups on VyOS network devices" b
- name: $1
	vyos_linkagg:
		name: ${2:# Name of the link aggregation group.}
		# mode: 802.3ad|active-backup|broadcast|round-robin|transmit-load-balance|adaptive-load-balance|xor-hash|on
		# members: # List of members of the link aggregation group.
		# aggregate: # L
		# state: #present|absent|up|down
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_banner "Manage multiline banners on VyOS devices" b
- name: $1
	vyos_banner:
		banner: ${2:pre-login|post-login}
		# text: # The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_vlan "Manage VLANs on VyOS network devices" b
- name: $1
	vyos_vlan:
		vlan_id: ${2:# ID of the VLAN. Range 0-4094.}
		interfaces: ${3:# List of interfaces that should be associated to the VLAN.}
		# name: # Name of the VLAN.
		# address: # Configure Virtual interface address.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan on device it will result in failure.
		# delay: 10
		# aggregate: # L
		# purge: no
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet vyos_l3_interface "Manage L3 interfaces on VyOS network devices" b
- name: $1
	vyos_l3_interface:
		# name: # Name of the L3 interface.
		# ipv4: # IPv4 of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# aggregate: # L
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet meraki_organization "Manage organizations in the Meraki cloud" b
- name: $1
	meraki_organization:
		# state: #present|query
		# clone: # Organization to clone to a new organization.
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_config_template "Manage configuration templates in the Meraki cloud" b
- name: $1
	meraki_config_template:
		# state: absent|#query|present
		# org_name: # Name of organization containing the configuration template.
		# org_id: # ID of organization associated to a configuration template.
		# config_template: # Name of the configuration template within an organization to manipulate.
		# net_name: # Name of the network to bind or unbind configuration template to.
		# net_id: # ID of the network to bind or unbind configuration template to.
		# auto_bind: # Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_device "Manage devices in the Meraki cloud" b
- name: $1
	meraki_device:
		# state: absent|present|#query
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# net_name: # Name of a network.
		# net_id: # ID of a network.
		# serial: # Serial number of a device to query.
		# hostname: # Hostname of network device to search for.
		# model: # Model of network device to search for.
		# tags: # Space delimited list of tags to assign to device.
		# lat: # Latitude of device's geographic location.
		# lng: # Longitude of device's geographic location.
		# address: # Postal address of device's location.
		# move_map_marker: # Whether or not to set the latitude and longitude of a device based on the new address.
		# serial_lldp_cdp: # Serial number of device to query LLDP/CDP information from.
		# lldp_cdp_timespan: # Timespan, in seconds, used to query LLDP and CDP information.
		# serial_uplink: # Serial number of device to query uplink information from.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_network "Manage networks in the Meraki cloud" b
- name: $1
	meraki_network:
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# state: absent|#present|query
		# net_name: # Name of a network.
		# net_id: # ID number of a network.
		# org_name: # Name of organization associated to a network.
		# org_id: # ID of organization associated to a network.
		# type: appliance|combined|switch|wireless
		# tags: # Comma delimited list of tags to assign to network.
		# timezone: # Timezone associated to network.
		# disable_my_meraki: # -
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_mr_l3_firewall "Manage MR access point layer 3 firewalls in the Meraki cloud" b
- name: $1
	meraki_mr_l3_firewall:
		# state: #present|query
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# net_name: # Name of network containing access points.
		# net_id: # ID of network containing access points.
		# number: # Number of SSID to apply firewall rule to.
		# ssid_name: # Name of SSID to apply firewall rule to.
		# allow_lan_access: yes
		# rules: # List of firewall rules.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_switchport "Manage switchports on a switch in the Meraki cloud" b
- name: $1
	meraki_switchport:
		# state: #query|present
		# access_policy_number: # Number of the access policy to apply.
		# allowed_vlans: all
		# enabled: yes
		# isolation_enabled: no
		# link_negotiation: #Auto negotiate|100Megabit (auto)|100 Megabit full duplex (forced)
		# name: # Switchport description.
		# number: # Port number.
		# poe_enabled: yes
		# rstp_enabled: yes
		# serial: # Serial nubmer of the switch.
		# stp_guard: #disabled|root guard|bpdu guard|loop guard
		# tags: # Space delimited list of tags to assign to a port.
		# type: #access|trunk
		# vlan: # VLAN number assigned to port.
		# voice_vlan: # VLAN number assigned to a port for voice traffic.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
		# org_name: # Name of organization.
		# org_id: # ID of organization.
$0
endsnippet

snippet meraki_mx_l3_firewall "Manage MX appliance layer 3 firewalls in the Meraki cloud" b
- name: $1
	meraki_mx_l3_firewall:
		# state: #present|query
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# net_name: # Name of network which MX firewall is in.
		# net_id: # ID of network which MX firewall is in.
		# rules: # List of firewall rules.
		# syslog_default_rule: no
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_vlan "Manage VLANs in the Meraki cloud" b
- name: $1
	meraki_vlan:
		# state: absent|present|#query
		# net_name: # Name of network which VLAN is in or should be in.
		# net_id: # ID of network which VLAN is in or should be in.
		# vlan_id: # ID number of VLAN.
		# name: # Name of VLAN.
		# subnet: # CIDR notation of network subnet.
		# appliance_ip: # IP address of appliance.
		# dns_nameservers: # Semi-colon delimited list of DNS IP addresses.
		# reserved_ip_range: # IP address ranges which should be reserve and not distributed via DHCP.
		# vpn_nat_subnet: # The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN.
		# fixed_ip_assignments: # Static IP address assignements to be distributed via DHCP by MAC address.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
		# org_name: # Name of organization.
		# org_id: # ID of organization.
$0
endsnippet

snippet meraki_admin "Manage administrators in the Meraki cloud" b
- name: $1
	meraki_admin:
		state: ${2:absent|present|query}
		# name: # Name of the dashboard administrator.
		# email: # Email address for the dashboard administrator.
		# orgAccess: full|none|read-only
		# tags: # Tags the administrator has privileges on.
		# networks: # List of networks the administrator has privileges on.
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_ssid "Manage wireless SSIDs in the Meraki cloud" b
- name: $1
	meraki_ssid:
		# state: absent|query|#present
		# number: # SSID number within network.
		# name: # Name of SSID.
		# org_name: # Name of organization.
		# org_id: # ID of organization.
		# net_name: # Name of network.
		# net_id: # ID of network.
		# enabled: # Enable or disable SSID network.
		# auth_mode: open|psk|open-with-radius|8021x-meraki|8021x-radius
		# encryption_mode: wpa|eap|wpa-eap
		# psk: # Password for wireless network.
		# wpa_encryption_mode: WPA1 and WPA2|WPA2 only
		# splash_page: None|Click-through splash page|Billing|Password-protected with Meraki RADIUS|Password-protected with custom RADIUS|Password-protected with Active Directory|Password-protected with LDAP|SMS authentication|Systems Manager Sentry|Facebook Wi-Fi|Google OAuth|Sponsored guest
		# radius_servers: # List of RADIUS servers.
		# radius_coa_enabled: # Enable or disable RADIUS CoA (Change of Authorization) on SSID.
		# radius_failover_policy: Deny access|Allow access
		# radius_load_balancing_policy: Strict priority order|Round robin
		# radius_accounting_enabled: # Enable or disable RADIUS accounting.
		# radius_accounting_servers: # List of RADIUS servers for RADIUS accounting.
		# ip_assignment_mode: NAT mode|Bridge mode|Layer 3 roaming|Layer 3 roaming with a concentrator|VPN
		# use_vlan_tagging: # Set whether to use VLAN tagging.
		# default_vlan_id: # Default VLAN ID.
		# vlan_id: # ID number of VLAN on SSID.
		# ap_tags_vlan_ids: # List of VLAN tags.
		# walled_garden_enabled: # Enable or disable walled garden functionality.
		# walled_garden_ranges: # List of walled garden ranges.
		# min_bitrate: 1|2|5.5|6|9|11|12|18|24|36|48|54
		# band_selection: Dual band operation|5 GHz band only|Dual band operation with Band Steering
		# per_client_bandwidth_limit_up: # Maximum bandwidth in Mbps devices on SSID can upload.
		# per_client_bandwidth_limit_down: # Maximum bandwidth in Mbps devices on SSID can download.
		# concentrator_network_id: # The concentrator to use for 'Layer 3 roaming with a concentrator' or 'VPN'.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet meraki_snmp "Manage organizations in the Meraki cloud" b
- name: $1
	meraki_snmp:
		# state: query|#present
		# v2c_enabled: # Specifies whether SNMPv2c is enabled.
		# v3_enabled: # Specifies whether SNMPv3 is enabled.
		# v3_auth_mode: MD5|SHA
		# v3_auth_pass: # Authentication password for SNMPv3.
		# v3_priv_mode: DES|AES128
		# v3_priv_pass: # Privacy password for SNMPv3.
		# peer_ips: # Semi-colon delimited IP addresses which can perform SNMP queries.
		# auth_key: # Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.
		# host: api.meraki.com
		# use_proxy: # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
		# use_https: yes
		# output_level: #normal|debug
		# timeout: 30
		# validate_certs: yes
		# org_name: # Name of organization.
		# org_id: # ID of organization.
$0
endsnippet

snippet net_vlan "Manage VLANs on network devices" b
- name: $1
	net_vlan:
		# name: # Name of the VLAN.
		# vlan_id: # ID of the VLAN.
		# interfaces: # List of interfaces the VLAN should be configured on.
		# aggregate: # L
		# purge: no
		# state: #present|absent|active|suspend
$0
endsnippet

snippet net_l2_interface "Manage Layer-2 interface on network devices" b
- name: $1
	net_l2_interface:
		# name: # Name of the interface excluding any logical unit number.
		# aggregate: # List of Layer-2 interface definitions.
		# mode: #access|trunk
		# access_vlan: # Configure given VLAN in access port.
		# trunk_vlans: # List of VLANs to be configured in trunk port.
		# native_vlan: # Native VLAN to be configured in trunk port.
		# trunk_allowed_vlans: # List of allowed VLAN's in a given trunk port.
		# state: #present|absent
$0
endsnippet

snippet panos_loadcfg "load configuration on PAN-OS device" b
- name: $1
	panos_loadcfg:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# file: # configuration file to load
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_restart "restart a device" b
- name: $1
	panos_restart:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# username: admin
$0
endsnippet

snippet panos_commit "commit firewall's candidate configuration" b
- name: $1
	panos_commit:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# interval: 0.5
		# timeout: # timeout for commit job
		# sync: yes
		# username: admin
$0
endsnippet

snippet panos_pg "create a security profiles group" b
- name: $1
	panos_pg:
		pg_name: ${2:# name of the security profile group}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		password: ${4:# Password for authentication.}
		# data_filtering: # name of the data filtering profile
		# file_blocking: # name of the file blocking profile
		# spyware: # name of the spyware profile
		# url_filtering: # name of the url filtering profile
		# virus: # name of the anti-virus profile
		# vulnerability: # name of the vulnerability profile
		# wildfire: # name of the wildfire analysis profile
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_security_rule "Create security rule policy on PAN-OS devices or Panorama management console." b
- name: $1
	panos_security_rule:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device being configured.}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		rule_name: ${4:# Name of the security rule.}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# operation: add
		# rule_type: universal
		# description: # Description for the security rule.
		# tag_name: # Administrative tags that can be added to the rule. Note, tags must be already defined.
		# source_zone: any
		# destination_zone: any
		# source_ip: any
		# source_user: any
		# hip_profiles: any
		# destination_ip: any
		# application: any
		# service: application-default
		# log_start: # Whether to log at session start.
		# log_end: yes
		# action: allow
		# group_profile: # -
		# antivirus: # Name of the already defined antivirus profile.
		# vulnerability: # Name of the already defined vulnerability profile.
		# spyware: # Name of the already defined spyware profile.
		# url_filtering: # Name of the already defined url_filtering profile.
		# file_blocking: # Name of the already defined file_blocking profile.
		# data_filtering: # Name of the already defined data_filtering profile.
		# wildfire_analysis: # Name of the already defined wildfire_analysis profile.
		# devicegroup: # -
		# commit: yes
$0
endsnippet

snippet panos_interface "configure data-port network interface for DHCP" b
- name: $1
	panos_interface:
		if_name: ${2:# Name of the interface to configure.}
		zone_name: ${3:# N}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device.}
		password: ${5:# Password for authentication.}
		# create_default_route: false
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_sag "Create a static address group." b
- name: $1
	panos_sag:
		sag_name: ${2:# name of the dynamic address group}
		static_match_filter: ${3:# Static filter user by the address group}
		operation: ${4:# The operation to perform Supported values are I(add)/I(list)/I(delete).}
		ip_address: ${5:# IP address (or hostname) of PAN-OS device.}
		password: ${6:# Password for authentication.}
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# devicegroup: # -
		# description: # The purpose / objective of the static Address Group
		# tags: # Tags to be associated with the address group
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_admin "Add or modify PAN-OS user accounts password." b
- name: $1
	panos_admin:
		admin_password: ${2:# password for admin user}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		password: ${4:# Password for authentication.}
		# admin_username: admin
		# role: # role for admin user
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_cert_gen_ssh "generates a self-signed certificate using SSH protocol with SSH key" b
- name: $1
	panos_cert_gen_ssh:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device being configured.}
		key_filename: ${3:# Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.}
		password: ${4:# Password credentials to use for auth. Either I(key_filename) or I(password) is required.}
		cert_friendly_name: ${5:# Human friendly certificate name (not CN but just a friendly name).}
		cert_cn: ${6:# Certificate CN (common name) embedded in the certificate signature.}
		signed_by: ${7:# Undersigning authority (CA) that MUST already be presents on the device.}
		# rsa_nbits: 2048
$0
endsnippet

snippet panos_object "create/read/update/delete object in PAN-OS or Panorama" b
- name: $1
	panos_object:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device or Panorama management console being configured.}
		password: ${3:# Password credentials to use for authentication.}
		operation: ${4:# The operation to be performed.  Supported values are I(add)/I(delete)/I(find).}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# addressobject: # The name of the address object.
		# address: # The IP address of the host or network in CIDR notation.
		# address_type: # The type of address object definition.  Valid types are I(ip-netmask) and I(ip-range).
		# addressgroup: # A static group of address objects or dynamic address group.
		# static_value: # A group of address objects to be used in an addressgroup definition.
		# dynamic_value: # The filter match criteria to be used in a dynamic addressgroup definition.
		# serviceobject: # The name of the service object.
		# source_port: # The source port to be used in a service object definition.
		# destination_port: # The destination port to be used in a service object definition.
		# protocol: # The IP protocol to be used in a service object definition.  Valid values are I(tcp) or I(udp).
		# servicegroup: # A group of service objects.
		# services: # The group of service objects used in a servicegroup definition.
		# description: # The description of the object.
		# tag_name: # The name of an object or rule tag.
		# color: # -
		# devicegroup: # -
$0
endsnippet

snippet panos_import "import file on PAN-OS devices" b
- name: $1
	panos_import:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# category: software
		# file: # Location of the file to import into device.
		# url: # URL of the file that will be imported to device.
		# validate_certs: yes
		# username: admin
$0
endsnippet

snippet panos_set "Execute arbitrary commands on a PAN-OS device using XPath and element" b
- name: $1
	panos_set:
		ip_address: ${2:# IP address or host FQDN of the target PAN-OS NVA}
		password: ${3:# Password for the given 'username'}
		xpath: ${4:# The 'xpath' for the commands configurable}
		# username: admin
		# command: #set|edit|delete|get|show|override
		# element: # The 'element' for the 'xpath' if required
$0
endsnippet

snippet panos_admpwd "change admin password of PAN-OS device using SSH with SSH key" b
- name: $1
	panos_admpwd:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device}
		key_filename: ${3:# filename of the SSH Key to use for authentication}
		newpassword: ${4:# password to configure for admin on the PAN-OS device}
		# username: admin
$0
endsnippet

snippet panos_check "check if PAN-OS device is ready for configuration" b
- name: $1
	panos_check:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# timeout: 0
		# interval: 0
		# username: admin
$0
endsnippet

snippet panos_dag_tags "Create tags for DAG's on PAN-OS devices." b
- name: $1
	panos_dag_tags:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# description: # The purpose / objective of the static Address Group
		# commit: yes
		# devicegroup: # -
		# operation: # The action to be taken. Supported values are I(add)/I(update)/I(find)/I(delete).
		# tag_names: # The list of the tags that will be added or removed from the IP address.
		# ip_to_register: # IP that will be registered with the given tag names.
		# username: admin
$0
endsnippet

snippet panos_query_rules "PANOS module that allows search for security rules in PANW NGFW devices." b
- name: $1
	panos_query_rules:
		ip_address: ${2:# IP address (or hostname) of PAN-OS firewall or Panorama management console being queried.}
		password: ${3:# Password credentials to use for authentication.}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# application: # Name of the application or application group to be queried.
		# source_zone: # Name of the source security zone to be queried.
		# source_ip: # The source IP address to be queried.
		# source_port: # The source port to be queried.
		# destination_zone: # Name of the destination security zone to be queried.
		# destination_ip: # The destination IP address to be queried.
		# destination_port: # The destination port to be queried.
		# protocol: # The protocol used to be queried.  Must be either I(tcp) or I(udp).
		# tag_name: # Name of the rule tag to be queried.
		# devicegroup: # The Panorama device group in which to conduct the query.
$0
endsnippet

snippet panos_op "execute arbitrary OP commands on PANW devices (e.g. show interface all)" b
- name: $1
	panos_op:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device or Panorama management console being configured.}
		password: ${3:# Password credentials to use for authentication.}
		cmd: ${4:# The OP command to be performed.}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
$0
endsnippet

snippet panos_lic "apply authcode to a device/instance" b
- name: $1
	panos_lic:
		auth_code: ${2:# authcode to be applied}
		ip_address: ${3:# IP address (or hostname) of PAN-OS device.}
		password: ${4:# Password for authentication.}
		# force: false
		# username: admin
$0
endsnippet

snippet panos_nat_rule "create a policy NAT rule" b
- name: $1
	panos_nat_rule:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device being configured.}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		rule_name: ${4:# name of the SNAT rule}
		source_zone: ${5:# list of source zones}
		destination_zone: ${6:# destination zone}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# operation: # The action to be taken.  Supported values are I(add)/I(update)/I(find)/I(delete).
		# source_ip: ['any']
		# destination_ip: ['any']
		# service: any
		# snat_type: # type of source translation
		# snat_address_type: translated-address
		# snat_static_address: # Source NAT translated address. Used with Static-IP translation.
		# snat_dynamic_address: # Source NAT translated address. Used with Dynamic-IP and Dynamic-IP-and-Port.
		# snat_interface: # snat interface
		# snat_interface_address: # snat interface address
		# snat_bidirectional: no
		# dnat_address: # dnat translated address
		# dnat_port: # dnat translated port
		# commit: yes
$0
endsnippet

snippet panos_dag "create a dynamic address group" b
- name: $1
	panos_dag:
		dag_name: ${2:# name of the dynamic address group}
		dag_filter: ${3:# dynamic filter user by the dynamic address group}
		ip_address: ${4:# IP address (or hostname) of PAN-OS device.}
		password: ${5:# Password for authentication.}
		# commit: yes
		# username: admin
$0
endsnippet

snippet panos_match_rule "Test for match against a security rule on PAN-OS devices or Panorama management console." b
- name: $1
	panos_match_rule:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device being configured.}
		password: ${3:# Password credentials to use for auth unless I(api_key) is set.}
		source_ip: ${4:# The source IP address.}
		vsys_id: ${5:vsys1}
		# username: admin
		# api_key: # API key that can be used instead of I(username)/I(password) credentials.
		# rule_type: security
		# source_zone: # The source zone.
		# source_port: # The source port.
		# source_user: # The source user or group.
		# to_interface: # The inbound interface in a NAT rule.
		# destination_zone: # The destination zone.
		# destination_ip: # The destination IP address.
		# destination_port: # The destination port.
		# application: # The application.
		# protocol: # The IP protocol number from 1 to 255.
		# category: # URL category
$0
endsnippet

snippet panos_mgtconfig "configure management settings of device" b
- name: $1
	panos_mgtconfig:
		ip_address: ${2:# IP address (or hostname) of PAN-OS device.}
		password: ${3:# Password for authentication.}
		# dns_server_primary: # address of primary DNS server
		# dns_server_secondary: # address of secondary DNS server
		# panorama_primary: # address of primary Panorama server
		# panorama_secondary: # address of secondary Panorama server
		# commit: yes
		# username: admin
$0
endsnippet

snippet ordnance_config "Manage Ordnance configuration sections" b
- name: $1
	ordnance_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# multiline_delimiter: @
		# backup: no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# defaults: no
		# save: no
$0
endsnippet

snippet ordnance_facts "Collect facts from Ordnance Virtual Routers over SSH" b
- name: $1
	ordnance_facts:
		# gather_subset: !config
$0
endsnippet

snippet net_l3_interface "Manage L3 interfaces on network devices" b
- name: $1
	net_l3_interface:
		# name: # Name of the L3 interface.
		# ipv4: # IPv4 of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet net_vrf "Manage VRFs on network devices" b
- name: $1
	net_vrf:
		# name: # Name of the VRF.
		# interfaces: # List of interfaces the VRF should be configured on.
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet net_get "Copy a file from a network device to Ansible Controller" b
- name: $1
	net_get:
		src: ${2:# Specifies the source file. The path to the source file can either be the full path on the network device or a relative path as per path supported by destination network device.}
		# protocol: #scp|sftp
		# dest: ['Same filename as specified in I(src). The path will be playbook root or role root directory if playbook is part of a role.']
$0
endsnippet

snippet net_put "Copy a file from Ansible Controller to a network device" b
- name: $1
	net_put:
		src: ${2:# Specifies the source file. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.}
		# protocol: #scp|sftp
		# dest: ['Filename from src and at default directory of user shell on network_os.']
		# mode: #binary|text
$0
endsnippet

snippet asa_acl "Manage access-lists on a Cisco ASA" b
- name: $1
	asa_acl:
		lines: ${2:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact
		# replace: #line|block
		# force: no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuruation to use as the base config for comparison.
		# authorize: no
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# provider: # B(Deprecated)
$0
endsnippet

snippet asa_command "Run arbitrary commands on Cisco ASA devices" b
- name: $1
	asa_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# authorize: no
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# provider: # B(Deprecated)
$0
endsnippet

snippet asa_config "Manage configuration sections on Cisco ASA devices" b
- name: $1
	asa_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# backup: no
		# config: # The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
		# defaults: no
		# passwords: no
		# save: no
		# authorize: no
		# context: # Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.
		# provider: # B(Deprecated)
$0
endsnippet

snippet fortios_config "Manage config on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_config:
		# src: # The I(src) argument provides a path to the configuration template to load into the remote device.
		# filter: 
		# file_mode: no
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# timeout: 60
		# vdom: # Specifies on which vdom to apply configuration
		# backup: no
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
$0
endsnippet

snippet fortios_address "Manage fortios firewall address objects" b
- name: $1
	fortios_address:
		state: ${2:present|absent}
		name: ${3:# Name of the address to add or delete.}
		# type: iprange|fqdn|ipmask|geography
		# value: # Address value, based on type. If type=fqdn, somthing like www.google.com. If type=ipmask, you can use simple ip (192.168.0.1), ip+mask (192.168.0.1 255.255.255.0) or CIDR (192.168.0.1/32).
		# start_ip: # First ip in range (used only with type=iprange).
		# end_ip: # Last ip in range (used only with type=iprange).
		# country: # 2 letter country code (like FR).
		# interface: any
		# comment: # free text to describe address.
		# file_mode: no
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# timeout: 60
		# vdom: # Specifies on which vdom to apply configuration
		# backup: no
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
$0
endsnippet

snippet fortios_ipv4_policy "Manage IPv4 policy objects on Fortinet FortiOS firewall devices" b
- name: $1
	fortios_ipv4_policy:
		id: ${2:# Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns}
		# state: #present|absent
		# src_intf: any
		# dst_intf: any
		# src_addr: # Specifies source address (or group) object name(s). Required when I(state=present).
		# src_addr_negate: no
		# dst_addr: # Specifies destination address (or group) object name(s). Required when I(state=present).
		# dst_addr_negate: no
		# policy_action: accept|deny
		# service: # Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).
		# service_negate: no
		# schedule: always
		# nat: no
		# fixedport: no
		# poolname: # Specifies NAT pool name.
		# av_profile: # Specifies Antivirus profile name.
		# webfilter_profile: # Specifies Webfilter profile name.
		# ips_sensor: # Specifies IPS Sensor profile name.
		# application_list: # Specifies Application Control name.
		# logtraffic: disable|#utm|all
		# logtraffic_start: no
		# comment: # free text to describe policy.
		# file_mode: no
		# config_file: # Path to configuration file. Required when I(file_mode) is True.
		# host: # Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.
		# username: # Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.
		# password: # Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.
		# timeout: 60
		# vdom: # Specifies on which vdom to apply configuration
		# backup: no
		# backup_path: # Specifies where to store backup files. Required if I(backup=yes).
		# backup_filename: # Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS
$0
endsnippet

snippet fortios_webfilter "Configure webfilter capabilities of FortiGate and FortiOS." b
- name: $1
	fortios_webfilter:
		host: ${2:# FortiOS or FortiGate ip adress.}
		username: ${3:# FortiOS or FortiGate username.}
		# password: 
		# vdom: root
		# webfilter_url: # Container for a group of url entries that the FortiGate must act upon
		# webfilter_content: # Container for a group of content-filtering entries that the FortiGate must act upon
$0
endsnippet

snippet net_static_route "Manage static IP routes on network appliances (routers, switches et. al.)" b
- name: $1
	net_static_route:
		prefix: ${2:# Network prefix of the static route.}
		mask: ${3:# Network prefix mask of the static route.}
		next_hop: ${4:# Next hop IP of the static route.}
		# admin_distance: # Admin distance of the static route.
		# aggregate: # L
		# purge: no
		# state: #present|absent
$0
endsnippet

snippet nclu "Configure network interfaces using NCLU" b
- name: $1
	nclu:
		# commands: # A list of strings containing the net commands to run. Mutually exclusive with I(template).
		# template: # A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).
		# commit: no
		# abort: no
		# atomic: no
		# description: Ansible-originated commit
$0
endsnippet

snippet edgeos_facts "Collect facts from remote devices running EdgeOS" b
- name: $1
	edgeos_facts:
		# gather_subset: !config
$0
endsnippet

snippet edgeos_command "Run one or more commands on EdgeOS devices" b
- name: $1
	edgeos_command:
		commands: ${2:# The commands or ordered set of commands that should be run against the remote device. The output of the command is returned to the playbook. If the C(wait_for) argument is provided, the module is not returned until the condition is met or the number of retries is exceeded.}
		# wait_for: # Causes the task to wait for a specific condition to be met before moving forward. If the condition is not met before the specified number of retries is exceeded, the task will fail.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet edgeos_config "Manage EdgeOS configuration on remote device" b
- name: $1
	edgeos_config:
		# lines: # The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
		# src: # The C(src) argument specifies the path to the source config file to load. The source config file can either be in bracket format or set format. The source file can include Jinja2 template variables.
		# match: #line|none
		# backup: no
		# comment: configured by edgeos_config
		# config: # The C(config) argument specifies the base configuration to use to compare against the desired configuration. If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
		# save: no
$0
endsnippet

snippet junos_vlan "Manage VLANs on Juniper JUNOS network devices" b
- name: $1
	junos_vlan:
		name: ${2:# Name of the VLAN.}
		vlan_id: ${3:# ID of the VLAN. Range 1-4094.}
		# l3_interface: # Name of logical layer 3 interface.
		# description: # Text description of VLANs.
		# interfaces: # List of interfaces to check the VLAN has been configured correctly.
		# aggregate: # L
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_interface "Manage Interface on Juniper JUNOS network devices" b
- name: $1
	junos_interface:
		name: ${2:# Name of the Interface.}
		# description: # Description of Interface.
		# enabled: # Configure interface link status.
		# speed: # Interface link speed.
		# mtu: # Maximum size of transmit packet.
		# duplex: full|half|#auto
		# tx_rate: # Transmit rate in bits per second (bps).
		# rx_rate: # Receiver rate in bits per second (bps).
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# delay: 10
		# aggregate: # L
		# state: #present|absent|up|down
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_user "Manage local user accounts on Juniper JUNOS devices" b
- name: $1
	junos_user:
		# aggregate: # The C(aggregate) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument.
		# name: # The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(aggregate) argument.
		# full_name: # The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value.
		# role: operator|read-only|super-user|unauthorized
		# sshkey: # The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key
		# purge: no
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_banner "Manage multiline banners on Juniper JUNOS devices" b
- name: $1
	junos_banner:
		banner: ${2:login|motd}
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_linkagg "Manage link aggregation groups on Juniper JUNOS network devices" b
- name: $1
	junos_linkagg:
		name: ${2:# Name of the link aggregation group.}
		members: ${3:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}
		# mode: on|off|active|passive
		# min_links: # Minimum members that should be up before bringing up the link aggregation group.
		# device_count: # Number of aggregated ethernet devices that can be configured. Acceptable integer value is between 1 and 128.
		# description: # Description of Interface.
		# aggregate: # L
		# state: #present|absent|up|down
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_vrf "Manage the VRF definitions on Juniper JUNOS devices" b
- name: $1
	junos_vrf:
		# name: # The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(aggregate) argument
		# description: # Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
		# rd: # The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF.
		# target: # It configures VRF target community configuration. The target value takes the form of C(target:A:B) where C(A) and C(B) are both numeric values.
		# table_label: # Causes JUNOS to allocate a VPN label per VRF rather than per VPN FEC. This allows for forwarding of traffic to directly connected subnets, COS Egress filtering etc.
		# aggregate: # The set of VRF definition objects to be configured on the remote JUNOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_l3_interface "Manage L3 interfaces on Juniper JUNOS network devices" b
- name: $1
	junos_l3_interface:
		# name: # Name of the L3 interface.
		# ipv4: # IPv4 of the L3 interface.
		# ipv6: # IPv6 of the L3 interface.
		# unit: 0
		# aggregate: # L
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_config "Manage configuration on devices running Juniper JUNOS" b
- name: $1
	junos_config:
		# lines: # This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system. The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.
		# src_format: xml|set|text|json
		# rollback: # The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.
		# zeroize: # The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.
		# confirm: 0
		# comment: configured by junos_config
		# replace: no
		# backup: no
		# update: #merge|override|replace
		# confirm_commit: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_scp "Transfer files from or to remote devices running Junos" b
- name: $1
	junos_scp:
		src: ${2:# The C(src) argument takes a single path, or a list of paths to be transfered. The argument C(recursive) must be C(true) to transfer directories.}
		# dest: .
		# recursive: no
		# remote_src: no
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_lldp_interface "Manage LLDP interfaces configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp_interface:
		# name: # Name of the interface LLDP should be configured on.
		# state: #present|absent|enabled|disabled
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_command "Run arbitrary commands on an Juniper JUNOS device" b
- name: $1
	junos_command:
		# commands: # The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.
		# rpcs: # The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# display: text|json|xml|set
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_facts "Collect facts from remote devices running Juniper Junos" b
- name: $1
	junos_facts:
		# gather_subset: ['!config', '!ofacts']
		# config_format: xml|#text|set|json
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_l2_interface "Manage Layer-2 interface on Juniper JUNOS network devices" b
- name: $1
	junos_l2_interface:
		# name: # Name of the interface excluding any logical unit number.
		# description: # Description of Interface.
		# aggregate: # List of Layer-2 interface definitions.
		# mode: access|trunk
		# access_vlan: # Configure given VLAN in access port. The value of C(access_vlan) should be vlan name.
		# trunk_vlans: # List of VLAN names to be configured in trunk port. The value of C(trunk_vlans) should be list of vlan names.
		# native_vlan: # Native VLAN to be configured in trunk port. The value of C(native_vlan) should be vlan id.
		# enhanced_layer: yes
		# unit: 0
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_package "Installs packages on remote devices running Junos" b
- name: $1
	junos_package:
		src: ${2:# The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install.}
		reboot: ${3:yes}
		force: ${4:no}
		# version: # The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename.
		# no_copy: no
		# validate: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_lldp "Manage LLDP configuration on Juniper JUNOS network devices" b
- name: $1
	junos_lldp:
		# interval: # Frequency at which LLDP advertisements are sent (in seconds).
		# transmit_delay: # Specify the number of seconds the device waits before sending advertisements to neighbors after a change is made in local system.
		# hold_multiplier: # Specify the number of seconds that LLDP information is held before it is discarded. The multiplier value is used in combination with the C(interval) value.
		# state: #present|absent|enabled|disabled
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_system "Manage the system attributes on Juniper JUNOS devices" b
- name: $1
	junos_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_logging "Manage logging on network devices" b
- name: $1
	junos_logging:
		# dest: console|host|file|user
		# name: # If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
		# facility: # Set logging facility.
		# level: # Set logging severity levels.
		# aggregate: # L
		# state: #present|absent
		# active: yes
		# rotate_frequency: # Rotate log frequency in minutes, this is applicable if value of I(dest) is C(file). The acceptable value is in range of 1 to 59. This controls the frequency after which log file is rotated.
		# size: # Size of the file in archive, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 65536 to 1073741824 bytes.
		# files: # Number of files to be archived, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 1 to 1000.
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_netconf "Configures the Junos Netconf system service" b
- name: $1
	junos_netconf:
		# netconf_port: 830
		# state: #present|absent
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_static_route "Manage static IP routes on Juniper JUNOS network devices" b
- name: $1
	junos_static_route:
		address: ${2:# Network address with prefix of the static route.}
		next_hop: ${3:# Next hop IP of the static route.}
		# qualified_next_hop: # Qualified next hop IP of the static route. Qualified next hops allow to associate preference with a particular next-hop address.
		# preference: # Global admin preference of the static route.
		# qualified_preference: # Assign preference for qualified next hop.
		# aggregate: # L
		# state: #present|absent
		# active: yes
		# provider: # B(Deprecated)
$0
endsnippet

snippet junos_rpc "Runs an arbitrary RPC over NetConf on an Juniper JUNOS device" b
- name: $1
	junos_rpc:
		rpc: ${2:# The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.}
		# args: # The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.
		# attrs: # The C(attrs) arguments defines a list of attributes and their values to set for the RPC call. This accepts a dictionary of key-values.
		# output: xml
		# provider: # B(Deprecated)
$0
endsnippet

snippet cnos_vlag "Manage VLAG resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlag:
		vlagArg1: ${2:enable|auto-recovery|config-consistency|isl|mac-address-table|peer-gateway|priority|startup-delay|tier-id|vrrp|instance|hlthchk}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${5:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# vlagArg2: Interval in seconds|disable or strict|Port Aggregation Number|VLAG priority|Delay time in seconds|VLAG tier-id value|VLAG instance number|keepalive-attempts|keepalive-interval|retry-interval|peer-ip
		# vlagArg3: enable or port-aggregation|Number of keepalive attempts|Interval in seconds|Interval in seconds|VLAG health check peer IP4 address
		# vlagArg4: Port Aggregation Number|default or management
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_rollback "Roll back the running or startup configuration from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_rollback:
		configType: ${2:running-config|startup-config}
		protocol: ${3:SFTP|SCP|FTP|TFTP}
		rcserverip: ${4:# This specifies the IP Address of the remote server from where the backup configuration will be downloaded.}
		rcpath: ${5:# This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		serverusername: ${6:# Specify username for the server relating to the protocol used.}
		serverpassword: ${7:# Specify password for the server relating to the protocol used.}
		outputfile: ${8:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${9:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${10:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${11:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${12:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_facts "Collect facts from remote devices running Lenovo CNOS" b
- name: $1
	cnos_facts:
		# authorize: no
		# auth_pass: # Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.
		# provider: # A dict object containing connection details.
		# gather_subset: !config
$0
endsnippet

snippet cnos_interface "Manage interface configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_interface:
		interfaceRange: ${2:# This specifies the interface range in which the port channel is envisaged}
		interfaceOption: ${3:None|ethernet|loopback|mgmt|port-channel|vlan}
		interfaceArg1: ${4:channel-group|bfd|switchport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-channel}
		outputfile: ${5:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${7:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${9:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# interfaceArg2: channel-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> for L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port
		# interfaceArg3: active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6
		# interfaceArg4: key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface
		# interfaceArg5: name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32
		# interfaceArg6: Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent
		# interfaceArg7: Authentication key string|admin-down
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_bgp "Manage BGP resources and attributes on devices running CNOS" b
- name: $1
	cnos_bgp:
		asNum: ${2:# AS number}
		bgpArg1: ${3:address-family|bestpath|bgp|cluster-id|confederation|enforce-first-as|fast-external-failover|graceful-restart|graceful-restart-helper|log-neighbor-changes|maxas-limit|neighbor|router-id|shutdown|synchronization|timers|vrf}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${6:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# bgpArg2: ipv4 or ipv6|always-compare-med|compare-confed-aspath|compare-routerid|dont-compare-originator-id|tie-break-on-age|as-path|med|identifier|peers
		# bgpArg3: aggregate-address|client-to-client|dampening|distance|maximum-paths|network|nexthop|redistribute|save|synchronization|ignore or multipath-relax|confed or missing-as-worst or non-deterministic or remove-recv-med or remove-send-med
		# bgpArg4: Aggregate prefix|Reachability Half-life time|route-map|Distance for routes ext|ebgp or ibgp|IP prefix <network>|IP prefix <network>/<length>|synchronization|Delay value|direct|ospf|static|memory
		# bgpArg5: as-set|summary-only|Value to start reusing a route|Distance for routes internal|Supported multipath numbers|backdoor|map|route-map
		# bgpArg6: summary-only|as-set|route-map name|Value to start suppressing a route|Distance local routes|Network mask|Pointer to route-map entries
		# bgpArg7: Maximum duration to suppress a stable route(minutes)|backdoor|route-map|Name of the route map
		# bgpArg8: Un-reachability Half-life time for the penalty(minutes)|backdoor
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_showrun "Collect the current running configuration on devices running on CNOS" b
- name: $1
	cnos_showrun:
		outputfile: ${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_conditional_command "Execute a single command based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_command:
		clicommand: ${2:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
		condition: ${3:# If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.}
		flag: ${4:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		outputfile: ${5:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${7:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${9:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_save "Save the running configuration as the startup configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_save:
		outputfile: ${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_command "Run arbitrary commands on Lenovo CNOS devices" b
- name: $1
	cnos_command:
		commands: ${2:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}
		# provider: # A dict object containing connection details.
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet cnos_vlan "Manage VLAN resources and attributes on devices running Lenovo CNOS" b
- name: $1
	cnos_vlan:
		vlanArg1: ${2:access-map|dot1q|filter|<1-3999> VLAN ID 1-3999 or range}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${5:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# vlanArg2: VLAN Access Map name|egress-only|name|flood|state|ip
		# vlanArg3: action|match|statistics|enter VLAN id or range of vlan|ascii name for the VLAN|ipv4 or ipv6|active or suspend|fast-leave|last-member-query-interval|mrouter|querier|querier-timeout|query-interval|query-max-response-time|report-suppression|robustness-variable|startup-query-count|startup-query-interval|static-group
		# vlanArg4: drop or forward or redirect|ip or mac|Interval in seconds|ethernet|port-aggregation|Querier IP address|Querier Timeout in seconds|Query Interval in seconds|Query Max Response Time in seconds|Robustness Variable value|Number of queries sent at startup|Query Interval at startup
		# vlanArg5: access-list name|Slot/chassis number|Port Aggregation Number
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_conditional_template "Manage switch configuration using templates based on condition on devices running Lenovo CNOS" b
- name: $1
	cnos_conditional_template:
		commandfile: ${2:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_ {{ inventory_hostname }}_LP21_commands.txt}
		condition: ${3:# If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.}
		flag: ${4:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
		outputfile: ${5:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${6:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${7:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${8:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${9:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_factory "Reset the switch startup configuration to default (factory) on devices running Lenovo CNOS." b
- name: $1
	cnos_factory:
		outputfile: ${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_reload "Perform switch restart on devices running Lenovo CNOS" b
- name: $1
	cnos_reload:
		outputfile: ${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${6:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_image "Perform firmware upgrade/download from a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_image:
		protocol: ${2:SFTP|SCP|FTP|TFTP}
		serverip: ${3:# This specifies the IP Address of the remote server from where the software image will be downloaded.}
		imgpath: ${4:# This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		imgtype: ${5:all|boot|os|onie}
		serverusername: ${6:# Specify the username for the server relating to the protocol used}
		outputfile: ${7:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${8:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${9:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${11:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# serverpassword: # Specify the password for the server relating to the protocol used
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_portchannel "Manage portchannel (port channel) configuration on devices running Lenovo CNOS" b
- name: $1
	cnos_portchannel:
		interfaceRange: ${2:# This specifies the interface range in which the port channel is envisaged}
		interfaceArg1: ${3:channel-group|bfd|bridgeport|description|duplex|flowcontrol|ip|ipv6|lacp|lldp|load-interval|mac|mac-address|mac-learn|microburst-detection|mtu|service|service-policy|shutdown|snmp|spanning-tree|speed|storm-control|vlan|vrrp|port-channel}
		outputfile: ${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${6:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${8:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# interfaceArg2: channel-group number|access or mode or trunk|description|auto or full or half|receive or send|port-priority|suspend-individual|timeout|receive or transmit or trap-notification|tlv-select|Load interval delay in seconds|counter|Name for the MAC Access List|mac-address in HHHH.HHHH.HHHH format|THRESHOLD  Value in unit of buffer cell|<64-9216>  MTU in bytes-<64-9216> for L2 packet|<576-9216> for L3 IPv4 packet|<1280-9216> L3 IPv6 packet|enter the instance id|input or output|copp-system-policy|type|1000  or  10000  or   40000 or   auto|broadcast or multicast or unicast|disable or enable or egress-only|Virtual router identifier|destination-ip or destination-mac or destination-port or source-dest-ip or source-dest-mac or source-dest-port or source-interface or source-ip or source-mac or source-port
		# interfaceArg3: active or on or passive|on or off|LACP port priority|long or short|link-aggregation or mac-phy-status or management-address or max-frame-size or port-description or port-protocol-vlan or port-vlan or power-mdi or protocol-identity or system-capabilities or system-description or system-name or vid-management or vlan-name|counter for load interval|policy input name|all or Copp class name to attach|qos|queueing|Enter the allowed traffic level|ipv6
		# interfaceArg4: key-chain|key-id|keyed-md5 or keyed-sha1 or meticulous-keyed-md5 or meticulous-keyed-sha1 or simple|Interval value in milliseconds|Destination IP (Both IPV4 and IPV6)|in or out|MAC address|Time-out value in seconds|class-id|request|Specify the IPv4 address|OSPF area ID as a decimal value|OSPF area ID in IP address format|anycast or secondary|ethernet|vlan|MAC (hardware) address in HHHH.HHHH.HHHH format|Load interval delay in seconds|Specify policy input name|input or output|cost|port-priority|BFD minimum receive interval|source-interface
		# interfaceArg5: name of key-chain|key-Id Value|key-chain|key-id|BFD minimum receive interval|Value of Hello Multiplier|admin-down or multihop or non-persistent|Vendor class-identifier name|bootfile-name or host-name or log-server or ntp-server or tftp-server-name|Slot/chassis number|Vlan interface|Specify policy input name|Port path cost or auto|Port priority increments of 32
		# interfaceArg6: Authentication key string|name of key-chain|key-Id Value|Value of Hello Multiplier|admin-down or non-persistent
		# interfaceArg7: Authentication key string|admin-down
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_config "Manage Lenovo CNOS configuration sections" b
- name: $1
	cnos_config:
		# provider: # A dict object containing connection details.
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block|config
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# comment: configured by cnos_config
		# admin: no
$0
endsnippet

snippet cnos_backup "Backup the current running or startup configuration to a remote server on devices running Lenovo CNOS" b
- name: $1
	cnos_backup:
		configType: ${2:running-config|startup-config}
		protocol: ${3:SFTP|SCP|FTP|TFTP}
		rcserverip: ${4:# -}
		rcpath: ${5:# This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
		serverusername: ${6:# Specify the username for the server relating to the protocol used.}
		serverpassword: ${7:# Specify the password for the server relating to the protocol used.}
		outputfile: ${8:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${9:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${10:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${11:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${12:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet cnos_template "Manage switch configuration using templates on devices running Lenovo CNOS" b
- name: $1
	cnos_template:
		commandfile: ${2:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt}
		outputfile: ${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
		host: ${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
		username: ${5:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		password: ${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
		deviceType: ${7:g8272_cnos|g8296_cnos|g8332_cnos|NE1072T|NE1032|NE1032T|NE10032|NE2572}
		# enablePassword: # Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.
$0
endsnippet

snippet voss_facts "Collect facts from remote devices running Extreme VOSS" b
- name: $1
	voss_facts:
		# gather_subset: !config
$0
endsnippet

snippet voss_command "Run commands on remote devices running Extreme VOSS" b
- name: $1
	voss_command:
		commands: ${2:# List of commands to send to the remote VOSS device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
$0
endsnippet

snippet pn_vrouterbgp "CLI command to add/remove/modify vrouter-bgp." b
- name: $1
	pn_vrouterbgp:
		state: ${2:present|absent|update}
		pn_vrouter_name: ${3:# Specify a name for the vRouter service.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_neighbor: # Specify a neighbor IP address to use for BGP.
		# pn_remote_as: # Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.
		# pn_next_hop_self: # Specify if the next-hop is the same router or not.
		# pn_password: # Specify a password, if desired.
		# pn_ebgp: # Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.
		# pn_prefix_listin: # Specify the prefix list to filter traffic inbound.
		# pn_prefix_listout: # Specify the prefix list to filter traffic outbound.
		# pn_route_reflector: # Specify if a route reflector client is used.
		# pn_override_capability: # Specify if you want to override capability.
		# pn_soft_reconfig: # Specify if you want a soft reconfiguration of inbound traffic.
		# pn_max_prefix: # Specify the maximum number of prefixes.
		# pn_max_prefix_warn: # Specify if you want a warning message when the maximum number of prefixes is exceeded.
		# pn_bfd: # Specify if you want BFD protocol support for fault detection.
		# pn_multiprotocol: ipv4-unicast|ipv6-unicast
		# pn_weight: # Specify a default weight value between 0 and 65535 for the neighbor routes.
		# pn_default_originate: # Specify if you want announce default routes to the neighbor or not.
		# pn_keepalive: # Specify BGP neighbor keepalive interval in seconds.
		# pn_holdtime: # Specify BGP neighbor holdtime in seconds.
		# pn_route_mapin: # Specify inbound route map for neighbor.
		# pn_route_mapout: # Specify outbound route map for neighbor.
$0
endsnippet

snippet pn_cluster "CLI command to create/delete a cluster." b
- name: $1
	pn_cluster:
		state: ${2:present|absent}
		pn_name: ${3:# Specify the name of the cluster.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch to run the cli on.
		# pn_cluster_node1: # Specify the name of the first switch in the cluster.
		# pn_cluster_node2: # Specify the name of the second switch in the cluster.
		# pn_validate: validate|no-validate
$0
endsnippet

snippet pn_ospf "CLI command to add/remove ospf protocol to a vRouter." b
- name: $1
	pn_ospf:
		state: ${2:#present|absent}
		pn_vrouter_name: ${3:# Specify the name of the vRouter.}
		pn_network_ip: ${4:# Specify the network IP (IPv4 or IPv6) address.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch to run the CLI on.
		# pn_ospf_area: # Stub area number for the configuration. Required for vrouter-ospf-add.
$0
endsnippet

snippet pn_vrouter "CLI command to create/delete/modify a vrouter." b
- name: $1
	pn_vrouter:
		state: ${2:present|absent|update}
		pn_name: ${3:# Specify the name of the vRouter.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the CLI on.
		# pn_vnet: # Specify the name of the VNET.
		# pn_service_type: dedicated|shared
		# pn_service_state: enable|disable
		# pn_router_type: hardware|software
		# pn_hw_vrrp_id: # Specifies the VRRP ID for a hardware vrouter.
		# pn_router_id: # Specify the vRouter IP address.
		# pn_bgp_as: # Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).
		# pn_bgp_redistribute: static|connected|rip|ospf
		# pn_bgp_max_paths: # Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.
		# pn_bgp_options: # Specify other BGP options as a whitespaces separated string within single quotes ''.
		# pn_rip_redistribute: static|connected|ospf|bgp
		# pn_ospf_redistribute: static|connected|bgp|rip
		# pn_ospf_options: # Specify other OSPF options as a whitespaces separated string within single quotes ''.
$0
endsnippet

snippet pn_vlag "CLI command to create/delete/modify vlag." b
- name: $1
	pn_vlag:
		state: ${2:present|absent|update}
		pn_name: ${3:# The C(pn_name) takes a valid name for vlag configuration.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run this command on.
		# pn_port: # Specify the local VLAG port.
		# pn_peer_port: # Specify the peer VLAG port.
		# pn_mode: active-active|active-standby
		# pn_peer_switch: # Specify the fabric-name of the peer switch.
		# pn_failover_action: move|ignore
		# pn_lacp_mode: off|passive|active
		# pn_lacp_timeout: slow|fast
		# pn_lacp_fallback: bundle|individual
		# pn_lacp_fallback_timeout: # Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
$0
endsnippet

snippet pn_ospfarea "CLI command to add/remove ospf area to/from a vrouter." b
- name: $1
	pn_ospfarea:
		pn_cliusername: ${2:# Login username.}
		pn_clipassword: ${3:# Login password.}
		state: ${4:present|absent|update}
		pn_vrouter_name: ${5:# Specify the name of the vRouter.}
		pn_ospf_area: ${6:# Specify the OSPF area number.}
		# pn_cliswitch: # Target switch(es) to run the CLI on.
		# pn_stub_type: none|stub|stub-no-summary|nssa|nssa-no-summary
		# pn_prefix_listin: # OSPF prefix list for filtering incoming packets.
		# pn_prefix_listout: # OSPF prefix list for filtering outgoing packets.
		# pn_quiet: yes
$0
endsnippet

snippet pn_vrouterif "CLI command to add/remove/modify vrouter-interface." b
- name: $1
	pn_vrouterif:
		state: ${2:present|absent|update}
		pn_vrouter_name: ${3:# Specify the name of the vRouter interface.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch to run the cli on.
		# pn_vlan: # Specify the VLAN identifier. This is a value between 1 and 4092.
		# pn_interface_ip: # Specify the IP address of the interface in x.x.x.x/n format.
		# pn_assignment: none|dhcp|dhcpv6|autov6
		# pn_vxlan: # Specify the VXLAN identifier. This is a value between 1 and 16777215.
		# pn_interface: mgmt|data|span
		# pn_alias: # Specify an alias for the interface.
		# pn_exclusive: # Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.
		# pn_nic_enable: # Specify if the NIC is enabled or not
		# pn_vrrp_id: # Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.
		# pn_vrrp_priority: # Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).
		# pn_vrrp_adv_int: # Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.
		# pn_l3port: # Specify a Layer 3 port for the interface.
		# pn_secondary_macs: # Specify a secondary MAC address for the interface.
		# pn_nic_str: # Specify the type of NIC. Used for vrouter-interface remove/modify.
$0
endsnippet

snippet pn_vrouterlbif "CLI command to add/remove vrouter-loopback-interface." b
- name: $1
	pn_vrouterlbif:
		state: ${2:present|absent}
		pn_vrouter_name: ${3:# Specify the name of the vRouter.}
		pn_interface_ip: ${4:# Specify the IP address.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_index: # Specify the interface index from 1 to 255.
$0
endsnippet

snippet pn_show "Run show commands on nvOS device." b
- name: $1
	pn_show:
		pn_command: ${2:# The C(pn_command) takes a CLI show command as value.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_parameters: # Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.
		# pn_options: # Specify formatting options.
$0
endsnippet

snippet pn_vlan "CLI command to create/delete a VLAN." b
- name: $1
	pn_vlan:
		state: ${2:present|absent}
		pn_vlanid: ${3:# Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_scope: fabric|local
		# pn_description: # Specify a description for the VLAN.
		# pn_stats: # Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.
		# pn_ports: # Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.
		# pn_untagged_ports: # Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.
$0
endsnippet

snippet pn_trunk "CLI command to create/delete/modify a trunk." b
- name: $1
	pn_trunk:
		state: ${2:present|absent|update}
		pn_name: ${3:# Specify the name for the trunk configuration.}
		# pn_cliusername: # Provide login username if user is not root.
		# pn_clipassword: # Provide login password if user is not root.
		# pn_cliswitch: # Target switch(es) to run the cli on.
		# pn_ports: # Specify the port number(s) for the link(s) to aggregate into the trunk.
		# pn_speed: disable|10m|100m|1g|2.5g|10g|40g
		# pn_egress_rate_limit: # Specify an egress port data rate limit for the configuration.
		# pn_jumbo: # Specify if the port can receive jumbo frames.
		# pn_lacp_mode: off|passive|active
		# pn_lacp_priority: # Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.
		# pn_lacp_timeout: slow|fast
		# pn_lacp_fallback: bundle|individual
		# pn_lacp_fallback_timeout: # Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
		# pn_edge_switch: # Specify if the switch is an edge switch.
		# pn_pause: # Specify if pause frames are sent.
		# pn_description: # Specify a description for the trunk configuration.
		# pn_loopback: # Specify loopback if you want to use loopback.
		# pn_mirror_receive: # Specify if the configuration receives mirrored traffic.
		# pn_unknown_ucast_level: # Specify an unknown unicast level in percent. The default value is 100%.
		# pn_unknown_mcast_level: # Specify an unknown multicast level in percent. The default value is 100%.
		# pn_broadcast_level: # Specify a broadcast level in percent. The default value is 100%.
		# pn_port_macaddr: # Specify the MAC address of the port.
		# pn_loopvlans: # Specify a list of looping vlans.
		# pn_routing: # Specify if the port participates in routing on the network.
		# pn_host: # Host facing port control setting.
$0
endsnippet

snippet dellos9_command "Run commands on remote devices running Dell OS9" b
- name: $1
	dellos9_command:
		commands: ${2:# List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos9_config "Manage Dell EMC Networking OS9 configuration sections" b
- name: $1
	dellos9_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# update: #merge|check
		# save: no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos9_facts "Collect facts from remote devices running Dell EMC Networking OS9" b
- name: $1
	dellos9_facts:
		# gather_subset: ['!config']
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet eos_lldp "Manage LLDP configuration on Arista EOS network devices" b
- name: $1
	eos_lldp:
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_config "Manage Arista EOS configuration sections" b
- name: $1
	eos_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments. It can be a Jinja2 template as well. src file must have same indentation as a live switch config. Arista EOS device config has 3 spaces indentation.
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block|config
		# force: no
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for this module.
		# defaults: no
		# save: no
		# save_when: always|#never|modified|changed
		# diff_against: startup|running|intended|#session
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_system "Manage the system attributes on Arista EOS devices" b
- name: $1
	eos_system:
		# hostname: # Configure the device hostname parameter. This option takes an ASCII string value.
		# domain_name: # Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
		# domain_search: # Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
		# lookup_source: # Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.
		# name_servers: # List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_vrf "Manage VRFs on Arista EOS network devices" b
- name: $1
	eos_vrf:
		name: ${2:# Name of the VRF.}
		# rd: # Route distinguisher of the VRF
		# interfaces: # Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF. The name of interface should be in expanded format and not abbreviated.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
		# aggregate: # L
		# purge: no
		# delay: 10
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_logging "Manage logging on network devices" b
- name: $1
	eos_logging:
		# dest: on|host|console'|monitor|buffered
		# name: # If value of C(dest) is I(host) C(name) should be specified, which indicates hostname or IP address.
		# size: # Size of buffer. The acceptable value is in range from 10 to 2147483647 bytes.
		# facility: # Set logging facility.
		# level: emergencies|alerts|critical|errors|warnings|notifications|informational|debugging
		# aggregate: # L
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_facts "Collect facts from remote devices running Arista EOS" b
- name: $1
	eos_facts:
		# gather_subset: !config
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_command "Run arbitrary commands on an Arista EOS device" b
- name: $1
	eos_command:
		commands: ${2:# The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
		# wait_for: # Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails. Note - With I(wait_for) the value in C(result['stdout']) can be accessed using C(result), that is to access C(result['stdout'][0]) use C(result[0]) See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_eapi "Manage and configure Arista EOS eAPI." b
- name: $1
	eos_eapi:
		# http: no
		# http_port: 80
		# https: yes
		# https_port: 443
		# local_http: no
		# local_http_port: 8080
		# socket: no
		# vrf: default
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# state: #started|stopped
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_user "Manage the collection of local users on EOS devices" b
- name: $1
	eos_user:
		# aggregate: # The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument.
		# name: # The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
		# configured_password: # The password to be configured on the remote Arista EOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).
		# update_password: on_create|#always
		# privilege: # The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.
		# role: # Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.
		# sshkey: # Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.
		# nopassword: # Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.
		# purge: no
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_static_route "Manage static IP routes on Arista EOS network devices" b
- name: $1
	eos_static_route:
		address: ${2:# Network address with prefix of the static route.}
		next_hop: ${3:# Next hop IP of the static route.}
		# admin_distance: 1
		# aggregate: # L
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_linkagg "Manage link aggregation groups on Arista EOS network devices" b
- name: $1
	eos_linkagg:
		# group: # Channel-group number for the port-channel Link aggregation group. Range 1-2000.
		# mode: active|on|passive
		# members: # List of members of the link aggregation group.
		# min_links: # Minimum number of ports required up before bringing up the link aggregation group.
		# aggregate: # L
		# state: #present|absent
		# purge: no
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_interface "Manage Interface on Arista EOS network devices" b
- name: $1
	eos_interface:
		name: ${2:# Name of the Interface to be configured on remote device. The name of interface should be in expanded format and not abbreviated.}
		# description: # Description of Interface upto 240 characters.
		# enabled: yes
		# speed: # This option configures autoneg and speed/duplex/flowcontrol for the interface given in C(name) option.
		# mtu: # Set maximum transmission unit size in bytes of transmit packet for the interface given in C(name) option.
		# tx_rate: # Transmit rate in bits per second (bps) for the interface given in C(name) option.
		# rx_rate: # Receiver rate in bits per second (bps) for the interface given in C(name) option.
		# neighbors: # Check the operational state of given interface C(name) for LLDP neighbor.
		# aggregate: # List of Interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and other options as required.
		# delay: 10
		# state: #present|absent|up|down
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_vlan "Manage VLANs on Arista EOS network devices" b
- name: $1
	eos_vlan:
		vlan_id: ${2:# ID of the VLAN.}
		# name: # Name of the VLAN.
		# interfaces: # List of interfaces that should be associated to the VLAN. The name of interface is case sensitive and should be in expanded format and not abbreviated.
		# associated_interfaces: # This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. The name of interface is case sensitive and should be in expanded format and not abbreviated. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
		# delay: 10
		# aggregate: # L
		# purge: no
		# state: #present|absent|active|suspend
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_banner "Manage multiline banners on Arista EOS devices" b
- name: $1
	eos_banner:
		banner: ${2:login|motd}
		# text: # The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_l3_interface "Manage L3 interfaces on Arista EOS network devices." b
- name: $1
	eos_l3_interface:
		# name: # Name of the L3 interface to be configured eg. ethernet1
		# ipv4: # IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
		# ipv6: # IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
		# aggregate: # List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
		# state: #present|absent
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet eos_l2_interface "Manage L2 interfaces on Arista EOS network devices." b
- name: $1
	eos_l2_interface:
		name: ${2:# Name of the interface}
		# mode: access|trunk
		# access_vlan: # Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.
		# native_vlan: # Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.
		# trunk_allowed_vlans: # List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the ONLY VLANs that will be configured on the trunk, i.e. C(2-10,15).
		# aggregate: # List of Layer-2 interface definitions.
		# state: #present|absent|unconfigured
		# authorize: no
		# auth_pass: # B(Deprecated)
		# provider: # B(Deprecated)
$0
endsnippet

snippet dellos6_config "Manage Dell EMC Networking OS6 configuration sections" b
- name: $1
	dellos6_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# update: #merge|check
		# save: no
		# config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# backup: no
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos6_command "Run commands on remote devices running Dell OS6" b
- name: $1
	dellos6_command:
		commands: ${2:# List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet dellos6_facts "Collect facts from remote devices running Dell EMC Networking OS6" b
- name: $1
	dellos6_facts:
		# gather_subset: ['!config']
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet aruba_command "Run commands on remote devices running Aruba Mobility Controller" b
- name: $1
	aruba_command:
		commands: ${2:# List of commands to send to the remote aruba device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}
		# wait_for: # List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
		# match: any|#all
		# retries: 10
		# interval: 1
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet aruba_config "Manage Aruba configuration sections" b
- name: $1
	aruba_config:
		# lines: # The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
		# parents: # The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
		# src: # Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).
		# before: # The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
		# after: # The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
		# match: #line|strict|exact|none
		# replace: #line|block
		# backup: no
		# running_config: # The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
		# save_when: always|#never|modified|changed
		# diff_against: startup|intended|running
		# diff_ignore_lines: # Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.
		# intended_config: # The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).
		# encrypt: yes
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet etcd3 "Set or delete key value pairs from an etcd3 cluster" b
- name: $1
	etcd3:
		key: ${2:# the key where the information is stored in the cluster}
		value: ${3:# the information stored}
		state: ${4:# the state of the value for the key.}
		# host: localhost
		# port: 2379
$0
endsnippet

snippet consul_acl "Manipulate Consul ACL keys and rules" b
- name: $1
	consul_acl:
		# mgmt_token: # a management token is required to manipulate the acl lists
		# state: #present|absent
		# token_type: #client|management
		# name: # the name that should be associated with the acl key, this is opaque to Consul
		# token: # the token key indentifying an ACL rule set. If generated by consul this will be a UUID
		# rules: # a list of the rules that should be associated with a given token
		# host: localhost
		# port: 8500
		# scheme: http
		# validate_certs: yes
$0
endsnippet

snippet consul_session "Manipulate consul sessions" b
- name: $1
	consul_session:
		# state: absent|info|list|node|#present
		# name: # The name that should be associated with the session. This is opaque to Consul and not required.
		# delay: 15
		# node: # The name of the node that with which the session will be associated. by default this is the name of the agent.
		# datacenter: # The name of the datacenter in which the session exists or should be created.
		# checks: # A list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.
		# host: localhost
		# port: 8500
		# scheme: http
		# validate_certs: yes
		# behavior: delete|#release
$0
endsnippet

snippet consul "Add, modify & delete services within a consul cluster." b
- name: $1
	consul:
		state: ${2:present|absent}
		# service_name: # Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check
		# service_id: service_name if supplied
		# host: localhost
		# port: 8500
		# scheme: http
		# validate_certs: yes
		# notes: # Notes to attach to check when registering it.
		# service_port: # the port on which the service is listening. Can optionally be supplied for registration of a service, i.e. if service_name or service_id is set
		# service_address: # the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.
		# tags: # a list of tags that will be attached to the service registration.
		# script: # the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa
		# interval: # the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.
		# check_id: # an ID for the service check, defaults to the check name, ignored if part of a service definition.
		# check_name: # a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.
		# ttl: # checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m
		# http: # checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.
		# timeout: # A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.
		# token: # the token key indentifying an ACL rule set. May be required to register services.
$0
endsnippet

snippet znode "Create, delete, retrieve, and update znodes using ZooKeeper" b
- name: $1
	znode:
		hosts: ${2:# A list of ZooKeeper servers (format '[server]:[port]').}
		name: ${3:# The path of the znode.}
		# value: # The value assigned to the znode.
		# op: # An operation to perform. Mutually exclusive with state.
		# state: # The state to enforce. Mutually exclusive with op.
		# timeout: 300
		# recursive: no
$0
endsnippet

snippet pacemaker_cluster "Manage pacemaker clusters" b
- name: $1
	pacemaker_cluster:
		state: ${2:cleanup|offline|online|restart}
		# node: # Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.
		# timeout: 300
		# force: yes
$0
endsnippet

snippet consul_kv "Manipulate entries in the key/value store of a consul cluster" b
- name: $1
	consul_kv:
		key: ${2:# The key at which the value should be stored.}
		value: ${3:# The value should be associated with the given key, required if C(state) is C(present).}
		# state: absent|acquire|#present|release
		# recurse: no
		# session: # The session that should be used to acquire or release a lock associated with a key/value pair.
		# token: # The token key indentifying an ACL rule set that controls access to the key value pair
		# cas: # Used when acquiring a lock with a session. If the C(cas) is C(0), then Consul will only put the key if it does not already exist. If the C(cas) value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.
		# flags: # Opaque integer value that can be passed when setting a value.
		# host: localhost
		# port: 8500
		# scheme: http
		# validate_certs: yes
$0
endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
- name: $1
	k8s:
		# merge_type: json|merge|strategic-merge
		# state: #present|absent
		# force: no
		# api_version: v1
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# resource_definition: # Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# src: # Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
$0
endsnippet

snippet k8s_scale "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job." b
- name: $1
	k8s_scale:
		# api_version: v1
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# resource_definition: # Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# src: # Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# replicas: # The desired number of replicas.
		# current_replicas: # For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.
		# resource_version: # Only attempt to scale, if the current object version matches.
		# wait: yes
		# wait_timeout: 20
$0
endsnippet

snippet k8s_facts "Describe Kubernetes (K8s) objects" b
- name: $1
	k8s_facts:
		kind: ${2:# Use to specify an object model. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object.}
		# api_version: v1
		# name: # Use to specify an object name.  Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object.
		# namespace: # Use to specify an object namespace. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object.
		# label_selectors: # L
		# field_selectors: # L
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
$0
endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
- name: $1
	k8s:
		# merge_type: json|merge|strategic-merge
		# state: #present|absent
		# force: no
		# api_version: v1
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# resource_definition: # Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# src: # Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
$0
endsnippet

snippet k8s_scale "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job." b
- name: $1
	k8s_scale:
		# api_version: v1
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
		# resource_definition: # Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# src: # Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# replicas: # The desired number of replicas.
		# current_replicas: # For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.
		# resource_version: # Only attempt to scale, if the current object version matches.
		# wait: yes
		# wait_timeout: 20
$0
endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
- name: $1
	k8s:
		# merge_type: json|merge|strategic-merge
		# state: #present|absent
		# force: no
		# api_version: v1
		# kind: # Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.
		# name: # Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.
		# namespace: # Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.
		# resource_definition: # Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).
		# src: # Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.
		# host: # Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# api_key: # Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.
		# kubeconfig: # Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.
		# context: # The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.
		# username: # Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.
		# password: # Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.
		# cert_file: # Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.
		# key_file: # Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_HOST environment variable.
		# ssl_ca_cert: # Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.
		# verify_ssl: # Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.
$0
endsnippet

snippet netapp_e_facts "NetApp E-Series retrieve facts about NetApp E-Series storage arrays" b
- name: $1
	netapp_e_facts:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_gather_facts "NetApp information gatherer" b
- name: $1
	na_ontap_gather_facts:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #info
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_syslog "NetApp E-Series manage syslog settings" b
- name: $1
	netapp_e_syslog:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# state: #present|absent
		# address: # The syslog server's IPv4 address or a fully qualified hostname.
		# port: 514
		# protocol: #udp|tcp|tls
		# components: ['auditLog']
		# test: no
		# log_path: # This argument specifies a local path for logging purposes.
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_job_schedule "NetApp ONTAP Job Schedule" b
- name: $1
	na_ontap_job_schedule:
		name: ${2:# The name of the job-schedule to manage.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# job_minutes: # The minute(s) of each hour when the job should be run. Job Manager cron scheduling minute. -1 represents all minutes and only supported for cron schedule create and modify. Range is [-1..59]
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_auditlog "NetApp E-Series manage audit-log configuration" b
- name: $1
	netapp_e_auditlog:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# max_records: 50000
		# log_level: all|#writeOnly
		# full_policy: #overWrite|preventSystemAccess
		# threshold: 90
		# force: no
		# log_path: # A
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_service_processor_network "NetApp ONTAP service processor network" b
- name: $1
	na_ontap_service_processor_network:
		address_type: ${2:ipv4|ipv6}
		is_enabled: ${3:# Specify whether to enable or disable the service processor network.}
		node: ${4:# The node where the service processor network should be enabled}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present
		# dhcp: v4|none
		# gateway_ip_address: # Specify the gateway ip.
		# ip_address: # Specify the service processor ip address.
		# netmask: # Specify the service processor netmask.
		# prefix_length: # Specify the service processor prefix_length.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_dns "NetApp ONTAP Create, delete, modify DNS servers." b
- name: $1
	na_ontap_dns:
		vserver: ${2:# The name of the vserver to use.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# domains: # List of DNS domains such as 'sales.bar.com'. The first domain is the one that the Vserver belongs to.
		# nameservers: # List of IPv4 addresses of name servers such as '123.123.123.123'.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_cifs "NetApp ONTAP manage cifs-share" b
- name: $1
	na_ontap_cifs:
		vserver: ${2:# Vserver containing the CIFS share.}
		share_name: ${3:# T}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# path: # T
		# state: #present|absent
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_volume "NetApp ONTAP manage volumes." b
- name: $1
	na_ontap_volume:
		name: ${2:# The name of the volume to manage.}
		vserver: ${3:# Name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# from_name: # Name of the existing volume to be renamed to name.
		# is_infinite: # S
		# is_online: yes
		# aggregate_name: # The name of the aggregate the flexvol should exist on.
		# size: # The size of the volume in (size_unit). Required when C(state=present).
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# type: # The volume type, either read-write (RW) or data-protection (DP).
		# policy: # Name of the export policy.
		# junction_path: # Junction path of the volume.
		# space_guarantee: none|volume
		# percent_snapshot_space: # Amount of space reserved for snapshot copies of the volume.
		# volume_security_style: #mixed|ntfs|unified|unix
		# encrypt: no
		# efficiency_policy: # Allows a storage efficiency policy to be set on volume creation.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_export_policy "NetApp ONTAP manage export-policy" b
- name: $1
	na_ontap_export_policy:
		name: ${2:# The name of the export-policy to manage.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# from_name: # The name of the export-policy to be renamed.
		# vserver: # Name of the vserver to use.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_amg_sync "NetApp E-Series conduct synchronization actions on asynchronous mirror groups." b
- name: $1
	netapp_e_amg_sync:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		name: ${5:# The name of the async mirror group you wish to target}
		state: ${6:running|suspended}
		# validate_certs: yes
		# ssid: # The ID of the storage array containing the AMG you wish to target
		# delete_recovery_point: no
$0
endsnippet

snippet na_ontap_volume_clone "NetApp ONTAP manage volume clones." b
- name: $1
	na_ontap_volume_clone:
		parent_volume: ${2:# The parent volume of the volume clone being created.}
		volume: ${3:# The name of the volume clone being created.}
		vserver: ${4:# Vserver in which the volume clone should be created.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present
		# parent_snapshot: # Parent snapshot in which volume clone is created off.
		# parent_vserver: # Vserver of parent volume in which clone is created off.
		# qos_policy_group_name: # The qos-policy-group-name which should be set for volume clone.
		# space_reserve: volume|none
		# volume_type: rw|dp
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_flashcache "NetApp E-Series manage SSD caches" b
- name: $1
	netapp_e_flashcache:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# The ID of the array to manage (as configured on the web services proxy).}
		state: ${6:#present|absent}
		name: ${7:# The name of the SSD cache to manage}
		# validate_certs: yes
		# io_type: #filesystem|database|media
		# disk_count: # The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# cache_size_min: # The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.
$0
endsnippet

snippet na_elementsw_snapshot "NetApp Element Software Manage Snapshots" b
- name: $1
	na_elementsw_snapshot:
		src_volume_id: ${2:# ID or Name of active volume.}
		account_id: ${3:# Account ID or Name of Parent/Source Volume.}
		password: ${4:# Element OS access account password}
		username: ${5:# Element OS access account user-name}
		hostname: ${6:# The hostname or IP address of the SolidFire cluster.}
		# name: # Name of new snapshot create.
		# state: #present|absent
		# retention: # Retention period for the snapshot.
		# src_snapshot_id: # ID or Name of an existing snapshot.
		# enable_remote_replication: # Flag, whether to replicate the snapshot created to a remote replication cluster.
		# snap_mirror_label: # Label used by SnapMirror software to specify snapshot retention policy on SnapMirror endpoint.
		# expiration_time: # The date and time (format ISO 8601 date string) at which this snapshot will expire.
$0
endsnippet

snippet na_ontap_net_routes "NetApp ONTAP network routes" b
- name: $1
	na_ontap_net_routes:
		vserver: ${2:# The name of the vserver.}
		destination: ${3:# Specify the route destination.}
		gateway: ${4:# Specify the route gateway.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present|absent
		# metric: # Specify the route metric.
		# new_destination: # Specify the new route destination.
		# new_gateway: # Specify the new route gateway.
		# new_metric: # Specify the new route metric.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_volume "NetApp E-Series manage storage volumes (standard and thin)" b
- name: $1
	netapp_e_volume:
		state: ${2:present|absent}
		name: ${3:# The name of the volume to manage}
		storage_pool_name: ${4:# Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.}
		size: ${5:# Required only when state = 'present'.  The size of the volume in (size_unit).}
		thin_volume_repo_size: ${6:# Initial size of the thin volume repository volume (in size_unit)}
		api_username: ${7:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${8:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${9:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${10:# The ID of the array to manage. This value must be unique for each array.}
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# segment_size_kb: 512
		# thin_provision: no
		# thin_volume_max_repo_size: same as size (in size_unit)
		# ssd_cache_enabled: # Whether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)
		# data_assurance_enabled: no
		# validate_certs: yes
$0
endsnippet

snippet na_elementsw_volume "NetApp Element Software Manage Volumes" b
- name: $1
	na_elementsw_volume:
		state: ${2:present|absent}
		name: ${3:# The name of the volume to manage.}
		account_id: ${4:# Account ID for the owner of this volume.}
		password: ${5:# ElementSW access account password}
		username: ${6:# ElementSW access account user-name}
		hostname: ${7:# The hostname or IP address of the SolidFire cluster.}
		# enable512e: # Required when C(state=present)
		# qos: # I
		# attributes: # A
		# size: # The size of the volume in (size_unit).
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# access: readOnly|readWrite|locked|replicationTarget
$0
endsnippet

snippet netapp_e_amg_role "NetApp E-Series update the role of a storage array within an Asynchronous Mirror Group (AMG)." b
- name: $1
	netapp_e_amg_role:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# The ID of the primary storage array for the async mirror action}
		role: ${6:primary|secondary}
		# validate_certs: yes
		# noSync: no
		# force: no
$0
endsnippet

snippet na_ontap_net_port "NetApp ONTAP network ports." b
- name: $1
	na_ontap_net_port:
		node: ${2:# Specifies the name of node.}
		port: ${3:# Specifies the name of port.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present
		# mtu: # Specifies the maximum transmission unit (MTU) reported by the port.
		# autonegotiate_admin: # Enables or disables Ethernet auto-negotiation of speed, duplex and flow control.
		# duplex_admin: # Specifies the user preferred duplex setting of the port.
		# speed_admin: # Specifies the user preferred speed setting of the port.
		# flowcontrol_admin: # Specifies the user preferred flow control setting of the port.
		# ipspace: # Specifies the port's associated IPspace name.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_lun_map "NetApp ONTAP LUN maps" b
- name: $1
	na_ontap_lun_map:
		initiator_group_name: ${2:# Initiator group to map to the given LUN.}
		path: ${3:# Path of the LUN..}
		vserver: ${4:# The name of the vserver to use.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present|absent
		# lun_id: # LUN ID assigned for the map.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_user "NetApp ONTAP user configuration and management" b
- name: $1
	na_ontap_user:
		name: ${2:# The name of the user to manage.}
		application: ${3:console|http|ontapi|rsh|snmp|service-processor|sp|ssh|telnet}
		authentication_method: ${4:community|password|publickey|domain|nsswitch|usm}
		vserver: ${5:# The name of the vserver to use.}
		hostname: ${6:# The hostname or IP address of the ONTAP instance.}
		username: ${7:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${8:# Password for the specified user.}
		# state: #present|absent
		# set_password: # Password for the user account.
		# role_name: # The name of the role. Required when C(state=present)
		# lock_user: # Whether the specified user account is locked.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_lun_mapping "NetApp E-Series create, delete, or modify lun mappings" b
- name: $1
	netapp_e_lun_mapping:
		state: ${2:present|absent}
		volume_name: ${3:# The name of the volume you wish to include in the mapping.}
		api_username: ${4:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${5:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${6:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${7:# The ID of the array to manage. This value must be unique for each array.}
		# target: # The name of host or hostgroup you wish to assign to the mapping
		# lun: # The LUN value you wish to give the mapping.
		# target_type: host|group
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_snapmirror "NetApp ONTAP Manage SnapMirror" b
- name: $1
	na_ontap_snapmirror:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #present|absent
		# source_volume: # Specifies the name of the source volume for the SnapMirror.
		# destination_volume: # Specifies the name of the destination volume for the SnapMirror.
		# source_vserver: # Name of the source vserver for the SnapMirror.
		# destination_vserver: # Name of the destination vserver for the SnapMirror.
		# source_path: # Specifies the source endpoint of the SnapMirror relationship.
		# destination_path: # Specifies the destination endpoint of the SnapMirror relationship.
		# relationship_type: data_protection|load_sharing|vault|restore|transition_data_protection|extended_data_protection
		# schedule: # Specify the name of the current schedule, which is used to update the SnapMirror relationship.
		# source_hostname: # Source hostname or IP address.
		# source_username: # Source username.
		# source_password: # Source password.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_snapshot_schedule "NetApp Element Software Snapshot Schedules" b
- name: $1
	na_elementsw_snapshot_schedule:
		state: ${2:present|absent}
		password: ${3:# Element SW access account password}
		username: ${4:# Element SW access account user-name}
		hostname: ${5:# The hostname or IP address of the SolidFire cluster.}
		# paused: # Pause / Resume a schedule.
		# recurring: # Should the schedule recur?
		# schedule_type: DaysOfWeekFrequency|DaysOfMonthFrequency|TimeIntervalFrequency
		# time_interval_days: 1
		# time_interval_hours: 0
		# time_interval_minutes: 0
		# days_of_week_weekdays: # L
		# days_of_week_hours: 0
		# days_of_week_minutes: 0
		# days_of_month_monthdays: # L
		# days_of_month_hours: 0
		# days_of_month_minutes: 0
		# name: # Name for the snapshot schedule.
		# snapshot_name: # Name for the created snapshots.
		# volumes: # Volume IDs that you want to set the snapshot schedule for.
		# account_id: # Account ID for the owner of this volume.
		# retention: # Retention period for the snapshot.
		# starting_date: # Starting date for the schedule.
$0
endsnippet

snippet na_elementsw_node "NetApp Element Software Node Operation" b
- name: $1
	na_elementsw_node:
		node_id: ${2:# List of IDs or Names or IP Address of nodes from cluster used for operation.}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
$0
endsnippet

snippet na_ontap_command "NetApp ONTAP Run any cli command" b
- name: $1
	na_ontap_command:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# command: # a comma separated list containing the command and arguments.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_access_group "NetApp Element Software Manage Access Groups" b
- name: $1
	na_elementsw_access_group:
		state: ${2:present|absent}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# src_access_group_id: # ID or Name of the access group to modify or delete.
		# new_name: # New name for the access group for create and modify operation.
		# initiators: # List of initiators to include in the access group. If unspecified, the access group will start out without configured initiators.
		# volumes: # List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.
		# virtual_network_id: # The ID of the Element SW Software Cluster Virtual Network ID to associate the access group with.
		# virtual_network_tags: # The ID of the VLAN Virtual Network Tag to associate the access group with.
		# attributes: # L
$0
endsnippet

snippet na_elementsw_cluster_pair "NetApp Element Software Manage Cluster Pair" b
- name: $1
	na_elementsw_cluster_pair:
		dest_mvip: ${2:# Destination IP address of the cluster to be paired.}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# dest_username: # Destination username for the cluster to be paired.
		# dest_password: # Destination password for the cluster to be paired.
$0
endsnippet

snippet netapp_e_mgmt_interface "NetApp E-Series management interface configuration" b
- name: $1
	netapp_e_mgmt_interface:
		controller: ${2:A|B}
		api_username: ${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${6:# The ID of the array to manage. This value must be unique for each array.}
		# state: enable|disable
		# name: # The port to modify the configuration for.
		# channel: # The port to modify the configuration for.
		# address: # The IPv4 address to assign to the interface.
		# subnet_mask: # The subnet mask to utilize for the interface.
		# gateway: # The IPv4 gateway address to utilize for the interface.
		# config_method: dhcp|static
		# dns_config_method: dhcp|static
		# dns_address: # Primary IPv4 DNS server address
		# dns_address_backup: # Backup IPv4 DNS server address
		# ntp_config_method: disable|dhcp|static
		# ntp_address: # Primary IPv4 NTP server address
		# ntp_address_backup: # Backup IPv4 NTP server address
		# ssh: # Enable ssh access to the controller for debug purposes.
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_elementsw_volume_pair "NetApp Element Software Volume Pair" b
- name: $1
	na_elementsw_volume_pair:
		src_volume: ${2:# Source volume name or volume ID}
		src_account: ${3:# Source account name or ID}
		dest_volume: ${4:# Destination volume name or volume ID}
		dest_account: ${5:# Destination account name or ID}
		dest_mvip: ${6:# Destination IP address of the paired cluster.}
		hostname: ${7:# The hostname or IP address of the SolidFire cluster.}
		username: ${8:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${9:# Password for the specified user.}
		# state: #present|absent
		# mode: #async|sync|snapshotsonly
		# dest_username: # Destination username for the paired cluster
		# dest_password: # Destination password for the paired cluster
$0
endsnippet

snippet netapp_e_iscsi_interface "NetApp E-Series manage iSCSI interface configuration" b
- name: $1
	netapp_e_iscsi_interface:
		controller: ${2:A|B}
		name: ${3:# The channel of the port to modify the configuration of.}
		api_username: ${4:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${5:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${6:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${7:# The ID of the array to manage. This value must be unique for each array.}
		# state: #enabled|disabled
		# address: # The IPv4 address to assign to the interface.
		# subnet_mask: # The subnet mask to utilize for the interface.
		# gateway: # The IPv4 gateway address to utilize for the interface.
		# config_method: #dhcp|static
		# mtu: 1500
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_ntp "NetApp ONTAP NTP server" b
- name: $1
	na_ontap_ntp:
		server_name: ${2:# The name of the NTP server to manage.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# version: #auto|3|4
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_lun "NetApp ONTAP manage LUNs" b
- name: $1
	na_ontap_lun:
		name: ${2:# The name of the LUN to manage.}
		flexvol_name: ${3:# The name of the FlexVol the LUN should exist on.}
		vserver: ${4:# The name of the vserver to use.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present|absent
		# size: # The size of the LUN in C(size_unit).
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# force_resize: no
		# force_remove: no
		# force_remove_fenced: no
		# ostype: image
		# space_reserve: yes
		# space_allocation: no
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_net_vlan "NetApp ONTAP network VLAN" b
- name: $1
	na_ontap_net_vlan:
		parent_interface: ${2:# The interface that hosts the VLAN interface.}
		vlanid: ${3:# The VLAN id. Ranges from 1 to 4094.}
		node: ${4:# Node name of VLAN interface.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present|absent
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_cifs_server "NetApp ONTAP CIFS server configuration" b
- name: $1
	na_ontap_cifs_server:
		cifs_server_name: ${2:# Specifies the cifs_server name.}
		vserver: ${3:# The name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# service_state: stopped|started
		# admin_user_name: # Specifies the cifs server admin username.
		# admin_password: # Specifies the cifs server admin password.
		# domain: # The Fully Qualified Domain Name of the Windows Active Directory this CIFS server belongs to.
		# workgroup: # The NetBIOS name of the domain or workgroup this CIFS server belongs to.
		# ou: # The Organizational Unit (OU) within the Windows Active Directory this CIFS server belongs to.
		# force: # If this is set and a machine account with the same name as specified in 'cifs_server_name' exists in the Active Directory, it will be overwritten and reused.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_global "NetApp E-Series manage global settings configuration" b
- name: $1
	netapp_e_global:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# name: # Set the name of the E-Series storage-system
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_elementsw_ldap "NetApp Element Software Manage ldap admin users" b
- name: $1
	na_elementsw_ldap:
		state: ${2:present|absent}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# authType: DirectBind|SearchAndBind
		# groupSearchBaseDn: # The base DN of the tree to start the group search (will do a subtree search from here)
		# groupSearchType: NoGroup|ActiveDirectory|MemberDN
		# serverURIs: # A comma-separated list of LDAP server URIs
		# userSearchBaseDN: # The base DN of the tree to start the search (will do a subtree search from here)
		# searchBindDN: # A dully qualified DN to log in with to perform an LDAp search for the user (needs read access to the LDAP directory).
		# searchBindPassword: # The password for the searchBindDN account used for searching
		# userSearchFilter: # the LDAP Filter to use
		# userDNTemplate: # A string that is used form a fully qualified user DN.
		# groupSearchCustomFilter: # For use with the CustomFilter Search type
$0
endsnippet

snippet na_ontap_snapshot "NetApp ONTAP manage Snapshots" b
- name: $1
	na_ontap_snapshot:
		snapshot: ${2:# N}
		volume: ${3:# Name of the volume on which the snapshot is to be created.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# async_bool: # If true, the snapshot is to be created asynchronously.
		# comment: # A
		# snapmirror_label: # A
		# ignore_owners: # if this field is true, snapshot will be deleted even if some other processes are accessing it.
		# snapshot_instance_uuid: # The 128 bit unique snapshot identifier expressed in the form of UUID.
		# vserver: # The Vserver name
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_auth "NetApp E-Series set or update the password for a storage array." b
- name: $1
	netapp_e_auth:
		new_password: ${2:# The password you would like to set. Cannot be more than 30 characters.}
		# validate_certs: yes
		# name: # The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.
		# ssid: # the identifier of the storage array in the Web Services Proxy.
		# set_admin: no
		# current_password: # The current admin password. This is not required if the password hasn't been set before.
		# api_url: # The full API url.
		# api_username: # The username used to authenticate against the API
		# api_password: # The password used to authenticate against the API
$0
endsnippet

snippet na_ontap_node "NetApp ONTAP Rename a node." b
- name: $1
	na_ontap_node:
		name: ${2:# The new name for the node}
		from_name: ${3:# The name of the node to be renamed.  If I(name) already exists, no action will be performed.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_vlan "NetApp Element Software Manage VLAN" b
- name: $1
	na_elementsw_vlan:
		vlan_tag: ${2:# Virtual Network Tag}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# name: # User defined name for the new VLAN
		# svip: # Storage virtual IP which is unique
		# address_blocks: # List of address blocks for the VLAN
		# netmask: # Netmask for the VLAN
		# gateway: # Gateway for the VLAN
		# namespace: # Enable or disable namespaces
		# attributes: # Dictionary of attributes with name and value for each attribute
$0
endsnippet

snippet na_ontap_cifs_acl "NetApp ONTAP manage cifs-share-access-control" b
- name: $1
	na_ontap_cifs_acl:
		share_name: ${2:# The name of the cifs-share-access-control to manage.}
		vserver: ${3:# Name of the vserver to use.}
		user_or_group: ${4:# The user or group name for which the permissions are listed.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# permission: no_access|read|change|full_control
		# state: #present|absent
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_cluster_peer "NetApp ONTAP Manage Cluster peering" b
- name: $1
	na_ontap_cluster_peer:
		dest_hostname: ${2:# Destination cluster IP or hostname which needs to be peered.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# source_intercluster_lif: # Intercluster address of the source cluster.
		# dest_intercluster_lif: # Intercluster address of the destination cluster.
		# passphrase: # The arbitrary passphrase that matches the one given to the peer cluster.
		# source_cluster_name: # The name of the source cluster name in the peer relation to be deleted.
		# dest_cluster_name: # The name of the destination cluster name in the peer relation to be deleted.
		# dest_username: # Destination username.
		# dest_password: # Destination password.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_storage_system "NetApp E-Series Web Services Proxy manage storage arrays" b
- name: $1
	netapp_e_storage_system:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		state: ${6:present|absent}
		controller_addresses: ${7:# The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.}
		# validate_certs: yes
		# array_wwn: # The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.
		# array_password: # The management password of the array to manage, if set.
		# enable_trace: no
		# meta_tags: # Optional meta tags to associate to this storage system
$0
endsnippet

snippet na_ontap_nfs "NetApp ONTAP NFS status" b
- name: $1
	na_ontap_nfs:
		vserver: ${2:# Name of the vserver to use.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# service_state: started|stopped
		# nfsv3: enabled|disabled
		# nfsv3_fsid_change: enabled|disabled
		# nfsv4: enabled|disabled
		# nfsv41: enabled|disabled
		# vstorage_state: enabled|disabled
		# nfsv4_id_domain: # Name of the nfsv4_id_domain to use.
		# nfsv40_acl: enabled|disabled
		# nfsv40_read_delegation: enabled|disabled
		# nfsv40_write_delegation: enabled|disabled
		# nfsv41_acl: enabled|disabled
		# nfsv41_read_delegation: enabled|disabled
		# nfsv41_write_delegation: enabled|disabled
		# tcp: enabled|disabled
		# udp: enabled|disabled
		# showmount: enabled|disabled
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_cluster "NetApp Element Software Create Cluster" b
- name: $1
	na_elementsw_cluster:
		management_virtual_ip: ${2:# Floating (virtual) IP address for the cluster on the management network.}
		storage_virtual_ip: ${3:# Floating (virtual) IP address for the cluster on the storage (iSCSI) network.}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		username: ${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${6:# Password for the specified user.}
		# replica_count: 2
		# cluster_admin_username: # Username for the cluster admin.
		# cluster_admin_password: # Initial password for the cluster admin account.
		# accept_eula: # Required to indicate your acceptance of the End User License Agreement when creating this cluster.
		# nodes: # Storage IP (SIP) addresses of the initial set of nodes making up the cluster.
		# attributes: # List of name-value pairs in JSON object format.
$0
endsnippet

snippet na_ontap_svm_options "NetApp ONTAP Modify SVM Options" b
- name: $1
	na_ontap_svm_options:
		vserver: ${2:# The name of the vserver to which this option belongs to.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# name: # Name of the option.
		# value: # Value of the option.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_broadcast_domain "NetApp ONTAP manage broadcast domains.." b
- name: $1
	na_ontap_broadcast_domain:
		broadcast_domain: ${2:# Specify the broadcast_domain name}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# mtu: # Specify the required mtu for the broadcast domain
		# ipspace: # Specify the required ipspace for the broadcast domain.
		# ports: # Specify the ports associated with this broadcast domain. Should be comma separated
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_amg "NetApp E-Series create, remove, and update asynchronous mirror groups" b
- name: $1
	netapp_e_amg:
		name: ${2:# The name of the async array you wish to target, or create.}
		secondaryArrayId: ${3:# The ID of the secondary array to be used in mirroing process}
		state: ${4:absent|present}
		api_username: ${5:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${6:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${7:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${8:# The ID of the array to manage. This value must be unique for each array.}
		# syncIntervalMinutes: 10
		# manualSync: no
		# recoveryWarnThresholdMinutes: 20
		# repoUtilizationWarnThreshold: 80
		# interfaceType: iscsi|fibre
		# syncWarnThresholdMinutes: 10
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_iscsi "NetApp ONTAP manage iSCSI service" b
- name: $1
	na_ontap_iscsi:
		vserver: ${2:# The name of the vserver to use.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# service_state: started|stopped
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_volume_clone "NetApp Element Software Create Volume Clone" b
- name: $1
	na_elementsw_volume_clone:
		name: ${2:# The name of the clone.}
		src_volume_id: ${3:# The id of the src volume to clone. id may be a numeric identifier or a volume name.}
		account_id: ${4:# Account ID for the owner of this cloned volume. id may be a numeric identifier or an account name.}
		hostname: ${5:# The hostname or IP address of the SolidFire cluster.}
		username: ${6:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${7:# Password for the specified user.}
		# src_snapshot_id: # The id of the snapshot to clone. id may be a numeric identifier or a snapshot name.
		# attributes: # A
		# size: # The size of the cloned volume in (size_unit).
		# size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# access: readOnly|readWrite|locked|replicationTarget
$0
endsnippet

snippet na_ontap_interface "NetApp ONTAP LIF configuration" b
- name: $1
	na_ontap_interface:
		interface_name: ${2:# Specifies the logical interface (LIF) name.}
		vserver: ${3:# The name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# home_node: # Specifies the LIF's home node.
		# home_port: # Specifies the LIF's home port.
		# role: # Specifies the role of the LIF.
		# address: # Specifies the LIF's IP address.
		# netmask: # Specifies the LIF's netmask.
		# firewall_policy: # Specifies the firewall policy for the LIF.
		# failover_policy: # Specifies the failover policy for the LIF.
		# admin_status: up|down
		# is_auto_revert: # I
		# protocols: # S
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_alerts "NetApp E-Series manage email notification settings" b
- name: $1
	netapp_e_alerts:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# state: #enabled|disabled
		# server: # A fully qualified domain name, IPv4 address, or IPv6 address of a mail server.
		# sender: # This is the sender that the recipient will see. It doesn't necessarily need to be a valid email account.
		# contact: # Allows the owner to specify some free-form contact information to be included in the emails.
		# recipients: # The email addresses that will receive the email notifications.
		# test: no
		# log_path: # Path to a file on the Ansible control node to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_iscsi_target "NetApp E-Series manage iSCSI target configuration" b
- name: $1
	netapp_e_iscsi_target:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# name: # The name/alias to assign to the iSCSI target.
		# ping: yes
		# chap_secret: # Enable Challenge-Handshake Authentication Protocol (CHAP), utilizing this value as the password.
		# unnamed_discovery: yes
		# log_path: # A local path (on the Ansible controller), to a file to be used for debug logging.
		# validate_certs: yes
$0
endsnippet

snippet na_elementsw_check_connections "NetApp Element Software Check connectivity to MVIP and SVIP." b
- name: $1
	na_elementsw_check_connections:
		hostname: ${2:# The hostname or IP address of the SolidFire cluster.}
		username: ${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${4:# Password for the specified user.}
		# skip: svip|mvip
		# mvip: # Optionally, use to test connection of a different MVIP.
		# svip: # Optionally, use to test connection of a different SVIP.
$0
endsnippet

snippet netapp_e_ldap "NetApp E-Series manage LDAP integration to use for authentication" b
- name: $1
	netapp_e_ldap:
		username: ${2:# This is the user account that will be used for querying the LDAP server.}
		password: ${3:# This is the password for the bind user account.}
		server: ${4:# This is the LDAP server url.}
		search_base: ${5:# The search base is used to find group memberships of the user.}
		role_mappings: ${6:# This is where you specify which groups should have access to what permissions for the storage-system.}
		api_username: ${7:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${8:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${9:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${10:# The ID of the array to manage. This value must be unique for each array.}
		# state: #present|absent
		# identifier: # This is a unique identifier for the configuration (for cases where there are multiple domains configured).
		# attributes: memberOf
		# name: # The domain name[s] that will be utilized when authenticating to identify which domain to utilize.
		# user_attribute: sAMAccountName
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_motd "Setup motd on cDOT" b
- name: $1
	na_ontap_motd:
		vserver: ${2:# The name of the SVM motd should be set for.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# message: # MOTD Text message, required when C(state=present).
		# show_cluster_motd: yes
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_svm "Manage NetApp ONTAP svm" b
- name: $1
	na_ontap_svm:
		name: ${2:# The name of the SVM to manage.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# from_name: # Name of the SVM to be renamed
		# root_volume: # Root volume of the SVM.
		# root_volume_aggregate: # The aggregate on which the root volume will be created.
		# root_volume_security_style: unix|ntfs|mixed|unified
		# allowed_protocols: # Allowed Protocols.
		# aggr_list: # List of aggregates assigned for volume operations.
		# ipspace: # IPSpace name
		# snapshot_policy: # Default snapshot policy setting for all volumes of the Vserver. This policy will be assigned to all volumes created in this Vserver unless the volume create request explicitly provides a snapshot policy or volume is modified later with a specific snapshot policy. A volume-level snapshot policy always overrides the default Vserver-wide snapshot policy.
		# language: # Language to use for the SVM
		# subtype: default|dp_destination|sync_source|sync_destination
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_asup "NetApp E-Series manage auto-support settings" b
- name: $1
	netapp_e_asup:
		api_username: ${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${5:# The ID of the array to manage. This value must be unique for each array.}
		# state: #enabled|disabled
		# active: yes
		# start: 0
		# end: 24
		# days: monday|tuesday|wednesday|thursday|friday|saturday|sunday
		# verbose: no
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_cg_snapshot "NetApp ONTAP manage consistency group snapshot" b
- name: $1
	na_ontap_cg_snapshot:
		vserver: ${2:# Name of the vserver.}
		volumes: ${3:# A list of volumes in this filer that is part of this CG operation.}
		snapshot: ${4:# The provided name of the snapshot that is created in each volume.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: present
		# timeout: urgent|#medium|relaxed
		# snapmirror_label: # A human readable SnapMirror label to be attached with the consistency group snapshot copies.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_qtree "NetApp ONTAP manage qtrees" b
- name: $1
	na_ontap_qtree:
		name: ${2:# The name of the qtree to manage.}
		vserver: ${3:# The name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# from_name: # Name of the qtree to be renamed.
		# flexvol_name: # The name of the FlexVol the qtree should exist on. Required when C(state=present).
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_firewall_policy "NetApp ONTAP Manage a firewall policy" b
- name: $1
	na_ontap_firewall_policy:
		policy: ${2:# A policy name for the firewall policy}
		service: ${3:http|https|ntp|rsh|snmp|ssh|telnet}
		vserver: ${4:# The Vserver to apply the policy to.}
		node: ${5:# The node to run the firewall configuration on}
		hostname: ${6:# The hostname or IP address of the ONTAP instance.}
		username: ${7:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${8:# Password for the specified user.}
		# state: #present|absent
		# allow_list: # A list of IPs and masks to use
		# enable: #enable|disable
		# logging: enable|#disable
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_drive "NetApp Element Software Manage Node Drives" b
- name: $1
	na_elementsw_drive:
		node_id: ${2:# ID or Name of cluster node.}
		hostname: ${3:# The hostname or IP address of the SolidFire cluster.}
		username: ${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${5:# Password for the specified user.}
		# drive_id: # Drive ID or Serial Name of Node drive.
		# state: #present|absent|clean
		# force_during_upgrade: # Flag to force drive operation during upgrade.
		# force_during_bin_sync: # Flag to force during a bin sync operation.
$0
endsnippet

snippet netapp_e_snapshot_volume "NetApp E-Series manage snapshot volumes." b
- name: $1
	netapp_e_snapshot_volume:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# storage array ID}
		snapshot_image_id: ${6:# The identifier of the snapshot image used to create the new snapshot volume.}
		name: ${7:# The name you wish to give the snapshot volume}
		view_mode: ${8:modeUnknown|readWrite|readOnly|__UNDEFINED}
		storage_pool_name: ${9:# Name of the storage pool on which to allocate the repository volume.}
		state: ${10:absent|present}
		# validate_certs: yes
		# full_threshold: 85
		# repo_percentage: 20
$0
endsnippet

snippet na_elementsw_account "NetApp Element Software Manage Accounts" b
- name: $1
	na_elementsw_account:
		state: ${2:present|absent}
		element_username: ${3:# Unique username for this account. (May be 1 to 64 characters in length).}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		username: ${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${6:# Password for the specified user.}
		# new_element_username: # New name for the user account.
		# initiator_secret: # CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.
		# target_secret: # CHAP secret to use for the target (mutual CHAP authentication).
		# attributes: # L
		# account_id: # The ID of the account to manage or update.
		# status: # Status of the account.
$0
endsnippet

snippet netapp_e_snapshot_group "NetApp E-Series manage snapshot groups" b
- name: $1
	netapp_e_snapshot_group:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		state: ${5:present|absent}
		name: ${6:# The name to give the snapshot group}
		base_volume_name: ${7:# The name of the base volume or thin volume to use as the base for the new snapshot group.}
		storage_pool_name: ${8:# The name of the storage pool on which to allocate the repository volume.}
		# validate_certs: yes
		# repo_pct: 20
		# warning_threshold: 80
		# delete_limit: 30
		# full_policy: #purgepit|unknown|failbasewrites|__UNDEFINED
		# rollback_priority: highest|high|#medium|low|lowest|__UNDEFINED
$0
endsnippet

snippet na_ontap_cluster "NetApp ONTAP cluster - create, join, add license" b
- name: $1
	na_ontap_cluster:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #present
		# cluster_name: # The name of the cluster to manage.
		# cluster_ip_address: # IP address of cluster to be joined
		# license_code: # License code to be applied to the cluster
		# license_package: # License package name of the license to be removed
		# node_serial_number: # Serial number of the cluster node
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_autosupport "NetApp ONTAP manage Autosupport" b
- name: $1
	na_ontap_autosupport:
		node_name: ${2:# The name fo the filer that owns the AutoSupport Configuration.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# transport: http|https|smtp
		# noteto: # Specifies up to five recipients of full AutoSupport e-mail messages.
		# post_url: # The URL used to deliver AutoSupport messages via HTTP POST
		# mail_hosts: # List of mail server(s) used to deliver AutoSupport messages via SMTP.
		# support: # Specifies whether AutoSupport notification to technical support is enabled.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_host "NetApp E-Series manage eseries hosts" b
- name: $1
	netapp_e_host:
		name: ${2:# If the host doesn't yet exist, the label/name to assign at creation time.}
		api_username: ${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${6:# The ID of the array to manage. This value must be unique for each array.}
		# state: absent|#present
		# host_type_index: # The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.
		# ports: # A list of host ports you wish to associate with the host.
		# force_port: # Allow ports that are already assigned to be re-assigned to your current host
		# group: # The unique identifier of the host-group you want the host to be a member of; this is used for clustering.
		# log_path: # A local path to a file to be used for debug logging
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_ucadapter "NetApp ONTAP UC adapter configuration" b
- name: $1
	na_ontap_ucadapter:
		adapter_name: ${2:# Specifies the adapter name.}
		node_name: ${3:# Specifies the adapter home node.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present
		# mode: # Specifies the mode of the adapter.
		# type: # Specifies the fc4 type of the adapter.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_snapshot_restore "NetApp Element Software Restore Snapshot" b
- name: $1
	na_elementsw_snapshot_restore:
		src_volume_id: ${2:# ID or Name of source active volume.}
		src_snapshot_id: ${3:# ID or Name of an existing snapshot.}
		dest_volume_name: ${4:# New Name of destination for restoring the snapshot}
		account_id: ${5:# Account ID or Name of Parent/Source Volume.}
		hostname: ${6:# The hostname or IP address of the SolidFire cluster.}
		username: ${7:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${8:# Password for the specified user.}
$0
endsnippet

snippet na_elementsw_backup "NetApp Element Software Create Backups" b
- name: $1
	na_elementsw_backup:
		src_hostname: ${2:# hostname for the backup source cluster}
		src_username: ${3:# username for the backup source cluster}
		src_password: ${4:# password for the backup source cluster}
		src_volume_id: ${5:# ID of the backup source volume.}
		dest_volume_id: ${6:# ID of the backup destination volume}
		hostname: ${7:# The hostname or IP address of the SolidFire cluster.}
		username: ${8:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${9:# Password for the specified user.}
		# dest_hostname: # hostname for the backup source cluster
		# dest_username: # username for the backup destination cluster
		# dest_password: # password for the backup destination cluster
		# format: #native|uncompressed
		# script: # the backup script to be executed
		# script_parameters: # the backup script parameters
$0
endsnippet

snippet na_ontap_broadcast_domain_ports "NetApp ONTAP manage broadcast domain ports" b
- name: $1
	na_ontap_broadcast_domain_ports:
		broadcast_domain: ${2:# Specify the broadcast_domain name}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# ipspace: # Specify the ipspace for the broadcast domain
		# ports: # Specify the list of ports to add to or remove from this broadcast domain.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_export_policy_rule "NetApp ONTAP manage export policy rules" b
- name: $1
	na_ontap_export_policy_rule:
		policy_name: ${2:# The name of the export rule to manage.}
		vserver: ${3:# Name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# client_match: # List of Client Match Hostnames, IP Addresses, Netgroups, or Domains
		# ro_rule: any|none|never|krb5|krb5i|krb5p|ntlm|sys
		# rw_rule: any|none|never|krb5|krb5i|krb5p|ntlm|sys
		# super_user_security: any|none|never|krb5|krb5i|krb5p|ntlm|sys
		# allow_suid: # If 'true', NFS server will honor SetUID bits in SETATTR operation. Default value on creation is 'true'
		# protocol: #any|nfs|nfs3|nfs4|cifs|flexcache
		# rule_index: # rule index of the export policy for delete and modify
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_igroup "NetApp ONTAP iSCSI igroup configuration" b
- name: $1
	na_ontap_igroup:
		name: ${2:# The name of the igroup to manage.}
		vserver: ${3:# The name of the vserver to use.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# initiator_group_type: fcp|iscsi|mixed
		# from_name: # Name of igroup to rename to name.
		# ostype: # OS type of the initiators within the group.
		# initiator: # WWPN, WWPN Alias, or iSCSI name of Initiator to add or remove.
		# bind_portset: # Name of a current portset to bind to the newly created igroup.
		# force_remove_initiator: # Forcibly remove the initiator even if there are existing LUNs mapped to this initiator group.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_net_ifgrp "NetApp Ontap modify network interface group" b
- name: $1
	na_ontap_net_ifgrp:
		name: ${2:# Specifies the interface group name.}
		node: ${3:# Specifies the name of node.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# distribution_function: mac|ip|sequential|port
		# mode: # Specifies the link policy for the ifgrp.
		# port: # Adds the specified port.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_snapshot_images "NetApp E-Series create and delete snapshot images" b
- name: $1
	netapp_e_snapshot_images:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		snapshot_group: ${5:# The name of the snapshot group in which you want to create a snapshot image.}
		state: ${6:create|remove}
		# validate_certs: yes
$0
endsnippet

snippet netapp_e_hostgroup "NetApp E-Series manage array host groups" b
- name: $1
	netapp_e_hostgroup:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API.}
		ssid: ${5:# The ID of the array to manage (as configured on the web services proxy).}
		state: ${6:present|absent}
		# validate_certs: yes
		# name: # The name of the host group to manage. Either this or C(id_num) must be supplied.
		# new_name: # specify this when you need to update the name of a host group
		# id: # The id number of the host group to manage. Either this or C(name) must be supplied.
		# hosts: # a list of host names/labels to add to the group
$0
endsnippet

snippet na_ontap_software_update "NetApp ONTAP Update Software" b
- name: $1
	na_ontap_software_update:
		package_version: ${2:# Specifies the package version.}
		package_url: ${3:# Specifies the package URL.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# node: # List of nodes to be updated, the nodes have to be a part of a HA Pair.
		# ignore_validation_warning: no
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_vserver_peer "NetApp ONTAP Vserver peering" b
- name: $1
	na_ontap_vserver_peer:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #present|absent
		# vserver: # Specifies name of the source Vserver in the relationship.
		# applications: snapmirror|file_copy|lun_copy
		# peer_vserver: # Specifies name of the peer Vserver in the relationship.
		# peer_cluster: # Specifies name of the peer Cluster.
		# dest_hostname: # Destination hostname or IP address.
		# dest_username: # Destination username.
		# dest_password: # Destination password.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_license "NetApp ONTAP protocol and feature licenses" b
- name: $1
	na_ontap_license:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #present|absent
		# remove_unused: # Remove licenses that have no controller affiliation in the cluster.
		# remove_expired: # Remove licenses that have expired in the cluster.
		# serial_number: # S
		# license_names: # List of license-names to delete.
		# license_codes: # List of license codes to be added.
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_elementsw_network_interfaces "NetApp Element Software Configure Node Network Interfaces" b
- name: $1
	na_elementsw_network_interfaces:
		method: ${2:loopback|manual|dhcp|static}
		ip_address_1g: ${3:# IP address for the 1G network.}
		ip_address_10g: ${4:# IP address for the 10G network.}
		subnet_1g: ${5:# 1GbE Subnet Mask.}
		subnet_10g: ${6:# 10GbE Subnet Mask.}
		gateway_address_1g: ${7:# Router network address to send packets out of the local network.}
		gateway_address_10g: ${8:# Router network address to send packets out of the local network.}
		hostname: ${9:# The hostname or IP address of the SolidFire cluster.}
		username: ${10:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${11:# Password for the specified user.}
		# mtu_1g: 1500
		# mtu_10g: 1500
		# dns_nameservers: # List of addresses for domain name servers.
		# dns_search_domains: # List of DNS search domains.
		# bond_mode_1g: #ActivePassive|ALB|LACP
		# bond_mode_10g: #ActivePassive|ALB|LACP
		# lacp_1g: Fast|#Slow
		# lacp_10g: Fast|#Slow
		# virtual_network_tag: # This is the primary network tag. All nodes in a cluster have the same VLAN tag.
$0
endsnippet

snippet na_elementsw_admin_users "NetApp Element Software Manage Admin Users" b
- name: $1
	na_elementsw_admin_users:
		state: ${2:present|absent}
		element_username: ${3:# Unique username for this account. (May be 1 to 64 characters in length).}
		hostname: ${4:# The hostname or IP address of the SolidFire cluster.}
		username: ${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
		password: ${6:# Password for the specified user.}
		# element_password: # The password for the new admin account. Setting the password attribute will always reset your password, even if the password is the same
		# acceptEula: # Boolean, true for accepting Eula, False Eula
		# access: # A list of type the admin has access to
$0
endsnippet

snippet na_ontap_snmp "NetApp ONTAP SNMP community" b
- name: $1
	na_ontap_snmp:
		access_control: ${2:# Access control for the community. The only supported value is 'ro' (read-only)}
		community_name: ${3:# The name of the SNMP community to manage.}
		hostname: ${4:# The hostname or IP address of the ONTAP instance.}
		username: ${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${6:# Password for the specified user.}
		# state: #present|absent
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_disks "NetApp ONTAP Assign disks to nodes" b
- name: $1
	na_ontap_disks:
		node: ${2:# It specifies the node to assign all visible unowned disks.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_aggregate "NetApp ONTAP manage aggregates." b
- name: $1
	na_ontap_aggregate:
		name: ${2:# The name of the aggregate to manage.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# service_state: online|offline
		# from_name: # Name of the aggregate to be renamed.
		# nodes: # Node(s) for the aggregate to be created on.  If no node specified, mgmt lif home will be used.
		# disk_type: ATA|BSAS|FCAL|FSAS|LUN|MSATA|SAS|SSD|VMDISK
		# disk_count: # Number of disks to place into the aggregate, including parity disks.
		# disk_size: # Disk size to use in 4K block size.  Disks within 10% of specified size will be used.
		# raid_size: # Sets the maximum number of drives per raid group.
		# raid_type: # Specifies the type of RAID groups to use in the new aggregate.
		# unmount_volumes: # If set to "TRUE", this option specifies that all of the volumes hosted by the given aggregate are to be unmounted
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_storagepool "NetApp E-Series manage disk groups and disk pools" b
- name: $1
	netapp_e_storagepool:
		state: ${2:present|absent}
		name: ${3:# The name of the storage pool to manage}
		raid_level: ${4:raidAll|raid0|raid1|raid3|raid5|raid6|raidDiskPool}
		api_username: ${5:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_password: ${6:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
		api_url: ${7:# The url to the SANtricity Web Services Proxy or Embedded Web Services API.}
		ssid: ${8:# The ID of the array to manage. This value must be unique for each array.}
		# criteria_drive_count: # The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place
		# criteria_drive_type: hdd|ssd
		# criteria_size_unit: bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb
		# criteria_drive_min_size: # The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.
		# criteria_min_usable_capacity: # The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.
		# criteria_drive_interface_type: sas|sas4k|fibre|fibre520b|scsi|sata|pata
		# criteria_drive_require_fde: # Whether full disk encryption ability is required for drives to be added to the storage pool
		# erase_secured_drives: # Whether to erase secured disks before adding to storage pool
		# secure_pool: # Whether to convert to a secure storage pool. Will only work if all drives in the pool are security capable.
		# reserve_drive_count: # Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.
		# remove_volumes: no
		# validate_certs: yes
$0
endsnippet

snippet na_ontap_fcp "NetApp ONTAP Start, Stop and Enable FCP services." b
- name: $1
	na_ontap_fcp:
		vserver: ${2:# The name of the vserver to use.}
		hostname: ${3:# The hostname or IP address of the ONTAP instance.}
		username: ${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${5:# Password for the specified user.}
		# state: #present|absent
		# status: #up|down
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet na_ontap_user_role "NetApp ONTAP user role configuration and management" b
- name: $1
	na_ontap_user_role:
		name: ${2:# The name of the role to manage.}
		command_directory_name: ${3:# The command or command directory to which the role has an access.}
		vserver: ${4:# The name of the vserver to use.}
		hostname: ${5:# The hostname or IP address of the ONTAP instance.}
		username: ${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${7:# Password for the specified user.}
		# state: #present|absent
		# access_level: none|readonly|#all
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet netapp_e_volume_copy "NetApp E-Series create volume copy pairs" b
- name: $1
	netapp_e_volume_copy:
		api_username: ${2:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_password: ${3:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
		api_url: ${4:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
		state: ${5:present|absent}
		ssid: ${6:# The ID of the array to manage. This value must be unique for each array.}
		# validate_certs: yes
		# source_volume_id: # The id of the volume copy source.
		# destination_volume_id: # The id of the volume copy destination.
		# volume_copy_pair_id: # The id of a given volume copy pair
		# create_copy_pair_if_does_not_exist: yes
		# start_stop_copy: # starts a re-copy or stops a copy in progress
		# search_volume_id: # Searches for all valid potential target and source volumes that could be used in a copy_pair
$0
endsnippet

snippet na_ontap_cluster_ha "NetApp ONTAP Manage HA status for cluster" b
- name: $1
	na_ontap_cluster_ha:
		hostname: ${2:# The hostname or IP address of the ONTAP instance.}
		username: ${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
		password: ${4:# Password for the specified user.}
		# state: #present|absent
		# https: no
		# validate_certs: yes
		# http_port: # Override the default port (80 or 443) with this port
$0
endsnippet

snippet gluster_volume "Manage GlusterFS volumes" b
- name: $1
	gluster_volume:
		name: ${2:# The volume name.}
		state: ${3:absent|present|started|stopped}
		# cluster: # List of hosts to use for probing and brick setup.
		# host: # Override local hostname (for peer probing purposes).
		# replicas: # Replica count for volume.
		# arbiters: # Arbiter count for volume.
		# stripes: # Stripe count for volume.
		# disperses: # Disperse count for volume.
		# redundancies: # Redundancy count for volume.
		# transport: #tcp|rdma|tcp,rdma
		# bricks: # Brick paths on servers. Multiple brick paths can be separated by commas.
		# start_on_create: yes
		# rebalance: no
		# directory: # Directory for limit-usage.
		# options: # A dictionary/hash with options/settings for the volume.
		# quota: # Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list).
		# force: # If brick is being created in the root partition, module will fail. Set force to true to override this behaviour.
$0
endsnippet

snippet gluster_peer "Attach/Detach peers to/from the cluster" b
- name: $1
	gluster_peer:
		state: ${2:#present|absent}
		nodes: ${3:# List of nodes that have to be probed into the pool.}
		# force: false
$0
endsnippet

snippet purefb_snap "Manage filesystem snapshots on Pure Storage FlashBlades" b
- name: $1
	purefb_snap:
		name: ${2:# The name of the source filesystem.}
		# suffix: # Suffix of snapshot name.
		# state: absent|#present
		# eradicate: no
		# fb_url: # FlashBlade management IP address or Hostname.
		# api_token: # FlashBlade API token for admin privilaed user.
$0
endsnippet

snippet purefa_ds "Configure FlashArray Directory Service" b
- name: $1
	purefa_ds:
		base_dn: ${2:# Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# state: absent|#present
		# enable: no
		# uri: # A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname "ad" in the domain "company.com" while specifying the unencrypted LDAP protocol.
		# bind_password: # Sets the password of the bind_user user name account.
		# bind_user: # Sets the user name that can be used to bind to and query the directory.
		# group_base: # Specifies where the configured groups are located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right. Each OU should not exceed 64 characters in length.
		# ro_group: # Sets the common Name (CN) of the configured directory service group containing users with read-only privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
		# sa_group: # Sets the common Name (CN) of the configured directory service group containing administrators with storage-related privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
		# aa_group: # Sets the common Name (CN) of the directory service group containing administrators with full privileges when managing the FlashArray. The name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
$0
endsnippet

snippet purefa_facts "Collect facts from Pure Storage FlashArray" b
- name: $1
	purefa_facts:
		fa_url: ${2:# FlashArray management IPv4 address or Hostname.}
		api_token: ${3:# FlashArray API token for admin privilaged user.}
		# gather_subset: minimum
$0
endsnippet

snippet purefa_host "Manage hosts on Pure Storage FlashArrays" b
- name: $1
	purefa_host:
		host: ${2:# The name of the host.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# state: absent|#present
		# protocol: fc|#iscsi|mixed
		# wwns: # List of wwns of the host if protocol is fc or mixed.
		# iqn: # List of IQNs of the host if protocol is iscsi or mixed.
		# volume: # Volume name to map to the host.
		# personality: hpux|vms|aix|esxi|solaris|hitachi-vsp|oracle-vm-server|
$0
endsnippet

snippet purefb_fs "Manage filesystemon Pure Storage FlashBlade`" b
- name: $1
	purefb_fs:
		name: ${2:# Filesystem Name.}
		# state: #present|absent
		# eradicate: no
		# size: 32G
		# nfs: yes
		# nfs_rules: *(rw,no_root_squash)
		# smb: no
		# http: no
		# snapshot: no
		# fastremove: no
		# fb_url: # FlashBlade management IP address or Hostname.
		# api_token: # FlashBlade API token for admin privilaed user.
$0
endsnippet

snippet purefa_snap "Manage volume snapshots on Pure Storage FlashArrays" b
- name: $1
	purefa_snap:
		name: ${2:# The name of the source volume.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# suffix: # Suffix of snapshot name.
		# target: # Name of target volume if creating from snapshot.
		# overwrite: no
		# state: absent|copy|#present
		# eradicate: no
$0
endsnippet

snippet purefa_hg "Manage hostgroups on Pure Storage FlashArrays" b
- name: $1
	purefa_hg:
		hostgroup: ${2:# The name of the hostgroup.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# state: absent|#present
		# host: # List of existing hosts to add to hostgroup.
		# volume: # List of existing volumes to add to hostgroup.
$0
endsnippet

snippet purefa_volume "Manage volumes on Pure Storage FlashArrays" b
- name: $1
	purefa_volume:
		name: ${2:# The name of the volume.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# target: # The name of the target volume, if copying.
		# state: absent|#present
		# eradicate: no
		# overwrite: no
		# size: # Volume size in M, G, T or P units.
$0
endsnippet

snippet purefb_facts "Collect facts from Pure Storage FlashBlade" b
- name: $1
	purefb_facts:
		# gather_subset: minimum
		# fb_url: # FlashBlade management IP address or Hostname.
		# api_token: # FlashBlade API token for admin privilaed user.
$0
endsnippet

snippet purefa_pg "Manage protection groups on Pure Storage FlashArrays" b
- name: $1
	purefa_pg:
		pgroup: ${2:# The name of the protection group.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# state: absent|#present
		# volume: # List of existing volumes to add to protection group.
		# host: # List of existing hosts to add to protection group.
		# hostgroup: # List of existing hostgroups to add to protection group.
		# eradicate: no
		# enabled: yes
$0
endsnippet

snippet purefa_pgsnap "Manage local protection group snapshots on Pure Storage FlashArrays" b
- name: $1
	purefa_pgsnap:
		name: ${2:# The name of the source protection group.}
		fa_url: ${3:# FlashArray management IPv4 address or Hostname.}
		api_token: ${4:# FlashArray API token for admin privilaged user.}
		# suffix: # Suffix of snapshot name.
		# state: absent|#present|copy
		# eradicate: no
		# restore: # Restore a specific volume from a protection group snapshot. This implies overwrite of the current full volume. USE WITH CARE!!
$0
endsnippet

snippet ibm_sa_host "Adds hosts to or removes them from IBM Spectrum Accelerate storage systems." b
- name: $1
	ibm_sa_host:
		host: ${2:# Host name.}
		state: ${3:#present|absent}
		username: ${4:# Management user on the spectrum accelerate storage system.}
		password: ${5:# Password for username on the spectrum accelerate storage system.}
		endpoints: ${6:# The hostname or management IP of Spectrum Accelerate storage system.}
		# cluster: # The name of the cluster to include the host.
		# domain: # The domains the cluster will be attached to. To include more than one domain, separate domain names with commas. To include all existing domains, use an asterisk ("*").
		# iscsi_chap_name: # The host's CHAP name identifier
		# iscsi_chap_secret: # The password of the initiator used to authenticate to the system when CHAP is enable
$0
endsnippet

snippet ibm_sa_pool "Handles pools on an IBM Spectrum Accelerate storage array." b
- name: $1
	ibm_sa_pool:
		pool: ${2:# Pool name.}
		state: ${3:#present|absent}
		username: ${4:# Management user on the spectrum accelerate storage system.}
		password: ${5:# Password for username on the spectrum accelerate storage system.}
		endpoints: ${6:# The hostname or management IP of Spectrum Accelerate storage system.}
		# size: # Pool size in GB
		# snapshot_size: # Pool snapshot size in GB
		# domain: # Adds the pool to the specified domain.
		# perf_class: # Assigns a perf_class to the pool.
$0
endsnippet

snippet ibm_sa_vol "Handle volumes on an IBM Spectrum Accelerate storage array" b
- name: $1
	ibm_sa_vol:
		vol: ${2:# Volume name.}
		state: ${3:#present|absent}
		username: ${4:# Management user on the spectrum accelerate storage system.}
		password: ${5:# Password for username on the spectrum accelerate storage system.}
		endpoints: ${6:# The hostname or management IP of Spectrum Accelerate storage system.}
		# pool: # Volume pool.
		# size: # Volume size.
$0
endsnippet

snippet zfs_facts "Gather facts about ZFS datasets." b
- name: $1
	zfs_facts:
		name: ${2:# ZFS dataset name.}
		# recurse: no
		# parsable: no
		# properties: all
		# type: #all|filesystem|volume|snapshot|bookmark
		# depth: # Specifiies recurion depth.
$0
endsnippet

snippet zfs "Manage zfs" b
- name: $1
	zfs:
		name: ${2:# File system, snapshot or volume name e.g. C(rpool/myfs).}
		state: ${3:absent|present}
		# origin: # Snapshot from which to create a clone.
		# key_value: # (**DEPRECATED**) This will be removed in Ansible-2.9.  Set these values in the
		# extra_zfs_properties: # A dictionary of zfs properties to be set.
$0
endsnippet

snippet zpool_facts "Gather facts about ZFS pools." b
- name: $1
	zpool_facts:
		# name: # ZFS pool name.
		# parsable: no
		# properties: all
$0
endsnippet

snippet infini_export "Create, Delete or Modify NFS Exports on Infinibox" b
- name: $1
	infini_export:
		name: ${2:# Export name. Should always start with C(/). (ex. name=/data)}
		filesystem: ${3:# Name of exported file system.}
		system: ${4:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# inner_path: /
		# client_list: All Hosts(*), RW, no_root_squash: True
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_host "Create, Delete and Modify Hosts on Infinibox" b
- name: $1
	infini_host:
		name: ${2:# Host Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# wwns: # List of wwns of the host
		# volume: # Volume name to map to the host
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_pool "Create, Delete and Modify Pools on Infinibox" b
- name: $1
	infini_pool:
		name: ${2:# Pool Name}
		system: ${3:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# size: # Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.
		# vsize: # Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.
		# ssd_cache: yes
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_fs "Create, Delete or Modify filesystems on Infinibox" b
- name: $1
	infini_fs:
		name: ${2:# File system name.}
		pool: ${3:# Pool that will host file system.}
		system: ${4:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# size: # File system size in MB, GB or TB units. See examples.
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_export_client "Create, Delete or Modify NFS Client(s) for existing exports on Infinibox" b
- name: $1
	infini_export_client:
		client: ${2:# Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.}
		export: ${3:# Name of the export.}
		system: ${4:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# access_mode: #RW|RO
		# no_root_squash: no
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet infini_vol "Create, Delete or Modify volumes on Infinibox" b
- name: $1
	infini_vol:
		name: ${2:# Volume Name}
		pool: ${3:# Pool that volume will reside on}
		system: ${4:# Infinibox Hostname or IPv4 Address.}
		# state: #present|absent
		# size: # Volume size in MB, GB or TB units. See examples.
		# user: # Infinibox User username with sufficient priveledges ( see notes ).
		# password: # Infinibox User password.
$0
endsnippet

snippet emc_vnx_sg_member "Manage storage group member on EMC VNX" b
- name: $1
	emc_vnx_sg_member:
		name: ${2:# Name of the Storage group to manage.}
		lunid: ${3:# Lun id to be added.}
		sp_address: ${4:# Address of the SP of target/secondary storage.}
		# state: #present|absent
		# sp_user: sysadmin
		# sp_password: sysadmin
$0
endsnippet

snippet async_status "Obtain status of asynchronous task" b
- name: $1
	async_status:
		jid: ${2:# Job or task identifier}
		# mode: #status|cleanup
$0
endsnippet

snippet include_role "Load and execute a role" b
- name: $1
	include_role:
		name: ${2:# The name of the role to be executed.}
		# apply: # Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.
		# tasks_from: main
		# vars_from: main
		# defaults_from: main
		# allow_duplicates: yes
		# private: # This option is a no op, and the functionality described in previous versions was not implemented. This option will be removed in Ansible v2.8.
		# public: no
$0
endsnippet

snippet wait_for "Waits for a condition before continuing" b
- name: $1
	wait_for:
		# host: 127.0.0.1
		# timeout: 300
		# connect_timeout: 5
		# delay: 0
		# port: # Port number to poll.
		# active_connection_states: ['ESTABLISHED', 'FIN_WAIT1', 'FIN_WAIT2', 'SYN_RECV', 'SYN_SENT', 'TIME_WAIT']
		# state: absent|drained|present|#started|stopped
		# path: # Path to a file on the filesystem that must exist before continuing.
		# search_regex: # Can be used to match a string in either a file or a socket connection.
		# exclude_hosts: # List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.
		# sleep: 1
		# msg: # This overrides the normal error message from a failure to meet the required conditions.
$0
endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable" b
- name: $1
	wait_for_connection:
		# connect_timeout: 5
		# delay: 0
		# sleep: 1
		# timeout: 600
$0
endsnippet

snippet include_tasks "Dynamically include a task list" b
- name: $1
	include_tasks:
		# file: # The name of the imported file is specified directly without any other option.
		# apply: # Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.
		# free-form: # Supplying a file name via free-form C(- include_tasks: file.yml) of a file to be included is the equivalent
of specifying an argument of I(file).

$0
endsnippet

snippet import_tasks "Import a task list" b
- name: $1
	import_tasks:
		# free-form: # The name of the imported file is specified directly without any other option.
$0
endsnippet

snippet assert "Asserts given expressions are true" b
- name: $1
	assert:
		that: ${2:# A string expression of the same form that can be passed to the 'when' statement}
		# fail_msg: # The customized message used for a failing assertion
		# success_msg: # The customized message used for a successful assertion
$0
endsnippet

snippet include_vars "Load variables from files, dynamically within a task" b
- name: $1
	include_vars:
		# file: # The file name from which variables should be loaded.
		# dir: # The directory name from which the variables should be loaded.
		# name: # The name of a variable into which assign the included vars. If omitted (null) they will be made top level vars.
		# depth: 0
		# files_matching: # Limit the files that are loaded within any directory to this regular expression.
		# ignore_files: # List of file names to ignore.
		# extensions: ['yaml', 'yml', 'json']
		# ignore_unknown_extensions: no
		# free-form: # This module allows you to specify the 'file' option directly without any other options. There is no 'free-form' option, this is just an indicator, see example below.
$0
endsnippet

snippet fail "Fail with custom message" b
- name: $1
	fail:
		# msg: 'Failed as requested from task'
$0
endsnippet

snippet set_fact "Set host facts from a task" b
- name: $1
	set_fact:
		key_value: ${2:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}
		# cacheable: no
$0
endsnippet

snippet pause "Pause playbook execution" b
- name: $1
	pause:
		# minutes: # A positive number of minutes to pause for.
		# seconds: # A positive number of seconds to pause for.
		# prompt: # Optional text to use for the prompt message.
		# echo: yes
$0
endsnippet

snippet import_playbook "Import a playbook" b
- name: $1
	import_playbook:
		# free-form: # The name of the imported playbook is specified directly without any other option.
$0
endsnippet

snippet debug "Print statements during execution" b
- name: $1
	debug:
		# msg: Hello world!
		# var: # A variable name to debug.  Mutually exclusive with the 'msg' option.
		# verbosity: 0
$0
endsnippet

snippet import_role "Import a role into a play" b
- name: $1
	import_role:
		name: ${2:# The name of the role to be executed.}
		# tasks_from: main
		# vars_from: main
		# defaults_from: main
		# allow_duplicates: yes
		# private: no
$0
endsnippet

snippet include "Include a play or task list" b
- name: $1
	include:
		# free-form: # This module allows you to specify the name of the file directly without any other options.
$0
endsnippet

snippet set_stats "Set stats for the current ansible run" b
- name: $1
	set_stats:
		data: ${2:# A dictionary of which each key represents a stat (or variable) you want to keep track of}
		# per_host: no
		# aggregate: yes
$0
endsnippet

snippet meta "Execute Ansible 'actions'" b
- name: $1
	meta: $2
	args:
$0
endsnippet

snippet cronvar "Manage variables in crontabs" b
- name: $1
	cronvar:
		name: ${2:# Name of the crontab variable.}
		# value: # The value to set this variable to.
		# insertafter: # If specified, the variable will be inserted after the variable specified.
		# insertbefore: # Used with C(state=present). If specified, the variable will be inserted just before the variable specified.
		# state: absent|#present
		# user: root
		# cron_file: # If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.
		# backup: no
$0
endsnippet

snippet osx_defaults "osx_defaults allows users to read, write, and delete macOS user defaults from Ansible" b
- name: $1
	osx_defaults:
		key: ${2:# The key of the user preference}
		# domain: NSGlobalDomain
		# host: # The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.
		# type: array|bool|boolean|date|float|int|integer|#string
		# array_add: no
		# value: # The value to write. Only required when state = present.
		# state: #present|absent
$0
endsnippet

snippet service "Manage services" b
- name: $1
	service:
		name: ${2:# Name of the service.}
		# state: reloaded|restarted|started|stopped
		# sleep: # If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
		# pattern: # If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be started.
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# runlevel: default
		# arguments: # Additional arguments provided on the command line
		# use: auto
$0
endsnippet

snippet user "Manage user accounts" b
- name: $1
	user:
		name: ${2:# Name of the user to create, remove or modify.}
		# uid: # Optionally sets the I(UID) of the user.
		# comment: # Optionally sets the description (aka I(GECOS)) of user account.
		# hidden: # macOS only, optionally hide the user from the login window and system preferences.
		# non_unique: no
		# seuser: # Optionally sets the seuser type (user_u) on selinux enabled systems.
		# group: # Optionally sets the user's primary group (takes a group name).
		# groups: # List of groups user will be added to. When set to an empty string C(''), C(null), or C(~), the user is removed from all groups except the primary group. (C(~) means C(null) in YAML)
		# append: no
		# shell: # Optionally set the user's shell.
		# home: # Optionally set the user's home directory.
		# skeleton: # Optionally set a home skeleton directory. Requires create_home option!
		# password: # Optionally set the user's password to this crypted value.
		# state: absent|#present
		# create_home: yes
		# move_home: no
		# system: no
		# force: no
		# remove: no
		# login_class: # Optionally sets the user's login class, a feature of most BSD OSs.
		# generate_ssh_key: no
		# ssh_key_bits: default set by ssh-keygen
		# ssh_key_type: rsa
		# ssh_key_file: .ssh/id_rsa
		# ssh_key_comment: ansible-generated on $HOSTNAME
		# ssh_key_passphrase: # Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.
		# update_password: #always|on_create
		# expires: # An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on GNU/Linux, FreeBSD, and DragonFlyBSD.
		# password_lock: # Lock the password (usermod -L, pw lock, usermod -C). BUT implementation differs on different platforms, this option does not always mean the user cannot login via other methods. This option does not disable the user, only lock the password. Do not change the password in the same task. Currently supported on Linux, FreeBSD, DragonFlyBSD, NetBSD, OpenBSD.
		# local: no
$0
endsnippet

snippet python_requirements_facts "Show python path and assert dependency versions" b
- name: $1
	python_requirements_facts:
		# dependencies: # A
$0
endsnippet

snippet sefcontext "Manages SELinux file context mapping definitions" b
- name: $1
	sefcontext:
		target: ${2:# Target path (expression).}
		setype: ${3:# SELinux type for the specified target.}
		# ftype: a
		# seuser: # SELinux user for the specified target.
		# selevel: # SELinux range for the specified target.
		# state: absent|#present
		# reload: yes
$0
endsnippet

snippet selinux "Change policy and state of SELinux" b
- name: $1
	selinux:
		state: ${2:enforcing|permissive|disabled}
		# policy: # name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)
		# conf: /etc/selinux/config
$0
endsnippet

snippet crypttab "Encrypted Linux block devices" b
- name: $1
	crypttab:
		name: ${2:# Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).}
		state: ${3:absent|opts_absent|opts_present|present}
		# backing_device: # Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=).
		# password: none
		# opts: # A comma-delimited list of options. See C(crypttab(5) ) for details.
		# path: /etc/crypttab
$0
endsnippet

snippet gconftool2 "Edit GNOME Configurations" b
- name: $1
	gconftool2:
		key: ${2:# A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)}
		state: ${3:absent|get|present}
		# value: # Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)
		# value_type: bool|float|int|string
		# config_source: # Specify a configuration source to use rather than the default path. See man gconftool-2(1)
		# direct: no
$0
endsnippet

snippet open_iscsi "Manage iscsi targets with open-iscsi" b
- name: $1
	open_iscsi:
		# portal: # the ip address of the iscsi target
		# port: 3260
		# target: # the iscsi target name
		# login: # whether the target node should be connected
		# node_auth: CHAP
		# node_user: # discovery.sendtargets.auth.username
		# node_pass: # discovery.sendtargets.auth.password
		# auto_node_startup: # whether the target node should be automatically connected at startup
		# discover: # whether the list of target nodes on the portal should be (re)discovered and added to the persistent iscsi database. Keep in mind that iscsiadm discovery resets configurtion, like node.startup to manual, hence combined with auto_node_startup=yes will always return a changed state.
		# show_nodes: # whether the list of nodes in the persistent iscsi database should be returned by the module
$0
endsnippet

snippet aix_inittab "Manages the inittab on AIX" b
- name: $1
	aix_inittab:
		name: ${2:# Name of the inittab entry.}
		runlevel: ${3:# Runlevel of the entry.}
		action: ${4:boot|bootwait|hold|initdefault|False|once|ondemand|powerfail|powerwait|respawn|sysinit|wait}
		command: ${5:# What command has to run.}
		# insertafter: # After which inittabline should the new entry inserted.
		# state: absent|#present
$0
endsnippet

snippet ohai "Returns inventory data from I(Ohai)" b
- name: $1
	ohai:
$0
endsnippet

snippet debconf "Configure a .deb package" b
- name: $1
	debconf:
		name: ${2:# Name of package to configure.}
		# question: # A debconf configuration setting.
		# vtype: boolean|error|multiselect|note|password|seen|select|string|text|title|text
		# value: # Value to set the configuration to.
		# unseen: no
$0
endsnippet

snippet systemd "Manage services" b
- name: $1
	systemd:
		# name: # Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service).
		# state: reloaded|restarted|started|stopped
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# force: # Whether to override existing symlinks.
		# masked: # Whether the unit should be masked or not, a masked unit is impossible to start.
		# daemon_reload: no
		# user: no
		# scope: #system|user|global
		# no_block: no
$0
endsnippet

snippet cron "Manage cron.d and crontab entries" b
- name: $1
	cron:
		# name: # Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.
		# user: root
		# job: # The command to execute or, if env is set, the value of environment variable. The command should not contain line breaks. Required if state=present.
		# state: absent|#present
		# cron_file: # If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). Many linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens. To use the C(cron_file) parameter you must specify the C(user) as well.
		# backup: no
		# minute: *
		# hour: *
		# day: *
		# month: *
		# weekday: *
		# reboot: no
		# special_time: reboot|yearly|annually|monthly|weekly|daily|hourly
		# disabled: no
		# env: no
		# insertafter: # Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable.
		# insertbefore: # Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable.
$0
endsnippet

snippet getent "A wrapper to the unix getent utility" b
- name: $1
	getent:
		database: ${2:# The name of a getent database supported by the target system (passwd, group, hosts, etc).}
		# key: 
		# split: # Character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database.
		# fail_key: yes
$0
endsnippet

snippet modprobe "Load or unload kernel modules" b
- name: $1
	modprobe:
		name: ${2:# Name of kernel module to manage.}
		# state: absent|#present
		# params: 
$0
endsnippet

snippet filesystem "Makes a filesystem" b
- name: $1
	filesystem:
		fstype: ${2:btrfs|ext2|ext3|ext4|ext4dev|f2fs|lvm|ocfs2|reiserfs|xfs|vfat}
		dev: ${3:# Target path to device or image file.}
		# force: no
		# resizefs: no
		# opts: # List of options to be passed to mkfs command.
$0
endsnippet

snippet facter "Runs the discovery program I(facter) on the remote system" b
- name: $1
$0
endsnippet

snippet dconf "Modify and read dconf database" b
- name: $1
	dconf:
		key: ${2:# A dconf key to modify or read from the dconf database.}
		# value: # Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present).
		# state: read|#present|absent
$0
endsnippet

snippet beadm "Manage ZFS boot environments on FreeBSD/Solaris/illumos systems." b
- name: $1
	beadm:
		name: ${2:# ZFS boot environment name.}
		# snapshot: no
		# description: no
		# options: no
		# mountpoint: no
		# state: #present|absent|activated|mounted|unmounted
		# force: no
$0
endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld" b
- name: $1
	firewalld:
		state: ${2:enabled|disabled|present|absent}
		# service: # Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.
		# port: # Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.
		# rich_rule: # Rich rule to add/remove to/from firewalld.
		# source: # The source/network you would like to add/remove to/from firewalld
		# interface: # The interface you would like to add/remove to/from a zone in firewalld
		# zone: work|drop|internal|external|trusted|home|dmz|public|block
		# permanent: # Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9). (NOTE: If this is false, immediate is assumed true.)

		# immediate: no
		# timeout: 0
		# masquerade: # The masquerade setting you would like to enable/disable to/from zones within firewalld
$0
endsnippet

snippet at "Schedule the execution of a command or script file via the at command" b
- name: $1
	at:
		count: ${2:# The count of units in the future to execute the command or script file.}
		units: ${3:minutes|hours|days|weeks}
		# command: # A command to be executed in the future.
		# script_file: # An existing script file to be executed in the future.
		# state: absent|#present
		# unique: no
$0
endsnippet

snippet mksysb "Generates AIX mksysb rootvg backups." b
- name: $1
	mksysb:
		name: ${2:# Backup name}
		storage_path: ${3:# Storage path where the mksysb will stored.}
		# backup_crypt_files: yes
		# backup_dmapi_fs: yes
		# create_map_files: no
		# exclude_files: no
		# exclude_wpar_files: no
		# extended_attrs: yes
		# new_image_data: yes
		# software_packing: no
		# use_snapshot: no
$0
endsnippet

snippet ufw "Manage firewall with UFW" b
- name: $1
	ufw:
		# state: disabled|enabled|reloaded|reset
		# policy: allow|deny|reject
		# direction: in|incoming|out|outgoing|routed
		# logging: True|False|low|medium|high|full
		# insert: # Insert the corresponding rule as rule number NUM
		# rule: allow|deny|limit|reject
		# log: # Log new connections matched to this rule
		# from_ip: any
		# from_port: # Source port.
		# to_ip: any
		# to_port: # Destination port.
		# proto: any|tcp|udp|ipv6|esp|ah
		# name: # Use profile located in C(/etc/ufw/applications.d).
		# delete: # Delete rule.
		# interface: # Specify interface for rule.
		# route: # Apply the rule to routed/forwarded packets.
		# comment: # Add a comment to the rule. Requires UFW version >=0.35.
$0
endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file" b
- name: $1
	known_hosts:
		name: ${2:# The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.}
		# key: # The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(8), section "SSH_KNOWN_HOSTS FILE FORMAT").
Specifically, the key should not match the format that is found in an SSH pubkey file, but should rather have the hostname prepended to a line that includes the pubkey, the same way that it would appear in the known_hosts file. The value prepended to the line must also match the value of the name parameter.
		# path: (homedir)+/.ssh/known_hosts
		# hash_host: no
		# state: #present|absent
$0
endsnippet

snippet solaris_zone "Manage Solaris zones" b
- name: $1
	solaris_zone:
		state: ${2:absent|attached|configured|detached|installed|#present|running|started|stopped}
		name: ${3:# Zone name.}
		# path: # The path where the zone will be created. This is required when the zone is created, but not used otherwise.
		# sparse: no
		# root_password: # The password hash for the root account. If not specified, the zone's root account will not have a password.
		# config: empty string
		# create_options: empty string
		# install_options: empty string
		# attach_options: empty string
		# timeout: 600
$0
endsnippet

snippet nosh "Manage services with nosh" b
- name: $1
	nosh:
		name: ${2:# Name of the service to manage.}
		# state: started|stopped|reset|restarted|reloaded
		# enabled: # Enable or disable the service, independently of C(*.preset) file preference or running state. Mutually exclusive with I(preset). Will take effect prior to I(state=reset).
		# preset: # Enable or disable the service according to local preferences in *.preset files. Mutually exclusive with I(enabled). Only has an effect if set to true. Will take effect prior to I(state=reset).
		# user: no
$0
endsnippet

snippet authorized_key "Adds or removes an SSH authorized key" b
- name: $1
	authorized_key:
		user: ${2:# The username on the remote host whose authorized_keys file will be modified}
		key: ${3:# The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)}
		# path: (homedir)+/.ssh/authorized_keys
		# manage_dir: yes
		# state: #present|absent
		# key_options: # A string of ssh key options to be prepended to the key in the authorized_keys file
		# exclusive: no
		# validate_certs: yes
		# comment: # Change the comment on the public key. Rewriting the comment is useful in cases such as fetching it from GitHub or GitLab.
		# follow: no
$0
endsnippet

snippet pamd "Manage PAM Modules" b
- name: $1
	pamd:
		name: ${2:# The name generally refers to the PAM service file to change, for example system-auth.}
		type: ${3:# The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		control: ${4:# The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.}
		module_path: ${5:# The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
		# new_type: # The new type to assign to the new rule.
		# new_control: # The new control to assign to the new rule.
		# new_module_path: # The new module path to be assigned to the new rule.
		# module_arguments: # When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.  Note that module_arguments is a list.  Please see the examples for usage.
		# state: #updated|before|after|args_present|args_absent|absent
		# path: /etc/pam.d/
		# backup: no
$0
endsnippet

snippet sysvinit "Manage SysV services." b
- name: $1
	sysvinit:
		name: ${2:# Name of the service.}
		# state: started|stopped|restarted|reloaded
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# sleep: 1
		# pattern: # A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.
		# runlevels: # The runlevels this script should be enabled/disabled from.
		# arguments: # Additional arguments provided on the command line that some init scripts accept.
		# daemonize: no
$0
endsnippet

snippet aix_lvol "Configure AIX LVM logical volumes" b
- name: $1
	aix_lvol:
		vg: ${2:# The volume group this logical volume is part of.}
		lv: ${3:# The name of the logical volume.}
		# lv_type: jfs2
		# size: # The size of the logical volume with one of the [MGT] units.
		# copies: 1
		# policy: #maximum|minimum
		# state: absent|#present
		# opts: # Free-form options to be passed to the mklv command.
		# pvs: # Comma separated list of physical volumes e.g. C(hdisk1,hdisk2).
$0
endsnippet

snippet svc "Manage daemontools services" b
- name: $1
	svc:
		name: ${2:# Name of the service to manage.}
		# state: killed|once|reloaded|restarted|started|stopped
		# downed: no
		# enabled: # Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).
		# service_dir: /service
		# service_src: # directory where services are defined, the source of symlinks to service_dir.
$0
endsnippet

snippet setup "Gathers facts about remote hosts" b
- name: $1
	setup:
		# gather_subset: all
		# gather_timeout: 10
		# filter: *
		# fact_path: /etc/ansible/facts.d
$0
endsnippet

snippet service_facts "Return service state information as fact data" b
- name: $1
$0
endsnippet

snippet vdo "Module to control VDO" b
- name: $1
	vdo:
		name: ${2:# The name of the VDO volume.}
		state: ${3:present|absent}
		# activated: yes|no
		# running: yes|no
		# device: # The full path of the device to use for VDO storage. This is required if "state" is "present".
		# logicalsize: # The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed.
		# deduplication: enabled|disabled
		# compression: enabled|disabled
		# blockmapcachesize: # The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# readcache: enabled|disabled
		# readcachesize: # Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# emulate512: # Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# growphysical: no
		# slabsize: # The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# writepolicy: auto|sync|async
		# indexmem: # Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# indexmode: # Specifies the index mode of the Albireo index.  The default is 'dense', which has a deduplication window of 1 GB of index memory per 1 TB of incoming data, requiring 10 GB of index data on persistent storage. The 'sparse' mode has a deduplication window of 1 GB of index memory per 10 TB of incoming data, but requires 100 GB of index data on persistent storage.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
		# ackthreads: # Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# biothreads: # Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# cputhreads: # Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# logicalthreads: # Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
		# physicalthreads: # Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
$0
endsnippet

snippet openwrt_init "Manage services on OpenWrt." b
- name: $1
	openwrt_init:
		name: ${2:# Name of the service.}
		# state: started|stopped|restarted|reloaded
		# enabled: # Whether the service should start on boot. B(At least one of state and enabled are required.)
		# pattern: # If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.
$0
endsnippet

snippet capabilities "Manage Linux capabilities" b
- name: $1
	capabilities:
		path: ${2:# Specifies the path to the file to be managed.}
		capability: ${3:# Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))}
		# state: absent|#present
$0
endsnippet

snippet java_keystore "Create or delete a Java keystore in JKS format." b
- name: $1
	java_keystore:
		name: ${2:# Name of the certificate.}
		dest: ${3:# Absolute path where the jks should be generated.}
		# certificate: # Certificate that should be used to create the key store.
		# private_key: # Private key that should be used to create the key store.
		# password: # Password that should be used to secure the key store.
		# owner: # Name of the user that should own jks file.
		# group: # Name of the group that should own jks file.
		# mode: # Mode the file should be.
		# force: no
$0
endsnippet

snippet puppet "Runs puppet" b
- name: $1
	puppet:
		# timeout: 30m
		# puppetmaster: # The hostname of the puppetmaster to contact.
		# modulepath: # Path to an alternate location for puppet modules.
		# manifest: # Path to the manifest file to run puppet apply on.
		# facts: # A dict of values to pass in as persistent external facter facts.
		# facter_basename: ansible
		# environment: # Puppet environment to be used.
		# logdest: #stdout|syslog|all
		# certname: # The name to use when handling certificates.
		# tags: # A comma-separated list of puppet tags to be used.
		# execute: # Execute a specific piece of Puppet code.
		# summarize: # Whether to print a transaction summary
		# verbose: # Print extra information
		# debug: # Enable full debugging
$0
endsnippet

snippet runit "Manage runit services" b
- name: $1
	runit:
		name: ${2:# Name of the service to manage.}
		# state: killed|once|reloaded|restarted|started|stopped
		# enabled: # Whether the service is enabled or not, if disabled it also implies stopped.
		# service_dir: /var/service
		# service_src: /etc/sv
$0
endsnippet

snippet pam_limits "Modify Linux PAM limits" b
- name: $1
	pam_limits:
		domain: ${2:# A username, @groupname, wildcard, uid/gid range.}
		limit_type: ${3:hard|soft|-}
		limit_item: ${4:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
		value: ${5:# The value of the limit.}
		# backup: no
		# use_min: no
		# use_max: no
		# dest: /etc/security/limits.conf
		# comment: 
$0
endsnippet

snippet awall "Manage awall policies" b
- name: $1
	awall:
		# name: # A policy name, like C(foo), or multiple policies, like C(foo, bar).
		# state: #enabled|disabled
		# activate: no
$0
endsnippet

snippet kernel_blacklist "Blacklist kernel modules" b
- name: $1
	kernel_blacklist:
		name: ${2:# Name of kernel module to black- or whitelist.}
		# state: absent|#present
		# blacklist_file: # If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).
$0
endsnippet

snippet reboot "Reboot a machine" b
- name: $1
	reboot:
		# pre_reboot_delay: 0
		# post_reboot_delay: 0
		# reboot_timeout: 600
		# connect_timeout: # Maximum seconds to wait for a successful connection to the managed hosts before trying again.
		# test_command: whoami
		# msg: Reboot initiated by Ansible
$0
endsnippet

snippet parted "Configure block device partitions" b
- name: $1
	parted:
		device: ${2:# T}
		# align: none|cylinder|minimal|#optimal
		# number: # The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.
		# unit: s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact
		# label: aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun
		# part_type: #primary|extended|logical
		# part_start: 0%
		# part_end: 100%
		# name: # Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).
		# flags: # A
		# state: present|absent|#info
$0
endsnippet

snippet lvol "Configure LVM logical volumes" b
- name: $1
	lvol:
		# vg: # The volume group this logical volume is part of.
		# lv: # The name of the logical volume.
		# size: # The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.
		# state: absent|#present
		# active: yes
		# force: no
		# opts: # Free-form options to be passed to the lvcreate command.
		# snapshot: # The name of the snapshot volume
		# pvs: # Comma separated list of physical volumes (e.g. /dev/sda,/dev/sdb).
		# thinpool: # The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name.
		# shrink: yes
		# resizefs: no
$0
endsnippet

snippet group "Add or remove groups" b
- name: $1
	group:
		name: ${2:# Name of the group to manage.}
		# gid: # Optional I(GID) to set for the group.
		# state: absent|#present
		# system: no
		# local: no
$0
endsnippet

snippet make "Run targets in a Makefile" b
- name: $1
	make:
		chdir: ${2:# cd into this directory before running make}
		# target: # The target to run
		# params: # Any extra parameters to pass to make
		# file: # Use file as a Makefile
$0
endsnippet

snippet mount "Control active and configured mount points" b
- name: $1
	mount:
		path: ${2:# Path to the mount point (e.g. C(/mnt/files)).}
		state: ${3:absent|mounted|present|unmounted}
		# src: # Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted).
		# fstype: # Filesystem type. Required when I(state) is C(present) or C(mounted).
		# opts: # Mount options (see fstab(5), or vfstab(4) on Solaris).
		# dump: 0
		# passno: 0
		# fstab: /etc/fstab (/etc/vfstab on Solaris)
		# boot: yes
		# backup: no
$0
endsnippet

snippet iptables "Modify the systems iptables" b
- name: $1
	iptables:
		# table: #filter|nat|mangle|raw|security
		# state: absent|#present
		# action: #append|insert
		# rule_num: # Insert the rule as the given rule number. This works only with action = 'insert'.
		# ip_version: #ipv4|ipv6
		# chain: # Chain to operate on.
		# protocol: # The protocol of the rule or of the packet to check.
		# source: # Source specification.
		# destination: # Destination specification.
		# tcp_flags: {}
		# match: []
		# jump: # This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
		# log_prefix: # Specifies a log text for the rule. Only make sense with a LOG jump.
		# goto: # This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.
		# in_interface: # Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
		# out_interface: # Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
		# fragment: # This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.
		# set_counters: # This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).
		# source_port: # Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
		# destination_port: # Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
		# to_ports: # This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
		# to_destination: # This specifies a destination address to use with DNAT.
		# to_source: # This specifies a source address to use with SNAT.
		# syn: #ignore|match|negate
		# set_dscp_mark: # This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.
		# set_dscp_mark_class: # This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.
		# comment: # This specifies a comment that will be added to the rule.
		# ctstate: ['DNAT', 'ESTABLISHED', 'INVALID', 'NEW', 'RELATED', 'SNAT', 'UNTRACKED'
		# limit: # Specifies the maximum average number of matches to allow per second.
		# limit_burst: # Specifies the maximum burst before the above limit kicks in.
		# uid_owner: # Specifies the UID or username to use in match by owner rule. From Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified.
		# reject_with: # Specifies the error packet type to return while rejecting. It implies "jump: REJECT"
		# icmp_type: # This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'
		# flush: # Flushes the specified table and chain of all rules.
		# policy: ACCEPT|DROP|QUEUE|RETURN
$0
endsnippet

snippet java_cert "Uses keytool to import/remove key from java keystore(cacerts)" b
- name: $1
	java_cert:
		keystore_pass: ${2:# Keystore password.}
		# cert_url: # Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate.
		# cert_port: 443
		# cert_path: # Local path to load certificate from. One of cert_url or cert_path is required to load certificate.
		# cert_alias: # Imported certificate alias.
		# pkcs12_path: # Local path to load PKCS12 keystore from.
		# pkcs12_password: 
		# pkcs12_alias: 1
		# keystore_path: # Path to keystore.
		# keystore_create: # Create keystore if it doesn't exist
		# executable: keytool
		# state: absent|#present
$0
endsnippet

snippet sysctl "Manage entries in sysctl.conf." b
- name: $1
	sysctl:
		name: ${2:# The dot-separated path (aka I(key)) specifying the sysctl variable.}
		# value: # Desired value of the sysctl key.
		# state: #present|absent
		# ignoreerrors: no
		# reload: yes
		# sysctl_file: /etc/sysctl.conf
		# sysctl_set: no
$0
endsnippet

snippet lvg "Configure LVM volume groups" b
- name: $1
	lvg:
		vg: ${2:# The name of the volume group.}
		# pvs: # List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.
		# pesize: 4
		# pv_options: # Additional options to pass to C(pvcreate) when creating the volume group.
		# vg_options: # Additional options to pass to C(vgcreate) when creating the volume group.
		# state: absent|#present
		# force: no
$0
endsnippet

snippet locale_gen "Creates or removes locales" b
- name: $1
	locale_gen:
		name: ${2:# Name and encoding of the locale, such as "en_GB.UTF-8".}
		# state: absent|#present
$0
endsnippet

snippet timezone "Configure timezone setting" b
- name: $1
	timezone:
		# name: # Name of the timezone for the system clock. Default is to keep current setting. B(At least one of name and hwclock are required.)
		# hwclock: UTC|local
$0
endsnippet

snippet seport "Manages SELinux network port type definitions" b
- name: $1
	seport:
		ports: ${2:# Ports or port ranges. Can be a list (since 2.6) or comma separated string.}
		proto: ${3:tcp|udp}
		setype: ${4:# SELinux type for the specified port.}
		state: ${5:absent|#present}
		# reload: yes
$0
endsnippet

snippet alternatives "Manages alternative programs for common commands" b
- name: $1
	alternatives:
		name: ${2:# The generic name of the link.}
		path: ${3:# The path to the real executable that the link should point to.}
		# link: # The path to the symbolic link that should point to the real executable.
		# priority: 50
$0
endsnippet

snippet hostname "Manage hostname" b
- name: $1
	hostname:
		name: ${2:# Name of the host}
$0
endsnippet

snippet seboolean "Toggles SELinux booleans" b
- name: $1
	seboolean:
		name: ${2:# Name of the boolean to configure.}
		state: ${3:# Desired boolean value}
		# persistent: no
$0
endsnippet

snippet ping "Try to connect to host, verify a usable python and return C(pong) on success" b
- name: $1
	ping:
		# data: pong
$0
endsnippet

snippet interfaces_file "Tweak settings in /etc/network/interfaces files" b
- name: $1
	interfaces_file:
		# dest: /etc/network/interfaces
		# iface: # Name of the interface, required for value changes or option remove
		# option: # Name of the option, required for value changes or option remove
		# value: # If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported
		# backup: no
		# state: #present|absent
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy" b
- name: $1
	selinux_permissive:
		domain: ${2:# the domain that will be added or removed from the list of permissive domains}
		permissive: ${3:# indicate if the domain should or should not be set as permissive}
		# no_reload: no
		# store: # name of the SELinux policy store to use
$0
endsnippet

snippet add_host "add a host (and alternatively a group) to the ansible-playbook in-memory inventory" b
- name: $1
	add_host:
		name: ${2:# The hostname/ip of the host to add to the inventory, can include a colon and a port number.}
		# groups: # The groups to add the hostname to, comma separated.
$0
endsnippet

snippet group_by "Create Ansible groups based on facts" b
- name: $1
	group_by:
		key: ${2:# The variables whose values will be used as groups}
		# parents: all
$0
endsnippet

snippet webfaction_site "Add or remove a website on a Webfaction host" b
- name: $1
	webfaction_site:
		name: ${2:# The name of the website}
		host: ${3:# The webfaction host on which the site should be created.}
		login_name: ${4:# The webfaction account to use}
		login_password: ${5:# The webfaction password to use}
		# state: #present|absent
		# https: no
		# site_apps: []
		# subdomains: []
$0
endsnippet

snippet webfaction_domain "Add or remove domains and subdomains on Webfaction" b
- name: $1
	webfaction_domain:
		name: ${2:# The name of the domain}
		login_name: ${3:# The webfaction account to use}
		login_password: ${4:# The webfaction password to use}
		# state: #present|absent
		# subdomains: []
$0
endsnippet

snippet webfaction_db "Add or remove a database on Webfaction" b
- name: $1
	webfaction_db:
		name: ${2:# The name of the database}
		type: ${3:mysql|postgresql}
		login_name: ${4:# The webfaction account to use}
		login_password: ${5:# The webfaction password to use}
		# state: #present|absent
		# password: # The password for the new database user.
		# machine: # The machine name to use (optional for accounts with only one machine)
$0
endsnippet

snippet webfaction_mailbox "Add or remove mailboxes on Webfaction" b
- name: $1
	webfaction_mailbox:
		mailbox_name: ${2:# The name of the mailbox}
		mailbox_password: ${3:# The password for the mailbox}
		login_name: ${4:# The webfaction account to use}
		login_password: ${5:# The webfaction password to use}
		# state: #present|absent
$0
endsnippet

snippet webfaction_app "Add or remove applications on a Webfaction host" b
- name: $1
	webfaction_app:
		name: ${2:# The name of the application}
		type: ${3:# The type of application to create. See the Webfaction docs at U(https://docs.webfaction.com/xmlrpc-api/apps.html) for a list.}
		login_name: ${4:# The webfaction account to use}
		login_password: ${5:# The webfaction password to use}
		# state: #present|absent
		# autostart: no
		# extra_info: 
		# port_open: no
		# machine: # The machine name to use (optional for accounts with only one machine)
$0
endsnippet

snippet serverless "Manages a Serverless Framework project" b
- name: $1
	serverless:
		service_path: ${2:# The path to the root of the Serverless Service to be operated on.}
		# state: #present|absent
		# serverless_bin_path: # The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless
		# stage: # The name of the serverless framework project stage to deploy to. This uses the serverless framework default "dev".
		# functions: []
		# region: us-east-1
		# deploy: yes
		# force: no
		# verbose: no
$0
endsnippet

snippet rhevm "RHEV/oVirt automation" b
- name: $1
	rhevm:
		# user: admin@internal
		# server: 127.0.0.1
		# port: 443
		# insecure_api: no
		# name: # The name of the VM.
		# cluster: # The rhev/ovirt cluster in which you want you VM to start.
		# datacenter: Default
		# state: ping|#present|absent|up|down|restarted|cd|info
		# image: # The template to use for the VM.
		# type: #server|desktop|host
		# vmhost: # The host you wish your VM to run on.
		# vmcpu: 2
		# cpu_share: 0
		# vmmem: 1
		# osver: rhel_6x64
		# mempol: 1
		# vm_ha: yes
		# disks: # This option uses complex arguments and is a list of disks with the options name, size and domain.
		# ifaces: # This option uses complex arguments and is a list of interfaces with the options name and vlan.
		# boot_order: ['network', 'hd']
		# del_prot: yes
		# cd_drive: # The CD you wish to have mounted on the VM when I(state = 'CD').
		# timeout: # The timeout you wish to define for power actions.
$0
endsnippet

snippet cloud_init_data_facts "Retrieve facts of cloud-init." b
- name: $1
	cloud_init_data_facts:
		# filter: status|result
$0
endsnippet

snippet terraform "Manages a Terraform deployment (and plans)" b
- name: $1
	terraform:
		project_path: ${2:# The path to the root of the Terraform directory with the vars.tf/main.tf/etc to use.}
		# state: planned|#present|absent
		# binary_path: # The path of a terraform binary to use, relative to the 'service_path' unless you supply an absolute path.
		# workspace: default
		# purge_workspace: no
		# plan_file: # The path to an existing Terraform plan file to apply. If this is not specified, Ansible will build a new TF plan and execute it. Note that this option is required if 'state' has the 'planned' value.
		# state_file: # The path to an existing Terraform state file to use when building plan. If this is not specified, the default `terraform.tfstate` will be used.
		# variables_file: # The path to a variables file for Terraform to fill into the TF configurations.
		# variables: # A group of key-values to override template variables or those in variables files.
		# targets: # A list of specific resources to target in this plan/application. The resources selected here will also auto-include any dependencies.
		# lock: # Enable statefile locking, if you use a service that accepts locks (such as S3+DynamoDB) to store your statefile.
		# lock_timeout: # How long to maintain the lock on the statefile, if you use a service that accepts locks (such as S3+DynamoDB).
		# force_init: no
		# backend_config: # A group of key-values to provide at init stage to the -backend-config parameter.
$0
endsnippet

snippet virt "Manages virtual machines supported by libvirt" b
- name: $1
	virt:
		# name: # name of the guest VM being managed. Note that VM must be previously defined with xml.
		# state: destroyed|paused|running|shutdown
		# command: create|define|destroy|freemem|get_xml|info|list_vms|nodeinfo|pause|shutdown|start|status|stop|undefine|unpause|virttype
		# autostart: # start VM at host startup.
		# uri: qemu:///system
		# xml: # XML document used with the define command.
$0
endsnippet

snippet ovirt "oVirt/RHEV platform management" b
- name: $1
	ovirt:
		user: ${2:# The user to authenticate with.}
		url: ${3:# The url of the oVirt instance.}
		instance_name: ${4:# The name of the instance to use.}
		password: ${5:# Password of the user to authenticate with.}
		# image: # The template to use for the instance.
		# resource_type: new|template
		# zone: # Deploy the image to this oVirt cluster.
		# instance_disksize: # Size of the instance's disk in GB.
		# instance_cpus: 1
		# instance_nic: # The name of the network interface in oVirt/RHEV.
		# instance_network: rhevm
		# instance_mem: # The instance's amount of memory in MB.
		# instance_type: desktop|#server|high_performance
		# disk_alloc: preallocated|#thin
		# disk_int: ide|#virtio
		# instance_os: # Type of Operating System.
		# instance_cores: 1
		# sdomain: # The Storage Domain where you want to create the instance's disk on.
		# region: # The oVirt/RHEV datacenter where you want to deploy to.
		# instance_dns: # Define the instance's Primary DNS server.
		# instance_domain: # Define the instance's Domain.
		# instance_hostname: # Define the instance's Hostname.
		# instance_ip: # Define the instance's IP.
		# instance_netmask: # Define the instance's Netmask.
		# instance_rootpw: # Define the instance's Root password.
		# instance_key: # Define the instance's Authorized key.
		# state: absent|#present|restarted|shutdown|started
$0
endsnippet

snippet proxmox "management of instances in Proxmox VE cluster" b
- name: $1
	proxmox:
		api_host: ${2:# the host of the Proxmox VE cluster}
		api_user: ${3:# the user to authenticate with}
		# api_password: # the password to authenticate with
		# vmid: # the instance id
		# validate_certs: no
		# node: # Proxmox VE node, when new VM will be created
		# pool: # Proxmox VE resource pool
		# password: # the instance root password
		# hostname: # the instance hostname
		# ostemplate: # the template for VM creating
		# disk: 3
		# cores: 1
		# cpus: 1
		# memory: 512
		# swap: 0
		# netif: # specifies network interfaces for the container. As a hash/dictionary defining interfaces.
		# mounts: # specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points
		# ip_address: # specifies the address the container will be assigned
		# onboot: no
		# storage: local
		# cpuunits: 1000
		# nameserver: # sets DNS server IP address for a container
		# searchdomain: # sets DNS search domain for a container
		# timeout: 30
		# force: no
		# state: #present|started|absent|stopped|restarted
		# pubkey: # Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions
		# unprivileged: no
$0
endsnippet

snippet proxmox_template "management of OS templates in Proxmox VE cluster" b
- name: $1
	proxmox_template:
		api_host: ${2:# the host of the Proxmox VE cluster}
		api_user: ${3:# the user to authenticate with}
		node: ${4:# Proxmox VE node, when you will operate with template}
		# api_password: # the password to authenticate with
		# validate_certs: no
		# src: # path to uploaded file
		# template: # the template name
		# content_type: #vztmpl|iso
		# storage: local
		# timeout: 30
		# force: no
		# state: #present|absent
$0
endsnippet

snippet virt_net "Manage libvirt network configuration" b
- name: $1
	virt_net:
		name: ${2:# name of the network being managed. Note that network must be previously defined with xml.}
		# state: active|inactive|present|absent
		# command: define|create|start|stop|destroy|undefine|get_xml|list_nets|facts|info|status|modify
		# autostart: # Specify if a given network should be started automatically on system boot.
		# uri: qemu:///system
		# xml: # XML document used with the define command.
$0
endsnippet

snippet xenserver_facts "get facts reported on xenserver" b
- name: $1
	xenserver_facts:
$0
endsnippet

snippet helm "Manages Kubernetes packages with the Helm package manager" b
- name: $1
	helm:
		# host: localhost
		# port: 44134
		# namespace: default
		# name: # Release name to manage.
		# state: absent|purged|#present
		# chart: {}
		# values: {}
		# disable_hooks: no
$0
endsnippet

snippet virt_pool "Manage libvirt storage pools" b
- name: $1
	virt_pool:
		# name: # name of the storage pool being managed. Note that pool must be previously defined with xml.
		# state: active|inactive|present|absent|undefined|deleted
		# command: define|build|create|start|stop|destroy|delete|undefine|get_xml|list_pools|facts|info|status
		# autostart: # Specify if a given storage pool should be started automatically on system boot.
		# uri: qemu:///system
		# xml: # XML document used with the define command.
		# mode: new|repair|resize|no_overwrite|overwrite|normal|zeroed
$0
endsnippet

snippet proxmox_kvm "Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster." b
- name: $1
	proxmox_kvm:
		api_host: ${2:# Specify the target host of the Proxmox VE cluster.}
		api_user: ${3:# Specify the user to authenticate with.}
		# acpi: yes
		# agent: # Specify if the QEMU Guest Agent should be enabled/disabled.
		# args: -serial unix:/var/run/qemu-server/VMID.serial,server,nowait
		# api_password: # Specify the password to authenticate with.
		# autostart: no
		# balloon: 0
		# bios: seabios|ovmf
		# boot: cnd
		# bootdisk: # Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)
		# clone: # Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone.
		# cores: 1
		# cpu: kvm64
		# cpulimit: # Specify if CPU usage will be limited. Value 0 indicates no CPU limit.
		# cpuunits: 1000
		# delete: # Specify a list of settings you want to delete.
		# description: # Specify the description for the VM. Only used on the configuration web interface.
		# digest: # Specify if to prevent changes if current configuration file has different SHA1 digest.
		# force: # Allow to force stop VM.
		# format: cloop|cow|qcow|#qcow2|qed|raw|vmdk
		# freeze: # Specify if PVE should freeze CPU at startup (use 'c' monitor command to start execution).
		# full: yes
		# hostpci: # Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').
		# hotplug: # Selectively enable hotplug features.
		# hugepages: any|2|1024
		# ide: # A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').
		# keyboard: # Sets the keyboard layout for VNC server.
		# kvm: yes
		# localtime: # Sets the real time clock to local time.
		# lock: migrate|backup|snapshot|rollback
		# machine: # Specifies the Qemu machine type.
		# memory: 512
		# migrate_downtime: # Sets maximum tolerated downtime (in seconds) for migrations.
		# migrate_speed: # Sets maximum speed (in MB/s) for migrations.
		# name: # Specifies the VM name. Only used on the configuration web interface.
		# net: # A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').
		# newid: # VMID for the clone. Used only with clone.
		# node: # Proxmox VE node, where the new VM will be created.
		# numa: # A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').
		# onboot: yes
		# ostype: other|wxp|w2k|w2k3|w2k8|wvista|win7|win8|l24|#l26|solaris
		# parallel: # A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').
		# pool: # Add the new VM to the specified pool.
		# protection: # Enable/disable the protection flag of the VM. This will enable/disable the remove VM and remove disk operations.
		# reboot: # Allow reboot. If set to C(yes), the VM exit on reboot.
		# revert: # Revert a pending change.
		# sata: # A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').
		# scsi: # A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').
		# scsihw: lsi|lsi53c810|virtio-scsi-pci|virtio-scsi-single|megasas|pvscsi
		# serial: # A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').
		# shares: # Rets amount of memory shares for auto-ballooning. (0 - 50000).
		# skiplock: # Ignore locks
		# smbios: # Specifies SMBIOS type 1 fields.
		# snapname: # The name of the snapshot. Used only with clone.
		# sockets: 1
		# startdate: # Sets the initial date of the real time clock.
		# startup: # Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).
		# state: #present|started|absent|stopped|restarted|current
		# storage: # Target storage for full clone.
		# tablet: no
		# target: # Target node. Only allowed if the original VM is on shared storage.
		# tdf: # Enables/disables time drift fix.
		# template: no
		# timeout: 30
		# update: no
		# validate_certs: no
		# vcpus: # Sets number of hotplugged vcpus.
		# vga: #std|cirrus|vmware|qxl|serial0|serial1|serial2|serial3|qxl2|qxl3|qxl4
		# virtio: # A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').
		# vmid: # Specifies the VM ID. Instead use I(name) parameter.
		# watchdog: # Creates a virtual hardware watchdog device.
$0
endsnippet

snippet os_client_config "Get OpenStack Client config" b
- name: $1
	os_client_config:
		# clouds: []
$0
endsnippet

snippet os_pool "Add/Delete a pool in the load balancing service from OpenStack Cloud" b
- name: $1
	os_pool:
		name: ${2:# Name that has to be given to the pool}
		# state: #present|absent
		# loadbalancer: # The name or id of the load balancer that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.
		# listener: # The name or id of the listener that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.
		# protocol: #HTTP|HTTPS|PROXY|TCP|UDP
		# lb_algorithm: LEAST_CONNECTIONS|#ROUND_ROBIN|SOURCE_IP
		# wait: yes
		# timeout: 180
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_nova_flavor "Manage OpenStack compute flavors" b
- name: $1
	os_nova_flavor:
		name: ${2:# Flavor name.}
		# state: #present|absent
		# ram: # Amount of memory, in MB.
		# vcpus: # Number of virtual CPUs.
		# disk: # Size of local disk, in GB.
		# ephemeral: 0
		# swap: 0
		# rxtx_factor: 1.0
		# is_public: yes
		# flavorid: auto
		# availability_zone: # Ignored. Present for backwards compatibility
		# extra_specs: # Metadata dictionary
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_security_group_rule "Add/Delete rule from an existing security group" b
- name: $1
	os_security_group_rule:
		security_group: ${2:# Name or ID of the security group}
		# protocol: tcp|udp|icmp|112|None
		# port_range_min: # Starting port
		# port_range_max: # Ending port
		# remote_ip_prefix: # Source IP address(es) in CIDR notation (exclusive with remote_group)
		# remote_group: # Name or ID of the Security group to link (exclusive with remote_ip_prefix)
		# ethertype: #IPv4|IPv6
		# direction: egress|#ingress
		# state: #present|absent
		# project: # Unique name or ID of the project.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_stack "Add/Remove Heat Stack" b
- name: $1
	os_stack:
		name: ${2:# Name of the stack that should be created, name could be char and digit, no space}
		# state: #present|absent
		# tag: # Tag for the stack that should be created, name could be char and digit, no space
		# template: # Path of the template file to use for the stack creation
		# environment: # List of environment files that should be used for the stack creation
		# parameters: # Dictionary of parameters for the stack creation
		# rollback: yes
		# timeout: 3600
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_subnets_facts "Retrieve facts about one or more OpenStack subnets." b
- name: $1
	os_subnets_facts:
		# subnet: # Name or ID of the subnet
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_group "Manage OpenStack Identity Groups" b
- name: $1
	os_group:
		name: ${2:# Group name}
		# description: # Group description
		# domain_id: # Domain id to create the group in if the cloud supports domains.
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_router "Create or delete routers from OpenStack" b
- name: $1
	os_router:
		name: ${2:# Name to be give to the router}
		# state: #present|absent
		# admin_state_up: yes
		# enable_snat: # Enable Source NAT (SNAT) attribute.
		# network: # Unique name or ID of the external gateway network.
		# project: # Unique name or ID of the project.
		# external_fixed_ips: # The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.
		# interfaces: # List of subnets to attach to the router internal interface. Default gateway associated with the subnet will be automatically attached with the router's internal interface. In order to provide an ip address different from the default gateway,parameters are passed as dictionary with keys as network name or ID(net), subnet name or ID (subnet) and the IP of port (portip) from the network. User defined portip is often required when a multiple router need to be connected to a single subnet for which the default gateway has been already used.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_project_access "Manage OpenStack compute flavors acceess" b
- name: $1
	os_project_access:
		target_project_id: ${2:# Project id.}
		# state: #present|absent
		# resource_type: # The resource type (eg. nova_flavor, cinder_volume_type).
		# resource_name: # The resource name (eg. tiny).
		# availability_zone: # The availability zone of the resource.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_metadata "Add/Update/Delete Metadata in Compute Instances from OpenStack" b
- name: $1
	os_server_metadata:
		server: ${2:# Name of the instance to update the metadata}
		meta: ${3:# A list of key value pairs that should be provided as a metadata to the instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"}
		# state: #present|absent
		# availability_zone: # Availability zone in which to create the snapshot.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_image_facts "Retrieve facts about an image within OpenStack." b
- name: $1
	os_image_facts:
		# image: # Name or ID of the image
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# wait: yes
		# timeout: 180
		# action: stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild
		# image: # Image the server should be rebuilt with
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_listener "Add/Delete a listener for a load balancer from OpenStack Cloud" b
- name: $1
	os_listener:
		name: ${2:# Name that has to be given to the listener}
		loadbalancer: ${3:# The name or id of the load balancer that this listener belongs to.}
		# state: #present|absent
		# protocol: #HTTP|HTTPS|TCP|TERMINATED_HTTPS
		# protocol_port: 80
		# wait: yes
		# timeout: 180
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_project_facts "Retrieve facts about one or more OpenStack projects" b
- name: $1
	os_project_facts:
		name: ${2:# Name or ID of the project}
		# domain: # Name or ID of the domain containing the project if the cloud supports domains
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_facts "Retrieve facts about one or more compute instances" b
- name: $1
	os_server_facts:
		# server: # restrict results to servers with names or UUID matching this glob expression (e.g., <web*>).
		# detailed: no
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_volume "Attach/Detach Volumes from OpenStack VM's" b
- name: $1
	os_server_volume:
		server: ${2:# Name or ID of server you want to attach a volume to}
		volume: ${3:# Name or id of volume you want to attach to a server}
		# state: #present|absent
		# device: # Device you want to attach. Defaults to auto finding a device name.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_port_facts "Retrieve facts about ports within OpenStack." b
- name: $1
	os_port_facts:
		# port: # Unique name or ID of a port.
		# filters: # A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_image "Add/Delete images from OpenStack Cloud" b
- name: $1
	os_image:
		name: ${2:# Name that has to be given to the image}
		# id: # The Id of the image
		# checksum: # The checksum of the image
		# disk_format: qcow2
		# container_format: bare
		# owner: # The owner of the image
		# min_disk: # The minimum disk space (in GB) required to boot this image
		# min_ram: # The minimum ram (in MB) required to boot this image
		# is_public: yes
		# filename: # The path to the file which has to be uploaded
		# ramdisk: # The name of an existing ramdisk image that will be associated with this image
		# kernel: # The name of an existing kernel image that will be associated with this image
		# properties: {}
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_user_group "Associate OpenStack Identity users and groups" b
- name: $1
	os_user_group:
		user: ${2:# Name or id for the user}
		group: ${3:# Name or id for the group.}
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_nova_host_aggregate "Manage OpenStack host aggregates" b
- name: $1
	os_nova_host_aggregate:
		name: ${2:# N}
		# metadata: # M
		# availability_zone: # A
		# hosts: # L
		# state: #present|absent
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_volume "Create/Delete Cinder Volumes" b
- name: $1
	os_volume:
		display_name: ${2:# Name of volume}
		# size: # Size of volume in GB. This parameter is required when the I(state) parameter is 'present'.
		# display_description: # String describing the volume
		# volume_type: # Volume type for volume
		# image: # Image name or id for boot from volume
		# snapshot_id: # Volume snapshot id to create from
		# volume: # Volume name or id to create from
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# scheduler_hints: # Scheduler hints passed to volume API in form of dict
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_zone "Manage OpenStack DNS zones" b
- name: $1
	os_zone:
		name: ${2:# Zone name}
		# zone_type: primary|secondary
		# email: # Email of the zone owner (only applies if zone_type is primary)
		# description: # Zone description
		# ttl: # TTL (Time To Live) value in seconds
		# masters: # Master nameservers (only applies if zone_type is secondary)
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keystone_service "Manage OpenStack Identity services" b
- name: $1
	os_keystone_service:
		name: ${2:# Name of the service}
		service_type: ${3:# The type of service}
		# description: # Description of the service
		# enabled: yes
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keystone_endpoint "Manage OpenStack Identity service endpoints" b
- name: $1
	os_keystone_endpoint:
		service: ${2:# Name or id of the service.}
		interface: ${3:admin|#public|internal}
		url: ${4:# URL of the service.}
		# region: # Region that the service belongs to. Note that I(region_name) is used for authentication.
		# enabled: yes
		# state: #present|absent
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
$0
endsnippet

snippet os_networks_facts "Retrieve facts about one or more OpenStack networks." b
- name: $1
	os_networks_facts:
		# name: # Name or ID of the Network
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_volume_snapshot "Create/Delete Cinder Volume Snapshots" b
- name: $1
	os_volume_snapshot:
		display_name: ${2:# Name of the snapshot}
		volume: ${3:# The volume name or id to create/delete the snapshot}
		# display_description: # String describing the snapshot
		# force: no
		# state: #present|absent
		# availability_zone: # Availability zone in which to create the snapshot.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_member "Add/Delete a member for a pool in load balancer from OpenStack Cloud" b
- name: $1
	os_member:
		name: ${2:# Name that has to be given to the member}
		pool: ${3:# The name or id of the pool that this member belongs to.}
		# state: #present|absent
		# protocol_port: 80
		# address: # The IP address of the member.
		# subnet_id: # The subnet ID the member service is accessible from.
		# wait: yes
		# timeout: 180
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_project "Manage OpenStack Projects" b
- name: $1
	os_project:
		name: ${2:# Name for the project}
		# description: # Description for the project
		# domain_id: # Domain id to create the project in if the cloud supports domains.
		# enabled: yes
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_recordset "Manage OpenStack DNS recordsets" b
- name: $1
	os_recordset:
		zone: ${2:# Zone managing the recordset}
		name: ${3:# Name of the recordset}
		recordset_type: ${4:# Recordset type}
		records: ${5:# List of recordset definitions}
		# description: # Description of the recordset
		# ttl: # TTL (Time To Live) value in seconds
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_flavor_facts "Retrieve facts about one or more flavors" b
- name: $1
	os_flavor_facts:
		# name: # A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).
		# ram: no
		# vcpus: no
		# limit: # Limits the number of flavors returned. All matching flavors are returned by default.
		# ephemeral: no
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
- name: $1
	os_server_action:
		server: ${2:# Name or ID of the instance}
		# wait: yes
		# timeout: 180
		# action: stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild
		# image: # Image the server should be rebuilt with
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_ironic "Create/Delete Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic:
		driver: ${2:# The name of the Ironic Driver to use with this node.}
		nics: ${3:# A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"}
		# state: #present|absent
		# uuid: # globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.
		# name: # unique name identifier to be given to the resource.
		# chassis_uuid: # Associate the node with a pre-defined chassis.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
		# driver_info: # Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.
		# properties: # Definition of the physical characteristics of this server, used for scheduling purposes
		# skip_update_of_driver_password: no
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_ironic_node "Activate/Deactivate Bare Metal Resources from OpenStack" b
- name: $1
	os_ironic_node:
		# state: #present|absent
		# deploy: yes
		# uuid: # globally unique identifier (UUID) to be given to the resource.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
		# config_drive: # A configdrive file or HTTP(S) URL that will be passed along to the node.
		# instance_info: # Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.
		# power: #present|absent
		# maintenance: no
		# maintenance_reason: # A string expression regarding the reason a node is in a maintenance mode.
		# wait: no
		# timeout: 180
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_security_group "Add/Delete security groups from an OpenStack cloud." b
- name: $1
	os_security_group:
		name: ${2:# Name that has to be given to the security group. This module requires that security group names be unique.}
		# description: # Long description of the purpose of the security group
		# state: #present|absent
		# project: # Unique name or ID of the project.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keystone_role "Manage OpenStack Identity Roles" b
- name: $1
	os_keystone_role:
		name: ${2:# Role Name}
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_loadbalancer "Add/Delete load balancer from OpenStack Cloud" b
- name: $1
	os_loadbalancer:
		name: ${2:# Name that has to be given to the load balancer}
		# state: #present|absent
		# vip_network: # The name or id of the network for the virtual IP of the load balancer. One of vip_network, vip_subnet, or vip_port must be specified.
		# vip_subnet: # The name or id of the subnet for the virtual IP of the load balancer. One of vip_network, vip_subnet, or vip_port must be specified.
		# vip_port: # The name or id of the load balancer virtual IP port. One of vip_network, vip_subnet, or vip_port must be specified.
		# vip_address: # IP address of the load balancer virtual IP.
		# wait: yes
		# timeout: 180
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_floating_ip "Add/Remove floating IP from an instance" b
- name: $1
	os_floating_ip:
		server: ${2:# The name or ID of the instance to which the IP address should be assigned.}
		# network: # The name or ID of a neutron external network or a nova pool name.
		# floating_ip_address: # A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.
		# reuse: no
		# fixed_address: # To which fixed IP of server the floating IP address should be attached to.
		# nat_destination: # The name or id of a neutron private network that the fixed IP to attach floating IP is on
		# wait: no
		# timeout: 60
		# state: #present|absent
		# purge: no
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_user "Manage OpenStack Identity Users" b
- name: $1
	os_user:
		name: ${2:# Username for the user}
		# password: # Password for the user
		# update_password: #always|on_create
		# email: # Email address for the user
		# description: # Description about the user
		# default_project: # Project name or ID that the user should be associated with by default
		# domain: # Domain to create the user in if the cloud supports domains
		# enabled: yes
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_user_role "Associate OpenStack Identity users and roles" b
- name: $1
	os_user_role:
		role: ${2:# Name or ID for the role.}
		# user: # Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.
		# group: # Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.
		# project: # Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.
		# domain: # ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keystone_domain "Manage OpenStack Identity Domains" b
- name: $1
	os_keystone_domain:
		name: ${2:# Name that has to be given to the instance}
		# description: # Description of the domain
		# enabled: yes
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_object "Create or Delete objects and containers from OpenStack" b
- name: $1
	os_object:
		container: ${2:# The name of the container in which to create the object}
		# name: # Name to be give to the object. If omitted, operations will be on the entire container
		# filename: # Path to local file to be uploaded.
		# container_access: #private|public
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_user_facts "Retrieve facts about one or more OpenStack users" b
- name: $1
	os_user_facts:
		name: ${2:# Name or ID of the user}
		# domain: # Name or ID of the domain containing the user if the cloud supports domains
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keystone_domain_facts "Retrieve facts about one or more OpenStack domains" b
- name: $1
	os_keystone_domain_facts:
		# name: # Name or ID of the domain
		# filters: # A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_network "Creates/removes networks from OpenStack" b
- name: $1
	os_network:
		name: ${2:# Name to be assigned to the network.}
		# shared: no
		# admin_state_up: yes
		# external: no
		# state: #present|absent
		# provider_physical_network: # The physical network where this network object is implemented.
		# provider_network_type: # The type of physical network that maps to this network resource.
		# provider_segmentation_id: # An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.
		# project: # Project name or ID containing the network (name admin-only)
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_port "Add/Update/Delete ports from an OpenStack cloud." b
- name: $1
	os_port:
		network: ${2:# Network ID or name this port belongs to.}
		# name: # Name that has to be given to the port.
		# fixed_ips: # Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.
		# admin_state_up: # Sets admin state.
		# mac_address: # MAC address of this port.
		# security_groups: # Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)
		# no_security_groups: no
		# allowed_address_pairs: # Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...
		# extra_dhcp_opts: # Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...
		# device_owner: # The ID of the entity that uses this port.
		# device_id: # Device ID of device using this port.
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_quota "Manage OpenStack Quotas" b
- name: $1
	os_quota:
		name: ${2:# Name of the OpenStack Project to manage.}
		# state: present
		# backup_gigabytes: # M
		# backups: # M
		# cores: # M
		# fixed_ips: # N
		# floating_ips: # N
		# floatingip: # N
		# gigabytes: # M
		# gigabytes_lvm: # M
		# injected_file_size: # M
		# injected_files: # N
		# injected_path_size: # M
		# instances: # M
		# key_pairs: # N
		# loadbalancer: # N
		# network: # N
		# per_volume_gigabytes: # M
		# pool: # N
		# port: # N
		# properties: # N
		# ram: # M
		# rbac_policy: # N
		# router: # N
		# security_group_rule: # N
		# security_group: # N
		# server_group_members: # N
		# server_groups: # N
		# snapshots: # N
		# snapshots_lvm: # N
		# subnet: # N
		# subnetpool: # N
		# volumes: # N
		# volumes_lvm: # N
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_auth "Retrieve an auth token" b
- name: $1
	os_auth:
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_ironic_inspect "Explicitly triggers baremetal node introspection in ironic." b
- name: $1
	os_ironic_inspect:
		# mac: # unique mac address that is used to attempt to identify the host.
		# uuid: # globally unique identifier (UUID) to identify the host.
		# name: # unique name identifier to identify the host in Ironic.
		# ironic_url: # If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.
		# timeout: 1200
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_subnet "Add/Remove subnet to an OpenStack network" b
- name: $1
	os_subnet:
		name: ${2:# The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.}
		# state: #present|absent
		# network_name: # Name of the network to which the subnet should be attached
		# cidr: # The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.
		# ip_version: 4
		# enable_dhcp: yes
		# gateway_ip: # The ip that would be assigned to the gateway for this subnet
		# no_gateway_ip: no
		# dns_nameservers: # List of DNS nameservers for this subnet.
		# allocation_pool_start: # From the subnet pool the starting address from which the IP should be allocated.
		# allocation_pool_end: # From the subnet pool the last IP that should be assigned to the virtual machines.
		# host_routes: # A list of host route dictionaries for the subnet.
		# ipv6_ra_mode: dhcpv6-stateful|dhcpv6-stateless|slaac
		# ipv6_address_mode: dhcpv6-stateful|dhcpv6-stateless|slaac
		# use_default_subnetpool: no
		# project: # Project name or ID containing the subnet (name admin-only)
		# availability_zone: # Ignored. Present for backwards compatibility
		# extra_specs: {}
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server "Create/Delete Compute Instances from OpenStack" b
- name: $1
	os_server:
		name: ${2:# Name that has to be given to the instance. It is also possible to specify the ID of the instance instead of its name if I(state) is I(absent).}
		image: ${3:# The name or id of the base image to boot.}
		# image_exclude: # Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"
		# flavor: 1
		# flavor_ram: 1
		# flavor_include: # Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.
		# key_name: # The key pair name to be used when creating a instance
		# security_groups: # Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.
		# network: # Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.
		# nics: # A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.
		# auto_ip: yes
		# floating_ips: # list of valid floating IPs that pre-exist to assign to this node
		# floating_ip_pools: # Name of floating IP pool from which to choose a floating IP
		# meta: # A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"
		# wait: yes
		# timeout: 180
		# config_drive: no
		# userdata: # Opaque blob of data which is made available to the instance
		# boot_from_volume: no
		# volume_size: # The size of the volume to create in GB if booting from volume based on an image.
		# boot_volume: # Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.
		# terminate_volume: no
		# volumes: []
		# scheduler_hints: # Arbitrary key/value pairs to the scheduler for custom use
		# state: #present|absent
		# delete_fip: no
		# reuse_ips: yes
		# availability_zone: # Availability zone in which to create the server.
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_coe_cluster_template "Add/Remove COE cluster template from OpenStack Cloud" b
- name: $1
	os_coe_cluster_template:
		name: ${2:# Name that has to be given to the cluster template}
		# availability_zone: # Ignored. Present for backwards compatibility
		# coe: kubernetes|swarm|mesos
		# dns_nameserver: 8.8.8.8
		# docker_storage_driver: devicemapper|overlay
		# docker_volume_size: # The size in GB of the docker volume
		# external_network_id: # The external network to attach to the Cluster
		# fixed_network: # The fixed network name to attach to the Cluster
		# fixed_subnet: # The fixed subnet name to attach to the Cluster
		# flavor_id: # The flavor of the minion node for this ClusterTemplate
		# floating_ip_enabled: yes
		# keypair_id: # Name or ID of the keypair to use.
		# image_id: # Image id the cluster will be based on
		# labels: # One or more key/value pairs
		# http_proxy: # Address of a proxy that will receive all HTTP requests and relay them The format is a URL including a port number
		# https_proxy: # Address of a proxy that will receive all HTTPS requests and relay them. The format is a URL including a port number
		# master_flavor_id: # The flavor of the master node for this ClusterTemplate
		# master_lb_enabled: no
		# network_driver: flannel|calico|docker
		# no_proxy: # A comma separated list of IPs for which proxies should not be used in the cluster
		# public: no
		# registry_enabled: no
		# server_type: #vm|bm
		# state: #present|absent
		# tls_disabled: no
		# volume_driver: cinder|rexray
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_keypair "Add/Delete a keypair from OpenStack" b
- name: $1
	os_keypair:
		name: ${2:# Name that has to be given to the key pair}
		# public_key: # The public key that would be uploaded to nova and injected into VMs upon creation.
		# public_key_file: # Path to local file containing ssh public key. Mutually exclusive with public_key.
		# state: #present|absent
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet os_server_group "Manage OpenStack server groups" b
- name: $1
	os_server_group:
		name: ${2:# Server group name.}
		# state: #present|absent
		# policies: # A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.
		# availability_zone: # Ignored. Present for backwards compatibility
		# cloud: # Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.
		# auth: # Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.
		# auth_type: # Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.
		# region_name: # Name of the region.
		# wait: yes
		# timeout: 180
		# api_timeout: # How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.
		# verify: # Whether or not SSL API requests should be verified. Before 2.3 this defaulted to True.
		# cacert: # A path to a CA Cert bundle that can be used as part of verifying SSL API requests.
		# cert: # A path to a client certificate to use as part of the SSL transaction.
		# key: # A path to a client key to use as part of the SSL transaction.
		# interface: #public|internal|admin
$0
endsnippet

snippet docker_service "Manage docker services and containers." b
- name: $1
	docker_service:
		# project_src: # Path to a directory containing a docker-compose.yml or docker-compose.yaml file.
		# project_name: # Provide a project name. If not provided, the project name is taken from the basename of C(project_src).
		# files: # List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.
		# state: absent|#present
		# services: # When C(state) is I(present) run I(docker-compose up) on a subset of services.
		# scale: # When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.
		# dependencies: yes
		# definition: # Provide docker-compose yaml describing one or more services, networks and volumes.
		# hostname_check: no
		# recreate: always|never|#smart
		# build: no
		# pull: no
		# nocache: no
		# remove_images: all|local
		# remove_volumes: no
		# stopped: no
		# restarted: no
		# remove_orphans: no
		# timeout: 10
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_image_facts "Inspect docker images" b
- name: $1
	docker_image_facts:
		name: ${2:# An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.}
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_image "Manage docker images." b
- name: $1
	docker_image:
		name: ${2:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}
		# archive_path: # Use with state C(present) to archive an image to a .tar file.
		# load_path: # Use with state C(present) to load an image from a .tar file.
		# dockerfile: # Use with state C(present) to provide an alternate name for the Dockerfile to use when building an image.
		# force: no
		# http_timeout: # Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.
		# path: # Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.
		# pull: yes
		# push: no
		# rm: yes
		# nocache: no
		# repository: # Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).
		# state: absent|#present|build
		# tag: latest
		# buildargs: # Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.
		# container_limits: # A dictionary of limits applied to each container created by the build process.
		# use_tls: #no|encrypt|verify
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_secret "Manage docker secrets." b
- name: $1
	docker_secret:
		name: ${2:# The name of the secret.}
		# data: # String. The value of the secret. Required when state is C(present).
		# labels: # A map of key:value meta data, where both the I(key) and I(value) are expected to be a string.
		# force: no
		# state: absent|#present
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_login "Log into a Docker registry." b
- name: $1
	docker_login:
		username: ${2:# The username for the registry account}
		password: ${3:# The plaintext password for the registry account}
		# registry_url: https://index.docker.io/v1/
		# email: # The email address for the registry account.
		# reauthorize: no
		# config_path: ~/.docker/config.json
		# state: #present|absent
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_volume "Manage Docker volumes" b
- name: $1
	docker_volume:
		name: ${2:# Name of the volume to operate on.}
		# driver: local
		# driver_options: # Dictionary of volume settings. Consult docker docs for valid options and values: U(https://docs.docker.com/engine/reference/commandline/volume_create/#driver-specific-options)
		# labels: # Dictionary of label key/values to set for the volume
		# force: no
		# state: absent|#present
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_swarm_service "docker swarm service" b
- name: $1
	docker_swarm_service:
		name: ${2:# Service name}
		image: ${3:# Service image path and tag. Maps docker service IMAGE parameter.}
		state: ${4:#present|absent}
		# args: []
		# constraints: []
		# hostname: 
		# tty: no
		# dns: []
		# dns_search: []
		# dns_options: []
		# force_update: no
		# labels: # Dictionary of key value pairs.
		# container_labels: # Dictionary of key value pairs.
		# endpoint_mode: vip|dnsrr
		# env: []
		# log_driver: json-file
		# log_driver_options: []
		# limit_cpu: 0.0
		# reserve_cpu: 0.0
		# limit_memory: 0
		# reserve_memory: 0
		# mode: replicated
		# mounts: []
		# secrets: []
		# configs: []
		# networks: []
		# publish: []
		# replicas: -1
		# restart_policy: #none|on-failure|any
		# restart_policy_attempts: 0
		# restart_policy_delay: 0
		# restart_policy_window: 0
		# update_delay: 10
		# update_parallelism: 1
		# update_failure_action: #continue|pause
		# update_monitor: 5000000000
		# update_max_failure_ratio: 0.0
		# update_order: #stop-first|start-first
		# user: root
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_network "Manage Docker networks" b
- name: $1
	docker_network:
		name: ${2:# Name of the network to operate on.}
		# connected: # List of container names or container IDs to connect to a network.
		# driver: bridge
		# driver_options: # Dictionary of network settings. Consult docker docs for valid options and values.
		# force: no
		# appends: no
		# ipam_driver: # Specify an IPAM driver.
		# ipam_options: # Dictionary of IPAM options.
		# state: absent|#present
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_swarm "Manage Swarm cluster" b
- name: $1
	docker_swarm:
		state: ${2:#present|join|absent|remove|inspect}
		# advertise_addr: # Externally reachable address advertised to other nodes.
		# listen_addr: 0.0.0.0:2377
		# force: no
		# node_id: # Swarm id of the node to remove.
		# join_token: # Swarm token used to join a swarm cluster.
		# remote_addrs: # Remote address of a manager to connect to.
		# task_history_retention_limit: # Maximum number of tasks history stored.
		# snapshot_interval: # Number of logs entries between snapshot.
		# keep_old_snapshots: # Number of snapshots to keep beyond the current snapshot.
		# log_entries_for_slow_followers: # Number of log entries to keep around to sync up slow followers after a snapshot is created.
		# heartbeat_tick: # Amount of ticks (in seconds) between each heartbeat.
		# election_tick: # Amount of ticks (in seconds) needed without a leader to trigger a new election.
		# dispatcher_heartbeat_period: # The delay for an agent to send a heartbeat to the dispatcher.
		# node_cert_expiry: # Automatic expiry for nodes certificates.
		# name: # The name of the swarm.
		# labels: # User-defined key/value metadata.
		# signing_ca_cert: # The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.
		# signing_ca_key: # The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.
		# ca_force_rotate: # An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified.
		# autolock_managers: # If set, generate a key and use it to lock data stored on the managers.
		# rotate_worker_token: no
		# rotate_manager_token: no
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet docker_container "manage docker containers" b
- name: $1
	docker_container:
		name: ${2:# Assign a name to a new container or match an existing container.}
		# auto_remove: no
		# blkio_weight: # Block IO (relative weight), between 10 and 1000.
		# capabilities: # List of capabilities to add to the container.
		# cap_drop: # List of capabilities to drop from the container.
		# cleanup: no
		# command: # Command to execute when the container starts. A command may be either a string or a list. Prior to version 2.4, strings were split on commas.
		# cpu_period: # Limit CPU CFS (Completely Fair Scheduler) period
		# cpu_quota: # Limit CPU CFS (Completely Fair Scheduler) quota
		# cpuset_cpus: # CPUs in which to allow execution C(1,3) or C(1-3).
		# cpuset_mems: # Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)
		# cpu_shares: # CPU shares (relative weight).
		# detach: yes
		# devices: # List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>
		# dns_opts: # list of DNS options
		# dns_servers: # List of custom DNS servers.
		# dns_search_domains: # List of custom DNS search domains.
		# domainname: # Container domainname.
		# env: # Dictionary of key,value pairs.
		# env_file: # Path to a file, present on the target, containing environment variables I(FOO=BAR).
		# entrypoint: # Command that overwrites the default ENTRYPOINT of the image.
		# etc_hosts: # Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.
		# exposed_ports: # List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.
		# force_kill: no
		# groups: # List of additional group names and/or IDs that the container process will run as.
		# hostname: # Container hostname.
		# ignore_image: no
		# image: # Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.
		# init: no
		# interactive: no
		# ipc_mode: # Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.
		# keep_volumes: yes
		# kill_signal: # Override default signal used to kill a running container.
		# kernel_memory: # Kernel memory limit (format: C(<number>[<unit>])). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte). Minimum is C(4M).
		# labels: # Dictionary of key value pairs.
		# links: # List of name aliases for linked containers in the format C(container_name:alias).
		# log_driver: # Specify the logging driver. Docker uses I(json-file) by default.
		# log_options: # Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details.
		# mac_address: # Container MAC address (e.g. 92:d0:c6:0a:29:33)
		# memory: 0
		# memory_reservation: # Memory soft limit (format: C(<number>[<unit>])). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).
		# memory_swap: # Total memory limit (memory + swap, format: C(<number>[<unit>])). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).
		# memory_swappiness: # Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
		# network_mode: # Connect the container to a network. Choices are "bridge", "host", "none" or "container:<name|id>"
		# userns_mode: # Set the user namespace mode for the container. Currently, the only valid value is C(host).
		# networks: # List of networks the container belongs to.
		# oom_killer: # Whether or not to disable OOM Killer for the container.
		# oom_score_adj: # An integer value containing the score given to the container in order to tune OOM killer preferences.
		# output_logs: no
		# paused: no
		# pid_mode: # Set the PID namespace mode for the container.
		# privileged: no
		# published_ports: # List of ports to publish from the container to the host.
		# pull: no
		# purge_networks: no
		# read_only: no
		# recreate: no
		# restart: no
		# restart_policy: no|on-failure|always|unless-stopped
		# restart_retries: # Use with restart policy to control maximum number of restart attempts.
		# shm_size: # Size of C(/dev/shm) (format: C(<number>[<unit>])). Number is positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).
		# security_opts: # List of security options in the form of C("label:user:User")
		# state: absent|present|stopped|#started
		# stop_signal: # Override default signal used to stop the container.
		# stop_timeout: # Number of seconds to wait for the container to stop before sending SIGKILL.
		# trust_image_content: no
		# tmpfs: # Mount a tmpfs directory
		# tty: no
		# ulimits: # List of ulimit options. A ulimit is specified as C(nofile:262144:262144)
		# sysctls: # Dictionary of key,value pairs.
		# user: # Sets the username or UID used and optionally the groupname or GID for the specified command.
		# uts: # Set the UTS namespace mode for the container.
		# volumes: # List of volumes to mount within the container.
		# volume_driver: # The container volume driver.
		# volumes_from: # List of container names or Ids to get volumes from.
		# working_dir: # Path to the working directory.
		# docker_host: unix://var/run/docker.sock
		# tls_hostname: localhost
		# api_version: auto
		# timeout: 60
		# cacert_path: # Use a CA certificate when performing server verification by providing the path to a CA certificate file.
		# cert_path: # Path to the client's TLS certificate file.
		# key_path: # Path to the client's TLS key file.
		# ssl_version: # Provide a valid SSL version number. Default value determined by ssl.py module.
		# tls: no
		# tls_verify: no
		# debug: no
$0
endsnippet

snippet ovh_ip_loadbalancing_backend "Manage OVH IP LoadBalancing backends" b
- name: $1
	ovh_ip_loadbalancing_backend:
		name: ${2:# Name of the LoadBalancing internal name (ip-X.X.X.X)}
		backend: ${3:# The IP address of the backend to update / modify / delete}
		endpoint: ${4:# The endpoint to use ( for instance ovh-eu)}
		application_key: ${5:# The applicationKey to use}
		application_secret: ${6:# The application secret to use}
		consumer_key: ${7:# The consumer key to use}
		# state: #present|absent
		# probe: #none|http|icmp|oco
		# weight: 8
		# timeout: 120
$0
endsnippet

snippet sl_vm "create or cancel a virtual instance in SoftLayer" b
- name: $1
	sl_vm:
		cpus: ${2:# Count of cpus to be assigned to new virtual instance.}
		memory: ${3:# Amount of memory to be assigned to new virtual instance.}
		disks: ${4:[25]}
		# instance_id: # Instance Id of the virtual instance to perform action option.
		# hostname: # Hostname to be provided to a virtual instance.
		# domain: # Domain name to be provided to a virtual instance.
		# datacenter: # Datacenter for the virtual instance to be deployed.
		# tags: # Tag or list of tags to be provided to a virtual instance.
		# hourly: yes
		# private: no
		# dedicated: no
		# local_disk: yes
		# os_code: # OS Code to be used for new virtual instance.
		# image_id: # Image Template to be used for new virtual instance.
		# nic_speed: 10
		# public_vlan: # VLAN by its Id to be assigned to the public NIC.
		# private_vlan: # VLAN by its Id to be assigned to the private NIC.
		# ssh_keys: # List of ssh keys by their Id to be assigned to a virtual instance.
		# post_uri: # URL of a post provisioning script to be loaded and executed on virtual instance.
		# state: absent|#present
		# wait: yes
		# wait_time: 600
$0
endsnippet

snippet ec2_ami "create or destroy an image in ec2" b
- name: $1
	ec2_ami:
		# instance_id: # Instance ID to create the AMI from.
		# name: # The name of the new AMI.
		# architecture: # The target architecture of the image to register
		# kernel_id: # The target kernel id of the image to register.
		# virtualization_type: # The virtualization type of the image to register.
		# root_device_name: # The root device name of the image to register.
		# wait: no
		# wait_timeout: 900
		# state: absent|#present
		# description: # Human-readable string describing the contents and purpose of the AMI.
		# no_reboot: no
		# image_id: # Image ID to be deregistered.
		# device_mapping: # List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters).
		# delete_snapshot: no
		# tags: # A dictionary of tags to add to the new image; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# purge_tags: no
		# launch_permissions: # Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, "all" is the only acceptable value currently.
		# image_location: # The s3 location of an image to use for the AMI.
		# enhanced_networking: # A boolean representing whether enhanced networking with ENA is enabled or not.
		# billing_products: # A list of valid billing codes. To be used with valid accounts by aws marketplace vendors.
		# ramdisk_id: # The ID of the RAM disk.
		# sriov_net_support: # Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudtrail "manage CloudTrail create, delete, update" b
- name: $1
	cloudtrail:
		state: ${2:present|absent|enabled|disabled}
		name: ${3:# Name for the CloudTrail.}
		# enable_logging: yes
		# s3_bucket_name: # An existing S3 bucket where CloudTrail will deliver log files.
		# s3_key_prefix: # S3 Key prefix for delivered log files. A trailing slash is not necessary and will be removed.
		# is_multi_region_trail: no
		# enable_log_file_validation: # Specifies whether log file integrity validation is enabled.
		# include_global_events: yes
		# sns_topic_name: # SNS Topic name to send notifications to when a log file is delivered
		# cloudwatch_logs_role_arn: # Specifies a full ARN for an IAM role that assigns the proper permissions for CloudTrail to create and write to the log group.
		# cloudwatch_logs_log_group_arn: # A full ARN specifying a valid CloudWatch log group to which CloudTrail logs will be delivered. The log group should already exist.
		# kms_key_id: # Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. This also has the effect of enabling log file encryption.
		# tags: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet redshift "create, delete, or modify an Amazon Redshift instance" b
- name: $1
	redshift:
		command: ${2:create|facts|delete|modify}
		identifier: ${3:# Redshift cluster identifier.}
		# node_type: ds1.xlarge|ds1.8xlarge|ds2.xlarge|ds2.8xlarge|dc1.large|dc1.8xlarge|dc2.large|dc2.8xlarge|dw1.xlarge|dw1.8xlarge|dw2.large|dw2.8xlarge
		# username: # Master database username. Used only when command=create.
		# password: # Master database password. Used only when command=create.
		# cluster_type: multi-node|#single-node
		# db_name: # Name of the database.
		# availability_zone: # availability zone in which to launch cluster
		# number_of_nodes: # Number of nodes. Only used when cluster_type=multi-node.
		# cluster_subnet_group_name: # which subnet to place the cluster
		# cluster_security_groups: # in which security group the cluster belongs
		# vpc_security_group_ids: # VPC security group
		# skip_final_cluster_snapshot: no
		# final_cluster_snapshot_identifier: # identifier of the final snapshot to be created before deleting the cluster. If this parameter is provided, final_cluster_snapshot_identifier must be false. Used only when command=delete.
		# preferred_maintenance_window: # maintenance window
		# cluster_parameter_group_name: # name of the cluster parameter group
		# automated_snapshot_retention_period: # period when the snapshot take place
		# port: # which port the cluster is listining
		# cluster_version: 1.0
		# allow_version_upgrade: yes
		# publicly_accessible: no
		# encrypted: no
		# elastic_ip: # if the cluster has an elastic IP or not
		# new_cluster_identifier: # Only used when command=modify.
		# wait: no
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elasticache_facts "Retrieve facts for AWS Elasticache clusters" b
- name: $1
	elasticache_facts:
		# name: # The name of an Elasticache cluster
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_target_facts "Gathers which target groups a target is associated with." b
- name: $1
	elb_target_facts:
		instance_id: ${2:# What instance ID to get facts for.}
		# get_unused_target_groups: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_ssm_parameter_store "Manage key-value pairs in aws parameter store." b
- name: $1
	aws_ssm_parameter_store:
		name: ${2:# parameter key name.}
		# description: # parameter key desciption.
		# value: # Parameter value.
		# state: #present|absent
		# string_type: #String|StringList|SecureString
		# decryption: yes
		# key_id: aws/ssm (this key is automatically generated at the first parameter created).
		# overwrite_value: never|#changed|always
		# region: # region.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet aws_glue_job "Manage an AWS Glue job" b
- name: $1
	aws_glue_job:
		command_script_location: ${2:# The S3 path to a script that executes a job.}
		name: ${3:# The name you assign to this job definition. It must be unique in your account.}
		role: ${4:# The name or ARN of the IAM role associated with this job.}
		state: ${5:present|absent}
		# allocated_capacity: # The number of AWS Glue data processing units (DPUs) to allocate to this Job. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
		# command_name: glueetl
		# connections: # A list of Glue connections used for this job.
		# default_arguments: # A dict of default arguments for this job.  You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
		# description: # Description of the job being defined.
		# max_concurrent_runs: # The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.
		# max_retries: # The maximum number of times to retry this job if it fails.
		# timeout: # The job timeout in minutes.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_ami_facts "Gather facts about ec2 AMIs" b
- name: $1
	ec2_ami_facts:
		# image_ids: # O
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value.
		# owners: # Filter the images by the owner. Valid options are an AWS account ID, self,
		# executable_users: # Filter images by users with explicit launch permissions. Valid options are an AWS account ID, self, or all (public AMIs).
		# describe_image_attributes: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_target_group_facts "Gather facts about ELB target groups in AWS" b
- name: $1
	elb_target_group_facts:
		# load_balancer_arn: # The Amazon Resource Name (ARN) of the load balancer.
		# target_group_arns: # The Amazon Resource Names (ARN) of the target groups.
		# names: # The names of the target groups.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudfront_distribution "create, update and delete aws cloudfront distributions." b
- name: $1
	cloudfront_distribution:
		# state: #present|absent
		# distribution_id: # The id of the cloudfront distribution. This parameter can be exchanged with I(alias) or I(caller_reference) and is used in conjunction with I(e_tag).
		# e_tag: # A unique identifier of a modified or existing distribution. Used in conjunction with I(distribution_id). Is determined automatically if not specified.
		# caller_reference: # A unique identifier for creating and updating cloudfront distributions. Each caller reference must be unique across all distributions. e.g. a caller reference used in a web distribution cannot be reused in a streaming distribution. This parameter can be used instead of I(distribution_id) to reference an existing distribution. If not specified, this defaults to a datetime stamp of the format 'YYYY-MM-DDTHH:MM:SS.ffffff'.
		# tags: # Should be input as a dict() of key-value pairs. Note that numeric keys or values must be wrapped in quotes. e.g. "Priority:" '1'
		# purge_tags: no
		# alias: # The name of an alias (CNAME) that is used in a distribution. This is used to effectively reference a distribution by its alias as an alias can only be used by one distribution per AWS account. This variable avoids having to provide the I(distribution_id) as well as the I(e_tag), or I(caller_reference) of an existing distribution.
		# aliases: # A I(list[]) of domain name aliases (CNAMEs) as strings to be used for the distribution. Each alias must be unique across all distribution for the AWS account.
		# purge_aliases: no
		# default_root_object: # A config element that specifies the path to request when the user requests the origin. e.g. if specified as 'index.html', this maps to www.example.com/index.html when www.example.com is called by the user. This prevents the entire distribution origin from being exposed at the root.
		# default_origin_domain_name: # The domain name to use for an origin if no I(origins) have been specified. Should only be used on a first run of generating a distribution and not on subsequent runs. Should not be used in conjunction with I(distribution_id), I(caller_reference) or I(alias).
		# default_origin_path: # The default origin path to specify for an origin if no I(origins) have been specified. Defaults to empty if not specified.
		# origins: # A config element that is a I(list[]) of complex origin objects to be specified for the distribution. Used for creating and updating distributions. Each origin item comprises the attributes I(id) I(domain_name) (defaults to default_origin_domain_name if not specified) I(origin_path) (defaults to default_origin_path if not specified) I(custom_headers[]) I(header_name) I(header_value) I(s3_origin_access_identity_enabled) I(custom_origin_config) I(http_port) I(https_port) I(origin_protocol_policy) I(origin_ssl_protocols[]) I(origin_read_timeout) I(origin_keepalive_timeout)
		# purge_origins: no
		# default_cache_behavior: # A config element that is a complex object specifying the default cache behavior of the distribution. If not specified, the I(target_origin_id) is defined as the I(target_origin_id) of the first valid I(cache_behavior) in I(cache_behaviors) with defaults. The default cache behavior comprises the attributes I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[]) I(lambda_function_arn) I(event_type) I(field_level_encryption_id)
		# cache_behaviors: # A config element that is a I(list[]) of complex cache behavior objects to be specified for the distribution. The order of the list is preserved across runs unless C(purge_cache_behavior) is enabled. Each cache behavior comprises the attributes I(path_pattern) I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[]) I(field_level_encryption_id)
		# purge_cache_behaviors: no
		# custom_error_responses: # A config element that is a I(list[]) of complex custom error responses to be specified for the distribution. This attribute configures custom http error messages returned to the user. Each custom error response object comprises the attributes I(error_code) I(reponse_page_path) I(response_code) I(error_caching_min_ttl)
		# purge_custom_error_responses: no
		# comment: # A comment that describes the cloudfront distribution. If not specified, it defaults to a generic message that it has been created with Ansible, and a datetime stamp.
		# logging: # A config element that is a complex object that defines logging for the distribution. The logging object comprises the attributes I(enabled) I(include_cookies) I(bucket) I(prefix)
		# price_class: PriceClass_100|PriceClass_200|PriceClass_All
		# enabled: yes
		# viewer_certificate: # A config element that is a complex object that specifies the encryption details of the distribution. Comprises the following attributes I(cloudfront_default_certificate) I(iam_certificate_id) I(acm_certificate_arn) I(ssl_support_method) I(minimum_protocol_version) I(certificate) I(certificate_source)
		# restrictions: # A config element that is a complex object that describes how a distribution should restrict it's content. The restriction object comprises the following attributes I(geo_restriction) I(restriction_type) I(items[])
		# web_acl_id: # The id of a Web Application Firewall (WAF) Access Control List (ACL).
		# http_version: http1.1|http2
		# ipv6_enabled: no
		# wait: no
		# wait_timeout: 1800
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet s3_logging "Manage logging facility of an s3 bucket in AWS" b
- name: $1
	s3_logging:
		name: ${2:# Name of the s3 bucket.}
		# state: #present|absent
		# target_bucket: # The bucket to log to. Required when state=present.
		# target_prefix: 
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_vpn_facts "Gather facts about VPN Connections in AWS." b
- name: $1
	ec2_vpc_vpn_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnConnections.html) for possible filters.
		# vpn_connection_ids: # Get details of a specific VPN connections using vpn connection ID/IDs. This value should be provided as a list.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_application_lb "Manage an Application load balancer" b
- name: $1
	elb_application_lb:
		name: ${2:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}
		# access_logs_enabled: # Whether or not to enable access logs. When true, I(access_logs_s3_bucket) must be set.
		# access_logs_s3_bucket: # The name of the S3 bucket for the access logs. This attribute is required if access logs in Amazon S3 are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permission to write to the bucket.
		# access_logs_s3_prefix: # The prefix for the location in the S3 bucket. If you don't specify a prefix, the access logs are stored in the root of the bucket.
		# deletion_protection: no
		# http2: no
		# idle_timeout: 60
		# listeners: # A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.
		# purge_listeners: yes
		# purge_tags: yes
		# subnets: # A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present.
		# security_groups: []
		# scheme: #internet-facing|internal
		# state: #present|absent
		# tags: # A dictionary of one or more tags to assign to the load balancer.
		# wait: no
		# wait_timeout: # The time in seconds to use in conjunction with I(wait).
		# purge_rules: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# dhcp_options_ids: # Get details of specific DHCP Option ID
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_application_scaling_policy "Manage Application Auto Scaling Scaling Policies" b
- name: $1
	aws_application_scaling_policy:
		policy_name: ${2:# T}
		service_namespace: ${3:ecs|elasticmapreduce|ec2|appstream|dynamodb}
		resource_id: ${4:# T}
		scalable_dimension: ${5:ecs:service:DesiredCount|ec2:spot-fleet-request:TargetCapacity|elasticmapreduce:instancegroup:InstanceCount|appstream:fleet:DesiredCapacity|dynamodb:table:ReadCapacityUnits|dynamodb:table:WriteCapacityUnits|dynamodb:index:ReadCapacityUnits|dynamodb:index:WriteCapacityUnits}
		policy_type: ${6:StepScaling|TargetTrackingScaling}
		# step_scaling_policy_configuration: # A
		# target_tracking_scaling_policy_configuration: # A
		# minimum_tasks: # T
		# maximum_tasks: # T
		# override_task_capacity: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_key "create or delete an ec2 key pair" b
- name: $1
	ec2_key:
		name: ${2:# Name of the key pair.}
		# key_material: # Public key material.
		# force: yes
		# state: #present|absent
		# wait: no
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet rds "create, delete, or modify an Amazon rds instance" b
- name: $1
	rds:
		command: ${2:create|replicate|delete|facts|modify|promote|snapshot|reboot|restore}
		region: ${3:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}
		# instance_name: # Database instance identifier. Required except when using command=facts or command=delete on just a snapshot
		# source_instance: # Name of the database to replicate. Used only when command=replicate.
		# db_engine: mariadb|MySQL|oracle-se1|oracle-se2|oracle-se|oracle-ee|sqlserver-ee|sqlserver-se|sqlserver-ex|sqlserver-web|postgres|aurora
		# size: # Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.
		# instance_type: # The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.
		# username: # Master database username. Used only when command=create.
		# password: # Password for the master database username. Used only when command=create or command=modify.
		# db_name: # Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.
		# engine_version: # Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used
		# parameter_group: # Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.
		# license_model: license-included|bring-your-own-license|general-public-license|postgresql-license
		# multi_zone: # Specifies if this is a Multi-availability-zone deployment. Can not be used in conjunction with zone parameter. Used only when command=create or command=modify.
		# iops: # Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000.
		# security_groups: # Comma separated list of one or more security groups.  Used only when command=create or command=modify.
		# vpc_security_groups: # Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.
		# port: 3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.
		# upgrade: no
		# option_group: # The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.
		# maint_window: # Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.

		# backup_window: # Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.
		# backup_retention: # Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.

		# zone: # availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.
		# subnet: # VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.
		# snapshot: # Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# wait: no
		# wait_timeout: 300
		# apply_immediately: no
		# force_failover: no
		# new_instance_name: # Name to rename an instance to. Used only when command=modify.
		# character_set_name: # Associate the DB instance with a specified character set. Used with command=create.
		# publicly_accessible: # explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0
		# tags: # tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet route53_health_check "add or delete health-checks in Amazons Route53 DNS service" b
- name: $1
	route53_health_check:
		state: ${2:present|absent}
		type: ${3:HTTP|HTTPS|HTTP_STR_MATCH|HTTPS_STR_MATCH|TCP}
		request_interval: ${4:10|#30}
		failure_threshold: ${5:1|2|#3|4|5|6|7|8|9|10}
		# ip_address: # IP address of the end-point to check. Either this or `fqdn` has to be provided.
		# port: # The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.
		# resource_path: # The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.
		# fqdn: # Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.
		# string_match: # If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_igw "Manage an AWS VPC Internet gateway" b
- name: $1
	ec2_vpc_igw:
		vpc_id: ${2:# The VPC ID for the VPC in which to manage the Internet Gateway.}
		# tags: # A dict of tags to apply to the internet gateway. Any tags currently applied to the internet gateway and not present here will be removed.
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_network_lb "Manage a Network Load Balancer" b
- name: $1
	elb_network_lb:
		name: ${2:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}
		state: ${3:present|absent}
		# cross_zone_load_balancing: no
		# deletion_protection: no
		# listeners: # A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.
		# purge_listeners: yes
		# purge_tags: yes
		# subnet_mappings: # A list of dicts containing the IDs of the subnets to attach to the load balancer. You can also specify the allocation ID of an Elastic IP to attach to the load balancer. You can specify one Elastic IP address per subnet. This parameter is mutually exclusive with I(subnets)
		# subnets: # A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present. This parameter is mutually exclusive with I(subnet_mappings)
		# scheme: #internet-facing|internal
		# tags: # A dictionary of one or more tags to assign to the load balancer.
		# wait: # Whether or not to wait for the network load balancer to reach the desired state.
		# wait_timeout: # The duration in seconds to wait, used in conjunction with I(wait).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_lc "Create or delete AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc:
		name: ${2:# Unique name for configuration}
		instance_type: ${3:# Instance type to use for the instance}
		# state: #present|absent
		# image_id: # The AMI unique identifier to be used for the group
		# key_name: # The SSH key name to be used for access to managed instances
		# security_groups: # A list of security groups to apply to the instances. Since version 2.4 you can specify either security group names or IDs or a mix.  Previous to 2.4, for VPC instances, specify security group IDs and for EC2-Classic, specify either security group names or IDs.
		# volumes: # A list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.
		# user_data: # Opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path).
		# user_data_path: # Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data).
		# kernel_id: # Kernel id for the EC2 instance
		# spot_price: # The spot price you are bidding. Only applies for an autoscaling group with spot instances.
		# instance_monitoring: no
		# assign_public_ip: # Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.
		# ramdisk_id: # A RAM disk id for the instances.
		# instance_profile_name: # The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.
		# ebs_optimized: no
		# classic_link_vpc_id: # Id of ClassicLink enabled VPC
		# classic_link_vpc_security_groups: # A list of security group IDs with which to associate the ClassicLink VPC instances.
		# vpc_id: # VPC ID, used when resolving security group names to IDs.
		# instance_id: # The Id of a running instance to use as a basis for a launch configuration. Can be used in place of image_id and instance_type.
		# placement_tenancy: default
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
- name: $1
$0
endsnippet

snippet aws_glue_connection "Manage an AWS Glue connection" b
- name: $1
	aws_glue_connection:
		connection_properties: ${2:# A dict of key-value pairs used as parameters for this connection.}
		name: ${3:# The name of the connection.}
		state: ${4:present|absent}
		# catalog_id: # The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.
		# connection_type: #JDBC|SFTP
		# description: # The description of the connection.
		# match_criteria: # A list of UTF-8 strings that specify the criteria that you can use in selecting this connection.
		# security_groups: # A list of security groups to be used by the connection. Use either security group name or ID.
		# subnet_id: # The subnet ID used by the connection.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_role "Manage AWS IAM roles" b
- name: $1
	iam_role:
		name: ${2:# The name of the role to create.}
		# path: /
		# description: # Provide a description of the new role
		# boundary: # Add the ARN of an IAM managed policy to restrict the permissions this role can pass on to IAM roles/users that it creates.
		# assume_role_policy_document: # The trust relationship policy document that grants an entity permission to assume the role.
		# managed_policy: # A list of managed policy ARNs or, since Ansible 2.4, a list of either managed policy ARNs or friendly names. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.
		# purge_policies: yes
		# state: #present|absent
		# create_instance_profile: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elasticache "Manage cache clusters in Amazon Elasticache." b
- name: $1
	elasticache:
		state: ${2:present|absent|rebooted}
		name: ${3:# The cache cluster identifier}
		# engine: redis|#memcached
		# cache_engine_version: # The version number of the cache engine
		# node_type: cache.m1.small
		# num_nodes: # The initial number of cache nodes that the cache cluster will have. Required when state=present.
		# cache_port: # The port number on which each of the cache nodes will accept connections
		# cache_parameter_group: # The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.
		# cache_subnet_group: # The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc
		# security_group_ids: # A list of vpc security group names to associate with this cache cluster. Only use if inside a vpc
		# cache_security_groups: # A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc
		# zone: # The EC2 Availability Zone in which the cache cluster will be created
		# wait: yes
		# hard_modify: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_asg_lifecycle_hook "Create, delete or update AWS ASG Lifecycle Hooks." b
- name: $1
	ec2_asg_lifecycle_hook:
		lifecycle_hook_name: ${2:# The name of the lifecycle hook.}
		autoscaling_group_name: ${3:# The name of the Auto Scaling group to which you want to assign the lifecycle hook.}
		transition: ${4:autoscaling:EC2_INSTANCE_TERMINATING|autoscaling:EC2_INSTANCE_LAUNCHING}
		# state: #present|absent
		# role_arn: # The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.
		# notification_target_arn: # The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an SQS queue or an SNS topic. If you specify an empty string, this overrides the current ARN.
		# notification_meta_data: # Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.
		# heartbeat_timeout: 3600 (1 hour)
		# default_result: #ABANDON|CONTINUE
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_nacl "create and delete Network ACLs." b
- name: $1
	ec2_vpc_nacl:
		# name: # Tagged name identifying a network ACL.
		# nacl_id: # NACL id identifying a network ACL.
		# vpc_id: # VPC id of the requesting VPC.
		# subnets: # The list of subnets that should be associated with the network ACL.
		# egress: []
		# ingress: []
		# tags: # Dictionary of tags to look for and apply when creating a network ACL.
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_placement_group "Create or delete an EC2 Placement Group" b
- name: $1
	ec2_placement_group:
		name: ${2:# The name for the placement group.}
		# state: #present|absent
		# strategy: #cluster|spread
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_nat_gateway "Manage AWS VPC NAT Gateways." b
- name: $1
	ec2_vpc_nat_gateway:
		# state: #present|absent
		# nat_gateway_id: # The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.
		# subnet_id: # The id of the subnet to create the NAT Gateway in. This is required with the present option.
		# allocation_id: # The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.
		# eip_address: # The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.
		# if_exist_do_not_create: no
		# release_eip: yes
		# wait: no
		# wait_timeout: 300
		# client_token: # Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_waf_condition "create and delete WAF Conditions" b
- name: $1
	aws_waf_condition:
		name: ${2:# N}
		# type: byte|geo|ip|regex|size|sql|xss
		# filters: # A list of the filters against which to match
		# purge_filters: # W
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_net_facts "Gather facts about ec2 VPCs in AWS" b
- name: $1
	ec2_vpc_net_facts:
		# vpc_ids: # A list of VPC IDs that exist in your account.
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_snapshot "creates a snapshot from an existing volume" b
- name: $1
	ec2_snapshot:
		# volume_id: # volume from which to take the snapshot
		# description: # description to be applied to the snapshot
		# instance_id: # instance that has the required volume to snapshot mounted
		# device_name: # device name of a mounted volume to be snapshotted
		# snapshot_tags: # a hash/dictionary of tags to add to the snapshot
		# wait: yes
		# wait_timeout: 0
		# state: absent|#present
		# snapshot_id: # snapshot id to remove
		# last_snapshot_min_age: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet redshift_facts "Gather facts about Redshift cluster(s)" b
- name: $1
	redshift_facts:
		# cluster_identifier: # The prefix of cluster identifier of the Redshift cluster you are searching for.
		# tags: # A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the security group(s) you are searching for.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet aws_config_delivery_channel "Manage AWS Config delivery channels" b
- name: $1
	aws_config_delivery_channel:
		name: ${2:# The name of the AWS Config resource.}
		# state: #present|absent
		# s3_bucket: # The name of the Amazon S3 bucket to which AWS Config delivers configuration snapshots and configuration history files.
		# s3_prefix: # The prefix for the specified Amazon S3 bucket.
		# sns_topic_arn: # The Amazon Resource Name (ARN) of the Amazon SNS topic to which AWS Config sends notifications about configuration changes.
		# delivery_frequency: One_Hour|Three_Hours|Six_Hours|Twelve_Hours|TwentyFour_Hours
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet data_pipeline "Create and manage AWS Datapipelines" b
- name: $1
	data_pipeline:
		name: ${2:# The name of the Datapipeline to create/modify/delete.}
		# description: 
		# objects: # A list of pipeline object definitions, each of which is a dict that takes the keys C(id), C(name) and C(fields).
		# parameters: # A list of parameter objects (dicts) in the pipeline definition.
		# values: # A list of parameter values (dicts) in the pipeline definition. Each dict takes the keys C(id) and C(stringValue) both of which are strings.
		# timeout: 300
		# state: #present|absent|active|inactive
		# tags: # A dict of key:value pair(s) to add to the pipeline.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_ses_identity "Manages SES email and domain identity" b
- name: $1
	aws_ses_identity:
		identity: ${2:# This is the email address or domain to verify / delete.}
		# state: #present|absent
		# bounce_notifications: # Setup the SNS topic used to report bounce notifications.
		# complaint_notifications: # Setup the SNS topic used to report complaint notifications.
		# delivery_notifications: # Setup the SNS topic used to report delivery notifications.
		# feedback_forwarding: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet s3_bucket "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3" b
- name: $1
	s3_bucket:
		name: ${2:# Name of the s3 bucket}
		# force: no
		# policy: # The JSON policy as a string.
		# s3_url: # S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS
		# ceph: # Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.
		# requester_pays: no
		# state: #present|absent
		# tags: # tags dict to apply to bucket
		# versioning: # Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudfront_invalidation "create invalidations for aws cloudfront distributions" b
- name: $1
	cloudfront_invalidation:
		target_paths: ${2:# A list of paths on the distribution to invalidate. Each path should begin with '/'. Wildcards are allowed. eg. '/foo/bar/*'}
		# distribution_id: # The id of the cloudfront distribution to invalidate paths for. Can be specified insted of the alias.
		# alias: # The alias of the cloudfront distribution to invalidate paths for. Can be specified instead of distribution_id.
		# caller_reference: current datetime stamp
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_az_facts "Gather facts about availability zones in AWS." b
- name: $1
	aws_az_facts:
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam "Manage IAM users, groups, roles and keys" b
- name: $1
	iam:
		name: ${2:# Name of IAM resource to create or identify}
		state: ${3:present|absent|update}
		# iam_type: user|group|role
		# new_name: # When state is update, will replace name with new_name on IAM resource
		# new_path: # When state is update, will replace the path with new_path on the IAM resource
		# path: /
		# trust_policy: # The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath).
		# trust_policy_filepath: # The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy).
		# access_key_state: create|remove|active|inactive
		# key_count: 1
		# access_key_ids: # A list of the keys that you want impacted by the access_key_state parameter.
		# groups: # A list of groups the user should belong to. When update, will gracefully remove groups not listed.
		# password: # When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.
		# update_password: #always|on_create
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_service_facts "list or describe services in ecs" b
- name: $1
	ecs_service_facts:
		# details: false
		# events: true
		# cluster: default
		# service: # One or more services to get details for
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_customer_gateway_facts "Gather facts about customer gateways in AWS" b
- name: $1
	ec2_customer_gateway_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCustomerGateways.html) for possible filters.
		# customer_gateway_ids: # Get details of a specific customer gateways using customer gateway ID/IDs. This value should be provided as a list.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_peer "create, delete, accept, and reject VPC peering connections between two VPCs." b
- name: $1
	ec2_vpc_peer:
		# vpc_id: # VPC id of the requesting VPC.
		# peering_id: # Peering connection id.
		# peer_region: # Region of the accepting VPC.
		# peer_vpc_id: # VPC id of the accepting VPC.
		# peer_owner_id: # The AWS account number for cross account peering.
		# tags: # Dictionary of tags to look for and apply when creating a Peering Connection.
		# state: #present|absent|accept|reject
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_route_table_facts "Gather facts about ec2 VPC route tables in AWS" b
- name: $1
	ec2_vpc_route_table_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_peering_facts "Retrieves AWS VPC Peering details using AWS methods." b
- name: $1
	ec2_vpc_peering_facts:
		# peer_connection_ids: # Get details of specific vpc peer IDs
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet rds_snapshot_facts "obtain facts about one or more RDS snapshots" b
- name: $1
	rds_snapshot_facts:
		# db_snapshot_identifier: # Name of an RDS (unclustered) snapshot. Mutually exclusive with I(db_instance_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)
		# db_instance_identifier: # RDS instance name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)
		# db_cluster_identifier: # RDS cluster name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_instance_identifier), I(db_cluster_snapshot_identifier)
		# db_cluster_snapshot_identifier: # Name of an RDS cluster snapshot. Mutually exclusive with I(db_instance_identifier), I(db_snapshot_identifier), I(db_cluster_identifier)
		# snapshot_type: automated|manual|shared|public
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudformation "Create or delete an AWS CloudFormation stack" b
- name: $1
	cloudformation:
		stack_name: ${2:# name of the cloudformation stack}
		# disable_rollback: no
		# create_timeout: # The amount of time (in minutes) that can pass before the stack status becomes CREATE_FAILED
		# template_parameters: {}
		# state: #present|absent
		# template: # The local path of the cloudformation template.
		# notification_arns: # The Simple Notification Service (SNS) topic ARNs to publish stack related events.
		# stack_policy: # the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. (for instance, [allow all updates](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)
		# tags: # Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.
		# template_url: # Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.
		# create_changeset: no
		# changeset_name: # Name given to the changeset when creating a changeset, only used when create_changeset is true. By default a name prefixed with Ansible-STACKNAME is generated based on input parameters. See the AWS Change Sets docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html)
		# template_format: #json|yaml
		# role_arn: # The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)
		# termination_protection: # enable or disable termination protection on the stack. Only works with botocore >= 1.7.18.
		# template_body: # Template body. Use this to pass in the actual body of the Cloudformation template.
		# events_limit: 200
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lambda "Manage AWS Lambda functions" b
- name: $1
	lambda:
		name: ${2:# The name you want to assign to the function you are uploading. Cannot be changed.}
		# state: #present|absent
		# runtime: # The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7
		# role: # The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.
		# handler: # The function within your code that Lambda calls to begin execution
		# zip_file: # A .zip file containing your deployment package
		# s3_bucket: # Amazon S3 bucket name where the .zip file containing your deployment package is stored
		# s3_key: # The Amazon S3 object (the deployment package) key name you want to upload
		# s3_object_version: # The Amazon S3 object (the deployment package) version you want to upload.
		# description: # A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.
		# timeout: 3
		# memory_size: 128
		# vpc_subnet_ids: # List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.
		# vpc_security_group_ids: # List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.
		# environment_variables: # A dictionary of environment variables the Lambda function is given.
		# dead_letter_arn: # The parent object that contains the target Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
		# tags: # tag dict to apply to the function (requires botocore 1.5.40 or above)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet dynamodb_table "Create, update or delete AWS Dynamo DB tables." b
- name: $1
	dynamodb_table:
		name: ${2:# Name of the table.}
		# state: #present|absent
		# hash_key_name: # Name of the hash key.
		# hash_key_type: #STRING|NUMBER|BINARY
		# range_key_name: # Name of the range key.
		# range_key_type: #STRING|NUMBER|BINARY
		# read_capacity: 1
		# write_capacity: 1
		# indexes: []
		# tags: # a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# wait_for_active_timeout: 60
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_elb_lb "Creates or destroys Amazon ELB." b
- name: $1
	ec2_elb_lb:
		state: ${2:present|absent}
		name: ${3:# The name of the ELB}
		# listeners: # List of ports/protocols for this ELB to listen on (see example)
		# purge_listeners: yes
		# instance_ids: no
		# purge_instance_ids: no
		# zones: # List of availability zones to enable on this ELB
		# purge_zones: no
		# security_group_ids: # A list of security groups to apply to the elb
		# security_group_names: # A list of security group names to apply to the elb
		# health_check: # An associative array of health check configuration settings (see example)
		# access_logs: # An associative array of access logs configuration settings (see example)
		# subnets: # A list of VPC subnets to use when creating ELB. Zones should be empty if using this.
		# purge_subnets: no
		# scheme: internal|#internet-facing
		# validate_certs: yes
		# connection_draining_timeout: # Wait a specified timeout allowing connections to drain before terminating an instance
		# idle_timeout: # ELB connections from clients and to servers are timed out after this amount of time
		# cross_az_load_balancing: no
		# stickiness: # An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )
		# wait: no
		# wait_timeout: 60
		# tags: # An associative array of tags. To delete all tags, supply an empty dict.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_ecr "Manage Elastic Container Registry repositories" b
- name: $1
	ecs_ecr:
		name: ${2:# the name of the repository}
		# registry_id: # AWS account id associated with the registry.
		# policy: # JSON or dict that represents the new policy
		# force_set_policy: no
		# delete_policy: no
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_subnet "Manage subnets in AWS virtual private clouds" b
- name: $1
	ec2_vpc_subnet:
		vpc_id: ${2:# VPC ID of the VPC in which to create or delete the subnet.}
		# az: # The availability zone for the subnet.
		# cidr: # The CIDR block for the subnet. E.g. 192.0.2.0/24.
		# ipv6_cidr: # The IPv6 CIDR block for the subnet. The VPC must have a /56 block assigned and this value must be a valid IPv6 /64 that falls in the VPC range.
		# tags: # A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.
		# state: #present|absent
		# map_public: no
		# assign_instances_ipv6: no
		# wait: yes
		# wait_timeout: 300
		# purge_tags: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sts_session_token "Obtain a session token from the AWS Security Token Service" b
- name: $1
	sts_session_token:
		# duration_seconds: # The duration, in seconds, of the session token. See http://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters for acceptable and default values.
		# mfa_serial_number: # The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.
		# mfa_token: # The value provided by the MFA device, if the trust policy of the user requires MFA.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_eni_facts "Gather facts about ec2 ENI interfaces in AWS" b
- name: $1
	ec2_eni_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_caller_facts "Get facts about the user and account being used to make AWS calls." b
- name: $1
	aws_caller_facts:
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_taskdefinition "register a task definition in ecs" b
- name: $1
	ecs_taskdefinition:
		state: ${2:present|absent}
		# arn: # The arn of the task description to delete
		# family: # A Name that would be given to the task definition
		# revision: # A revision number for the task definition
		# force_create: # Always create new task definition
		# containers: # A list of containers definitions
		# network_mode: #bridge|host|none|awsvpc
		# task_role_arn: # The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.
		# execution_role_arn: # The Amazon Resource Name (ARN) of the task execution role that the Amazon ECS container agent and the Docker daemon can assume.
		# volumes: # A list of names of volumes to be attached
		# launch_type: EC2|FARGATE
		# cpu: # The number of cpu units used by the task. If using the EC2 launch type, this field is optional and any value can be used. If using the Fargate launch type, this field is required and you must use one of [256, 512, 1024, 2048, 4096]
		# memory: # The amount (in MiB) of memory used by the task. If using the EC2 launch type, this field is optional and any value can be used. If using the Fargate launch type, this field is required and is limited by the cpu
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet rds_instance_facts "obtain facts about one or more RDS instances" b
- name: $1
	rds_instance_facts:
		# db_instance_identifier: # The RDS instance's unique identifier.
		# filters: # A filter that specifies one or more DB instances to describe. See U(https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet rds_instance "Manage RDS instances" b
- name: $1
	rds_instance:
		db_instance_identifier: ${2:# The DB instance (lowercase) identifier. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens.}
		# state: #present|absent|terminated|running|started|stopped|rebooted|restarted
		# creation_source: snapshot|s3|instance
		# force_update_password: no
		# purge_cloudwatch_logs_exports: yes
		# purge_tags: yes
		# read_replica: # Set to False to promote a read replica cluster or true to create one. When creating a read replica C(creation_source) should be set to 'instance' or not provided. C(source_db_instance_identifier) must be provided with this option.
		# wait: yes
		# allocated_storage: # The amount of storage (in gibibytes) to allocate for the DB instance.
		# allow_major_version_upgrade: # Whether to allow major version upgrades.
		# apply_immediately: no
		# auto_minor_version_upgrade: # Whether minor version upgrades are applied automatically to the DB instance during the maintenance window.
		# availability_zone: # A list of EC2 Availability Zones that instances in the DB cluster can be created in. May be used when creating a cluster or when restoring from S3 or a snapshot. Mutually exclusive with I(multi_az).
		# backup_retention_period: # The number of days for which automated backups are retained (must be greater or equal to 1). May be used when creating a new cluster, when restoring from S3, or when modifying a cluster.
		# ca_certificate_identifier: # The identifier of the CA certificate for the DB instance.
		# character_set_name: # The character set to associate with the DB cluster.
		# copy_tags_to_snapshot: # Whether or not to copy all tags from the DB instance to snapshots of the instance. When initially creating a DB instance the RDS API defaults this to false if unspecified.
		# db_cluster_identifier: # The DB cluster (lowercase) identifier to add the aurora DB instance to. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens.
		# db_instance_class: # The compute and memory capacity of the DB instance, for example db.t2.micro.
		# db_name: # The name for your database. If a name is not provided Amazon RDS will not create a database.
		# db_parameter_group_name: # The name of the DB parameter group to associate with this DB instance. When creating the DB instance if this argument is omitted the default DBParameterGroup for the specified engine is used.
		# db_security_groups: # (EC2-Classic platform) A list of DB security groups to associate with this DB instance.
		# db_snapshot_identifier: # The identifier for the DB snapshot to restore from if using I(creation_source=snapshot).
		# db_subnet_group_name: # The DB subnet group name to use for the DB instance.
		# domain: # The Active Directory Domain to restore the instance in.
		# domain_iam_role_name: # The name of the IAM role to be used when making API calls to the Directory Service.
		# enable_cloudwatch_logs_exports: # A list of log types that need to be enabled for exporting to CloudWatch Logs.
		# enable_iam_database_authentication: # Enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. If this option is omitted when creating the cluster, Amazon RDS sets this to False.
		# enable_performance_insights: # Whether to enable Performance Insights for the DB instance.
		# engine: # The name of the database engine to be used for this DB instance. This is required to create an instance. Valid choices are aurora | aurora-mysql | aurora-postgresql | mariadb | mysql | oracle-ee | oracle-se | oracle-se1 | oracle-se2 | postgres | sqlserver-ee | sqlserver-ex | sqlserver-se | sqlserver-web
		# engine_version: # The version number of the database engine to use. For Aurora MySQL that could be 5.6.10a , 5.7.12. Aurora PostgreSQL example, 9.6.3
		# final_db_snapshot_identifier: # The DB instance snapshot identifier of the new DB instance snapshot created when I(skip_final_snapshot) is false.
		# force_failover: # Set to true to conduct the reboot through a MultiAZ failover.
		# iops: # The Provisioned IOPS (I/O operations per second) value.
		# kms_key_id: # The ARN of the AWS KMS key identifier for an encrypted DB instance. If you are creating a DB instance with the same AWS account that owns the KMS encryption key used to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the KM encryption key.
		# license_model: license-included|bring-your-own-license|general-public-license
		# master_user_password: # An 8-41 character password for the master database user. The password can contain any printable ASCII character except "/", """, or "@". To modify the password use I(force_password_update). Use I(apply immediately) to change the password immediately, otherwise it is updated during the next maintenance window.
		# master_username: # The name of the master user for the DB cluster. Must be 1-16 letters or numbers and begin with a letter.
		# monitoring_interval: # The interval, in seconds, when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting metrics, specify 0. Amazon RDS defaults this to 0 if omitted when initially creating a DB instance.
		# monitoring_role_arn: # The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.
		# multi_az: # Specifies if the DB instance is a Multi-AZ deployment. Mutually exclusive with I(availability_zone).
		# new_db_instance_identifier: # The new DB cluster (lowercase) identifier for the DB cluster when renaming a DB instance. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens. Use I(apply_immediately) to rename immediately, otherwise it is updated during the next maintenance window.
		# option_group_name: # The option group to associate with the DB instance.
		# performance_insights_kms_key_id: # The AWS KMS key identifier (ARN, name, or alias) for encryption of Performance Insights data.
		# performance_insights_retention_period: # The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731.
		# port: # The port number on which the instances accept connections.
		# preferred_backup_window: # The daily time range (in UTC) of at least 30 minutes, during which automated backups are created if automated backups are enabled using I(backup_retention_period). The option must be in the format of "hh24:mi-hh24:mi" and not conflict with I(preferred_maintenance_window).
		# preferred_maintenance_window: # The weekly time range (in UTC) of at least 30 minutes, during which system maintenance can occur. The option must be in the format "ddd:hh24:mi-ddd:hh24:mi" where ddd is one of Mon, Tue, Wed, Thu, Fri, Sat, Sun.
		# processor_features: # A dictionary of Name, Value pairs to indicate the number of CPU cores and the number of threads per core for the DB instance class of the DB instance. Names are threadsPerCore and coreCount. Set this option to an empty dictionary to use the default processor features.
		# promotion_tier: # An integer that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance.
		# publicly_accessible: # Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.
		# restore_time: # If using I(creation_source=instance) this indicates the UTC date and time to restore from the source instance. For example, "2009-09-07T23:45:00Z". May alternatively set c(use_latest_restore_time) to True.
		# s3_bucket_name: # The name of the Amazon S3 bucket that contains the data used to create the Amazon DB instance.
		# s3_ingestion_role_arn: # The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon RDS to access the Amazon S3 bucket on your behalf.
		# s3_prefix: # The prefix for all of the file names that contain the data used to create the Amazon DB instance. If you do not specify a SourceS3Prefix value, then the Amazon DB instance is created by using all of the files in the Amazon S3 bucket.
		# skip_final_snapshot: no
		# snapshot_identifier: # The ARN of the DB snapshot to restore from when using I(creation_source=snapshot).
		# source_db_instance_identifier: # The identifier or ARN of the source DB instance from which to restore when creating a read replica or spinning up a point-in-time DB instance using I(creation_source=instance). If the source DB is not in the same region this should be an ARN.
		# source_engine: mysql
		# source_engine_version: # The version of the database that the backup files were created from.
		# source_region: # The region of the DB instance from which the replica is created.
		# storage_encrypted: # Whether the DB instance is encrypted.
		# storage_type: standard|gp2|io1
		# tags: # A dictionary of key value pairs to assign the DB cluster.
		# tde_credential_arn: # The ARN from the key store with which to associate the instance for Transparent Data Encryption. This is supported by Oracle or SQL Server DB instances and may be used in conjunction with C(storage_encrypted) though it might slightly affect the performance of your database.
		# tde_credential_password: # The password for the given ARN from the key store in order to access the device.
		# timezone: # The time zone of the DB instance.
		# use_latest_restorable_time: # Whether to restore the DB instance to the latest restorable backup time. Only one of I(use_latest_restorable_time) and I(restore_to_time) may be provided.
		# vpc_security_group_ids: # A list of EC2 VPC security groups to associate with the DB cluster.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_vgw "Create and delete AWS VPN Virtual Gateways." b
- name: $1
	ec2_vpc_vgw:
		# state: #present|absent
		# name: # name of the vgw to be created or deleted
		# type: ipsec.1
		# vpn_gateway_id: # vpn gateway id of an existing virtual gateway
		# vpc_id: # the vpc-id of a vpc to attach or detach
		# asn: # the BGP ASN of the amazon side
		# wait_timeout: 320
		# tags: # dictionary of resource tags
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# domain_name: # The domain name to set in the DHCP option sets
		# dns_servers: # A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)
		# ntp_servers: # List of hosts to advertise as NTP servers for the VPC.
		# netbios_name_servers: # List of hosts to advertise as NetBIOS servers.
		# netbios_node_type: # NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
		# vpc_id: # VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.
		# delete_old: yes
		# inherit_existing: no
		# tags: # Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)
		# dhcp_options_id: # The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)
		# state: absent|#present
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lightsail "Create or delete a virtual machine instance in AWS Lightsail" b
- name: $1
	lightsail:
		name: ${2:# Name of the instance}
		# state: #present|absent|running|restarted|stopped
		# zone: # AWS availability zone in which to launch the instance. Required when state='present'
		# blueprint_id: # ID of the instance blueprint image. Required when state='present'
		# bundle_id: # Bundle of specification info for the instance. Required when state='present'
		# user_data: # Launch script that can configure the instance with additional data
		# key_pair_name: # Name of the key pair to use with the instance
		# wait: yes
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_group_facts "Gather facts about ec2 security groups in AWS." b
- name: $1
	ec2_group_facts:
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_scaling_policy "Create or delete AWS scaling policies for Autoscaling groups" b
- name: $1
	ec2_scaling_policy:
		state: ${2:present|absent}
		name: ${3:# Unique name for the scaling policy}
		asg_name: ${4:# Name of the associated autoscaling group}
		# adjustment_type: ChangeInCapacity|ExactCapacity|PercentChangeInCapacity
		# scaling_adjustment: # The amount by which the autoscaling group is adjusted by the policy
		# min_adjustment_step: # Minimum amount of adjustment when policy is triggered
		# cooldown: # The minimum period of time between which autoscaling actions can take place
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_managed_policy "Manage User Managed IAM policies" b
- name: $1
	iam_managed_policy:
		policy_name: ${2:# The name of the managed policy.}
		# policy_description: 
		# policy: # A properly json formatted policy
		# make_default: yes
		# only_version: no
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_waf_rule "create and delete WAF Rules" b
- name: $1
	aws_waf_rule:
		name: ${2:# N}
		# metric_name: # A friendly name or description for the metrics for the rule
		# state: #present|absent
		# conditions: # l
		# purge_conditions: # Whether or not to remove conditions that are not passed when updating `conditions`. Defaults to false.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_attribute "manage ecs attributes" b
- name: $1
	ecs_attribute:
		cluster: ${2:# The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to apply attributes.}
		attributes: ${3:# List of attributes.}
		ec2_instance_id: ${4:# EC2 instance ID of ECS cluster container instance.}
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_igw_facts "Gather facts about internet gateways in AWS" b
- name: $1
	ec2_vpc_igw_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html) for possible filters.
		# internet_gateway_ids: # Get details of specific Internet Gateway ID. Provide this value as a list.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_batch_job_definition "Manage AWS Batch Job Definitions" b
- name: $1
	aws_batch_job_definition:
		job_definition_name: ${2:# The name for the job definition}
		state: ${3:#present|absent}
		type: ${4:# The type of job definition}
		# job_definition_arn: # The arn for the job definition
		# parameters: # Default parameter substitution placeholders to set in the job definition. Parameters are specified as a key-value pair mapping. Parameters in a SubmitJob request override any corresponding parameter defaults from the job definition.
		# image: # The image used to start a container. This string is passed directly to the Docker daemon. Images in the Docker Hub registry are available by default. Other repositories are specified with `` repository-url /image <colon>tag ``. Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed. This parameter maps to Image in the Create a container section of the Docker Remote API and the IMAGE parameter of docker run.
		# vcpus: # The number of vCPUs reserved for the container. This parameter maps to CpuShares in the Create a container section of the Docker Remote API and the --cpu-shares option to docker run. Each vCPU is equivalent to 1,024 CPU shares.
		# memory: # The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed. This parameter maps to Memory in the Create a container section of the Docker Remote API and the --memory option to docker run.
		# command: # The command that is passed to the container. This parameter maps to Cmd in the Create a container section of the Docker Remote API and the COMMAND parameter to docker run. For more information, see https://docs.docker.com/engine/reference/builder/#cmd.
		# job_role_arn: # The Amazon Resource Name (ARN) of the IAM role that the container can assume for AWS permissions.
		# volumes: # A list of data volumes used in a job. List of dictionaries.
		# environment: # The environment variables to pass to a container. This parameter maps to Env in the Create a container section of the Docker Remote API and the --env option to docker run. List of dictionaries.
		# mount_points: # The mount points for data volumes in your container. This parameter maps to Volumes in the Create a container section of the Docker Remote API and the --volume option to docker run. List of dictionaries.
		# readonly_root_filesystem: # When this parameter is true, the container is given read-only access to its root file system. This parameter maps to ReadonlyRootfs in the Create a container section of the Docker Remote API and the --read-only option to docker run.
		# privileged: # When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). This parameter maps to Privileged in the Create a container section of the Docker Remote API and the --privileged option to docker run.
		# ulimits: # A list of ulimits to set in the container. This parameter maps to Ulimits in the Create a container section of the Docker Remote API and the --ulimit option to docker run. List of dictionaries.
		# user: # The user name to use inside the container. This parameter maps to User in the Create a container section of the Docker Remote API and the --user option to docker run.
		# attempts: # Retry strategy - The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If attempts is greater than one, the job is retried if it fails until it has moved to RUNNABLE that many times.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_placement_group_facts "List EC2 Placement Group(s) details" b
- name: $1
	ec2_placement_group_facts:
		# names: []
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_service "create, terminate, start or stop a service in ecs" b
- name: $1
	ecs_service:
		state: ${2:present|absent|deleting}
		name: ${3:# The name of the service}
		# cluster: # The name of the cluster in which the service exists
		# task_definition: # The task definition the service will run. This parameter is required when state=present
		# load_balancers: # The list of ELBs defined for this service
		# desired_count: # The count of how many instances of the service. This parameter is required when state=present
		# client_token: # Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.
		# role: # The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service, in a network mode other than `awsvpc`.
		# delay: 10
		# repeat: 10
		# deployment_configuration: # Optional parameters that control the deployment_configuration; format is '{"maximum_percent":<integer>, "minimum_healthy_percent":<integer>}
		# placement_constraints: # The placement constraints for the tasks in the service
		# placement_strategy: # The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service
		# network_configuration: # network configuration of the service. Only applicable for task definitions created with C(awsvpc) I(network_mode).
		# launch_type: EC2|FARGATE
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_eip_facts "List EC2 EIP details" b
- name: $1
	ec2_eip_facts:
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_nacl_facts "Gather facts about Network ACLs in an AWS VPC" b
- name: $1
	ec2_vpc_nacl_facts:
		# nacl_ids: []
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_ses_identity_policy "Manages SES sending authorization policies" b
- name: $1
	aws_ses_identity_policy:
		identity: ${2:# T}
		policy_name: ${3:# T}
		# policy: # A
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sqs_queue "Creates or deletes AWS SQS queues." b
- name: $1
	sqs_queue:
		name: ${2:# Name of the queue.}
		# state: #present|absent
		# default_visibility_timeout: # The default visibility timeout in seconds.
		# message_retention_period: # The message retention period in seconds.
		# maximum_message_size: # The maximum message size in bytes.
		# delivery_delay: # The delivery delay in seconds.
		# receive_message_wait_time: # The receive message wait time in seconds.
		# policy: # The json dict policy to attach to queue
		# redrive_policy: # json dict with the redrive_policy (see example)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_vpn "Create, modify, and delete EC2 VPN connections." b
- name: $1
	ec2_vpc_vpn:
		# state: #present|absent
		# customer_gateway_id: # The ID of the customer gateway.
		# connection_type: #ipsec.1
		# vpn_gateway_id: # The ID of the virtual private gateway.
		# vpn_connection_id: # The ID of the VPN connection. Required to modify or delete a connection if the filters option does not provide a unique match.
		# tags: # Tags to attach to the VPN connection.
		# purge_tags: no
		# static_only: no
		# tunnel_options: # An optional list object containing no more than two dict members, each of which may contain 'TunnelInsideCidr' and/or 'PreSharedKey' keys with appropriate string values.  AWS defaults will apply in absence of either of the aforementioned keys.
		# filters: # An alternative to using vpn_connection_id. If multiple matches are found, vpn_connection_id is required. If one of the following suboptions is a list of items to filter by, only one item needs to match to find the VPN that correlates. e.g. if the filter 'cidr' is ['194.168.2.0/24', '192.168.2.0/24'] and the VPN route only has the destination cidr block of '192.168.2.0/24' it will be found with this filter (assuming there are not multiple VPNs that are matched). Another example, if the filter 'vpn' is equal to ['vpn-ccf7e7ad', 'vpn-cb0ae2a2'] and one of of the VPNs has the state deleted (exists but is unmodifiable) and the other exists and is not deleted, it will be found via this filter. See examples.
		# routes: # Routes to add to the connection.
		# purge_routes: # Whether or not to delete VPN connections routes that are not specified in the task.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet route53_facts "Retrieves route53 details using AWS methods" b
- name: $1
	route53_facts:
		query: ${2:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}
		# change_id: # The ID of the change batch request. The value that you specify here is the value that ChangeResourceRecordSets returned in the Id element when you submitted the request.
		# hosted_zone_id: # The Hosted Zone ID of the DNS zone
		# max_items: # Maximum number of items to return for various get/list requests
		# next_marker: # Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100 or the number specified by max_items. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results
		# delegation_set_id: # The DNS Zone delegation set ID
		# start_record_name: # The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from
		# type: A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS
		# dns_name: # The first name in the lexicographic ordering of domain names that you want the list_command to start listing from
		# resource_id: # The ID/s of the specified resource/s
		# health_check_id: # The ID of the health check
		# hosted_zone_method: details|#list|list_by_name|count|tags
		# health_check_method: #list|details|status|failure_reason|count|tags
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudfront_facts "Obtain facts about an AWS CloudFront distribution" b
- name: $1
	cloudfront_facts:
		# distribution_id: # The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).
		# invalidation_id: # The id of the invalidation to get information about. Used with I(invalidation).
		# origin_access_identity_id: # The id of the cloudfront origin access identity to get information about.
		# web_acl_id: # Used with I(list_distributions_by_web_acl_id).
		# domain_name_alias: # Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.
		# all_lists: no
		# origin_access_identity: no
		# origin_access_identity_config: no
		# distribution: no
		# distribution_config: no
		# invalidation: no
		# streaming_distribution: no
		# streaming_distribution_config: no
		# list_origin_access_identities: no
		# list_distributions: no
		# list_distributions_by_web_acl_id: no
		# list_invalidations: no
		# list_streaming_distributions: no
		# summary: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_direct_connect_connection "Creates, deletes, modifies a DirectConnect connection" b
- name: $1
	aws_direct_connect_connection:
		# state: present|absent
		# name: # The name of the Direct Connect connection. This is required to create a new connection. To recreate or delete a connection I(name) or I(connection_id) is required.
		# connection_id: # The ID of the Direct Connect connection. I(name) or I(connection_id) is required to recreate or delete a connection. Modifying attributes of a connection with I(forced_update) will result in a new Direct Connect connection ID.
		# location: # Where the Direct Connect connection is located. Required when I(state=present).
		# bandwidth: 1Gbps|10Gbps
		# link_aggregation_group: # The ID of the link aggregation group you want to associate with the connection. This is optional in case a stand-alone connection is desired.
		# forced_update: # To modify bandwidth or location the connection will need to be deleted and recreated. By default this will not happen - this option must be set to True.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_acm_facts "Retrieve certificate facts from AWS Certificate Manager service" b
- name: $1
	aws_acm_facts:
		# domain_name: # The domain name of an ACM certificate to limit the search to
		# status: PENDING_VALIDATION|ISSUED|INACTIVE|EXPIRED|VALIDATION_TIMED_OUT
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elasticache_parameter_group "Manage cache security groups in Amazon Elasticache." b
- name: $1
	elasticache_parameter_group:
		name: ${2:# A user-specified name for the cache parameter group.}
		state: ${3:present|absent|reset}
		# group_family: memcached1.4|redis2.6|redis2.8|redis3.2|redis4.0
		# description: # A user-specified description for the cache parameter group.
		# values: # A user-specified dictionary of parameters to reset or modify for the cache parameter group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_batch_job_queue "Manage AWS Batch Job Queues" b
- name: $1
	aws_batch_job_queue:
		job_queue_name: ${2:# The name for the job queue}
		state: ${3:#present|absent}
		priority: ${4:# The priority of the job queue. Job queues with a higher priority (or a lower integer value for the priority parameter) are evaluated first when associated with same compute environment. Priority is determined in ascending order, for example, a job queue with a priority value of 1 is given scheduling preference over a job queue with a priority value of 10.}
		compute_environment_order: ${5:# The set of compute environments mapped to a job queue and their order relative to each other. The job scheduler uses this parameter to determine which compute environment should execute a given job. Compute environments must be in the VALID state before you can associate them with a job queue. You can associate up to 3 compute environments with a job queue.}
		# job_queue_state: #ENABLED|DISABLED
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_lc_facts "Gather facts about AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_facts:
		# name: []
		# sort: launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name
		# sort_order: #ascending|descending
		# sort_start: # Which result to start with (when sorting).
		# sort_end: # Which result to end with (when sorting).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_config_aggregation_authorization "Manage cross-account AWS Config authorizations" b
- name: $1
	aws_config_aggregation_authorization:
		# state: #present|absent
		# authorized_account_id: # The 12-digit account ID of the account authorized to aggregate data.
		# authorized_aws_region: # The region authorized to collect aggregated data.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_user "Manage AWS IAM users" b
- name: $1
	iam_user:
		name: ${2:# The name of the user to create.}
		state: ${3:present|absent}
		# managed_policy: # A list of managed policy ARNs or friendly names to attach to the user. To embed an inline policy, use M(iam_policy).
		# purge_policy: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_direct_connect_virtual_interface "Manage Direct Connect virtual interfaces." b
- name: $1
	aws_direct_connect_virtual_interface:
		# state: present|absent
		# id_to_associate: # The ID of the link aggrecation group or connection to associate with the virtual interface.
		# public: # The type of virtual interface.
		# name: # The name of the virtual interface.
		# vlan: 100
		# bgp_asn: 65000
		# authentication_key: # The authentication key for BGP configuration.
		# amazon_address: # The amazon address CIDR with which to create the virtual interface.
		# customer_address: # The customer address CIDR with which to create the virtual interface.
		# address_type: # The type of IP address for the BGP peer.
		# cidr: # A list of route filter prefix CIDRs with which to create the public virtual interface.
		# virtual_gateway_id: # The virtual gateway ID required for creating a private virtual interface.
		# virtual_interface_id: # The virtual interface ID.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_s3_bucket_facts "Lists S3 buckets in AWS" b
- name: $1
	aws_s3_bucket_facts:
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudwatchlogs_log_group_facts "get facts about log_group in CloudWatchLogs" b
- name: $1
	cloudwatchlogs_log_group_facts:
		# log_group_name: # The name or prefix of the log group to filter by.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudfront_origin_access_identity "create, update and delete origin access identities for a cloudfront distribution." b
- name: $1
	cloudfront_origin_access_identity:
		# state: present|absent
		# origin_access_identity_id: # The origin_access_identity_id of the cloudfront distribution.
		# comment: # A comment to describe the cloudfront origin access identity.
		# caller_reference: # A unique identifier to reference the origin access identity by.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_s3 "manage objects in S3." b
- name: $1
	aws_s3:
		bucket: ${2:# Bucket name.}
		mode: ${3:get|put|delete|create|geturl|getstr|delobj|list}
		# aws_access_key: # AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# dest: # The destination file path when downloading an object/key with a GET operation.
		# encrypt: yes
		# encryption_mode: #AES256|aws:kms
		# expiration: 600
		# headers: # Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# marker: # Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.
		# max_keys: 1000
		# metadata: # Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.
		# object: # Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.
		# permission: private
		# prefix: 
		# version: # Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.
		# overwrite: always
		# region: # AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.
		# retries: 0
		# s3_url: # S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc.  Otherwise assumes AWS
		# dualstack: no
		# rgw: no
		# src: # The source file path when performing a PUT operation.
		# ignore_nonexistent_bucket: # Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.
		# encryption_kms_key_id: # KMS key id to use when encrypting objects using C(aws:kms) encryption. Ignored if encryption is not C(aws:kms)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet aws_sgw_facts "Fetch AWS Storage Gateway facts" b
- name: $1
	aws_sgw_facts:
		# gather_local_disks: yes
		# gather_tapes: yes
		# gather_file_shares: yes
		# gather_volumes: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_classic_lb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	elb_classic_lb_facts:
		# names: # List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_net "Configure AWS virtual private clouds" b
- name: $1
	ec2_vpc_net:
		name: ${2:# The name to give your VPC. This is used in combination with C(cidr_block) to determine if a VPC already exists.}
		cidr_block: ${3:# The primary CIDR of the VPC. After 2.5 a list of CIDRs can be provided. The first in the list will be used as the primary CIDR and is used in conjunction with the C(name) to ensure idempotence.}
		# purge_cidrs: no
		# tenancy: #default|dedicated
		# dns_support: yes
		# dns_hostnames: yes
		# dhcp_opts_id: # the id of the DHCP options to use for this vpc
		# tags: # The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.
		# state: #present|absent
		# multi_ok: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_batch_compute_environment "Manage AWS Batch Compute Environments" b
- name: $1
	aws_batch_compute_environment:
		compute_environment_name: ${2:# The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed.}
		type: ${3:MANAGED|UNMANAGED}
		state: ${4:#present|absent}
		service_role: ${5:# The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf.}
		compute_resource_type: ${6:EC2|SPOT}
		minv_cpus: ${7:# The minimum number of EC2 vCPUs that an environment should maintain.}
		maxv_cpus: ${8:# The maximum number of EC2 vCPUs that an environment can reach.}
		instance_types: ${9:# The instance types that may be launched.}
		subnets: ${10:# The VPC subnets into which the compute resources are launched.}
		security_group_ids: ${11:# The EC2 security groups that are associated with instances launched in the compute environment.}
		instance_role: ${12:# The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment.}
		# compute_environment_state: #ENABLED|DISABLED
		# desiredv_cpus: # The desired number of EC2 vCPUS in the compute environment.
		# image_id: # The Amazon Machine Image (AMI) ID used for instances launched in the compute environment.
		# ec2_key_pair: # The EC2 key pair that is used for instances launched in the compute environment.
		# tags: # Key-value pair tags to be applied to resources that are launched in the compute environment.
		# bid_percentage: # The minimum percentage that a Spot Instance price must be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20%, then the Spot price must be below 20% of the current On-Demand price for that EC2 instance.
		# spot_iam_fleet_role: # The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_eni "Create and optionally attach an Elastic Network Interface (ENI) to an instance" b
- name: $1
	ec2_eni:
		# eni_id: # The ID of the ENI (to modify); if null and state is present, a new eni will be created.
		# instance_id: # Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.
		# private_ip_address: # Private IP address.
		# subnet_id: # ID of subnet in which to create the ENI.
		# description: # Optional description of the ENI.
		# security_groups: # List of security groups associated with the interface. Only used when state=present. Since version 2.2, you can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.
		# state: #present|absent
		# device_index: 0
		# attached: # Specifies if network interface should be attached or detached from instance. If omitted, attachment status won't change
		# force_detach: no
		# delete_on_termination: # Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.
		# source_dest_check: # By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.
		# secondary_private_ip_addresses: # A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count
		# purge_secondary_private_ip_addresses: no
		# secondary_private_ip_address_count: # The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses
		# allow_reassignment: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_asg "Create or delete AWS Autoscaling Groups" b
- name: $1
	ec2_asg:
		name: ${2:# Unique name for group to be created or deleted}
		launch_config_name: ${3:# Name of the Launch configuration to use for the group. See the ec2_lc module for managing these. If unspecified then the current group value will be used.}
		# state: #present|absent
		# load_balancers: # List of ELB names to use for the group. Use for classic load balancers.
		# target_group_arns: # List of target group ARNs to use for the group. Use for application load balancers.
		# availability_zones: # List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.
		# min_size: # Minimum number of instances in group, if unspecified then the current group value will be used.
		# max_size: # Maximum number of instances in group, if unspecified then the current group value will be used.
		# placement_group: # Physical location of your cluster placement group created in Amazon EC2.
		# desired_capacity: # Desired number of instances in group, if unspecified then the current group value will be used.
		# replace_all_instances: no
		# replace_batch_size: 1
		# replace_instances: # List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.
		# lc_check: yes
		# vpc_zone_identifier: # List of VPC subnets to use
		# tags: # A list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.
		# health_check_period: 500 seconds
		# health_check_type: #EC2|ELB
		# default_cooldown: 300 seconds
		# wait_timeout: 300
		# wait_for_instances: yes
		# termination_policies: OldestInstance|NewestInstance|OldestLaunchConfiguration|ClosestToNextInstanceHour|#Default
		# notification_topic: # A SNS topic ARN to send auto scaling notifications to.
		# notification_types: ['autoscaling:EC2_INSTANCE_LAUNCH', 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', 'autoscaling:EC2_INSTANCE_TERMINATE', 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']
		# suspend_processes: ['Launch', 'Terminate', 'HealthCheck', 'ReplaceUnhealthy', 'AZRebalance', 'AlarmNotification', 'ScheduledActions', 'AddToLoadBalancer'
		# metrics_collection: no
		# metrics_granularity: 1minute
		# metrics_list: ['GroupMinSize', 'GroupMaxSize', 'GroupDesiredCapacity', 'GroupInServiceInstances', 'GroupPendingInstances', 'GroupStandbyInstances', 'GroupTerminatingInstances', 'GroupTotalInstances']
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_group "Manage AWS IAM groups" b
- name: $1
	iam_group:
		name: ${2:# The name of the group to create.}
		state: ${3:present|absent}
		# managed_policy: # A list of managed policy ARNs or friendly names to attach to the role. To embed an inline policy, use M(iam_policy).
		# users: # A list of existing users to add as members of the group.
		# purge_policy: no
		# purge_users: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudformation_stack_set "Manage groups of CloudFormation stacks" b
- name: $1
	cloudformation_stack_set:
		name: ${2:# name of the cloudformation stack set}
		# description: # A description of what this stack set creates
		# parameters: {}
		# state: #present|absent
		# template: # The local path of the cloudformation template.
		# template_body: # Template body. Use this to pass in the actual body of the Cloudformation template.
		# template_url: # Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.
		# purge_stacks: yes
		# wait: no
		# wait_timeout: 900
		# capabilities: CAPABILITY_IAM|CAPABILITY_NAMED_IAM
		# regions: # A list of AWS regions to create instances of a stack in. The I(region) parameter chooses where the Stack Set is created, and I(regions) specifies the region for stack instances.
		# accounts: # A list of AWS accounts in which to create instance of CloudFormation stacks.
		# administration_role_arn: # ARN of the administration role, meaning the role that CloudFormation Stack Sets use to assume the roles in your child accounts.
		# execution_role_name: # ARN of the execution role, meaning the role that CloudFormation Stack Sets assumes in your child accounts.
		# tags: # Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.
		# failure_tolerance: # Settings to change what is considered "failed" when running stack instance updates, and how many to do at a time.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_metric_alarm "Create/update or delete AWS Cloudwatch 'metric alarms'" b
- name: $1
	ec2_metric_alarm:
		state: ${2:present|absent}
		name: ${3:# Unique name for the alarm}
		# metric: # Name of the monitored metric (e.g. CPUUtilization)
		# namespace: # Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch
		# statistic: SampleCount|Average|Sum|Minimum|Maximum
		# comparison: <=|<|>|>=
		# threshold: # Sets the min/max bound for triggering the alarm
		# period: # The time (in seconds) between metric evaluations
		# evaluation_periods: # The number of times in which the metric is evaluated before final calculation
		# unit: Seconds|Microseconds|Milliseconds|Bytes|Kilobytes|Megabytes|Gigabytes|Terabytes|Bits|Kilobits|Megabits|Gigabits|Terabits|Percent|Count|Bytes/Second|Kilobytes/Second|Megabytes/Second|Gigabytes/Second|Terabytes/Second|Bits/Second|Kilobits/Second|Megabits/Second|Gigabits/Second|Terabits/Second|Count/Second|None
		# description: # A longer description of the alarm
		# dimensions: # Describes to what the alarm is applied
		# alarm_actions: # A list of the names action(s) taken when the alarm is in the 'alarm' status
		# insufficient_data_actions: # A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status
		# ok_actions: # A list of the names of action(s) to take when the alarm is in the 'ok' status
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_region_facts "Gather facts about AWS regions." b
- name: $1
	aws_region_facts:
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_ami_copy "copies AMI between AWS regions, return new image id" b
- name: $1
	ec2_ami_copy:
		source_region: ${2:# The source region the AMI should be copied from.}
		source_image_id: ${3:# The ID of the AMI in source region that should be copied.}
		# name: default
		# description: # An optional human-readable string describing the contents and purpose of the new AMI.
		# encrypted: # Whether or not the destination snapshots of the copied AMI should be encrypted.
		# kms_key_id: # KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.
		# wait: no
		# wait_timeout: 600
		# tags: # A hash/dictionary of tags to add to the new copied AMI; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# tag_equality: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_eip "manages EC2 elastic IP (EIP) addresses." b
- name: $1
	ec2_eip:
		# device_id: # The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.
		# public_ip: # The IP address of a previously allocated EIP.
		# state: #present|absent
		# in_vpc: no
		# reuse_existing_ip_allowed: no
		# release_on_disassociation: no
		# private_ip_address: # The primary or secondary private IP address to associate with the Elastic IP address.
		# allow_reassociation: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudwatchevent_rule "Manage CloudWatch Event rules and targets" b
- name: $1
	cloudwatchevent_rule:
		name: ${2:# The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\.\-_A-Za-z0-9]+))}
		# schedule_expression: # A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))
		# event_pattern: # A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered
		# state: #present|disabled|absent
		# description: # A description of the rule
		# role_arn: # The Amazon Resource Name (ARN) of the IAM role associated with the rule
		# targets: # A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], role_arn: [string], input: [valid JSON string], input_path: [valid JSONPath string], ecs_parameters: {task_definition_arn: [string], task_count: [int]}}). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(role_arn) (optional) is The Amazon Resource Name of the IAM role to be used for this target when the rule is triggered. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form. I(task_definition_arn) [optional] is ecs task definition arn. I(task_count) [optional] is ecs task count.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_mfa_device_facts "List the MFA (Multi-Factor Authentication) devices registered for a user" b
- name: $1
	iam_mfa_device_facts:
		# user_name: # The name of the user whose MFA devices will be listed
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_subnet_facts "Gather facts about ec2 VPC subnets in AWS" b
- name: $1
	ec2_vpc_subnet_facts:
		# subnet_ids: # A list of subnet IDs to gather facts for.
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_server_certificate_facts "Retrieve the facts of a server certificate" b
- name: $1
	iam_server_certificate_facts:
		name: ${2:# The name of the server certificate you are retrieving attributes for.}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_instance_facts "Gather facts about ec2 instances in AWS" b
- name: $1
	ec2_instance_facts:
		# instance_ids: # If you specify one or more instance IDs, only instances that have the specified IDs are returned.
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudformation_facts "Obtain facts about an AWS CloudFormation stack" b
- name: $1
	cloudformation_facts:
		# stack_name: # The name or id of the CloudFormation stack. Gathers facts for all stacks by default.
		# all_facts: no
		# stack_events: no
		# stack_template: no
		# stack_resources: no
		# stack_policy: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_direct_connect_gateway "Manage AWS Direct Connect Gateway." b
- name: $1
	aws_direct_connect_gateway:
		amazon_asn: ${2:# amazon side asn}
		# state: #present|absent
		# name: # name of the dxgw to be created or deleted
		# direct_connect_gateway_id: # id of an existing direct connect gateway
		# virtual_gateway_id: # vpn gateway id of an existing virtual gateway
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet route53 "add or delete entries in Amazons Route53 DNS service" b
- name: $1
	route53:
		state: ${2:present|absent|get|create|delete}
		zone: ${3:# The DNS zone to modify}
		record: ${4:# The full DNS record to create or delete}
		type: ${5:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS|SOA}
		# hosted_zone_id: # The Hosted Zone ID of the DNS zone to modify
		# ttl: 3600 (one hour)
		# alias: no
		# alias_hosted_zone_id: # The hosted zone identifier.
		# alias_evaluate_target_health: no
		# value: # The new value when creating a DNS record.  YAML lists or multiple comma-spaced values are allowed for non-alias records.
		# overwrite: # Whether an existing record should be overwritten on create if values do not match
		# retry_interval: 500
		# private_zone: no
		# identifier: # Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.
		# weight: # Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.
		# region: # Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing
		# health_check: # Health check to associate with this record
		# failover: # Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY
		# vpc_id: # When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.
		# wait: no
		# wait_timeout: 300
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet rds_param_group "manage RDS parameter groups" b
- name: $1
	rds_param_group:
		state: ${2:#present|absent}
		name: ${3:# Database parameter group identifier.}
		# description: # Database parameter group description. Only set when a new group is added.
		# engine: aurora5.6|mariadb10.0|mariadb10.1|mysql5.1|mysql5.5|mysql5.6|mysql5.7|oracle-ee-11.2|oracle-ee-12.1|oracle-se-11.2|oracle-se-12.1|oracle-se1-11.2|oracle-se1-12.1|postgres9.3|postgres9.4|postgres9.5|postgres9.6|sqlserver-ee-10.5|sqlserver-ee-11.0|sqlserver-ex-10.5|sqlserver-ex-11.0|sqlserver-ex-12.0|sqlserver-se-10.5|sqlserver-se-11.0|sqlserver-se-12.0|sqlserver-web-10.5|sqlserver-web-11.0|sqlserver-web-12.0
		# immediate: # Whether to apply the changes immediately, or after the next reboot of any associated instances.
		# params: # Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.
		# tags: # Dictionary of tags to attach to the parameter group
		# purge_tags: # Whether or not to remove tags that do not appear in the I(tags) list. Defaults to false.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2 "create, terminate, start or stop an instance in ec2" b
- name: $1
	ec2:
		instance_type: ${2:# instance type to use for the instance, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html)}
		image: ${3:# I(ami) ID to use for the instance}
		# key_name: # key pair to use on the instance
		# id: # identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances. This identifier is valid for at least 24 hours after the termination of the instance, and should not be reused for another call later on. For details, see the description of client token at U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
		# group: # security group (or list of groups) to use with the instance
		# group_id: # security group id (or list of ids) to use with the instance
		# region: # The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
		# zone: # AWS availability zone in which to launch the instance
		# tenancy: #default|dedicated
		# spot_price: # Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started.
		# spot_type: #one-time|persistent
		# kernel: # kernel I(eki) to use for the instance
		# ramdisk: # ramdisk I(eri) to use for the instance
		# wait: no
		# wait_timeout: 300
		# spot_wait_timeout: 600
		# count: 1
		# monitoring: no
		# user_data: # opaque blob of data which is made available to the ec2 instance
		# instance_tags: # a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# placement_group: # placement group for the instance when using EC2 Clustered Compute
		# vpc_subnet_id: # the subnet ID in which to launch the instance (VPC)
		# assign_public_ip: # when provisioning within vpc, assign a public IP address. Boto library must be 2.13.0+
		# private_ip: # the private ip address to assign the instance (from the vpc subnet)
		# instance_profile_name: # Name of the IAM instance profile (i.e. what the EC2 console refers to as an "IAM Role") to use. Boto library must be 2.5.0+
		# instance_ids: # list of instance ids, currently used for states: absent, running, stopped
		# source_dest_check: # Enable or Disable the Source/Destination checks (for NAT instances and Virtual Routers). When initially creating an instance the EC2 API defaults this to True.
		# termination_protection: no
		# instance_initiated_shutdown_behavior: #stop|terminate
		# state: #present|absent|running|restarted|stopped
		# volumes: # a list of hash/dictionaries of volumes to add to the new instance; '[{"key":"value", "key":"value"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), volume_size (int, GB), iops (int) - device_type is deprecated use volume_type, iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.
		# ebs_optimized: no
		# exact_count: # An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.
		# count_tag: # Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running. This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with "class=webserver". The specified tag must already exist or be passed in as the 'instance_tags' option.
		# network_interfaces: # A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)
		# spot_launch_group: # Launch group for spot request, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet elasticache_snapshot "Manage cache snapshots in Amazon Elasticache." b
- name: $1
	elasticache_snapshot:
		name: ${2:# The name of the snapshot we want to create, copy, delete}
		# state: present|absent|copy
		# replication_id: # The name of the existing replication group to make the snapshot.
		# cluster_id: # The name of an existing cache cluster in the replication group to make the snapshot.
		# target: # The name of a snapshot copy
		# bucket: # The s3 bucket to which the snapshot is exported
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet rds_subnet_group "manage RDS database subnet groups" b
- name: $1
	rds_subnet_group:
		state: ${2:#present|absent}
		name: ${3:# Database subnet group identifier.}
		# description: # Database subnet group description. Only set when a new group is added.
		# subnets: # List of subnet IDs that make up the database subnet group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_config_rule "Manage AWS Config resources" b
- name: $1
	aws_config_rule:
		name: ${2:# The name of the AWS Config resource.}
		# state: #present|absent
		# description: # The description that you provide for the AWS Config rule.
		# scope: # Defines which resources can trigger an evaluation for the rule.
		# source: # Provides the rule owner (AWS or customer), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.
		# input_parameters: # A string, in JSON format, that is passed to the AWS Config rule Lambda function.
		# execution_frequency: One_Hour|Three_Hours|Six_Hours|Twelve_Hours|TwentyFour_Hours
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_kms "Perform various KMS management tasks." b
- name: $1
	aws_kms:
		mode: ${2:#grant|deny}
		# key_alias: # Alias label to the key. One of C(key_alias) or C(key_arn) are required.
		# key_arn: # Full ARN to the key. One of C(key_alias) or C(key_arn) are required.
		# role_name: # Role to allow/deny access. One of C(role_name) or C(role_arn) are required.
		# role_arn: # ARN of role to allow/deny access. One of C(role_name) or C(role_arn) are required.
		# grant_types: # List of grants to give to user/role. Likely "role,role grant" or "role,role grant,admin". Required when C(mode=grant).
		# clean_invalid_entries: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_tag "create and remove tags on ec2 resources." b
- name: $1
	ec2_tag:
		resource: ${2:# The EC2 resource id.}
		tags: ${3:# a hash/dictionary of tags to add to the resource; '{"key":"value"}' and '{"key":"value","key":"value"}'}
		# state: #present|absent|list
		# purge_tags: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_target_group "Manage a target group for an Application or Network load balancer" b
- name: $1
	elb_target_group:
		name: ${2:# The name of the target group.}
		state: ${3:present|absent}
		# deregistration_delay_timeout: # The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds.
		# health_check_protocol: http|https|tcp
		# health_check_port: The port on which each target receives traffic from the load balancer.
		# health_check_path: # The ping path that is the destination on the targets for health checks. The path must be defined in order to set a health check.
		# health_check_interval: # The approximate amount of time, in seconds, between health checks of an individual target.
		# health_check_timeout: # The amount of time, in seconds, during which no response from a target means a failed health check.
		# healthy_threshold_count: # The number of consecutive health checks successes required before considering an unhealthy target healthy.
		# modify_targets: yes
		# port: # The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. Required if I(state) is C(present).
		# protocol: http|https|tcp
		# purge_tags: yes
		# stickiness_enabled: # Indicates whether sticky sessions are enabled.
		# stickiness_lb_cookie_duration: # The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds).
		# stickiness_type: lb_cookie
		# successful_response_codes: # The HTTP codes to use when checking for a successful response from a target. You can specify multiple values (for example, "200,202") or a range of values (for example, "200-299").
		# tags: # A dictionary of one or more tags to assign to the target group.
		# target_type: #instance|ip
		# targets: # A list of targets to assign to the target group. This parameter defaults to an empty list. Unless you set the 'modify_targets' parameter then all existing targets will be removed from the group. The list should be an Id and a Port parameter. See the Examples for detail.
		# unhealthy_threshold_count: # The number of consecutive health check failures required before considering a target unhealthy.
		# vpc_id: # The identifier of the virtual private cloud (VPC). Required when I(state) is C(present).
		# wait: no
		# wait_timeout: 200
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_classic_lb "Creates or destroys Amazon ELB." b
- name: $1
	elb_classic_lb:
		state: ${2:present|absent}
		name: ${3:# The name of the ELB}
		# listeners: # List of ports/protocols for this ELB to listen on (see example)
		# purge_listeners: yes
		# instance_ids: # List of instance ids to attach to this ELB
		# purge_instance_ids: no
		# zones: # List of availability zones to enable on this ELB
		# purge_zones: no
		# security_group_ids: # A list of security groups to apply to the elb
		# security_group_names: # A list of security group names to apply to the elb
		# health_check: # An associative array of health check configuration settings (see example)
		# access_logs: # An associative array of access logs configuration settings (see example)
		# subnets: # A list of VPC subnets to use when creating ELB. Zones should be empty if using this.
		# purge_subnets: no
		# scheme: internal|#internet-facing
		# validate_certs: yes
		# connection_draining_timeout: # Wait a specified timeout allowing connections to drain before terminating an instance
		# idle_timeout: # ELB connections from clients and to servers are timed out after this amount of time
		# cross_az_load_balancing: no
		# stickiness: # An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )
		# wait: no
		# wait_timeout: 60
		# tags: # An associative array of tags. To delete all tags, supply an empty dict.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sns_topic "Manages AWS SNS topics and subscriptions" b
- name: $1
	sns_topic:
		name: ${2:# The name or ARN of the SNS topic to manage}
		# state: absent|#present
		# display_name: # Display name of the topic
		# policy: # Policy to apply to the SNS topic
		# delivery_policy: # Delivery policy to apply to the SNS topic
		# subscriptions: []
		# purge_subscriptions: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sts_assume_role "Assume a role using AWS Security Token Service and obtain temporary credentials" b
- name: $1
	sts_assume_role:
		role_arn: ${2:# The Amazon Resource Name (ARN) of the role that the caller is assuming (http://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs)}
		role_session_name: ${3:# Name of the role's session - will be used by CloudTrail}
		# policy: # Supplemental policy to use in addition to assumed role's policies.
		# duration_seconds: # The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 43200 seconds (12 hours). The max dependis on the IAM role's sessions duration setting. By default, the value is set to 3600 seconds.s
		# external_id: # A unique identifier that is used by third parties to assume a role in their customers' accounts.
		# mfa_serial_number: # The identification number of the MFA device that is associated with the user who is making the AssumeRole call.
		# mfa_token: # The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet s3_sync "Efficiently upload multiple files to S3" b
- name: $1
	s3_sync:
		mode: ${2:#push}
		bucket: ${3:# Bucket name.}
		file_root: ${4:# File/directory path for synchronization. This is a local path.}
		# file_change_strategy: force|checksum|#date_size
		# key_prefix: # In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary.
		# permission: |private|public-read|public-read-write|authenticated-read|aws-exec-read|bucket-owner-read|bucket-owner-full-control
		# mime_map: # Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({".txt": "application/text", ".yml": "application/text"})

		# include: *
		# exclude: .*
		# cache_control: # This is a string.
		# delete: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_direct_connect_link_aggregation_group "Manage Direct Connect LAG bundles." b
- name: $1
	aws_direct_connect_link_aggregation_group:
		# state: present|absent
		# name: # The name of the Direct Connect link aggregation group.
		# link_aggregation_group_id: # The ID of the Direct Connect link aggregation group.
		# num_connections: # The number of connections with which to intialize the link aggregation group.
		# min_links: # The minimum number of physical connections that must be operational for the LAG itself to be operational.
		# location: # The location of the link aggregation group.
		# bandwidth: # The bandwidth of the link aggregation group.
		# force_delete: # This allows the minimum number of links to be set to 0, any hosted connections disassociated, and any virtual interfaces associated to the LAG deleted.
		# connection_id: # A connection ID to link with the link aggregation group upon creation.
		# delete_with_disassociation: # To be used with I(state=absent) to delete connections after disassociating them with the LAG.
		# wait: # Whether or not to wait for the operation to complete. May be useful when waiting for virtual interfaces to be deleted. May modify the time of waiting with C(wait_timeout).
		# wait_timeout: 120
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_config_recorder "Manage AWS Config Recorders" b
- name: $1
	aws_config_recorder:
		name: ${2:# The name of the AWS Config resource.}
		# state: #present|absent
		# role_arn: # Amazon Resource Name (ARN) of the IAM role used to describe the AWS resources associated with the account.
		# recording_group: # Specifies the types of AWS resources for which AWS Config records configuration changes.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_group "maintain an ec2 VPC security group." b
- name: $1
	ec2_group:
		# name: # Name of the security group.
		# group_id: # Id of group to delete (works only with absent).
		# description: # Description of the security group. Required when C(state) is C(present).
		# vpc_id: # ID of the VPC to create the group in.
		# rules: # List of firewall inbound rules to enforce in this group (see example). If none are supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to access itself). Rule sources list support was added in version 2.4. This allows to define multiple sources per source type as well as multiple source types per rule. Prior to 2.4 an individual source is allowed. In version 2.5 support for rule descriptions was added.
		# rules_egress: # List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled. Rule Egress sources list support was added in version 2.4. In version 2.5 support for rule descriptions was added.
		# state: #present|absent
		# purge_rules: true
		# purge_rules_egress: true
		# tags: # A dictionary of one or more tags to assign to the security group.
		# purge_tags: yes
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_waf_web_acl "create and delete WAF Web ACLs" b
- name: $1
	aws_waf_web_acl:
		name: ${2:# N}
		# default_action: block|allow|count
		# state: #present|absent
		# metric_name: # A friendly name or description for the metrics for this WebACL
		# rules: # A list of rules that the Web ACL will enforce.
		# purge_rules: # W
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_policy "Manage IAM policies for users, groups, and roles" b
- name: $1
	iam_policy:
		iam_type: ${2:user|group|role}
		iam_name: ${3:# Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.}
		policy_name: ${4:# The name label for the policy to create or remove.}
		state: ${5:present|absent}
		# policy_document: # The path to the properly json formatted policy file (mutually exclusive with C(policy_json))
		# policy_json: # A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)
		# skip_duplicates: /
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_endpoint_facts "Retrieves AWS VPC endpoints details using AWS methods." b
- name: $1
	ec2_vpc_endpoint_facts:
		query: ${2:services|endpoints}
		# vpc_endpoint_ids: # Get details of specific endpoint IDs
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_route_table "Manage route tables for AWS virtual private clouds" b
- name: $1
	ec2_vpc_route_table:
		vpc_id: ${2:# V}
		# lookup: #tag|id
		# propagating_vgw_ids: # E
		# purge_routes: yes
		# purge_subnets: true
		# purge_tags: no
		# route_table_id: # T
		# routes: # L
		# state: #present|absent
		# subnets: # A
		# tags: # A
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_config_aggregator "Manage AWS Config aggregations across multiple accounts" b
- name: $1
	aws_config_aggregator:
		name: ${2:# The name of the AWS Config resource.}
		# state: #present|absent
		# account_sources: # Provides a list of source accounts and regions to be aggregated.
		# organization_source: # The region authorized to collect aggregated data.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_snapshot_facts "Gather facts about ec2 volume snapshots in AWS" b
- name: $1
	ec2_snapshot_facts:
		# snapshot_ids: []
		# owner_ids: []
		# restorable_by_user_ids: []
		# filters: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_api_gateway "Manage AWS API Gateway APIs" b
- name: $1
	aws_api_gateway:
		# api_id: # The ID of the API you want to manage.
		# state: #present|absent
		# swagger_file: # JSON or YAML file containing swagger definitions for API. Exactly one of swagger_file, swagger_text or swagger_dict must be present.
		# swagger_text: # Swagger definitions for API in JSON or YAML as a string direct from playbook.
		# swagger_dict: # Swagger definitions API ansible dictionary which will be converted to JSON and uploaded.
		# stage: # The name of the stage the API should be deployed to.
		# deploy_desc: Automatic deployment by Ansible.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_waf_facts "Retrieve facts for WAF ACLs, Rule , Conditions and Filters." b
- name: $1
	aws_waf_facts:
		# name: # The name of a Web Application Firewall
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_dhcp_option_facts "Gather facts about dhcp options sets in AWS" b
- name: $1
	ec2_vpc_dhcp_option_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# dhcp_options_ids: # Get details of specific DHCP Option ID
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_nat_gateway_facts "Retrieves AWS VPC Managed Nat Gateway details using AWS methods." b
- name: $1
	ec2_vpc_nat_gateway_facts:
		# nat_gateway_ids: # Get details of specific nat gateway IDs
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet efs "create and maintain EFS file systems" b
- name: $1
	efs:
		# encrypt: no
		# kms_key_id: # The id of the AWS KMS CMK that will be used to protect the encrypted file system. This parameter is only required if you want to use a non-default CMK. If this parameter is not specified, the default CMK for Amazon EFS is used. The key id can be Key ID, Key ID ARN, Key Alias or Key Alias ARN.
		# purge_tags: yes
		# state: #present|absent
		# name: # Creation Token of Amazon EFS file system. Required for create and update. Either name or ID required for delete.
		# id: # ID of Amazon EFS. Either name or ID required for delete.
		# performance_mode: #general_purpose|max_io
		# tags: # List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.
		# targets: # List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in. - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet. - security_groups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.
		# wait: no
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lambda_policy "Creates, updates or deletes AWS Lambda policy statements." b
- name: $1
	lambda_policy:
		function_name: ${2:# Name of the Lambda function whose resource policy you are updating by adding a new permission.}
		state: ${3:#present|absent}
		statement_id: ${4:# A unique statement identifier.}
		action: ${5:# The AWS Lambda action you want to allow in this statement. Each Lambda action is a string starting with lambda: followed by the API name (see Operations ). For example, lambda:CreateFunction . You can use wildcard (lambda:* ) to grant permission for all AWS Lambda actions.}
		principal: ${6:# The principal who is getting this permission. It can be Amazon S3 service Principal (s3.amazonaws.com ) if you want Amazon S3 to invoke the function, an AWS account ID if you are granting cross-account permission, or any valid AWS service principal such as sns.amazonaws.com . For example, you might want to allow a custom application in another AWS account to push events to AWS Lambda by invoking your function.}
		# alias: # Name of the function alias. Mutually exclusive with C(version).
		# version: # Version of the Lambda function. Mutually exclusive with C(alias).
		# source_arn: # This is optional; however, when granting Amazon S3 permission to invoke your function, you should specify this field with the bucket Amazon Resource Name (ARN) as its value. This ensures that only events generated from the specified bucket can invoke the function.
		# source_account: # The AWS account ID (without a hyphen) of the source owner. For example, if the SourceArn identifies a bucket, then this is the bucket owner's account ID. You can use this additional condition to ensure the bucket you specify is owned by a specific account (it is possible the bucket owner deleted the bucket and some other AWS account created the bucket). You can also use this condition to specify all sources (that is, you don't specify the SourceArn ) owned by a specific account.
		# event_source_token: # Token string representing source ARN or account. Mutually exclusive with C(source_arn) or C(source_account).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet execute_lambda "Execute an AWS Lambda function" b
- name: $1
	execute_lambda:
		# name: # The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN.
		# function_arn: # The name of the function to be invoked
		# tail_log: no
		# wait: yes
		# dry_run: no
		# version_qualifier: LATEST
		# payload: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_target "Manage a target in a target group" b
- name: $1
	elb_target:
		target_id: ${2:# The ID of the target.}
		state: ${3:present|absent}
		# deregister_unused: # The default behaviour for targets that are unused is to leave them registered. If instead you would like to remove them set I(deregister_unused) to yes.
		# target_az: # An Availability Zone or all. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer. This parameter is not supported if the target type of the target group is instance.
		# target_group_arn: # The Amazon Resource Name (ARN) of the target group. Mutually exclusive of I(target_group_name).
		# target_group_name: # The name of the target group. Mutually exclusive of I(target_group_arn).
		# target_port: The default port for a target is the port for the target group.
		# target_status: initial|healthy|unhealthy|unused|draining|unavailable
		# target_status_timeout: 60
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_application_lb_facts "Gather facts about application ELBs in AWS" b
- name: $1
	elb_application_lb_facts:
		# load_balancer_arns: # The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load balancers in a single call.
		# names: # The names of the load balancers.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet kinesis_stream "Manage a Kinesis Stream." b
- name: $1
	kinesis_stream:
		name: ${2:# The name of the Kinesis Stream you are managing.}
		# shards: # The number of shards you want to have with this stream.
		# retention_period: # The default retention period is 24 hours and can not be less than 24 hours.
		# state: #present|absent
		# wait: yes
		# wait_timeout: 300
		# tags: # A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.
		# encryption_state: enabled|disabled
		# encryption_type: KMS
		# key_id: # The GUID or alias for the KMS key.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_vgw_facts "Gather facts about virtual gateways in AWS" b
- name: $1
	ec2_vpc_vgw_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.
		# vpn_gateway_ids: # Get details of a specific Virtual Gateway ID. This value should be provided as a list.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_elb_facts "Gather facts about EC2 Elastic Load Balancers in AWS" b
- name: $1
	ec2_elb_facts:
		# names: # List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet route53_zone "add or delete Route53 zones" b
- name: $1
	route53_zone:
		zone: ${2:# The DNS zone record (eg: foo.com.)}
		# state: #present|absent
		# vpc_id: # The VPC ID the zone should be a part of (if this is going to be a private zone)
		# vpc_region: # The VPC Region the zone should be a part of (if this is going to be a private zone)
		# comment: 
		# hosted_zone_id: # The unique zone identifier you want to delete or "all" if there are many zones with the same domain name. Required if there are multiple zones identified with the above options
		# delegation_set_id: # The reusable delegation set ID to be associated with the zone. Note that you can't associate a reusable delegation set with a private hosted zone.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
- name: $1
	ec2_vpc_dhcp_option:
		# domain_name: # The domain name to set in the DHCP option sets
		# dns_servers: # A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)
		# ntp_servers: # List of hosts to advertise as NTP servers for the VPC.
		# netbios_name_servers: # List of hosts to advertise as NetBIOS servers.
		# netbios_node_type: # NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
		# vpc_id: # VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.
		# delete_old: yes
		# inherit_existing: no
		# tags: # Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)
		# dhcp_options_id: # The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)
		# state: absent|#present
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet efs_facts "Get information about Amazon EFS file systems" b
- name: $1
	efs_facts:
		# name: # Creation Token of Amazon EFS file system.
		# id: # ID of Amazon EFS.
		# tags: # List of tags of Amazon EFS. Should be defined as dictionary
		# targets: # list of targets on which to filter the returned results
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet dynamodb_ttl "set TTL for a given DynamoDB table." b
- name: $1
	dynamodb_ttl:
		table_name: ${2:# name of the DynamoDB table to work on}
		attribute_name: ${3:# the name of the Time to Live attribute used to store the expiration time for items in the table}
		# state: #enable|disable
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lambda_facts "Gathers AWS Lambda function details as Ansible facts" b
- name: $1
	lambda_facts:
		query: ${2:aliases|#all|config|mappings|policy|versions}
		# function_name: # The name of the lambda function for which facts are requested.
		# event_source_arn: # For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet s3_website "Configure an s3 bucket as a website" b
- name: $1
	s3_website:
		name: ${2:# Name of the s3 bucket}
		# error_key: # The object key name to use when a 4XX class error occurs. To remove an error key, set to None.
		# redirect_all_requests: # Describes the redirect behavior for every request to this s3 bucket website endpoint
		# region: # AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.

		# state: #present|absent
		# suffix: index.html
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet s3_lifecycle "Manage s3 bucket lifecycle rules in AWS" b
- name: $1
	s3_lifecycle:
		name: ${2:# Name of the s3 bucket}
		# expiration_date: # Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.

		# expiration_days: # Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
		# prefix: # Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket.
		# purge_transitions: yes
		# noncurrent_version_expiration_days: # Delete noncurrent versions this many days after they become noncurrent
		# noncurrent_version_storage_class: #glacier|onezone_ia|standard_ia
		# noncurrent_version_transition_days: # Transition noncurrent versions this many days after they become noncurrent
		# noncurrent_version_transitions: # A list of transition behaviors to be applied to noncurrent versions for the rule. Each storage class may be used only once. Each transition behavior contains these elements
  I(transition_days)
  I(storage_class)

		# rule_id: # Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.
		# state: #present|absent
		# status: #enabled|disabled
		# storage_class: #glacier|onezone_ia|standard_ia
		# transition_date: # Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required."

		# transition_days: # Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.
		# transitions: # A list of transition behaviors to be applied to the rule. Each storage class may be used only once. Each transition behavior may contain these elements I(transition_days) I(transition_date) I(storage_class)
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_role_facts "Gather information on IAM roles" b
- name: $1
	iam_role_facts:
		# name: # Name of a role to search for
		# path_prefix: # Prefix of role I(path) to restrict IAM role search for
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet redshift_subnet_group "manage Redshift cluster subnet groups" b
- name: $1
	redshift_subnet_group:
		group_name: ${2:# Cluster subnet group name.}
		# state: #present|absent
		# group_description: # Database subnet group description.
		# group_subnets: # List of subnet IDs that make up the cluster subnet group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_instance "Create & manage EC2 instances" b
- name: $1
	ec2_instance:
		# instance_ids: # If you specify one or more instance IDs, only instances that have the specified IDs are returned.
		# state: #present|terminated|running|started|stopped|restarted|rebooted|absent
		# wait: yes
		# wait_timeout: 600
		# instance_type: t2.micro
		# user_data: # Opaque blob of data which is made available to the ec2 instance
		# tower_callback: # Preconfigured user-data to enable an instance to perform a Tower callback (Linux only).
		# tags: # A hash/dictionary of tags to add to the new instance or to add/remove from an existing one.
		# purge_tags: no
		# image: # An image to use for the instance. The ec2_ami_facts module may be used to retrieve images. One of I(image) or I(image_id) are required when instance is not already present.
		# image_id: # I(ami) ID to use for the instance. One of I(image) or I(image_id) are required when instance is not already present.
		# security_groups: # A list of security group IDs or names (strings). Mutually exclusive with I(security_group).
		# security_group: # A security group ID or name. Mutually exclusive with I(security_groups).
		# name: # The Name tag for the instance.
		# vpc_subnet_id: # The subnet ID in which to launch the instance (VPC) If none is provided, ec2_instance will chose the default zone of the default VPC
		# network: # Either a dictionary containing the key 'interfaces' corresponding to a list of network interface IDs or containing specifications for a single network interface.
		# volumes: # A list of block device mappings, by default this will always use the AMI root device so the volumes option is primarily for adding more storage.
		# launch_template: # The EC2 launch template to base instance configuration on.
		# key_name: # Name of the SSH access key to assign to the instance - must exist in the region the instance is created.
		# availability_zone: # Specify an availability zone to use the default subnet it. Useful if not specifying the I(vpc_subnet_id) parameter.
		# instance_initiated_shutdown_behavior: stop|terminate
		# tenancy: dedicated|default
		# termination_protection: # Whether to enable termination protection. This module will not terminate an instance with termination protection active, it must be turned off first.
		# cpu_credit_specification: unlimited|standard
		# cpu_options: # Reduce the number of vCPU exposed to the instance.
		# detailed_monitoring: # Whether to allow detailed cloudwatch metrics to be collected, enabling more detailed alerting.
		# ebs_optimized: # Whether instance is should use optimized EBS volumes, see U(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html)
		# filters: {'tag:Name': '<provided-Name-attribute>', 'subnet-id': '<provided-or-default subnet>'}
		# instance_role: # The ARN or name of an EC2-enabled instance role to be used. If a name is not provided in arn format then the ListInstanceProfiles permission must also be granted. U(https://docs.aws.amazon.com/IAM/latest/APIReference/API_ListInstanceProfiles.html) If no full ARN is provided, the role with a matching name will be used from the active AWS account.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lambda_event "Creates, updates or deletes AWS Lambda function event mappings." b
- name: $1
	lambda_event:
		lambda_function_arn: ${2:# The name or ARN of the lambda function.}
		state: ${3:#present|absent}
		alias: ${4:# Name of the function alias. Mutually exclusive with C(version).}
		source_params: ${5:# Sub-parameters required for event source.}
		# version: # Version of the Lambda function. Mutually exclusive with C(alias).
		# event_source: #stream|sqs
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_elasticbeanstalk_app "create, update, and delete an elastic beanstalk application" b
- name: $1
	aws_elasticbeanstalk_app:
		# app_name: # name of the beanstalk application you wish to manage
		# description: # the description of the application
		# state: absent|#present
		# terminate_by_force: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_snapshot_copy "copies an EC2 snapshot and returns the new Snapshot ID." b
- name: $1
	ec2_snapshot_copy:
		source_region: ${2:# The source region the Snapshot should be copied from.}
		source_snapshot_id: ${3:# The ID of the Snapshot in source region that should be copied.}
		# description: # An optional human-readable string describing purpose of the new Snapshot.
		# encrypted: no
		# kms_key_id: # KMS key id used to encrypt snapshot. If not specified, defaults to EBS Customer Master Key (CMK) for that account.
		# wait: no
		# wait_timeout: 600
		# tags: # A hash/dictionary of tags to add to the new Snapshot; '{"key":"value"}' and '{"key":"value","key":"value"}'
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vol_facts "Gather facts about ec2 volumes in AWS" b
- name: $1
	ec2_vol_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet lambda_alias "Creates, updates or deletes AWS Lambda function aliases." b
- name: $1
	lambda_alias:
		function_name: ${2:# The name of the function alias.}
		state: ${3:#present|absent}
		name: ${4:# Name of the function alias.}
		# description: # A short, user-defined function alias description.
		# version: # Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_elb "De-registers or registers instances from EC2 ELBs" b
- name: $1
	ec2_elb:
		state: ${2:present|absent}
		instance_id: ${3:# EC2 Instance ID}
		# ec2_elbs: # List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.
		# enable_availability_zone: yes
		# wait: yes
		# validate_certs: yes
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elb_instance "De-registers or registers instances from EC2 ELBs" b
- name: $1
	elb_instance:
		state: ${2:present|absent}
		instance_id: ${3:# EC2 Instance ID}
		# ec2_elbs: # List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.
		# enable_availability_zone: yes
		# wait: yes
		# validate_certs: yes
		# wait_timeout: 0
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_cluster "create or terminate ecs clusters" b
- name: $1
	ecs_cluster:
		state: ${2:present|absent|has_instances}
		name: ${3:# The cluster name}
		# delay: # Number of seconds to wait
		# repeat: # The number of times to wait for the cluster to have an instance
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_win_password "gets the default administrator password for ec2 windows instances" b
- name: $1
	ec2_win_password:
		instance_id: ${2:# The instance id to get the password data from.}
		key_file: ${3:# Path to the file containing the key pair used on the instance.}
		# key_passphrase: # The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) C(openssl rsa -in current_key -out new_key -des3).
		# wait: no
		# wait_timeout: 120
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet elasticache_subnet_group "manage Elasticache subnet groups" b
- name: $1
	elasticache_subnet_group:
		state: ${2:#present|absent}
		name: ${3:# Database subnet group identifier.}
		# description: # Elasticache subnet group description. Only set when a new group is added.
		# subnets: # List of subnet IDs that make up the Elasticache subnet group.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_eks_cluster "Manage Elastic Kubernetes Service Clusters" b
- name: $1
	aws_eks_cluster:
		name: ${2:# N}
		# version: # K
		# role_arn: # A
		# subnets: # l
		# security_groups: # l
		# state: absent|#present
		# wait: no
		# wait_timeout: 1200
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet cloudwatchlogs_log_group "create or delete log_group in CloudWatchLogs" b
- name: $1
	cloudwatchlogs_log_group:
		log_group_name: ${2:# The name of the log group.}
		# state: #present|absent
		# kms_key_id: # The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
		# tags: # The key-value pairs to use for the tags.
		# retention: # The number of days to retain the log events in the specified log group. Valid values are: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
		# overwrite: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_task "run, start or stop a task in ecs" b
- name: $1
	ecs_task:
		operation: ${2:run|start|stop}
		# cluster: # The name of the cluster to run the task on
		# task_definition: # The task definition to start or run
		# overrides: # A dictionary of values to pass to the new instances
		# count: # How many new instances to start
		# task: # The task to stop
		# container_instances: # The list of container instances on which to deploy the task
		# started_by: # A value showing who or what started the task (for informational purposes)
		# network_configuration: # network configuration of the service. Only applicable for task definitions created with C(awsvpc) I(network_mode).
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet iam_cert "Manage server certificates for use on ELBs and CloudFront" b
- name: $1
	iam_cert:
		name: ${2:# Name of certificate to add, update or remove.}
		state: ${3:present|absent}
		# new_name: # When state is present, this will update the name of the cert.
		# new_path: # When state is present, this will update the path of the cert.
		# path: /
		# cert_chain: # The path to, or content of the CA certificate chain in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
		# cert: # The path to, or content of the certificate body in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
		# key: # The path to, or content of the private key in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.
		# dup_ok: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_customer_gateway "Manage an AWS customer gateway" b
- name: $1
	ec2_customer_gateway:
		ip_address: ${2:# Internet-routable IP address for customers gateway, must be a static address.}
		name: ${3:# Name of the customer gateway.}
		# bgp_asn: # Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.
		# routing: static|#dynamic
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet sns "Send Amazon Simple Notification Service (SNS) messages" b
- name: $1
	sns:
		msg: ${2:# Default message to send.}
		topic: ${3:# The topic you want to publish to.}
		message_structure: ${4:#json|string}
		# subject: # Subject line for email delivery.
		# email: # Message to send to email-only subscription
		# sqs: # Message to send to SQS-only subscription
		# sms: # Message to send to SMS-only subscription
		# http: # Message to send to HTTP-only subscription
		# https: # Message to send to HTTPS-only subscription
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.
		# region: # The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.
		# message_attributes: # Dictionary of message attributes. These are optional structured data entries to be sent along to the endpoint.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet ec2_vpc_endpoint "Create and delete AWS VPC Endpoints." b
- name: $1
	ec2_vpc_endpoint:
		# vpc_id: # Required when creating a VPC endpoint.
		# service: # An AWS supported vpc endpoint service. Use the ec2_vpc_endpoint_facts module to describe the supported endpoint services.
		# policy: # A properly formatted json policy as string, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813). Cannot be used with I(policy_file).
		# policy_file: # The path to the properly json formatted policy file, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813) on how to use it properly. Cannot be used with I(policy).
		# state: #present|absent
		# wait: no
		# wait_timeout: 320
		# route_table_ids: # List of one or more route table ids to attach to the endpoint. A route is added to the route table with the destination of the endpoint if provided.
		# vpc_endpoint_id: # One or more vpc endpoint ids to remove from the AWS account
		# client_token: # Optional client token to ensure idempotency
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_inspector_target "Create, Update and Delete Amazon Inspector Assessment Targets" b
- name: $1
	aws_inspector_target:
		name: ${2:# The user-defined name that identifies the assessment target.  The name must be unique within the AWS account.}
		# state: absent|#present
		# tags: # Tags of the EC2 instances to be added to the assessment target.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_asg_facts "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS" b
- name: $1
	ec2_asg_facts:
		# name: # The prefix or name of the auto scaling group(s) you are searching for.
		# tags: # A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.

		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vpc_egress_igw "Manage an AWS VPC Egress Only Internet gateway" b
- name: $1
	ec2_vpc_egress_igw:
		vpc_id: ${2:# The VPC ID for the VPC that this Egress Only Internet Gateway should be attached.}
		# state: #present|absent
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet aws_s3_cors "Manage CORS for S3 buckets in AWS" b
- name: $1
	aws_s3_cors:
		name: ${2:# Name of the s3 bucket}
		state: ${3:present|absent}
		# rules: # Cors rules to put on the s3 bucket
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_lc_find "Find AWS Autoscaling Launch Configurations" b
- name: $1
	ec2_lc_find:
		region: ${2:# The AWS region to use.}
		name_regex: ${3:# A Launch Configuration to match}
		# sort_order: #ascending|descending
		# limit: # How many results to show.
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
$0
endsnippet

snippet aws_kms_facts "Gather facts about AWS KMS keys" b
- name: $1
	aws_kms_facts:
		# filters: # A dict of filters to apply. Each dict item consists of a filter key and a filter value. The filters aren't natively supported by boto3, but are supported to provide similar functionality to other modules. Standard tag filters (C(tag-key), C(tag-value) and C(tag:tagName)) are available, as are C(key-id) and C(alias)
		# pending_deletion: no
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ecs_taskdefinition_facts "describe a task definition in ecs" b
- name: $1
	ecs_taskdefinition_facts:
		task_definition: ${2:# The name of the task definition to get details for}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# validate_certs: yes
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet ec2_vol "create and attach a volume, return volume id and device map" b
- name: $1
	ec2_vol:
		# instance: # instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.
		# name: # volume Name tag if you wish to attach an existing volume (requires instance)
		# id: # volume id if you wish to attach an existing volume (requires instance) or remove an existing volume
		# volume_size: # size of volume (in GB) to create.
		# volume_type: standard
		# iops: 100
		# encrypted: no
		# kms_key_id: # Specify the id of the KMS key to use.
		# device_name: # device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.
		# delete_on_termination: no
		# zone: # zone in which to create the volume, if unset uses the zone the instance is in (if set)
		# snapshot: # snapshot ID on which to base the volume
		# validate_certs: yes
		# state: absent|#present|list
		# tags: {}
		# ec2_url: # Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.
		# aws_secret_key: # AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.
		# aws_access_key: # AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.
		# security_token: # AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.
		# profile: # Uses a boto profile. Only works with boto >= 2.24.0.
		# region: # The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
$0
endsnippet

snippet profitbricks_datacenter "Create or destroy a ProfitBricks Virtual Datacenter." b
- name: $1
	profitbricks_datacenter:
		name: ${2:# The name of the virtual datacenter.}
		# description: # The description of the virtual datacenter.
		# location: #us/las|de/fra|de/fkb
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: yes
		# wait_timeout: 600
		# state: #present|absent
$0
endsnippet

snippet profitbricks_nic "Create or Remove a NIC." b
- name: $1
	profitbricks_nic:
		datacenter: ${2:# The datacenter in which to operate.}
		server: ${3:# The server name or ID.}
		name: ${4:# The name or ID of the NIC. This is only required on deletes, but not on create.}
		lan: ${5:# The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.}
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: yes
		# wait_timeout: 600
		# state: #present|absent
$0
endsnippet

snippet profitbricks "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine." b
- name: $1
	profitbricks:
		name: ${2:# The name of the virtual machine.}
		image: ${3:# The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.}
		# auto_increment: yes
		# image_password: # Password set for the administrative user.
		# ssh_keys: # Public SSH keys allowing access to the virtual machine.
		# datacenter: # The datacenter to provision this virtual machine.
		# cores: 2
		# ram: 2048
		# cpu_family: #AMD_OPTERON|INTEL_XEON
		# volume_size: 10
		# bus: IDE|#VIRTIO
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances.
		# count: 1
		# location: #us/las|de/fra|de/fkb
		# assign_public_ip: no
		# lan: 1
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: yes
		# wait_timeout: 600
		# remove_boot_volume: yes
		# state: running|stopped|absent|#present
$0
endsnippet

snippet profitbricks_volume_attachments "Attach or detach a volume." b
- name: $1
	profitbricks_volume_attachments:
		datacenter: ${2:# The datacenter in which to operate.}
		server: ${3:# The name of the server you wish to detach or attach the volume.}
		volume: ${4:# The volume name or ID.}
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: yes
		# wait_timeout: 600
		# state: #present|absent
$0
endsnippet

snippet profitbricks_volume "Create or destroy a volume." b
- name: $1
	profitbricks_volume:
		datacenter: ${2:# The datacenter in which to create the volumes.}
		name: ${3:# The name of the volumes. You can enumerate the names using auto_increment.}
		image: ${4:# The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.}
		# size: 10
		# bus: IDE|#VIRTIO
		# image_password: # Password set for the administrative user.
		# ssh_keys: # Public SSH keys allowing access to the virtual machine.
		# disk_type: #HDD|SSD
		# licence_type: LINUX|WINDOWS|#UNKNOWN|OTHER
		# count: 1
		# auto_increment: yes
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances.
		# subscription_user: # The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
		# subscription_password: # THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
		# wait: yes
		# wait_timeout: 600
		# state: #present|absent
$0
endsnippet

snippet memset_dns_reload "Request reload of Memset's DNS infrastructure," b
- name: $1
	memset_dns_reload:
		api_key: ${2:# The API key obtained from the Memset control panel.}
		# poll: no
$0
endsnippet

snippet memset_zone_domain "Create and delete domains in Memset DNS zones." b
- name: $1
	memset_zone_domain:
		api_key: ${2:# The API key obtained from the Memset control panel.}
		domain: ${3:# The zone domain name. Ensure this value has at most 250 characters.}
		zone: ${4:# The zone to add the domain to (this must already exist).}
		# state: absent|#present
$0
endsnippet

snippet memset_zone_record "Create and delete records in Memset DNS zones." b
- name: $1
	memset_zone_record:
		api_key: ${2:# The API key obtained from the Memset control panel.}
		address: ${3:# The address for this record (can be IP or text string depending on record type).}
		type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT}
		zone: ${5:# The name of the zone to which to add the record to.}
		# state: absent|#present
		# priority: # C(SRV) and C(TXT) record priority, in the range 0 > 999 (inclusive).
		# record: # The subdomain to create.
		# relative: # If set then the current domain is added onto the address field for C(CNAME), C(MX), C(NS) and C(SRV)record types.
		# ttl: 0|300|600|900|1800|3600|7200|10800|21600|43200|86400
$0
endsnippet

snippet memset_zone "Creates and deletes Memset DNS zones." b
- name: $1
	memset_zone:
		state: ${2:absent|present}
		api_key: ${3:# The API key obtained from the Memset control panel.}
		name: ${4:# The zone nickname; usually the same as the main domain. Ensure this value has at most 250 characters.}
		# ttl: 0|300|600|900|1800|3600|7200|10800|21600|43200|86400
		# force: no
$0
endsnippet

snippet heroku_collaborator "Add or delete app collaborators on Heroku" b
- name: $1
	heroku_collaborator:
		apps: ${2:# List of Heroku App names}
		user: ${3:# User ID or e-mail}
		# api_key: # Heroku API key
		# suppress_invitation: no
		# state: #present|absent
$0
endsnippet

snippet azure_rm_resourcegroup_facts "Get resource group facts." b
- name: $1
	azure_rm_resourcegroup_facts:
		# name: # Limit results to a specific resource group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_dnsrecordset_facts "Get DNS Record Set facts." b
- name: $1
	azure_rm_dnsrecordset_facts:
		# relative_name: # Only show results for a Record Set.
		# resource_group: # Limit results by resource group. Required when filtering by name or type.
		# zone_name: # Limit results by zones. Required when filtering by name or type.
		# record_type: # Limit record sets by record type.
		# top: 100
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_loadbalancer_facts "Get load balancer facts." b
- name: $1
	azure_rm_loadbalancer_facts:
		# name: # Limit results to a specific resource group.
		# resource_group: # The resource group to search for the desired load balancer
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_trafficmanagerprofile_facts "Get Azure Traffic Manager profile facts" b
- name: $1
	azure_rm_trafficmanagerprofile_facts:
		# name: # Limit results to a specific Traffic Manager profile.
		# resource_group: # The resource group to search for the desired Traffic Manager profile
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_storageaccount "Manage Azure storage accounts." b
- name: $1
	azure_rm_storageaccount:
		resource_group: ${2:# Name of the resource group to use.}
		# name: # Name of the storage account to update or create.
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# account_type: Premium_LRS|Standard_GRS|Standard_LRS|StandardSSD_LRS|Standard_RAGRS|Standard_ZRS
		# custom_domain: # User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.
		# kind: #Storage|StorageV2|BlobStorage
		# access_tier: Hot|Cool
		# force: # Attempt deletion if resource already exists and cannot be updated
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_containerregistry "Manage an Azure Container Registry." b
- name: $1
	azure_rm_containerregistry:
		resource_group: ${2:# Name of a resource group where the Container Registry exists or will be created.}
		name: ${3:# Name of the Container Registry.}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# admin_user_enabled: no
		# sku: Basic|#Standard|Premium
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_dnszone "Manage Azure DNS zones." b
- name: $1
	azure_rm_dnszone:
		resource_group: ${2:# name of resource group.}
		name: ${3:# name of the DNS Zone.}
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_webapp_facts "Get azure web app facts." b
- name: $1
	azure_rm_webapp_facts:
		# name: # Only show results for a specific web app.
		# resource_group: # Limit results by resource group.
		# return_publish_profile: no
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_sqlserver "Manage SQL Server instance" b
- name: $1
	azure_rm_sqlserver:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the server.}
		# location: # Resource location.
		# admin_username: # Administrator username for the server. Once created it cannot be changed.
		# admin_password: # The administrator login password (required for server creation).
		# version: # The version of the server. For example '12.0'.
		# identity: # The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resour ce. Possible values include: 'SystemAssigned'
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_virtualmachine_extension "Managed Azure Virtual Machine extension" b
- name: $1
	azure_rm_virtualmachine_extension:
		resource_group: ${2:# Name of a resource group where the vm extension exists or will be created.}
		name: ${3:# Name of the vm extension}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# virtual_machine_name: # The name of the virtual machine where the extension should be create or updated.
		# publisher: # The name of the extension handler publisher.
		# virtual_machine_extension_type: # The type of the extension handler.
		# type_handler_version: # The type version of the extension handler.
		# settings: # Json formatted public settings for the extension.
		# protected_settings: # Json formatted protected settings for the extension.
		# auto_upgrade_minor_version: # Whether the extension handler should be automatically upgraded across minor versions.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_trafficmanagerprofile "Manage Azure Traffic Manager profile." b
- name: $1
	azure_rm_trafficmanagerprofile:
		resource_group: ${2:# Name of a resource group where the Traffic Manager profile exists or will be created.}
		name: ${3:# Name of the Traffic Manager profile.}
		# state: absent|#present
		# location: global
		# profile_status: #enabled|disabled
		# routing_method: #performance|priority|weighted|geographic
		# dns_config: # The DNS settings of the Traffic Manager profile.
		# monitor_config: {'protocol': 'HTTP', 'port': 80, 'path': '/'}
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_acs "Manage an Azure Container Service Instance (ACS)." b
- name: $1
	azure_rm_acs:
		resource_group: ${2:# Name of a resource group where the Container Services exists or will be created.}
		name: ${3:# Name of the Container Services instance.}
		orchestration_platform: ${4:DCOS|Kubernetes|Swarm}
		master_profile: ${5:# Master profile suboptions.}
		linux_profile: ${6:# The linux profile suboptions.}
		agent_pool_profiles: ${7:# The agent pool profile suboptions.}
		diagnostics_profile: ${8:# Should VM Diagnostics be enabled for the Container Service VM's.}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# service_principal: # The service principal suboptions.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_networkinterface_facts "Get network interface facts." b
- name: $1
	azure_rm_networkinterface_facts:
		# name: # Only show results for a specific network interface.
		# resource_group: # Name of the resource group containing the network interface(s). Required when searching by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_dnsrecordset "Create, delete and update DNS record sets and records." b
- name: $1
	azure_rm_dnsrecordset:
		resource_group: ${2:# name of resource group}
		zone_name: ${3:# name of the existing DNS zone in which to manage the record set}
		relative_name: ${4:# relative name of the record set}
		record_type: ${5:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		# record_mode: append|#purge
		# state: absent|#present
		# time_to_live: 3600
		# records: # list of records to be created depending on the type of record (set)
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_postgresqldatabase_facts "Get Azure PostgreSQL Database facts." b
- name: $1
	azure_rm_postgresqldatabase_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		# name: # The name of the database.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_containerregistry_facts "Get Azure Container Registry facts." b
- name: $1
	azure_rm_containerregistry_facts:
		resource_group: ${2:# The name of the resource group to which the container registry belongs.}
		# name: # The name of the container registry.
		# retrieve_credentials: no
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_storageblob "Manage blob containers and blob objects." b
- name: $1
	azure_rm_storageblob:
		storage_account_name: ${2:# Name of the storage account to use.}
		container: ${3:# Name of a blob container within the storage account.}
		resource_group: ${4:# Name of the resource group to use.}
		# blob: # Name of a blob object within the container.
		# blob_type: #block|page
		# content_type: # Set the blob content-type header. For example, 'image/png'.
		# cache_control: # Set the blob cache-control header.
		# content_disposition: # Set the blob content-disposition header.
		# content_encoding: # Set the blob encoding header.
		# content_language: # Set the blob content-language header.
		# content_md5: # Set the blob md5 hash value.
		# dest: # Destination file path. Use with state 'present' to download a blob.
		# force: no
		# src: # Source file path. Use with state 'present' to upload a blob.
		# state: absent|#present
		# public_access: container|blob
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_trafficmanagerendpoint_facts "Get Azure Traffic Manager endpoint facts" b
- name: $1
	azure_rm_trafficmanagerendpoint_facts:
		resource_group: ${2:# The resource group to search for the desired Traffic Manager profile}
		profile_name: ${3:# Name of Traffic Manager Profile}
		# name: # Limit results to a specific Traffic Manager endpoint.
		# type: azure_endpoints|external_endpoints|nested_endpoints
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_publicipaddress_facts "Get public IP facts." b
- name: $1
	azure_rm_publicipaddress_facts:
		# name: # Only show results for a specific Public IP.
		# resource_group: # Limit results by resource group. Required when using name parameter.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_appserviceplan_facts "Get azure app service plan facts." b
- name: $1
	azure_rm_appserviceplan_facts:
		# name: # Only show results for a specific app service plan.
		# resource_group: # Limit results by resource group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_virtualmachineimage_facts "Get virtual machine image facts." b
- name: $1
	azure_rm_virtualmachineimage_facts:
		location: ${2:# Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.}
		# publisher: # Name of an image publisher. List image offerings associated with a particular publisher.
		# offer: # Name of an image offering. Combine with sku to see a list of available image versions.
		# sku: # Image offering SKU. Combine with offer to see a list of available versions.
		# version: # Specific version number of an image.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset_facts "Get Virtual Machine Scale Set facts" b
- name: $1
	azure_rm_virtualmachine_scaleset_facts:
		# name: # Limit results to a specific virtual machine scale set
		# resource_group: # The resource group to search for the desired virtual machine scale set
		# tags: # List of tags to be matched
		# format: curated|#raw
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_route "Manage Azure route resource." b
- name: $1
	azure_rm_route:
		resource_group: ${2:# name of resource group.}
		name: ${3:# name of the route.}
		route_table_name: ${4:# The name of the route table.}
		# state: absent|#present
		# address_prefix: # The destination CIDR to which the route applies.
		# next_hop_type: virtual_network_gateway|vnet_local|internet|virtual_appliance|#none
		# next_hop_ip_address: # The IP address packets should be forwarded to.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_functionapp "Manage Azure Function Apps" b
- name: $1
	azure_rm_functionapp:
		resource_group: ${2:# Name of resource group}
		name: ${3:# Name of the Azure Function App}
		storage_account: ${4:# Name of the storage account to use.}
		# location: # Valid Azure location. Defaults to location of the resource group.
		# app_settings: # Dictionary containing application settings
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_managed_disk "Manage Azure Manage Disks" b
- name: $1
	azure_rm_managed_disk:
		resource_group: ${2:# Name of a resource group where the managed disk exists or will be created.}
		name: ${3:# Name of the managed disk.}
		# state: absent|#present
		# location: # Valid Azure location. Defaults to location of the resource group.
		# storage_account_type: Standard_LRS|Premium_LRS
		# create_option: empty|import|copy
		# source_uri: # URI to a valid VHD file to be used when I(create_option) is C(import).
		# source_resource_uri: # The resource ID of the managed disk to copy when I(create_option) is C(copy).
		# os_type: linux|windows
		# disk_size_gb: # Size in GB of the managed disk to be created. If I(create_option) is C(copy) then the value must be greater than or equal to the source's size.
		# managed_by: # Name of an existing virtual machine with which the disk is or will be associated, this VM should be in the same resource group.
		# tags: # Tags to assign to the managed disk.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# append_tags: yes
$0
endsnippet

snippet azure_rm_virtualnetwork "Manage Azure virtual networks." b
- name: $1
	azure_rm_virtualnetwork:
		resource_group: ${2:# name of resource group.}
		name: ${3:# name of the virtual network.}
		# address_prefixes_cidr: # List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_address_prefixes.
		# dns_servers: # Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.
		# location: # Valid azure location. Defaults to location of the resource group.
		# purge_address_prefixes: no
		# purge_dns_servers: no
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_storageaccount_facts "Get storage account facts." b
- name: $1
	azure_rm_storageaccount_facts:
		# name: # Only show results for a specific account.
		# resource_group: # Limit results to a resource group. Required when filtering by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_resourcegroup "Manage Azure resource groups." b
- name: $1
	azure_rm_resourcegroup:
		name: ${2:# Name of the resource group.}
		# force: no
		# location: # Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_autoscale_facts "Get Azure Auto Scale Setting facts." b
- name: $1
	azure_rm_autoscale_facts:
		resource_group: ${2:# The name of the resource group.}
		# name: # The name of the Auto Scale Setting.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_availabilityset "Manage Azure availability set." b
- name: $1
	azure_rm_availabilityset:
		resource_group: ${2:# Name of a resource group where the availability set exists or will be created.}
		name: ${3:# Name of the availability set.}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# platform_update_domain_count: 5
		# platform_fault_domain_count: 3
		# sku: #Classic|Aligned
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_containerinstance "Manage an Azure Container Instance." b
- name: $1
	azure_rm_containerinstance:
		resource_group: ${2:# Name of resource group.}
		name: ${3:# The name of the container group.}
		# os_type: #linux|windows
		# state: absent|#present
		# ip_address: public|#none
		# ports: # List of ports exposed within the container group.
		# location: # Valid azure location. Defaults to location of the resource group.
		# registry_login_server: # The container image registry login server.
		# registry_username: # The username to log in container image registry server.
		# registry_password: # The password to log in container image registry server.
		# containers: # List of containers.
		# force_update: no
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_mysqldatabase "Manage MySQL Database instance." b
- name: $1
	azure_rm_mysqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		name: ${4:# The name of the database.}
		# charset: # The charset of the database. Check MySQL documentation for possible values.
		# collation: # The collation of the database. Check MySQL documentation for possible values.
		# force_update: no
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_aks_facts "Get Azure Kubernetes Service facts." b
- name: $1
	azure_rm_aks_facts:
		# name: # Limit results to a specific resource group.
		# resource_group: # The resource group to search for the desired Azure Kubernetes Service
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_mysqlserver "Manage MySQL Server instance." b
- name: $1
	azure_rm_mysqlserver:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the server.}
		# sku: # The SKU (pricing tier) of the server.
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# storage_mb: # The maximum storage allowed for a server.
		# version: 5.6|5.7
		# enforce_ssl: no
		# admin_username: # The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
		# admin_password: # The password of the administrator login.
		# create_mode: Default
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_sqlserver_facts "Get SQL Server facts." b
- name: $1
	azure_rm_sqlserver_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# server_name: # The name of the server.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_virtualmachine "Manage Azure virtual machines." b
- name: $1
	azure_rm_virtualmachine:
		resource_group: ${2:# Name of the resource group containing the virtual machine.}
		name: ${3:# Name of the virtual machine.}
		image: ${4:# Specifies the image used to build the VM.}
		# custom_data: # Data which is made available to the virtual machine and used by e.g., cloud-init.
		# state: absent|#present
		# started: yes
		# allocated: yes
		# restarted: # Use with state 'present' to restart a running VM.
		# location: # Valid Azure location. Defaults to location of the resource group.
		# short_hostname: # Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.
		# vm_size: # A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices. Required when creating a VM.
		# admin_username: # Admin username used to access the host after it is created. Required when creating a VM.
		# admin_password: # Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.
		# ssh_password_enabled: yes
		# ssh_public_keys: # For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.
		# availability_set: # Name or ID of an existing availability set to add the VM to. The availability_set should be in the same resource group as VM.
		# storage_account_name: # Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.
		# storage_container_name: vhds
		# storage_blob_name: # Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'
		# managed_disk_type: Standard_LRS|Premium_LRS
		# os_disk_caching: #ReadOnly|ReadWrite
		# os_disk_size_gb: # Type of OS disk size in GB.
		# os_type: Windows|#Linux
		# data_disks: # Describes list of data disks.
		# public_ip_allocation_method: Dynamic|#Static|Disabled
		# open_ports: # If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.
		# network_interface_names: # List of existing network interface names to add to the VM.
		# virtual_network_resource_group: # When creating a virtual machine, if a specific virtual network from another resource group should be used, use this parameter to specify the resource group to use.
		# virtual_network_name: # When creating a virtual machine, if a network interface name is not provided, one will be created.
		# subnet_name: # When creating a virtual machine, if a network interface name is not provided, one will be created.
		# remove_on_absent: ['all']
		# plan: # A dictionary describing a third-party billing plan for an instance
		# accept_terms: no
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_keyvaultsecret "Use Azure KeyVault Secrets." b
- name: $1
	azure_rm_keyvaultsecret:
		keyvault_uri: ${2:# URI of the keyvault endpoint.}
		secret_name: ${3:# Name of the keyvault secret.}
		# secret_value: # Secret to be secured by keyvault.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_postgresqldatabase "Manage PostgreSQL Database instance." b
- name: $1
	azure_rm_postgresqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		name: ${4:# The name of the database.}
		# charset: # The charset of the database. Check PostgreSQL documentation for possible values.
		# collation: # The collation of the database. Check PostgreSQL documentation for possible values.
		# force_update: no
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_routetable "Manage Azure route table resource." b
- name: $1
	azure_rm_routetable:
		resource_group: ${2:# name of resource group.}
		name: ${3:# name of the route table.}
		# state: absent|#present
		# disable_bgp_route_propagation: no
		# location: # Region of the resource.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_sqlfirewallrule "Manage Firewall Rule instance." b
- name: $1
	azure_rm_sqlfirewallrule:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		name: ${4:# The name of the firewall rule.}
		# start_ip_address: # The start IP address of the firewall rule. Must be IPv4 format. Use value C(0.0.0.0) to represent all Azure-internal IP addresses.
		# end_ip_address: # The end IP address of the firewall rule. Must be IPv4 format. Must be greater than or equal to startIpAddress. Use value C(0.0.0.0) to represe nt all Azure-internal IP addresses.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_dnszone_facts "Get DNS zone facts." b
- name: $1
	azure_rm_dnszone_facts:
		# resource_group: # Limit results by resource group. Required when filtering by name.
		# name: # Only show results for a specific zone.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# append_tags: yes
$0
endsnippet

snippet azure_rm_securitygroup_facts "Get security group facts." b
- name: $1
	azure_rm_securitygroup_facts:
		resource_group: ${2:# Name of the resource group to use.}
		# name: # Only show results for a specific security group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_virtualnetwork_facts "Get virtual network facts." b
- name: $1
	azure_rm_virtualnetwork_facts:
		# name: # Only show results for a specific security group.
		# resource_group: # Limit results by resource group. Required when filtering by name.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_functionapp_facts "Get Azure Function App facts" b
- name: $1
	azure_rm_functionapp_facts:
		# name: # Only show results for a specific Function App
		# resource_group: # Limit results to a resource group. Required when filtering by name
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_mysqlserver_facts "Get Azure MySQL Server facts." b
- name: $1
	azure_rm_mysqlserver_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# name: # The name of the server.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_resource_facts "Generic facts of Azure resources." b
- name: $1
	azure_rm_resource_facts:
		api_version: ${2:# Specific API version to be used.}
		# url: # Azure RM Resource URL.
		# provider: # Provider type, should be specified in no URL is given
		# resource_group: # Resource group to be used.
		# resource_type: # Resource type.
		# resource_name: # Resource name.
		# subresource: # List of subresources
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_trafficmanagerendpoint "Manage Azure Traffic Manager endpoint." b
- name: $1
	azure_rm_trafficmanagerendpoint:
		resource_group: ${2:# Name of a resource group where the Traffic Manager endpoint exists or will be created.}
		name: ${3:# The name of the endpoint.}
		profile_name: ${4:# N}
		type: ${5:azure_endpoints|external_endpoints|nested_endpoints}
		# target_resource_id: # The Azure Resource URI of the of the endpoint.
		# target: # The fully-qualified DNS name of the endpoint.
		# enabled: yes
		# weight: # The weight of this endpoint when traffic manager profile has routing_method of C(weighted).
		# priority: # The priority of this endpoint when traffic manager profile has routing_method of C(priority).
		# location: # Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
		# min_child_endpoints: # The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available.
		# geo_mapping: # The list of countries/regions mapped to this endpoint when traffic manager profile has routing_method of C(geographic).
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_appgateway "Manage Application Gateway instance." b
- name: $1
	azure_rm_appgateway:
		resource_group: ${2:# The name of the resource group.}
		name: ${3:# The name of the application gateway.}
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# sku: # SKU of the application gateway resource.
		# ssl_policy: # SSL policy of the application gateway resource.
		# gateway_ip_configurations: # List of subnets used by the application gateway.
		# authentication_certificates: # Authentication certificates of the application gateway resource.
		# ssl_certificates: # SSL certificates of the application gateway resource.
		# frontend_ip_configurations: # Frontend IP addresses of the application gateway resource.
		# frontend_ports: # List of frontend ports of the application gateway resource.
		# backend_address_pools: # List of backend address pool of the application gateway resource.
		# backend_http_settings_collection: # Backend http settings of the application gateway resource.
		# http_listeners: # List of HTTP listeners of the application gateway resource.
		# request_routing_rules: # List of request routing rules of the application gateway resource.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_deployment "Create or destroy Azure Resource Manager template deployments" b
- name: $1
	azure_rm_deployment:
		resource_group_name: ${2:# The resource group name to use or create to host the deployed template}
		# location: westus
		# deployment_mode: complete|#incremental
		# state: #present|absent
		# template: # A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if "state" parameter is "present".
		# template_link: # Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if "state" parameter is "present".
		# parameters: # A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'parameters_link'. Either one of them is required if "state" parameter is "present".
		# parameters_link: # Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if "state" parameter is "present".
		# deployment_name: ansible-arm
		# wait_for_deployment_completion: yes
		# wait_for_deployment_polling_period: 10
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_subnet "Manage Azure subnets." b
- name: $1
	azure_rm_subnet:
		resource_group: ${2:# Name of resource group.}
		name: ${3:# Name of the subnet.}
		address_prefix_cidr: ${4:# CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.}
		virtual_network_name: ${5:# Name of an existing virtual network with which the subnet is or will be associated.}
		# security_group: # Existing security group with which to associate the subnet.
		# state: absent|#present
		# route_table: # The reference of the RouteTable resource.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_postgresqlserver_facts "Get Azure PostgreSQL Server facts." b
- name: $1
	azure_rm_postgresqlserver_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		# name: # The name of the server.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_appserviceplan "Manage App Service Plan" b
- name: $1
	azure_rm_appserviceplan:
		resource_group: ${2:# Name of the resource group to which the resource belongs.}
		name: ${3:# Unique name of the app service plan to create or update.}
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# sku: # The pricing tiers, e.g., F1, D1, B1, B2, B3, S1, P1, P1V2 etc.
		# is_linux: no
		# number_of_workers: # Describe number of workers to be allocated.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_autoscale "Manage Azure autoscale setting." b
- name: $1
	azure_rm_autoscale:
		resource_group: ${2:# r}
		name: ${3:# n}
		# target: # The identifier of the resource to apply autoscale setting.
		# enabled: yes
		# profiles: # The collection of automatic scaling profiles that specify different scaling parameters for different time periods.
		# notifications: # t
		# state: #present|absent
		# location: # l
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_resource "Create any Azure resource." b
- name: $1
	azure_rm_resource:
		api_version: ${2:# Specific API version to be used.}
		# url: # Azure RM Resource URL.
		# provider: # Provider type.
		# resource_group: # Resource group to be used.
		# resource_type: # Resource type.
		# resource_name: # Resource name.
		# subresource: # List of subresources
		# body: # The body of the http request/response to the web service.
		# method: GET|#PUT|POST|HEAD|PATCH|DELETE|MERGE
		# status_code: [200, 201, 202]
		# idempotency: no
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_networkinterface "Manage Azure network interfaces." b
- name: $1
	azure_rm_networkinterface:
		resource_group: ${2:# Name of a resource group where the network interface exists or will be created.}
		name: ${3:# Name of the network interface.}
		virtual_network: ${4:# An existing virtual network with which the network interface will be associated. Required when creating a network interface.}
		subnet_name: ${5:# Name of an existing subnet within the specified virtual network. Required when creating a network interface}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# os_type: Windows|#Linux
		# private_ip_address: # (Deprecate) Valid IPv4 address that falls within the specified subnet.
		# private_ip_allocation_method: #Dynamic|Static
		# public_ip: yes
		# public_ip_address_name: # (Deprecate) Name of an existing public IP address object to associate with the security group.
		# public_ip_allocation_method: #Dynamic|Static
		# ip_configurations: # List of ip configuration if contains mutilple configuration, should contain configuration object include field private_ip_address, private_ip_allocation_method, public_ip_address_name, public_ip, public_ip_allocation_method, name
		# enable_accelerated_networking: no
		# create_with_security_group: yes
		# security_group: # An existing security group with which to associate the network interface. If not provided, a default security group will be created when C(create_with_security_group) is true.
		# open_ports: # When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.
		# enable_ip_forwarding: no
		# dns_servers: # Which DNS servers should the NIC lookup
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_virtualmachine_scaleset "Manage Azure virtual machine scale sets." b
- name: $1
	azure_rm_virtualmachine_scaleset:
		resource_group: ${2:# Name of the resource group containing the virtual machine scale set.}
		name: ${3:# Name of the virtual machine.}
		vm_size: ${4:# A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices.}
		capacity: ${5:1}
		image: ${6:# Specifies the image used to build the VM.}
		# state: absent|#present
		# location: # Valid Azure location. Defaults to location of the resource group.
		# short_hostname: # Short host name
		# tier: Basic|Standard
		# upgrade_policy: Manual|Automatic
		# admin_username: # Admin username used to access the host after it is created. Required when creating a VM.
		# admin_password: # Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.
		# ssh_password_enabled: yes
		# ssh_public_keys: # For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.
		# os_disk_caching: #ReadOnly|ReadWrite
		# os_type: Windows|#Linux
		# managed_disk_type: Standard_LRS|Premium_LRS
		# data_disks: # Describes list of data disks.
		# virtual_network_resource_group: # When creating a virtual machine, if a specific virtual network from another resource group should be used, use this parameter to specify the resource group to use.
		# virtual_network_name: # Virtual Network name.
		# subnet_name: # Subnet name.
		# load_balancer: # Load balancer name.
		# remove_on_absent: ['all']
		# enable_accelerated_networking: # Indicates whether user wants to allow accelerated networking for virtual machines in scaleset being created.
		# security_group: # Existing security group with which to associate the subnet.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_managed_disk_facts "Get managed disk facts." b
- name: $1
	azure_rm_managed_disk_facts:
		# name: # Limit results to a specific managed disk
		# resource_group: # Limit results to a specific resource group
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# append_tags: yes
$0
endsnippet

snippet azure_rm_postgresqlserver "Manage PostgreSQL Server instance." b
- name: $1
	azure_rm_postgresqlserver:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		name: ${3:# The name of the server.}
		# sku: # The SKU (pricing tier) of the server.
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# storage_mb: # The maximum storage allowed for a server.
		# version: 9.5|9.6
		# enforce_ssl: no
		# admin_username: # The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
		# admin_password: # The password of the administrator login.
		# create_mode: Default
		# state: #present|absent
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_keyvaultkey "Use Azure KeyVault keys." b
- name: $1
	azure_rm_keyvaultkey:
		keyvault_uri: ${2:# URI of the keyvault endpoint.}
		key_name: ${3:# Name of the keyvault key.}
		# byok_file: # BYOK file.
		# pem_file: # PEM file.
		# pem_password: # PEM password.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_routetable_facts "Get route table facts." b
- name: $1
	azure_rm_routetable_facts:
		# name: # Limit results to a specific route table.
		# resource_group: # Limit results in a specific resource group.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_keyvault "Manage Key Vault instance." b
- name: $1
	azure_rm_keyvault:
		resource_group: ${2:# The name of the Resource Group to which the server belongs.}
		vault_name: ${3:# Name of the vault}
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# vault_tenant: # The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
		# sku: # SKU details
		# access_policies: # An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID.
		# enabled_for_deployment: # Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault.
		# enabled_for_disk_encryption: # Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
		# enabled_for_template_deployment: # Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
		# enable_soft_delete: # Property to specify whether the soft delete functionality is enabled for this key vault.
		# recover_mode: # Create vault in recovery mode.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_publicipaddress "Manage Azure Public IP Addresses." b
- name: $1
	azure_rm_publicipaddress:
		resource_group: ${2:# Name of resource group with which the Public IP is associated.}
		name: ${3:# Name of the Public IP.}
		# allocation_method: #Dynamic|Static
		# domain_name: # The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP.
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# sku: Basic|Standard
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_availabilityset_facts "Get availability set facts." b
- name: $1
	azure_rm_availabilityset_facts:
		# name: # Limit results to a specific availability set
		# resource_group: # The resource group to search for the desired availability set
		# tags: # List of tags to be matched
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_mysqldatabase_facts "Get Azure MySQL Database facts." b
- name: $1
	azure_rm_mysqldatabase_facts:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		# name: # The name of the database.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_virtualmachine_facts "Get virtual machine facts." b
- name: $1
	azure_rm_virtualmachine_facts:
		# resource_group: # Name of the resource group containing the virtual machines (required when filtering by vm name).
		# name: # Name of the virtual machine.
		# tags: # Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_aks "Manage a managed Azure Container Service (AKS) Instance." b
- name: $1
	azure_rm_aks:
		resource_group: ${2:# Name of a resource group where the managed Azure Container Services (AKS) exists or will be created.}
		name: ${3:# Name of the managed Azure Container Services (AKS) instance.}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# dns_prefix: # DNS prefix specified when creating the managed cluster.
		# kubernetes_version: # Version of Kubernetes specified when creating the managed cluster.
		# linux_profile: # The linux profile suboptions.
		# agent_pool_profiles: # The agent pool profile suboptions.
		# service_principal: # The service principal suboptions.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_loadbalancer "Manage Azure load balancers." b
- name: $1
	azure_rm_loadbalancer:
		resource_group: ${2:# Name of a resource group where the load balancer exists or will be created.}
		name: ${3:# Name of the load balancer.}
		# state: absent|#present
		# location: # Valid azure location. Defaults to location of the resource group.
		# sku: Basic|Standard
		# frontend_ip_configurations: # L
		# backend_address_pools: # L
		# probes: # L
		# inbound_nat_pools: # Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer.
		# load_balancing_rules: # Object collection representing the load balancing rules Gets the provisioning.
		# public_ip_address_name: # (deprecated) Name of an existing public IP address object to associate with the security group.
		# probe_port: # (deprecated) The port that the health probe will use.
		# probe_protocol: Tcp|Http
		# probe_interval: 15
		# probe_fail_count: 3
		# probe_request_path: # (deprecated) The URL that an HTTP probe will use (only relevant if probe_protocol is set to Http).
		# protocol: Tcp|Udp
		# load_distribution: Default|SourceIP|SourceIPProtocol
		# frontend_port: # (deprecated) Frontend port that will be exposed for the load balancer.
		# backend_port: # (deprecated) Backend port that will be exposed for the load balancer.
		# idle_timeout: 4
		# natpool_frontend_port_start: # (deprecated) Start of the port range for a NAT pool.
		# natpool_frontend_port_end: # (deprecated) End of the port range for a NAT pool.
		# natpool_backend_port: # (deprecated) Backend port used by the NAT pool.
		# natpool_protocol: # (deprecated) The protocol for the NAT pool.
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_sqldatabase "Manage SQL Database instance." b
- name: $1
	azure_rm_sqldatabase:
		resource_group: ${2:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
		server_name: ${3:# The name of the server.}
		name: ${4:# The name of the database to be operated on (updated or created).}
		# location: # Resource location. If not set, location from the resource group will be used as C(default).
		# collation: # The collation of the database. If I(create_mode) is not C(default), this value is ignored.
		# create_mode: copy|default|non_readable_secondary|online_secondary|point_in_time_restore|recovery|restore|restore_long_term_retention_backup
		# source_database_id: # Required unless I(create_mode) is C(default) or C(restore_long_term_retention_backup).
		# source_database_deletion_date: # Required if I(create_mode) is C(restore) and I(source_database_id) is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
		# restore_point_in_time: # Required if I(create_mode) is C(point_in_time_restore), this value is required. If I(create_mode) is C(restore), this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database's earliestRestoreDate value.
		# recovery_services_recovery_point_resource_id: # Required if I(create_mode) is C(restore_long_term_retention_backup), then this value is required. Specifies the resource ID of the recovery point to restore from.
		# edition: web|business|basic|standard|premium|free|stretch|data_warehouse|system|system2
		# max_size_bytes: # The max size of the database expressed in bytes. If I(create_mode) is not C(default), this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: 'Capabilities_ListByLocation.'
		# elastic_pool_name: # The name of the elastic pool the database is in. Not supported for C(data_warehouse) edition.
		# read_scale: no
		# sample_name: adventure_works_lt
		# zone_redundant: no
		# force_update: # SQL Database will be updated if given parameters differ from existing resource state.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
$0
endsnippet

snippet azure_rm_image "Manage Azure image." b
- name: $1
	azure_rm_image:
		resource_group: ${2:# Name of resource group.}
		name: ${3:# Name of the image.}
		source: ${4:# OS disk source from the same region, including a virtual machine id or name, OS disk blob uri, managed OS disk id or name, or OS snapshot id or name.}
		# data_disk_sources: # List of data disk sources, including unmanaged blob uri, managed disk id or name, or snapshot id or name.
		# location: # Location of the image. Derived from I(resource_group) if not specified.
		# os_type: Windows|Linux
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_webapp "Manage Web App instance." b
- name: $1
	azure_rm_webapp:
		resource_group: ${2:# Name of the resource group to which the resource belongs.}
		name: ${3:# Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.}
		# location: # Resource location. If not set, location from the resource group will be used as default.
		# plan: # App service plan. Required for creation.
		# frameworks: # Set of run time framework settings. Each setting is a dictionary.
		# container_settings: # W
		# scm_type: # Repository type of deployment source. Eg. LocalGit, GitHub.
		# deployment_source: # Deployment source for git
		# startup_file: # The web's startup file.
		# client_affinity_enabled: yes
		# https_only: # Configures web site to accept only https requests.
		# dns_registration: # If true web app hostname is not registered with DNS on creation.
		# skip_custom_domain_verification: # If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
		# ttl_in_seconds: # Time to live in seconds for web app default domain name.
		# app_settings: # Configure web app application settings. Suboptions are in key value pair format.
		# purge_app_settings: # Purge any existing application settings. Replace web app application settings with app_settings.
		# app_state: #started|stopped|restarted
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet azure_rm_securitygroup "Manage Azure network security groups." b
- name: $1
	azure_rm_securitygroup:
		resource_group: ${2:# Name of the resource group the security group belongs to.}
		# default_rules: # The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.
		# location: # Valid azure location. Defaults to location of the resource group.
		# name: # Name of the security group to operate on.
		# purge_default_rules: no
		# purge_rules: no
		# rules: # Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.
		# state: absent|#present
		# ad_user: # Active Directory username. Use when authenticating with an Active Directory user rather than service principal.
		# password: # Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.
		# profile: # Security profile found in ~/.azure/credentials file.
		# subscription_id: # Your Azure subscription Id.
		# client_id: # Azure client ID. Use when authenticating with a Service Principal.
		# secret: # Azure client secret. Use when authenticating with a Service Principal.
		# tenant: # Azure tenant ID. Use when authenticating with a Service Principal.
		# cloud_environment: AzureCloud
		# adfs_authority_url: # Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.
		# cert_validation_mode: validate|ignore
		# auth_source: auto|cli|credential_file|env|msi
		# api_profile: latest
		# tags: # Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.

		# append_tags: yes
$0
endsnippet

snippet linode "Manage instances on the Linode Public Cloud" b
- name: $1
	linode:
		name: ${2:# Name to give the instance (alphanumeric, dashes, underscore).}
		# state: absent|active|deleted|#present|restarted|started|stopped
		# api_key: # Linode API key
		# displaygroup: # Add the instance to a Display Group in Linode Manager.
		# linode_id: # Unique ID of a linode server
		# additional_disks: # List of dictionaries for creating additional disks that are added to the Linode configuration settings.
		# alert_bwin_enabled: # Set status of bandwidth in alerts.
		# alert_bwin_threshold: # Set threshold in MB of bandwidth in alerts.
		# alert_bwout_enabled: # Set status of bandwidth out alerts.
		# alert_bwout_threshold: # Set threshold in MB of bandwidth out alerts.
		# alert_bwquota_enabled: # Set status of bandwidth quota alerts as percentage of network transfer quota.
		# alert_bwquota_threshold: # Set threshold in MB of bandwidth quota alerts.
		# alert_cpu_enabled: # Set status of receiving CPU usage alerts.
		# alert_cpu_threshold: # Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.
		# alert_diskio_enabled: # Set status of receiving disk IO alerts.
		# alert_diskio_threshold: # Set threshold for average IO ops/sec over 2 hour period.
		# backupweeklyday: # Integer value for what day of the week to store weekly backups.
		# plan: # plan to use for the instance (Linode plan)
		# payment_term: #1|12|24
		# password: # root password to apply to a new server (auto generated if missing)
		# private_ip: no
		# ssh_pub_key: # SSH public key applied to root user
		# swap: 512
		# distribution: # distribution to use for the instance (Linode Distribution)
		# datacenter: # datacenter to create an instance in (Linode Datacenter)
		# kernel_id: # kernel to use for the instance (Linode Kernel)
		# wait: no
		# wait_timeout: 300
		# watchdog: True
$0
endsnippet

snippet rax_cdb_user "create / delete a Rackspace Cloud Database" b
- name: $1
	rax_cdb_user:
		# cdb_id: # The databases server UUID
		# db_username: # Name of the database user
		# db_password: # Database user password
		# databases: []
		# host: %
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_dns_record "Manage DNS records on Rackspace Cloud DNS" b
- name: $1
	rax_dns_record:
		data: ${2:# IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT}
		name: ${3:# FQDN record name to create}
		type: ${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}
		# comment: # Brief description of the domain. Maximum length of 160 characters
		# domain: # Domain name to create the record in. This is an invalid option when type=PTR
		# loadbalancer: # Load Balancer ID to create a PTR record for. Only used with type=PTR
		# overwrite: yes
		# priority: # Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.
		# server: # Server ID to create a PTR record for. Only used with type=PTR
		# state: #present|absent
		# ttl: 3600
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_mon_notification "Create or delete a Rackspace Cloud Monitoring notification." b
- name: $1
	rax_mon_notification:
		label: ${2:# Defines a friendly name for this notification. String between 1 and 255 characters long.}
		notification_type: ${3:webhook|email|pagerduty}
		details: ${4:# Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.}
		# state: present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_files_objects "Upload, download, and delete objects in Rackspace Cloud Files" b
- name: $1
	rax_files_objects:
		container: ${2:# The container to use for file object operations.}
		# clear_meta: no
		# dest: # The destination of a "get" operation; i.e. a local directory, "/home/user/myfolder". Used to specify the destination of an operation on a remote object; i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17"
		# expires: # Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds
		# meta: # A hash of items to set as metadata values on an uploaded file or folder
		# method: #get|put|delete
		# src: # Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17".  src and dest are mutually exclusive on remote-only object operations
		# structure: yes
		# state: #present|absent
		# type: #file|meta
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_cbs "Manipulate Rackspace Cloud Block Storage Volumes" b
- name: $1
	rax_cbs:
		name: ${2:# Name to give the volume being created}
		size: ${3:100}
		state: ${4:#present|absent}
		volume_type: ${5:#SATA|SSD}
		# description: # Description to give the volume being created
		# image: # image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)
		# meta: # A hash of metadata to associate with the volume
		# snapshot_id: # The id of the snapshot to create the volume from
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_facts "Gather facts for Rackspace Cloud Servers" b
- name: $1
	rax_facts:
		# address: # Server IP address to retrieve facts for, will match any IP assigned to the server
		# id: # Server ID to retrieve facts for
		# name: # Server name to retrieve facts for
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_files "Manipulate Rackspace Cloud Files Containers" b
- name: $1
	rax_files:
		container: ${2:# The container to use for container or metadata operations.}
		# clear_meta: no
		# meta: # A hash of items to set as metadata values on a container
		# private: # Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires
		# public: # Used to set a container as public, available via the Cloud Files CDN
		# region: DFW
		# state: #present|absent
		# ttl: # In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public
		# type: #file|meta
		# web_error: # Sets an object to be presented as the HTTP error page when accessed by the CDN URL
		# web_index: # Sets an object to be presented as the HTTP index page when accessed by the CDN URL
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_queue "create / delete a queue in Rackspace Public Cloud" b
- name: $1
	rax_queue:
		# name: # Name to give the queue
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_clb_nodes "add, modify and remove nodes from a Rackspace Cloud Load Balancer" b
- name: $1
	rax_clb_nodes:
		load_balancer_id: ${2:# Load balancer id}
		# address: # IP address or domain name of the node
		# condition: enabled|disabled|draining
		# node_id: # Node id
		# port: # Port number of the load balanced service on the node
		# state: #present|absent
		# type: primary|secondary
		# wait: no
		# wait_timeout: 30
		# weight: # Weight of node
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_network "create / delete an isolated network in Rackspace Public Cloud" b
- name: $1
	rax_network:
		# state: #present|absent
		# label: # Label (name) to give the network
		# cidr: # cidr of the network being created
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_meta "Manipulate metadata for Rackspace Cloud Servers" b
- name: $1
	rax_meta:
		# address: # Server IP address to modify metadata for, will match any IP assigned to the server
		# id: # Server ID to modify metadata for
		# name: # Server name to modify metadata for
		# meta: # A hash of metadata to associate with the instance
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_scaling_policy "Manipulate Rackspace Cloud Autoscale Scaling Policy" b
- name: $1
	rax_scaling_policy:
		name: ${2:# Name to give the policy}
		policy_type: ${3:webhook|schedule}
		scaling_group: ${4:# Name of the scaling group that this policy will be added to}
		# at: # The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)
		# change: # The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.
		# cron: # The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)
		# cooldown: # The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
		# desired_capacity: # The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.
		# is_percent: no
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_clb "create / delete a load balancer in Rackspace Public Cloud" b
- name: $1
	rax_clb:
		# algorithm: RANDOM|#LEAST_CONNECTIONS|ROUND_ROBIN|WEIGHTED_LEAST_CONNECTIONS|WEIGHTED_ROUND_ROBIN
		# meta: # A hash of metadata to associate with the instance
		# name: # Name to give the load balancer
		# port: 80
		# protocol: DNS_TCP|DNS_UDP|FTP|#HTTP|HTTPS|IMAPS|IMAPv4|LDAP|LDAPS|MYSQL|POP3|POP3S|SMTP|TCP|TCP_CLIENT_FIRST|UDP|UDP_STREAM|SFTP
		# state: #present|absent
		# timeout: 30
		# type: #PUBLIC|SERVICENET
		# vip_id: # Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_mon_entity "Create or delete a Rackspace Cloud Monitoring entity" b
- name: $1
	rax_mon_entity:
		label: ${2:# Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.}
		# state: present|absent
		# agent_id: # Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.
		# named_ip_addresses: # Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.
		# metadata: # Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax "create / delete an instance in Rackspace Public Cloud" b
- name: $1
	rax:
		# auto_increment: yes
		# boot_from_volume: no
		# boot_volume: # Cloud Block Storage ID or Name to use as the boot volume of the instance
		# boot_volume_size: 100
		# boot_volume_terminate: no
		# config_drive: no
		# count: 1
		# count_offset: 1
		# disk_config: #auto|manual
		# exact_count: no
		# extra_client_args: # A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.
		# extra_create_args: # A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.
		# files: # Files to insert into the instance. remotefilename:localcontent
		# flavor: # flavor to use for the instance
		# group: # host group to assign to server, is also used for idempotent operations to ensure a specific number of instances
		# image: # image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image
		# instance_ids: # list of instance ids, currently only used when state='absent' to remove instances
		# key_name: # key pair to use on the instance
		# meta: # A hash of metadata to associate with the instance
		# name: # Name to give the instance
		# networks: ['public', 'private']
		# state: #present|absent
		# user_data: # Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_keypair "Create a keypair for use with Rackspace Cloud Servers" b
- name: $1
	rax_keypair:
		name: ${2:# Name of keypair}
		# public_key: # Public Key string to upload. Can be a file path or string
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_cdb_database "create / delete a database in the Cloud Databases" b
- name: $1
	rax_cdb_database:
		# cdb_id: # The databases server UUID
		# name: # Name to give to the database
		# character_set: utf8
		# collate: utf8_general_ci
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_dns "Manage domains on Rackspace Cloud DNS" b
- name: $1
	rax_dns:
		# comment: # Brief description of the domain. Maximum length of 160 characters
		# email: # Email address of the domain administrator
		# name: # Domain name to create
		# state: #present|absent
		# ttl: 3600
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_clb_ssl "Manage SSL termination for a Rackspace Cloud Load Balancer." b
- name: $1
	rax_clb_ssl:
		loadbalancer: ${2:# Name or ID of the load balancer on which to manage SSL termination.}
		# state: #present|absent
		# enabled: yes
		# private_key: # The private SSL key as a string in PEM format.
		# certificate: # The public SSL certificates as a string in PEM format.
		# intermediate_certificate: # One or more intermediate certificate authorities as a string in PEM
		# secure_port: 443
		# secure_traffic_only: no
		# https_redirect: # If "true", the load balancer will redirect HTTP traffic to HTTPS.
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_mon_check "Create or delete a Rackspace Cloud Monitoring check for an existing entity." b
- name: $1
	rax_mon_check:
		entity_id: ${2:# ID of the rax_mon_entity to target with this check.}
		label: ${3:# Defines a label for this check, between 1 and 64 characters long.}
		check_type: ${4:remote.dns|remote.ftp-banner|remote.http|remote.imap-banner|remote.mssql-banner|remote.mysql-banner|remote.ping|remote.pop3-banner|remote.postgresql-banner|remote.smtp-banner|remote.smtp|remote.ssh|remote.tcp|remote.telnet-banner|agent.filesystem|agent.memory|agent.load_average|agent.cpu|agent.disk|agent.network|agent.plugin}
		# state: present|absent
		# monitoring_zones_poll: # Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.
		# target_hostname: # One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.
		# target_alias: # One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.
		# details: # Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.
		# disabled: # If "yes", ensure the check is created, but don't actually use it yet.
		# metadata: # Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.
		# period: # The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.
		# timeout: # The number of seconds this check will wait when attempting to collect results. Must be less than the period.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_identity "Load Rackspace Cloud Identity" b
- name: $1
	rax_identity:
		# state: #present|absent
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_cdb "create/delete or resize a Rackspace Cloud Databases instance" b
- name: $1
	rax_cdb:
		# name: # Name of the databases server instance
		# flavor: 1
		# volume: 2
		# cdb_type: MySQL
		# cdb_version: 5.1|5.6|10
		# state: #present|absent
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_cbs_attachments "Manipulate Rackspace Cloud Block Storage Volume Attachments" b
- name: $1
	rax_cbs_attachments:
		volume: ${2:# Name or id of the volume to attach/detach}
		server: ${3:# Name or id of the server to attach/detach}
		state: ${4:#present|absent}
		# device: # The device path to attach the volume to, e.g. /dev/xvde.
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_mon_notification_plan "Create or delete a Rackspace Cloud Monitoring notification plan." b
- name: $1
	rax_mon_notification_plan:
		label: ${2:# Defines a friendly name for this notification plan. String between 1 and 255 characters long.}
		# state: present|absent
		# critical_state: # Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.
		# warning_state: # Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.
		# ok_state: # Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet rax_scaling_group "Manipulate Rackspace Cloud Autoscale Groups" b
- name: $1
	rax_scaling_group:
		flavor: ${2:# flavor to use for the instance}
		image: ${3:# image to use for the instance. Can be an C(id), C(human_id) or C(name)}
		max_entities: ${4:# The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		min_entities: ${5:# The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
		name: ${6:# Name to give the scaling group}
		server_name: ${7:# The base name for servers created by Autoscale}
		# config_drive: no
		# cooldown: # The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
		# disk_config: #auto|manual
		# files: # Files to insert into the instance. Hash of C(remotepath: localpath)
		# key_name: # key pair to use on the instance
		# loadbalancers: # List of load balancer C(id) and C(port) hashes
		# meta: # A hash of metadata to associate with the instance
		# networks: ['public', 'private']
		# state: #present|absent
		# user_data: # Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string
		# wait: no
		# wait_timeout: 300
		# api_key: # Rackspace API key, overrides I(credentials).
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# region: DFW
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# identity_type: rackspace
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
$0
endsnippet

snippet rax_mon_alarm "Create or delete a Rackspace Cloud Monitoring alarm." b
- name: $1
	rax_mon_alarm:
		label: ${2:# Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.}
		entity_id: ${3:# ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.}
		check_id: ${4:# ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.}
		notification_plan_id: ${5:# ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.}
		# state: #present|absent
		# criteria: # Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.
		# disabled: # If yes, create this alarm, but leave it in an inactive state. Defaults to no.
		# metadata: # Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.
		# api_key: # Rackspace API key, overrides I(credentials).
		# auth_endpoint: https://identity.api.rackspacecloud.com/v2.0/
		# credentials: # File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.
		# env: # Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).
		# identity_type: rackspace
		# region: DFW
		# tenant_id: # The tenant ID used for authentication.
		# tenant_name: # The tenant name used for authentication.
		# username: # Rackspace username, overrides I(credentials).
		# verify_ssl: # Whether or not to require SSL validation of API endpoints.
$0
endsnippet

snippet pubnub_blocks "PubNub blocks management module." b
- name: $1
	pubnub_blocks:
		application: ${2:# Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.}
		keyset: ${3:# Name of application's keys set which is bound to managed blocks.}
		name: ${4:# Name of managed block which will be later visible on admin.pubnub.com.}
		# email: # Email from account for which new session should be started.
		# password: # Password which match to account to which specified C(email) belong.
		# cache: {}
		# account: # Name of PubNub account for from which C(application) will be used to manage blocks.
		# state: #started|stopped|present|absent
		# description: New block
		# event_handlers: []
		# changes: {}
		# validate_certs: yes
$0
endsnippet

snippet gcp_compute_forwarding_rule_facts "Gather facts for GCP ForwardingRule" b
- name: $1
	gcp_compute_forwarding_rule_facts:
		region: ${2:# A reference to the region where the regional forwarding rule resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_backend_service "Creates a GCP BackendService" b
- name: $1
	gcp_compute_backend_service:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# affinity_cookie_ttl_sec: # Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value for TTL is one day.
		# backends: # The list of backends that serve this BackendService.
		# cdn_policy: # Cloud CDN configuration for this BackendService.
		# connection_draining: # Settings for connection draining.
		# description: # An optional description of this resource.
		# enable_cdn: # If true, enable Cloud CDN for this BackendService.
		# health_checks: # The list of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health checking this BackendService. Currently at most one health check can be specified, and a health check is required.
		# iap: # Settings for enabling Cloud Identity Aware Proxy.
		# load_balancing_scheme: INTERNAL|EXTERNAL
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# port_name: # Name of backend port. The same name should appear in the instance groups referenced by this service. Required when the load balancing scheme is EXTERNAL.
		# protocol: HTTP|HTTPS|TCP|SSL
		# region: # The region where the regional backend service resides.
		# session_affinity: NONE|CLIENT_IP|GENERATED_COOKIE|CLIENT_IP_PROTO|CLIENT_IP_PORT_PROTO
		# timeout_sec: # How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is [1, 86400].
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_sql_database "Creates a GCP Database" b
- name: $1
	gcp_sql_database:
		instance: ${2:# The name of the Cloud SQL instance. This does not include the project ID.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# charset: # The MySQL charset value.
		# collation: # The MySQL collation value.
		# name: # The name of the database in the Cloud SQL instance.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_target_proxy "Create, Update or Destroy a Target_Proxy." b
- name: $1
	gcp_target_proxy:
		target_proxy_name: ${2:# Name of the Target_Proxy.}
		target_proxy_type: ${3:# Type of Target_Proxy. HTTP, HTTPS or SSL. Only HTTP is currently supported.}
		# url_map_name: # Name of the Url Map.  Required if type is HTTP or HTTPS proxy.
$0
endsnippet

snippet gcp_compute_image_facts "Gather facts for GCP Image" b
- name: $1
	gcp_compute_image_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_ssl_certificate "Creates a GCP SslCertificate" b
- name: $1
	gcp_compute_ssl_certificate:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# certificate: # The certificate in PEM format.
		# description: # An optional description of this resource.
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# private_key: # The private key in PEM format.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_sql_user "Creates a GCP User" b
- name: $1
	gcp_sql_user:
		host: ${2:# The host name from which the user can connect. For insert operations, host defaults to an empty string. For update operations, host is specified as part of the request URL. The host name cannot be updated after insertion.}
		name: ${3:# The name of the user in the Cloud SQL instance.}
		instance: ${4:# The name of the Cloud SQL instance. This does not include the project ID.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# password: # The password for the user.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_global_forwarding_rule "Creates a GCP GlobalForwardingRule" b
- name: $1
	gcp_compute_global_forwarding_rule:
		name: ${2:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# ip_address: # The IP address that this forwarding rule is serving on behalf of.
		# ip_protocol: TCP|UDP|ESP|AH|SCTP|ICMP
		# backend_service: # A reference to a BackendService to receive the matched traffic.
		# ip_version: IPV4|IPV6
		# load_balancing_scheme: INTERNAL|EXTERNAL
		# network: # For internal load balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
		# port_range: # This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.
		# ports: # This field is used along with the backend_service field for internal load balancing.
		# subnetwork: # A reference to a subnetwork.
		# target: # This target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_mig "Create, Update or Destroy a Managed Instance Group (MIG)." b
- name: $1
	gce_mig:
		name: ${2:# Name of the Managed Instance Group.}
		zone: ${3:# The GCE zone to use for this Managed Instance Group.}
		# template: # Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.
		# size: # Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.
		# service_account_email: # service account email
		# credentials_file: # Path to the JSON file associated with the service account email
		# project_id: # GCE project ID
		# state: absent|#present
		# autoscaling: # A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.
		# named_ports: # Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.
$0
endsnippet

snippet gcp_compute_router_facts "Gather facts for GCP Router" b
- name: $1
	gcp_compute_router_facts:
		region: ${2:# Region where the router resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_container_node_pool "Creates a GCP NodePool" b
- name: $1
	gcp_container_node_pool:
		initial_node_count: ${2:# The initial node count for the pool. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota.}
		cluster: ${3:# The cluster this node pool belongs to.}
		zone: ${4:# The zone where the node pool is deployed.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # The name of the node pool.
		# config: # The node configuration of the pool.
		# autoscaling: # Autoscaler configuration for this NodePool. Autoscaler is enabled only if a valid configuration is present.
		# management: # Management configuration for this NodePool.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_tcp_proxy "Creates a GCP TargetTcpProxy" b
- name: $1
	gcp_compute_target_tcp_proxy:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		service: ${3:# A reference to the BackendService resource.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# proxy_header: NONE|PROXY_V1
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_instance_group_manager "Creates a GCP InstanceGroupManager" b
- name: $1
	gcp_compute_instance_group_manager:
		base_instance_name: ${2:# The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name.}
		instance_template: ${3:# The instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group.}
		name: ${4:# The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.}
		zone: ${5:# The zone the managed instance group resides.}
		auth_kind: ${6:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# named_ports: # Named ports configured for the Instance Groups complementary to this Instance Group Manager.
		# target_pools: # TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
		# target_size: # The target number of running instances for this managed instance group. Deleting or abandoning instances reduces this number. Resizing the group changes this number.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_global_address "Creates a GCP GlobalAddress" b
- name: $1
	gcp_compute_global_address:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# ip_version: IPV4|IPV6
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_ssl_proxy "Creates a GCP TargetSslProxy" b
- name: $1
	gcp_compute_target_ssl_proxy:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		service: ${3:# A reference to the BackendService resource.}
		ssl_certificates: ${4:# A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# proxy_header: NONE|PROXY_V1
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_ssl_certificate_facts "Gather facts for GCP SslCertificate" b
- name: $1
	gcp_compute_ssl_certificate_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_https_health_check "Creates a GCP HttpsHealthCheck" b
- name: $1
	gcp_compute_https_health_check:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# check_interval_sec: # How often (in seconds) to send a health check. The default value is 5 seconds.
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# healthy_threshold: # A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		# host: # The value of the host header in the HTTPS health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.
		# port: # The TCP port number for the HTTPS health check request.
		# request_path: # The request path of the HTTPS health check request.
		# timeout_sec: # How long (in seconds) to wait before claiming failure.
		# unhealthy_threshold: # A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_backend_service "Create or Destroy a Backend Service." b
- name: $1
	gcp_backend_service:
		backend_service_name: ${2:# Name of the Backend Service.}
		backends: ${3:# List of backends that make up the backend service. A backend is made up of an instance group and optionally several other parameters.  See U(https://cloud.google.com/compute/docs/reference/latest/backendServices) for details.}
		healthchecks: ${4:# List of healthchecks. Only one healthcheck is supported.}
		# enable_cdn: # If true, enable Cloud CDN for this Backend Service.
		# port_name: # Name of the port on the managed instance group (MIG) that backend services can forward data to. Required for external load balancing.
		# protocol: # The protocol this Backend Service uses to communicate with backends. Possible values are HTTP, HTTPS, TCP, and SSL. The default is HTTP.
		# timeout: # How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is 1-86400.
		# service_account_email: # Service account email
		# credentials_file: # Path to the JSON file associated with the service account email.
		# project_id: # GCE project ID.
		# state: absent|#present
$0
endsnippet

snippet gcp_compute_route "Creates a GCP Route" b
- name: $1
	gcp_compute_route:
		dest_range: ${2:# The destination range of outgoing packets that this route applies to.}
		name: ${3:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		network: ${4:# The network that this route applies to.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# priority: # The priority of this route. Priority is used to break ties in cases where there is more than one matching route of equal prefix length.
		# tags: # A list of instance tags to which this route applies.
		# next_hop_gateway: # URL to a gateway that should handle matching packets.
		# next_hop_instance: # URL to an instance that should handle matching packets.
		# next_hop_ip: # Network IP address of an instance that should handle matching packets.
		# next_hop_vpn_tunnel: # URL to a VpnTunnel that should handle matching packets.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_http_proxy "Creates a GCP TargetHttpProxy" b
- name: $1
	gcp_compute_target_http_proxy:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		url_map: ${3:# A reference to the UrlMap resource that defines the mapping from URL to the BackendService.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcdns_record "Creates or removes resource records in Google Cloud DNS" b
- name: $1
	gcdns_record:
		record: ${2:# The fully-qualified domain name of the resource record.}
		type: ${3:A|AAAA|CNAME|SRV|TXT|SOA|NS|MX|SPF|PTR}
		# state: #present|absent
		# zone: # The DNS domain name of the zone (e.g., example.com).
		# zone_id: # The Google Cloud ID of the zone (e.g., example-com).
		# record_data: # The record_data to use for the resource record.
		# ttl: 300
		# overwrite: no
		# service_account_email: # The e-mail address for a service account with access to Google Cloud DNS.
		# pem_file: # The path to the PEM file associated with the service account email.
		# credentials_file: # The path to the JSON file associated with the service account email.
		# project_id: # The Google Cloud Platform project ID to use.
$0
endsnippet

snippet gcp_compute_url_map_facts "Gather facts for GCP UrlMap" b
- name: $1
	gcp_compute_url_map_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_address "Creates a GCP Address" b
- name: $1
	gcp_compute_address:
		name: ${2:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		region: ${3:# URL of the region where the regional address resides.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# address: # The static external IP address represented by this resource. Only IPv4 is supported. An address may only be specified for INTERNAL address types. The IP address must be inside the specified subnetwork, if any.
		# address_type: INTERNAL|#EXTERNAL
		# description: # An optional description of this resource.
		# subnetwork: # The URL of the subnetwork in which to reserve the address. If an IP address is specified, it must be within the subnetwork's IP range.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_tcp_proxy_facts "Gather facts for GCP TargetTcpProxy" b
- name: $1
	gcp_compute_target_tcp_proxy_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_route_facts "Gather facts for GCP Route" b
- name: $1
	gcp_compute_route_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcdns_zone "Creates or removes zones in Google Cloud DNS" b
- name: $1
	gcdns_zone:
		zone: ${2:# The DNS domain name of the zone.}
		# state: #present|absent
		# description: 
		# service_account_email: # The e-mail address for a service account with access to Google Cloud DNS.
		# pem_file: # The path to the PEM file associated with the service account email.
		# credentials_file: # The path to the JSON file associated with the service account email.
		# project_id: # The Google Cloud Platform project ID to use.
$0
endsnippet

snippet gcp_compute_forwarding_rule "Creates a GCP ForwardingRule" b
- name: $1
	gcp_compute_forwarding_rule:
		name: ${2:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		region: ${3:# A reference to the region where the regional forwarding rule resides.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# ip_address: # The IP address that this forwarding rule is serving on behalf of.
		# ip_protocol: TCP|UDP|ESP|AH|SCTP|ICMP
		# backend_service: # A reference to a BackendService to receive the matched traffic.
		# ip_version: IPV4|IPV6
		# load_balancing_scheme: INTERNAL|EXTERNAL
		# network: # For internal load balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
		# port_range: # This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.
		# ports: # This field is used along with the backend_service field for internal load balancing.
		# subnetwork: # A reference to a subnetwork.
		# target: # A reference to a TargetPool resource to receive the matched traffic.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_instance "Creates a GCP Instance" b
- name: $1
	gcp_compute_instance:
		zone: ${2:# A reference to the zone where the machine resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# can_ip_forward: # Allows this instance to send and receive packets with non-matching destination or source IPs. This is required if you plan to use this instance to forward routes.
		# disks: # An array of disks that are associated with the instances that are created from this template.
		# guest_accelerators: # List of the type and count of accelerator cards attached to the instance .
		# label_fingerprint: # A fingerprint for this request, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata.
		# metadata: # The metadata key/value pairs to assign to instances that are created from this template. These pairs can consist of custom metadata or predefined keys.
		# machine_type: # A reference to a machine type which defines VM kind.
		# min_cpu_platform: # Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms .
		# name: # The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# network_interfaces: # An array of configurations for this interface. This specifies how this interface is configured to interact with other network services, such as connecting to the internet. Only one network interface is supported per instance.
		# scheduling: # Sets the scheduling options for this instance.
		# service_accounts: # A list of service accounts, with their specified scopes, authorized for this instance. Only one service account per VM instance is supported.
		# tags: # A list of tags to apply to this instance. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during instance creation. The tags can be later modified by the setTags method. Each tag within the list must comply with RFC1035.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_https_proxy "Creates a GCP TargetHttpsProxy" b
- name: $1
	gcp_compute_target_https_proxy:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		ssl_certificates: ${3:# A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.}
		url_map: ${4:# A reference to the UrlMap resource that defines the mapping from URL to the BackendService.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# quic_override: NONE|ENABLE|DISABLE
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_sql_instance "Creates a GCP Instance" b
- name: $1
	gcp_sql_instance:
		name: ${2:# Name of the Cloud SQL instance. This does not include the project ID.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# backend_type: FIRST_GEN|SECOND_GEN|EXTERNAL
		# connection_name: # Connection name of the Cloud SQL instance used in connection strings.
		# database_version: MYSQL_5_5|MYSQL_5_6|MYSQL_5_7|POSTGRES_9_6
		# failover_replica: # The name and status of the failover replica. This property is applicable only to Second Generation instances.
		# instance_type: CLOUD_SQL_INSTANCE|ON_PREMISES_INSTANCE|READ_REPLICA_INSTANCE
		# ipv6_address: # The IPv6 address assigned to the instance. This property is applicable only to First Generation instances.
		# master_instance_name: # The name of the instance which will act as master in the replication setup.
		# max_disk_size: # The maximum disk size of the instance in bytes.
		# region: # The geographical region. Defaults to us-central or us-central1 depending on the instance type (First Generation or Second Generation/PostgreSQL).
		# replica_configuration: # Configuration specific to failover replicas and read replicas.
		# settings: # The user settings.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_healthcheck "Create, Update or Destroy a Healthcheck." b
- name: $1
	gcp_healthcheck:
		healthcheck_name: ${2:# Name of the Healthcheck.}
		healthcheck_type: ${3:HTTP|HTTPS}
		host_header: ${4:}
		state: ${5:present|absent}
		# check_interval: 5
		# port: # The TCP port number for the health check request. The default value is 443 for HTTPS and 80 for HTTP.
		# request_path: /
		# timeout: 5
		# unhealthy_threshold: 2
		# healthy_threshold: 2
		# service_account_email: # service account email
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# credentials_file: # Path to the JSON file associated with the service account email
		# project_id: # Your GCP project ID
$0
endsnippet

snippet gcp_dns_resource_record_set "Creates a GCP ResourceRecordSet" b
- name: $1
	gcp_dns_resource_record_set:
		name: ${2:# For example, U(www.example.com.)}
		type: ${3:A|AAAA|CAA|CNAME|MX|NAPTR|NS|PTR|SOA|SPF|SRV|TXT}
		managed_zone: ${4:# Identifies the managed zone addressed by this request.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# ttl: # Number of seconds that this ResourceRecordSet can be cached by resolvers.
		# target: # As defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1) .
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_net "create/destroy GCE networks and firewall rules" b
- name: $1
	gce_net:
		# allowed: # the protocol:ports to allow (I(tcp:80) or I(tcp:80,443) or I(tcp:80-800;udp:1-25)) this parameter is mandatory when creating or updating a firewall rule
		# ipv4_range: # the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory
		# fwname: # name of the firewall rule
		# name: # name of the network
		# src_range: []
		# src_tags: []
		# target_tags: []
		# state: active|#present|absent|deleted
		# service_account_email: # service account email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use C(credentials_file).
		# credentials_file: # path to the JSON file associated with the service account email
		# project_id: # your GCE project ID
		# mode: #legacy|auto|custom
		# subnet_name: # name of subnet to create
		# subnet_region: # region of subnet to create
		# subnet_desc: # description of subnet to create
$0
endsnippet

snippet gcp_compute_global_address_facts "Gather facts for GCP GlobalAddress" b
- name: $1
	gcp_compute_global_address_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcpubsub "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub" b
- name: $1
	gcpubsub:
		topic: ${2:# GCP pubsub topic name.}
		# subscription: # Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields. See subfields name, push_endpoint and ack_deadline for more information.
		# name: # S
		# ack_deadline: # S
		# pull: # Subfield of subscription. Not required. If specified, messages will be retrieved from topic via the provided subscription name. max_messages (int; default None; max number of messages to pull), message_ack (bool; default False; acknowledge the message) and return_immediately (bool; default True, don't wait for messages to appear). If the messages are acknowledged, changed is set to True, otherwise, changed is False.
		# push_endpoint: # Subfield of subscription.  Not required.  If specified, message will be sent to an endpoint. See U(https://cloud.google.com/pubsub/docs/advanced#push_endpoints) for more information.
		# publish: # List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.
		# state: absent|#present
$0
endsnippet

snippet gcp_compute_instance_group_facts "Gather facts for GCP InstanceGroup" b
- name: $1
	gcp_compute_instance_group_facts:
		zone: ${2:# A reference to the zone where the instance group resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce "create or terminate GCE instances" b
- name: $1
	gce:
		zone: ${2:us-central1-a}
		# image: debian-8
		# image_family: # image family from which to select the image.  The most recent non-deprecated image in the family will be used.
		# external_projects: # A list of other projects (accessible with the provisioning credentials) to be searched for the image.
		# instance_names: # a comma-separated list of instance names to create or destroy
		# machine_type: n1-standard-1
		# metadata: # a hash/dictionary of custom data for the instance; '{"key":"value", ...}'
		# service_account_email: # service account email
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# credentials_file: # path to the JSON file associated with the service account email
		# project_id: # your GCE project ID
		# name: # either a name of a single instance or when used with 'num_instances', the base name of a cluster of nodes
		# num_instances: # can be used with 'name', specifies the number of nodes to provision using 'name' as a base name
		# network: default
		# subnetwork: # name of the subnetwork in which the instance should be created
		# persistent_boot_disk: no
		# disks: # a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).
		# state: active|#present|absent|deleted|started|stopped|terminated
		# tags: # a comma-separated list of tags to associate with the instance
		# ip_forward: no
		# external_ip: ephemeral
		# disk_auto_delete: yes
		# preemptible: no
		# disk_size: 10
$0
endsnippet

snippet gcp_compute_target_vpn_gateway_facts "Gather facts for GCP TargetVpnGateway" b
- name: $1
	gcp_compute_target_vpn_gateway_facts:
		region: ${2:# The region this gateway should sit in.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_router "Creates a GCP Router" b
- name: $1
	gcp_compute_router:
		name: ${2:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		network: ${3:# A reference to the network to which this router belongs.}
		region: ${4:# Region where the router resides.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# bgp: # BGP information specific to this router.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_instance_group "Creates a GCP InstanceGroup" b
- name: $1
	gcp_compute_instance_group:
		zone: ${2:# A reference to the zone where the instance group resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# name: # The name of the instance group.
		# named_ports: # Assigns a name to a port number.
		# network: # The network to which all instances in the instance group belong.
		# region: # The region where the instance group is located (for regional resources).
		# subnetwork: # The subnetwork to which all instances in the instance group belong.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_health_check_facts "Gather facts for GCP HealthCheck" b
- name: $1
	gcp_compute_health_check_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_storage_bucket "Creates a GCP Bucket" b
- name: $1
	gcp_storage_bucket:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# acl: # Access controls on the bucket.
		# cors: # The bucket's Cross-Origin Resource Sharing (CORS) configuration.
		# default_object_acl: # Default access controls to apply to new objects when no ACL is provided.
		# lifecycle: # The bucket's lifecycle configuration.
		# location: # The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Defaults to US. See the developer's guide for the authoritative list.
		# logging: # The bucket's logging configuration, which defines the destination bucket and optional name prefix for the current bucket's logs.
		# metageneration: # The metadata generation of this bucket.
		# name: # The name of the bucket.
		# owner: # The owner of the bucket. This is always the project team's owner group.
		# storage_class: MULTI_REGIONAL|REGIONAL|STANDARD|NEARLINE|COLDLINE|DURABLE_REDUCED_AVAILABILITY
		# versioning: # The bucket's versioning configuration.
		# website: # The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.
		# project: # A valid API project identifier.
		# predefined_default_object_acl: authenticatedRead|bucketOwnerFullControl|bucketOwnerRead|private|projectPrivate|publicRead
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_backend_bucket_facts "Gather facts for GCP BackendBucket" b
- name: $1
	gcp_compute_backend_bucket_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_firewall "Creates a GCP Firewall" b
- name: $1
	gcp_compute_firewall:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# allowed: # The list of ALLOW rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a permitted connection.
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# network: # URL of the network resource for this firewall rule. If not specified when creating a firewall rule, the default network is used: global/networks/default If you choose to specify this property, you can specify the network as a full or partial URL. For example, the following are all valid URLs: U(https://www.googleapis.com/compute/v1/projects/myproject/global/) networks/my-network projects/myproject/global/networks/my-network global/networks/default .
		# source_ranges: # If source ranges are specified, the firewall will apply only to traffic that has source IP address in these ranges. These ranges must be expressed in CIDR format. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply. Only IPv4 is supported.
		# source_tags: # If source tags are specified, the firewall will apply only to traffic with source IP that belongs to a tag listed in source tags. Source tags cannot be used to control traffic to an instance's external IP address. Because tags are associated with an instance, not an IP address. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply.
		# target_tags: # A list of instance tags indicating sets of instances located in the network that may make network connections as specified in allowed[].
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcspanner "Create and Delete Instances/Databases on Spanner" b
- name: $1
	gcspanner:
		configuration: ${2:# Configuration the instance should use.}
		instance_id: ${3:# GCP spanner instance name.}
		# database_name: # Name of database contained on the instance.
		# force_instance_delete: no
		# instance_display_name: # Name of Instance to display.
		# node_count: 1
		# state: absent|#present
$0
endsnippet

snippet gcp_compute_instance_group_manager_facts "Gather facts for GCP InstanceGroupManager" b
- name: $1
	gcp_compute_instance_group_manager_facts:
		zone: ${2:# The zone the managed instance group resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_pool "Creates a GCP TargetPool" b
- name: $1
	gcp_compute_target_pool:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		region: ${3:# The region where the target pool resides.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# backup_pool: # This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool, and its failoverRatio field is properly set to a value between [0, 1].
		# description: # An optional description of this resource.
		# failover_ratio: # This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool (i.e., not as a backup pool to some other target pool). The value of the field must be in [0, 1].
		# health_check: # A reference to a HttpHealthCheck resource.
		# instances: # A list of virtual machine instances serving this pool.
		# session_affinity: NONE|CLIENT_IP|CLIENT_IP_PROTO
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_global_forwarding_rule_facts "Gather facts for GCP GlobalForwardingRule" b
- name: $1
	gcp_compute_global_forwarding_rule_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_forwarding_rule "Create, Update or Destroy a Forwarding_Rule." b
- name: $1
	gcp_forwarding_rule:
		forwarding_rule_name: ${2:# Name of the Forwarding_Rule.}
		state: ${3:present|absent}
		# address: # IPv4 or named IP address. Must be of the same scope (regional, global). Reserved addresses can (and probably should) be used for global forwarding rules. You may reserve IPs from the console or via the gce_eip module.
		# port_range: # For global forwarding rules, must be set to 80 or 8080 for TargetHttpProxy, and 443 for TargetHttpsProxy or TargetSslProxy.
		# protocol: # For global forwarding rules, TCP, UDP, ESP, AH, SCTP or ICMP. Default is TCP.
		# region: # The region for this forwarding rule. Currently, only 'global' is supported.
		# target: # Target resource for forwarding rule. For global proxy, this is a Global TargetProxy resource. Required for external load balancing (including Global load balancing)
$0
endsnippet

snippet gcp_compute_backend_service_facts "Gather facts for GCP BackendService" b
- name: $1
	gcp_compute_backend_service_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_image "Creates a GCP Image" b
- name: $1
	gcp_compute_image:
		name: ${2:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# disk_size_gb: # Size of the image when restored onto a persistent disk (in GB).
		# family: # The name of the image family to which this image belongs. You can create disks by specifying an image family instead of a specific image name. The image family always returns its latest image that is not deprecated. The name of the image family must comply with RFC1035.
		# guest_os_features: # A list of features to enable on the guest OS. Applicable for bootable images only. Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which allows each virtual CPU to have its own queue. For Windows images, you can only enable VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher. Linux images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.
		# image_encryption_key: # Encrypts the image using a customer-supplied encryption key.
		# licenses: # Any applicable license URI.
		# raw_disk: # The parameters of the raw disk image.
		# source_disk: # Refers to a gcompute_disk object You must provide either this property or the rawDisk.source property but not both to create an image.
		# source_disk_encryption_key: # The customer-supplied encryption key of the source disk. Required if the source disk is protected by a customer-supplied encryption key.
		# source_disk_id: # The ID value of the disk used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given disk name.
		# source_type: RAW
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_img "utilize GCE image resources" b
- name: $1
	gce_img:
		name: ${2:# the name of the image to create or delete}
		# description: # an optional description
		# family: # an optional family name
		# source: # the source disk or the Google Cloud Storage URI to create the image from
		# state: #present|absent
		# zone: us-central1-a
		# timeout: 180
		# service_account_email: # service account email
		# pem_file: # path to the pem file associated with the service account email
		# project_id: # your GCE project ID
$0
endsnippet

snippet gcp_compute_instance_template "Creates a GCP InstanceTemplate" b
- name: $1
	gcp_compute_instance_template:
		name: ${2:# Name of the resource. The name is 1-63 characters long and complies with RFC1035.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# properties: # The instance properties for this instance template.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_url_map "Create, Update or Destory a Url_Map." b
- name: $1
	gcp_url_map:
		url_map_name: ${2:# Name of the Url_Map.}
		default_service: ${3:# Default Backend Service if no host rules match.}
		# host_rules: # The list of HostRules to use against the URL. Contains a list of hosts and an associated path_matcher.
		# path_matchers: # The list of named PathMatchers to use against the URL. Contains path_rules, which is a list of paths and an associated service. A default_service can also be specified for each path_matcher.
$0
endsnippet

snippet gce_lb "create/destroy GCE load-balancer resources" b
- name: $1
	gce_lb:
		# httphealthcheck_name: # the name identifier for the HTTP health check
		# httphealthcheck_port: 80
		# httphealthcheck_path: /
		# httphealthcheck_interval: 5
		# httphealthcheck_timeout: 5
		# httphealthcheck_unhealthy_count: 2
		# httphealthcheck_healthy_count: 2
		# httphealthcheck_host: # host header to pass through on HTTP check requests
		# name: # name of the load-balancer resource
		# protocol: #tcp|udp
		# region: # the GCE region where the load-balancer is defined
		# external_ip: # the external static IPv4 (or auto-assigned) address for the LB
		# port_range: # the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports
		# members: # a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]
		# state: active|#present|absent|deleted
		# service_account_email: # service account email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# credentials_file: # path to the JSON file associated with the service account email
		# project_id: # your GCE project ID
$0
endsnippet

snippet gc_storage "This module manages objects/buckets in Google Cloud Storage." b
- name: $1
	gc_storage:
		bucket: ${2:# Bucket name.}
		mode: ${3:get|put|get_url|get_str|delete|create}
		gs_secret_key: ${4:# GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used.}
		gs_access_key: ${5:# GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.}
		# object: # Keyname of the object inside the bucket. Can be also be used to create "virtual directories" (see examples).
		# src: # The source file path when performing a PUT operation.
		# dest: # The destination file path when downloading an object/key with a GET operation.
		# force: yes
		# permission: private
		# headers: {}
		# expiration: # Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.
		# region: US
		# versioning: # Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)
$0
endsnippet

snippet gce_pd "utilize GCE persistent disk resources" b
- name: $1
	gce_pd:
		name: ${2:# name of the disk}
		# detach_only: no
		# instance_name: # instance name if you wish to attach or detach the disk
		# mode: READ_WRITE|#READ_ONLY
		# size_gb: 10
		# image: # the source image to use for the disk
		# snapshot: # the source snapshot to use for the disk
		# state: active|#present|absent|deleted
		# zone: us-central1-b
		# service_account_email: # service account email
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# credentials_file: # path to the JSON file associated with the service account email
		# project_id: # your GCE project ID
		# disk_type: #pd-standard|pd-ssd
		# delete_on_termination: no
$0
endsnippet

snippet gcp_compute_vpn_tunnel "Creates a GCP VpnTunnel" b
- name: $1
	gcp_compute_vpn_tunnel:
		name: ${2:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		target_vpn_gateway: ${3:# URL of the Target VPN gateway with which this VPN tunnel is associated.}
		peer_ip: ${4:# IP address of the peer VPN gateway. Only IPv4 is supported.}
		shared_secret: ${5:# Shared secret used to set the secure session between the Cloud VPN gateway and the peer VPN gateway.}
		region: ${6:# The region where the tunnel is located.}
		auth_kind: ${7:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# router: # URL of router resource to be used for dynamic routing.
		# ike_version: 2
		# local_traffic_selector: # Local traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.
		# remote_traffic_selector: # Remote traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.
		# labels: # Labels to apply to this VpnTunnel.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_labels "Create, Update or Destroy GCE Labels." b
- name: $1
	gce_labels:
		# labels: # A list of labels (key/value pairs) to add or remove for the resource.
		# resource_url: # The 'self_link' for the resource (instance, disk, snapshot, etc)
		# resource_type: # The type of resource (instances, disks, snapshots, images)
		# resource_location: # The location of resource (global, us-central1-f, etc.)
		# resource_name: # The name of resource.
$0
endsnippet

snippet gcp_compute_subnetwork_facts "Gather facts for GCP Subnetwork" b
- name: $1
	gcp_compute_subnetwork_facts:
		region: ${2:# URL of the GCP region for this subnetwork.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcpubsub_facts "List Topics/Subscriptions and Messages from Google PubSub." b
- name: $1
	gcpubsub_facts:
		view: ${2:# Choices are 'topics' or 'subscriptions'}
		# topic: # GCP pubsub topic name.  Only the name, not the full path, is required.
		# state: # list is the only valid option.
$0
endsnippet

snippet gcp_spanner_instance "Creates a GCP Instance" b
- name: $1
	gcp_spanner_instance:
		display_name: ${2:# The descriptive name for this instance as it appears in UIs. Must be unique per project and between 4 and 30 characters in length.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # A unique identifier for the instance, which cannot be changed after the instance is created. Values are of the form projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]. The final segment of the name must be between 6 and 30 characters in length.
		# config: # A reference to the instance configuration.
		# node_count: # The number of nodes allocated to this instance.
		# labels: # Cloud Labels are a flexible and lightweight mechanism for organizing cloud resources into groups that reflect a customer's organizational needs and deployment strategies. Cloud Labels can be used to filter collections of resources. They can be used to control how resource metrics are aggregated. And they can be used as arguments to policy management rules (e.g. route, firewall, load balancing, etc.).
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_backend_bucket "Creates a GCP BackendBucket" b
- name: $1
	gcp_compute_backend_bucket:
		bucket_name: ${2:# Cloud Storage bucket name.}
		name: ${3:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional textual description of the resource; provided by the client when the resource is created.
		# enable_cdn: # If true, enable Cloud CDN for this BackendBucket.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_ssl_proxy_facts "Gather facts for GCP TargetSslProxy" b
- name: $1
	gcp_compute_target_ssl_proxy_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_health_check "Creates a GCP HealthCheck" b
- name: $1
	gcp_compute_health_check:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# check_interval_sec: 5
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# healthy_threshold: # A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# timeout_sec: 5
		# unhealthy_threshold: 2
		# type: TCP|SSL|HTTP
		# http_health_check: # A nested object resource.
		# https_health_check: # A nested object resource.
		# tcp_health_check: # A nested object resource.
		# ssl_health_check: # A nested object resource.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_snapshot "Create or destroy snapshots for GCE storage volumes" b
- name: $1
	gce_snapshot:
		instance_name: ${2:# The GCE instance to snapshot}
		service_account_email: ${3:# GCP service account email for the project where the instance resides}
		credentials_file: ${4:# The path to the credentials file associated with the service account}
		project_id: ${5:# The GCP project ID to use}
		# snapshot_name: # The name of the snapshot to manage
		# disks: all
		# state: #present|absent
$0
endsnippet

snippet gcp_compute_target_https_proxy_facts "Gather facts for GCP TargetHttpsProxy" b
- name: $1
	gcp_compute_target_https_proxy_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_instance_template "create or destroy instance templates of Compute Engine of GCP." b
- name: $1
	gce_instance_template:
		# state: #present|absent
		# name: # The name of the GCE instance template.
		# size: f1-micro
		# source: # A source disk to attach to the instance. Cannot specify both I(image) and I(source).
		# image: # The image to use to create the instance. Cannot specify both both I(image) and I(source).
		# image_family: # The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source).
		# disk_type: pd-standard
		# disk_auto_delete: yes
		# network: default
		# subnetwork: # The Subnetwork resource name for this instance.
		# can_ip_forward: no
		# external_ip: ephemeral
		# service_account_email: # service account email
		# service_account_permissions: bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email
		# automatic_restart: # Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.
		# preemptible: # Defines whether the instance is preemptible.
		# tags: # a comma-separated list of tags to associate with the instance
		# metadata: # a hash/dictionary of custom data for the instance; '{"key":"value", ...}'
		# description: # description of instance template
		# disks: # a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).
		# nic_gce_struct: # Support passing in the GCE-specific formatted networkInterfaces[] structure.
		# disks_gce_struct: # Support passing in the GCE-specific formatted formatted disks[] structure. Case sensitive. see U(https://cloud.google.com/compute/docs/reference/latest/instanceTemplates#resource) for detailed information
		# project_id: # your GCE project ID
		# pem_file: # path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
		# credentials_file: # path to the JSON file associated with the service account email
		# subnetwork_region: # Region that subnetwork resides in. (Required for subnetwork to successfully complete)
$0
endsnippet

snippet gcp_compute_target_http_proxy_facts "Gather facts for GCP TargetHttpProxy" b
- name: $1
	gcp_compute_target_http_proxy_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_vpn_tunnel_facts "Gather facts for GCP VpnTunnel" b
- name: $1
	gcp_compute_vpn_tunnel_facts:
		region: ${2:# The region where the tunnel is located.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_url_map "Creates a GCP UrlMap" b
- name: $1
	gcp_compute_url_map:
		default_service: ${2:# A reference to BackendService resource if none of the hostRules match.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# host_rules: # The list of HostRules to use against the URL.
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# path_matchers: # The list of named PathMatchers to use against the URL.
		# tests: # The list of expected URL mappings. Request to update this UrlMap will succeed only if all of the test cases pass.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_eip "Create or Destroy Global or Regional External IP addresses." b
- name: $1
	gce_eip:
		name: ${2:# Name of Address.}
		region: ${3:# Region to create the address in. Set to 'global' to create a global address.}
		# state: #present|absent
$0
endsnippet

snippet gcp_compute_target_vpn_gateway "Creates a GCP TargetVpnGateway" b
- name: $1
	gcp_compute_target_vpn_gateway:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		network: ${3:# The network this VPN gateway is accepting traffic for.}
		region: ${4:# The region this gateway should sit in.}
		auth_kind: ${5:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_instance_facts "Gather facts for GCP Instance" b
- name: $1
	gcp_compute_instance_facts:
		zone: ${2:# A reference to the zone where the machine resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_instance_template_facts "Gather facts for GCP InstanceTemplate" b
- name: $1
	gcp_compute_instance_template_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_address_facts "Gather facts for GCP Address" b
- name: $1
	gcp_compute_address_facts:
		region: ${2:# URL of the region where the regional address resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_https_health_check_facts "Gather facts for GCP HttpsHealthCheck" b
- name: $1
	gcp_compute_https_health_check_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_container_cluster "Creates a GCP Cluster" b
- name: $1
	gcp_container_cluster:
		initial_node_count: ${2:# The number of nodes to create in this cluster. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota. For requests, this field should only be used in lieu of a "nodePool" object, since this configuration (along with the "nodeConfig") will be used to create a "NodePool" object with an auto-generated name. Do not use this and a nodePool at the same time.}
		zone: ${3:# The zone where the cluster is deployed.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # The name of this cluster. The name must be unique within this project and zone, and can be up to 40 characters. Must be Lowercase letters, numbers, and hyphens only. Must start with a letter. Must end with a number or a letter.
		# description: # An optional description of this cluster.
		# node_config: # Parameters used in creating the cluster's nodes.
		# master_auth: # The authentication information for accessing the master endpoint.
		# logging_service: logging.googleapis.com|none
		# monitoring_service: monitoring.googleapis.com|none
		# network: # The name of the Google Compute Engine network to which the cluster is connected. If left unspecified, the default network will be used.
		# cluster_ipv4_cidr: # The IP address range of the container pods in this cluster, in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8.
		# addons_config: # Configurations for the various addons available to run in the cluster.
		# subnetwork: # The name of the Google Compute Engine subnetwork to which the cluster is connected.
		# location: # The list of Google Compute Engine locations in which the cluster's nodes should be located.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_storage_bucket_access_control "Creates a GCP BucketAccessControl" b
- name: $1
	gcp_storage_bucket_access_control:
		bucket: ${2:# The name of the bucket.}
		entity: ${3:# The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# entity_id: # The ID for the entity.
		# project_team: # The project team associated with the entity.
		# role: OWNER|READER|WRITER
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_ssl_policy "Creates a GCP SslPolicy" b
- name: $1
	gcp_compute_ssl_policy:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource.
		# profile: COMPATIBLE|MODERN|RESTRICTED|CUSTOM
		# min_tls_version: TLS_1_0|TLS_1_1|TLS_1_2
		# custom_features: # A list of features enabled when the selected profile is CUSTOM. The method returns the set of features that can be specified in this list. This field must be empty if the profile is not CUSTOM.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_disk_facts "Gather facts for GCP Disk" b
- name: $1
	gcp_compute_disk_facts:
		zone: ${2:# A reference to the zone where the disk resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_http_health_check "Creates a GCP HttpHealthCheck" b
- name: $1
	gcp_compute_http_health_check:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# check_interval_sec: 5
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# healthy_threshold: # A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		# host: # The value of the host header in the HTTP health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.
		# port: # The TCP port number for the HTTP health check request.
		# request_path: # The request path of the HTTP health check request.
		# timeout_sec: # How long (in seconds) to wait before claiming failure.
		# unhealthy_threshold: # A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_disk "Creates a GCP Disk" b
- name: $1
	gcp_compute_disk:
		name: ${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		zone: ${3:# A reference to the zone where the disk resides.}
		auth_kind: ${4:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# labels: # Labels to apply to this disk.  A list of key->value pairs.
		# licenses: # Any applicable publicly visible licenses.
		# size_gb: # Size of the persistent disk, specified in GB. You can specify this field when creating a persistent disk using the sourceImage or sourceSnapshot parameter, or specify it alone to create an empty persistent disk.
		# type: # URL of the disk type resource describing which disk type to use to create the disk. Provide this when creating the disk.
		# source_image: # The source image used to create this disk. If the source image is deleted, this field will not be set.
		# source_image_encryption_key: # The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key.
		# disk_encryption_key: # Encrypts the disk using a customer-supplied encryption key.
		# source_snapshot: # The source snapshot used to create this disk. You can provide this as a partial or full URL to the resource. For example, the following are valid values: * `U(https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot`) * `projects/project/global/snapshots/snapshot` * `global/snapshots/snapshot` .
		# source_snapshot_encryption_key: # The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_dns_managed_zone "Creates a GCP ManagedZone" b
- name: $1
	gcp_dns_managed_zone:
		name: ${2:# User assigned name for this resource.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.
		# dns_name: # The DNS name of this managed zone, for instance "example.com.".
		# name_server_set: # Optionally specifies the NameServerSet for this ManagedZone. A NameServerSet is a set of DNS name servers that all host the same ManagedZones. Most users will leave this field unset.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_subnetwork "Creates a GCP Subnetwork" b
- name: $1
	gcp_compute_subnetwork:
		ip_cidr_range: ${2:# The range of internal addresses that are owned by this subnetwork.}
		name: ${3:# The name of the resource, provided by the client when initially creating the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
		network: ${4:# The network this subnet belongs to.}
		region: ${5:# URL of the GCP region for this subnetwork.}
		auth_kind: ${6:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource. This field can be set only at resource creation time.
		# private_ip_google_access: # Whether the VMs in this subnet can access Google services without assigned external IP addresses.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_target_pool_facts "Gather facts for GCP TargetPool" b
- name: $1
	gcp_compute_target_pool_facts:
		region: ${2:# The region where the target pool resides.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_ssl_policy_facts "Gather facts for GCP SslPolicy" b
- name: $1
	gcp_compute_ssl_policy_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_network_facts "Gather facts for GCP Network" b
- name: $1
	gcp_compute_network_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gce_tag "add or remove tag(s) to/from GCE instances" b
- name: $1
	gce_tag:
		tags: ${2:# Comma-separated list of tags to add or remove.}
		# instance_name: # The name of the GCE instance to add/remove tags.
		# instance_pattern: # The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details.
		# state: absent|#present
		# zone: us-central1-a
		# service_account_email: # Service account email.
		# pem_file: # Path to the PEM file associated with the service account email.
		# project_id: # Your GCE project ID.
$0
endsnippet

snippet gcp_pubsub_subscription "Creates a GCP Subscription" b
- name: $1
	gcp_pubsub_subscription:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # Name of the subscription.
		# topic: # A reference to a Topic resource.
		# push_config: # If push delivery is used with this subscription, this field is used to configure it. An empty pushConfig signifies that the subscriber will pull and ack messages using API methods.
		# ack_deadline_seconds: # This value is the maximum time after a subscriber receives a message before the subscriber should acknowledge the message. After message delivery but before the ack deadline expires and before the message is acknowledged, it is an outstanding message and will not be delivered again during that time (on a best-effort basis).
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_firewall_facts "Gather facts for GCP Firewall" b
- name: $1
	gcp_compute_firewall_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_spanner_database "Creates a GCP Database" b
- name: $1
	gcp_spanner_database:
		instance: ${2:# The instance to create the database on.}
		auth_kind: ${3:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # A unique identifier for the database, which cannot be changed after the instance is created. Values are of the form projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]. The final segment of the name must be between 6 and 30 characters in length.
		# extra_statements: # An optional list of DDL statements to run inside the newly created database. Statements can create tables, indexes, etc. These statements execute atomically with the creation of the database: if there is an error in any statement, the database is not created.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_http_health_check_facts "Gather facts for GCP HttpHealthCheck" b
- name: $1
	gcp_compute_http_health_check_facts:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# filters: # A
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_compute_network "Creates a GCP Network" b
- name: $1
	gcp_compute_network:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# description: # An optional description of this resource. Provide this property when you create the resource.
		# gateway_ipv4: # A gateway address for default routing to other networks. This value is read only and is selected by the Google Compute Engine, typically as the first usable address in the IPv4Range.
		# ipv4_range: # The range of internal addresses that are legal on this network. This range is a CIDR specification, for example: 192.168.0.0/16. Provided by the client when the network is created.
		# name: # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		# auto_create_subnetworks: # When set to true, the network is created in "auto subnet mode". When set to false, the network is in "custom subnet mode".
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet gcp_pubsub_topic "Creates a GCP Topic" b
- name: $1
	gcp_pubsub_topic:
		auth_kind: ${2:machineaccount|serviceaccount|application}
		# state: #present|absent
		# name: # Name of the topic.
		# project: # The Google Cloud Platform project to use.
		# service_account_file: # The path of a Service Account JSON file if serviceaccount is selected as type.
		# service_account_email: # An optional service account email address if machineaccount is selected and the user does not wish to use the default email.
		# scopes: # Array of scopes to be used.
$0
endsnippet

snippet cs_resourcelimit "Manages resource limits on Apache CloudStack based clouds." b
- name: $1
	cs_resourcelimit:
		resource_type: ${2:instance|ip_address|volume|snapshot|template|network|vpc|cpu|memory|primary_storage|secondary_storage}
		# limit: -1
		# domain: # Domain the resource is related to.
		# account: # Account the resource is related to.
		# project: # Name of the project the resource is related to.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_instance_nic_secondaryip "Manages secondary IPs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic_secondaryip:
		vm: ${2:# Name of instance.}
		# network: # Name of the network.
		# vm_guest_ip: # Secondary IP address to be added to the instance nic.
		# vpc: # Name of the VPC the C(vm) is related to.
		# domain: # Domain the instance is related to.
		# account: # Account the instance is related to.
		# project: # Name of the project the instance is deployed in.
		# zone: # Name of the zone in which the instance is deployed in.
		# state: #present|absent
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_iso "Manages ISO images on Apache CloudStack based clouds." b
- name: $1
	cs_iso:
		name: ${2:# Name of the ISO.}
		# display_text: # Display text of the ISO.
		# url: # URL where the ISO can be downloaded from. Required if C(state) is present.
		# os_type: # Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present.
		# is_ready: no
		# is_public: # Register the ISO to be publicly available to all users. Only used if C(state) is present.
		# is_featured: # Register the ISO to be featured. Only used if C(state) is present.
		# is_dynamically_scalable: # Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if C(state) is present.
		# checksum: # The MD5 checksum value of this ISO. If set, we search by checksum instead of name.
		# bootable: # Register the ISO to be bootable. Only used if C(state) is present.
		# domain: # Domain the ISO is related to.
		# account: # Account the ISO is related to.
		# project: # Name of the project the ISO to be registered in.
		# zone: # Name of the zone you wish the ISO to be registered or deleted from.
		# cross_zones: no
		# iso_filter: featured|#self|selfexecutable|sharedexecutable|executable|community
		# state: #present|absent
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vpc_offering "Manages vpc offerings on Apache CloudStack based clouds." b
- name: $1
	cs_vpc_offering:
		name: ${2:# The name of the vpc offering}
		# state: enabled|#present|disabled|absent
		# display_text: # Display text of the vpc offerings
		# service_capabilities: # Desired service capabilities as part of vpc offering.
		# service_offering: # The name or ID of the service offering for the VPC router appliance.
		# supported_services: # Services supported by the vpc offering
		# service_providers: # provider to service mapping. If not specified, the provider for the service will be mapped to the default provider on the physical network
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_region "Manages regions on Apache CloudStack based clouds." b
- name: $1
	cs_region:
		id: ${2:# ID of the region.}
		# name: # Name of the region.
		# endpoint: # Endpoint URL of the region.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_zone "Manages zones on Apache CloudStack based clouds." b
- name: $1
	cs_zone:
		name: ${2:# Name of the zone.}
		# id: # uuid of the existing zone.
		# state: #present|enabled|disabled|absent
		# domain: # Domain the zone is related to.
		# network_domain: # Network domain for the zone.
		# network_type: #basic|advanced
		# dns1: # First DNS for the zone.
		# dns2: # Second DNS for the zone.
		# internal_dns1: # First internal DNS for the zone.
		# internal_dns2: # Second internal DNS for the zone.
		# dns1_ipv6: # First DNS for IPv6 for the zone.
		# dns2_ipv6: # Second DNS for IPv6 for the zone.
		# guest_cidr_address: # Guest CIDR address for the zone.
		# dhcp_provider: # DHCP provider for the Zone.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_network_acl_rule "Manages network access control list (ACL) rules on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl_rule:
		network_acl: ${2:# Name of the network ACL.}
		rule_position: ${3:# CIDR of the rule.}
		vpc: ${4:# VPC the network ACL is related to.}
		# cidr: 0.0.0.0/0
		# protocol: #tcp|udp|icmp|all|by_number
		# protocol_number: # Protocol number from 1 to 256 required if C(protocol=by_number).
		# start_port: # Start port for this rule.
		# end_port: # End port for this rule.
		# icmp_type: # Type of the icmp message being sent.
		# icmp_code: # Error code for this icmp message.
		# traffic_type: #ingress|egress
		# action_policy: allow|deny
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# domain: # Domain the VPC is related to.
		# account: # Account the VPC is related to.
		# project: # Name of the project the VPC is related to.
		# zone: # Name of the zone the VPC related to.
		# state: #present|absent
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_securitygroup_rule "Manages security group rules on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup_rule:
		security_group: ${2:# Name of the security group the rule is related to. The security group must be existing.}
		# state: #present|absent
		# protocol: #tcp|udp|icmp|ah|esp|gre
		# type: #ingress|egress
		# cidr: 0.0.0.0/0
		# user_security_group: # Security group this rule is based of.
		# start_port: # Start port for this rule. Required if C(protocol=tcp) or C(protocol=udp).
		# end_port: # End port for this rule. Required if C(protocol=tcp) or C(protocol=udp), but C(start_port) will be used if not set.
		# icmp_type: # Type of the icmp message being sent. Required if C(protocol=icmp).
		# icmp_code: # Error code for this icmp message. Required if C(protocol=icmp).
		# project: # Name of the project the security group to be created in.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_instance_facts "Gathering facts from the API of instances from Apache CloudStack based clouds." b
- name: $1
	cs_instance_facts:
		name: ${2:# Name or display name of the instance.}
		# domain: # Domain the instance is related to.
		# account: # Account the instance is related to.
		# project: # Project the instance is related to.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_zone_facts "Gathering facts of zones from Apache CloudStack based clouds." b
- name: $1
	cs_zone_facts:
		name: ${2:# Name of the zone.}
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_loadbalancer_rule_member "Manages load balancer rule members on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule_member:
		name: ${2:# The name of the load balancer rule.}
		vms: ${3:# List of VMs to assign to or remove from the rule.}
		# ip_address: # Public IP address from where the network traffic will be load balanced from.
		# state: #present|absent
		# project: # Name of the project the firewall rule is related to.
		# domain: # Domain the rule is related to.
		# account: # Account the rule is related to.
		# zone: # Name of the zone in which the rule should be located.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_template "Manages templates on Apache CloudStack based clouds." b
- name: $1
	cs_template:
		name: ${2:# Name of the template.}
		# url: # URL of where the template is hosted on I(state=present).
		# vm: # VM name the template will be created from its volume or alternatively from a snapshot.
		# snapshot: # Name of the snapshot, created from the VM ROOT volume, the template will be created from.
		# os_type: # OS type that best represents the OS of this template.
		# checksum: # The MD5 checksum value of this template.
		# is_ready: # Note: this flag was not implemented and therefore marked as deprecated.
		# is_public: # Register the template to be publicly available to all users.
		# is_featured: # Register the template to be featured.
		# is_dynamically_scalable: # Register the template having XS/VMWare tools installed in order to support dynamic scaling of VM CPU/memory.
		# cross_zones: no
		# mode: #http_download|ftp_upload
		# domain: # Domain the template, snapshot or VM is related to.
		# account: # Account the template, snapshot or VM is related to.
		# project: # Name of the project the template to be registered in.
		# zone: # Name of the zone you wish the template to be registered or deleted from.
		# template_filter: all|featured|#self|selfexecutable|sharedexecutable|executable|community
		# template_find_options: ['display_text', 'checksum', 'cross_zones'
		# hypervisor: KVM|kvm|VMware|vmware|BareMetal|baremetal|XenServer|xenserver|LXC|lxc|HyperV|hyperv|UCS|ucs|OVM|ovm|Simulator|simulator
		# requires_hvm: # Whether the template requires HVM or not.
		# password_enabled: # Enable template password reset support.
		# template_tag: # The tag for this template.
		# sshkey_enabled: # True if the template supports the sshkey upload feature.
		# is_routing: # Sets the template type to routing, i.e. if template is used to deploy routers.
		# format: QCOW2|RAW|VHD|OVA
		# is_extractable: # Allows the template or its derivatives to be extractable.
		# details: # Template details in key/value pairs.
		# bits: 32|#64
		# display_text: # Display text of the template.
		# state: #present|absent|extracted
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_staticnat "Manages static NATs on Apache CloudStack based clouds." b
- name: $1
	cs_staticnat:
		ip_address: ${2:# Public IP address the static NAT is assigned to.}
		# vm: # Name of virtual machine which we make the static NAT for.
		# vm_guest_ip: no
		# network: # Network the IP address is related to.
		# vpc: # VPC the network related to.
		# state: #present|absent
		# domain: # Domain the static NAT is related to.
		# account: # Account the static NAT is related to.
		# project: # Name of the project the static NAT is related to.
		# zone: # Name of the zone in which the virtual machine is in.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_affinitygroup "Manages affinity groups on Apache CloudStack based clouds." b
- name: $1
	cs_affinitygroup:
		name: ${2:# Name of the affinity group.}
		# affinity_type: # Type of the affinity group. If not specified, first found affinity type is used.
		# description: # Description of the affinity group.
		# state: #present|absent
		# domain: # Domain the affinity group is related to.
		# account: # Account the affinity group is related to.
		# project: # Name of the project the affinity group is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_configuration "Manages configuration on Apache CloudStack based clouds." b
- name: $1
	cs_configuration:
		name: ${2:# Name of the configuration.}
		value: ${3:# Value of the configuration.}
		# account: # Ensure the value for corresponding account.
		# domain: ROOT
		# zone: # Ensure the value for corresponding zone.
		# storage: # Ensure the value for corresponding storage pool.
		# cluster: # Ensure the value for corresponding cluster.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_network_offering "Manages network offerings on Apache CloudStack based clouds." b
- name: $1
	cs_network_offering:
		name: ${2:# The name of the network offering.}
		# state: enabled|#present|disabled|absent
		# display_text: # Display text of the network offerings.
		# guest_ip_type: Shared|Isolated
		# supported_services: Dns|PortForwarding|Dhcp|SourceNat|UserData|Firewall|StaticNat|Vpn|Lb
		# traffic_type: Guest
		# availability: # The availability of network offering. Default value is Optional
		# conserve_mode: # Whether the network offering has IP conserve mode enabled.
		# details: internallbprovider|publiclbprovider
		# egress_default_policy: allow|deny
		# persistent: # True if network offering supports persistent networks
		# keepalive_enabled: # If true keepalive will be turned on in the loadbalancer.
		# max_connections: # Maximum number of concurrent connections supported by the network offering.
		# network_rate: # Data transfer rate in megabits per second allowed.
		# service_capabilities: # Desired service capabilities as part of network offering.
		# service_offering: # The service offering name or ID used by virtual router provider.
		# service_provider: # Provider to service mapping.
		# specify_ip_ranges: # Wheter the network offering supports specifying IP ranges.
		# specify_vlan: # Whether the network offering supports vlans or not.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_securitygroup "Manages security groups on Apache CloudStack based clouds." b
- name: $1
	cs_securitygroup:
		name: ${2:# Name of the security group.}
		# description: # Description of the security group.
		# state: #present|absent
		# domain: # Domain the security group is related to.
		# account: # Account the security group is related to.
		# project: # Name of the project the security group to be created in.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_domain "Manages domains on Apache CloudStack based clouds." b
- name: $1
	cs_domain:
		path: ${2:# Path of the domain.}
		# network_domain: # Network domain for networks in the domain.
		# clean_up: no
		# state: #present|absent
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vpn_gateway "Manages site-to-site VPN gateways on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_gateway:
		vpc: ${2:# Name of the VPC.}
		# state: #present|absent
		# domain: # Domain the VPN gateway is related to.
		# account: # Account the VPN gateway is related to.
		# project: # Name of the project the VPN gateway is related to.
		# zone: # Name of the zone the VPC is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_router "Manages routers on Apache CloudStack based clouds." b
- name: $1
	cs_router:
		name: ${2:# Name of the router.}
		# service_offering: # Name or id of the service offering of the router.
		# domain: # Domain the router is related to.
		# account: # Account the router is related to.
		# project: # Name of the project the router is related to.
		# zone: # Name of the zone the router is deployed in.
		# state: #present|absent|started|stopped|restarted
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_network_acl "Manages network access control lists (ACL) on Apache CloudStack based clouds." b
- name: $1
	cs_network_acl:
		name: ${2:# Name of the network ACL.}
		vpc: ${3:# VPC the network ACL is related to.}
		# description: # Description of the network ACL.
		# state: #present|absent
		# domain: # Domain the network ACL rule is related to.
		# account: # Account the network ACL rule is related to.
		# project: # Name of the project the network ACL is related to.
		# zone: # Name of the zone the VPC is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vpn_connection "Manages site-to-site VPN connections on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_connection:
		vpc: ${2:# Name of the VPC the VPN connection is related to.}
		vpn_customer_gateway: ${3:# Name of the VPN customer gateway.}
		# passive: no
		# force: no
		# state: #present|absent
		# domain: # Domain the VPN connection is related to.
		# account: # Account the VPN connection is related to.
		# project: # Name of the project the VPN connection is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_portforward "Manages port forwarding rules on Apache CloudStack based clouds." b
- name: $1
	cs_portforward:
		ip_address: ${2:# Public IP address the rule is assigned to.}
		public_port: ${3:# Start public port for this rule.}
		private_port: ${4:# Start private port for this rule.}
		# vm: # Name of virtual machine which we make the port forwarding rule for.
		# state: #present|absent
		# protocol: #tcp|udp
		# public_end_port: # End public port for this rule.
		# private_end_port: # End private port for this rule.
		# open_firewall: no
		# vm_guest_ip: no
		# network: # Name of the network.
		# vpc: # Name of the VPC.
		# domain: # Domain the C(vm) is related to.
		# account: # Account the C(vm) is related to.
		# project: # Name of the project the C(vm) is located in.
		# zone: # Name of the zone in which the virtual machine is in.
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_user "Manages users on Apache CloudStack based clouds." b
- name: $1
	cs_user:
		username: ${2:# Username of the user.}
		# account: # Account the user will be created under.
		# password: # Password of the user to be created.
		# first_name: # First name of the user.
		# last_name: # Last name of the user.
		# email: # Email of the user.
		# timezone: # Timezone of the user.
		# keys_registered: no
		# domain: ROOT
		# state: #present|absent|enabled|disabled|locked|unlocked
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_pod "Manages pods on Apache CloudStack based clouds." b
- name: $1
	cs_pod:
		name: ${2:# Name of the pod.}
		# id: # uuid of the existing pod.
		# start_ip: # Starting IP address for the Pod.
		# end_ip: # Ending IP address for the Pod.
		# netmask: # Netmask for the Pod.
		# gateway: # Gateway for the Pod.
		# zone: # Name of the zone in which the pod belongs to.
		# state: #present|enabled|disabled|absent
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_project "Manages projects on Apache CloudStack based clouds." b
- name: $1
	cs_project:
		name: ${2:# Name of the project.}
		# display_text: # Display text of the project.
		# state: #present|absent|active|suspended
		# domain: # Domain the project is related to.
		# account: # Account the project is related to.
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_storage_pool "Manages Primary Storage Pools on Apache CloudStack based clouds." b
- name: $1
	cs_storage_pool:
		name: ${2:# Name of the storage pool.}
		# zone: # Name of the zone in which the host should be deployed.
		# storage_url: # URL of the storage pool.
		# pod: # Name of the pod.
		# cluster: # Name of the cluster.
		# scope: cluster|zone
		# managed: # Whether the storage pool should be managed by CloudStack.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# storage_tags: # Tags associated with this storage pool.
		# provider: DefaultPrimary
		# capacity_bytes: # Bytes CloudStack can provision from this storage pool.
		# capacity_iops: # Bytes CloudStack can provision from this storage pool.
		# allocation_state: enabled|disabled|maintenance
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_account "Manages accounts on Apache CloudStack based clouds." b
- name: $1
	cs_account:
		name: ${2:# Name of account.}
		# username: # Username of the user to be created if account did not exist.
		# password: # Password of the user to be created if account did not exist.
		# first_name: # First name of the user to be created if account did not exist.
		# last_name: # Last name of the user to be created if account did not exist.
		# email: # Email of the user to be created if account did not exist.
		# timezone: # Timezone of the user to be created if account did not exist.
		# network_domain: # Network domain of the account.
		# account_type: #user|root_admin|domain_admin
		# domain: ROOT
		# state: #present|absent|enabled|disabled|locked|unlocked
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_volume "Manages volumes on Apache CloudStack based clouds." b
- name: $1
	cs_volume:
		name: ${2:# Name of the volume.}
		# account: # Account the volume is related to.
		# custom_id: # Custom id to the resource.
		# disk_offering: # Name of the disk offering to be used.
		# display_volume: yes
		# domain: # Name of the domain the volume to be deployed in.
		# max_iops: # Max iops
		# min_iops: # Min iops
		# project: # Name of the project the volume to be deployed in.
		# size: # Size of disk in GB
		# snapshot: # The snapshot name for the disk volume.
		# force: no
		# shrink_ok: no
		# vm: # Name of the virtual machine to attach the volume to.
		# zone: # Name of the zone in which the volume should be deployed.
		# state: #present|absent|attached|detached
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_firewall "Manages firewall rules on Apache CloudStack based clouds." b
- name: $1
	cs_firewall:
		# ip_address: # Public IP address the ingress rule is assigned to.
		# network: # Network the egress rule is related to.
		# state: #present|absent
		# type: #ingress|egress
		# protocol: #tcp|udp|icmp|all
		# cidrs: 0.0.0.0/0
		# start_port: # Start port for this rule.
		# end_port: # End port for this rule. Considered if C(protocol=tcp) or C(protocol=udp).
		# icmp_type: # Type of the icmp message being sent.
		# icmp_code: # Error code for this icmp message.
		# domain: # Domain the firewall rule is related to.
		# account: # Account the firewall rule is related to.
		# project: # Name of the project the firewall rule is related to.
		# zone: # Name of the zone in which the virtual machine is in.
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_facts "Gather facts on instances of Apache CloudStack based clouds." b
- name: $1
	cs_facts:
		# filter: cloudstack_service_offering|cloudstack_availability_zone|cloudstack_public_hostname|cloudstack_public_ipv4|cloudstack_local_hostname|cloudstack_local_ipv4|cloudstack_instance_id|cloudstack_user_data
		# meta_data_host: # Host or IP of the meta data API service.
$0
endsnippet

snippet cs_role_permission "Manages role permissions on Apache CloudStack based clouds." b
- name: $1
	cs_role_permission:
		name: ${2:# The API name of the permission.}
		role: ${3:# Name or ID of the role.}
		# permission: allow|#deny
		# state: #present|absent
		# description: # The description of the role permission.
		# parent: # The parent role permission uuid. use 0 to move this rule at the top of the list.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vpn_customer_gateway "Manages site-to-site VPN customer gateway configurations on Apache CloudStack based clouds." b
- name: $1
	cs_vpn_customer_gateway:
		name: ${2:# Name of the gateway.}
		# cidrs: # List of guest CIDRs behind the gateway.
		# gateway: # Public IP address of the gateway.
		# esp_policy: # ESP policy in the format e.g. C(aes256-sha1;modp1536).
		# ike_policy: # IKE policy in the format e.g. C(aes256-sha1;modp1536).
		# ipsec_psk: # IPsec Preshared-Key.
		# ike_lifetime: # Lifetime in seconds of phase 1 VPN connection.
		# esp_lifetime: # Lifetime in seconds of phase 2 VPN connection.
		# dpd: # Enable Dead Peer Detection.
		# force_encap: # Force encapsulation for NAT traversal.
		# state: #present|absent
		# domain: # Domain the VPN customer gateway is related to.
		# account: # Account the VPN customer gateway is related to.
		# project: # Name of the project the VPN gateway is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_disk_offering "Manages disk offerings on Apache CloudStack based clouds." b
- name: $1
	cs_disk_offering:
		name: ${2:# Name of the disk offering.}
		# disk_size: # Size of the disk offering in GB (1GB = 1,073,741,824 bytes).
		# bytes_read_rate: # Bytes read rate of the disk offering.
		# bytes_write_rate: # Bytes write rate of the disk offering.
		# display_text: # Display text of the disk offering.
		# domain: # Domain the disk offering is related to.
		# hypervisor_snapshot_reserve: # Hypervisor snapshot reserve space as a percent of a volume.
		# customized: no
		# iops_read_rate: # IO requests read rate of the disk offering.
		# iops_write_rate: # IO requests write rate of the disk offering.
		# iops_max: # Max. iops of the disk offering.
		# iops_min: # Min. iops of the disk offering.
		# provisioning_type: thin|sparse|fat
		# state: #present|absent
		# storage_type: local|shared
		# storage_tags: # The storage tags for this disk offering.
		# display_offering: # An optional field, whether to display the offering to the end user or not.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_role "Manages user roles on Apache CloudStack based clouds." b
- name: $1
	cs_role:
		name: ${2:# Name of the role.}
		# id: # ID of the role.
		# role_type: #User|DomainAdmin|ResourceAdmin|Admin
		# description: # Description of the role.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_cluster "Manages host clusters on Apache CloudStack based clouds." b
- name: $1
	cs_cluster:
		name: ${2:# name of the cluster.}
		# zone: # Name of the zone in which the cluster belongs to.
		# pod: # Name of the pod in which the cluster belongs to.
		# cluster_type: CloudManaged|ExternalManaged
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM
		# url: # URL for the cluster
		# username: # Username for the cluster.
		# password: # Password for the cluster.
		# guest_vswitch_name: # Name of virtual switch used for guest traffic in the cluster.
		# guest_vswitch_type: vmwaresvs|vmwaredvs
		# public_vswitch_name: # Name of virtual switch used for public traffic in the cluster.
		# public_vswitch_type: vmwaresvs|vmwaredvs
		# vms_ip_address: # IP address of the VSM associated with this cluster.
		# vms_username: # Username for the VSM associated with this cluster.
		# vms_password: # Password for the VSM associated with this cluster.
		# ovm3_cluster: # Ovm3 native OCFS2 clustering enabled for cluster.
		# ovm3_pool: # Ovm3 native pooling enabled for cluster.
		# ovm3_vip: # Ovm3 vip to use for pool (and cluster).
		# state: #present|absent|disabled|enabled
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vpc "Manages VPCs on Apache CloudStack based clouds." b
- name: $1
	cs_vpc:
		name: ${2:# Name of the VPC.}
		# display_text: # Display text of the VPC.
		# cidr: # CIDR of the VPC, e.g. 10.1.0.0/16
		# network_domain: # Network domain for the VPC.
		# vpc_offering: # Name of the VPC offering.
		# clean_up: # Whether to redeploy a VPC router or not when I(state=restarted)
		# state: #present|absent|stopped|restarted
		# domain: # Domain the VPC is related to.
		# account: # Account the VPC is related to.
		# project: # Name of the project the VPC is related to.
		# zone: # Name of the zone.
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_sshkeypair "Manages SSH keys on Apache CloudStack based clouds." b
- name: $1
	cs_sshkeypair:
		name: ${2:# Name of public key.}
		# domain: # Domain the public key is related to.
		# account: # Account the public key is related to.
		# project: # Name of the project the public key to be registered in.
		# state: #present|absent
		# public_key: # String of the public key.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_host "Manages hosts on Apache CloudStack based clouds." b
- name: $1
	cs_host:
		name: ${2:# Name of the host.}
		# url: # Url of the host used to create a host.
		# username: # Username for the host.
		# password: # Password for the host.
		# pod: # Name of the pod.
		# cluster: # Name of the cluster.
		# hypervisor: KVM|VMware|BareMetal|XenServer|LXC|HyperV|UCS|OVM|Simulator
		# allocation_state: enabled|disabled
		# host_tags: # Tags of the host.
		# state: #present|absent
		# zone: # Name of the zone in which the host should be deployed.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_instancegroup "Manages instance groups on Apache CloudStack based clouds." b
- name: $1
	cs_instancegroup:
		name: ${2:# Name of the instance group.}
		# domain: # Domain the instance group is related to.
		# account: # Account the instance group is related to.
		# project: # Project the instance group is related to.
		# state: #present|absent
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_loadbalancer_rule "Manages load balancer rules on Apache CloudStack based clouds." b
- name: $1
	cs_loadbalancer_rule:
		name: ${2:# The name of the load balancer rule.}
		public_port: ${3:# The public port from where the network traffic will be load balanced from.}
		ip_address: ${4:# Public IP address from where the network traffic will be load balanced from.}
		# description: # The description of the load balancer rule.
		# algorithm: #source|roundrobin|leastconn
		# private_port: # The private port of the private ip address/virtual machine where the network traffic will be load balanced to.
		# open_firewall: no
		# cidr: # CIDR (full notation) to be used for firewall rule if required.
		# protocol: # The protocol to be used on the load balancer
		# project: # Name of the project the load balancer IP address is related to.
		# state: #present|absent
		# domain: # Domain the rule is related to.
		# account: # Account the rule is related to.
		# zone: # Name of the zone in which the rule should be created.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_service_offering "Manages service offerings on Apache CloudStack based clouds." b
- name: $1
	cs_service_offering:
		name: ${2:# Name of the service offering.}
		# bytes_read_rate: # Bytes read rate of the disk offering.
		# bytes_write_rate: # Bytes write rate of the disk offering.
		# cpu_number: # The number of CPUs of the service offering.
		# cpu_speed: # The CPU speed of the service offering in MHz.
		# limit_cpu_usage: # Restrict the CPU usage to committed service offering.
		# deployment_planner: # The deployment planner heuristics used to deploy a VM of this offering.
		# display_text: # Display text of the service offering.
		# domain: # Domain the service offering is related to.
		# host_tags: # The host tagsfor this service offering.
		# hypervisor_snapshot_reserve: # Hypervisor snapshot reserve space as a percent of a volume.
		# disk_iops_customized: no
		# disk_iops_read_rate: # IO requests read rate of the disk offering.
		# disk_iops_write_rate: # IO requests write rate of the disk offering.
		# disk_iops_max: # Max. iops of the compute offering.
		# disk_iops_min: # Min. iops of the compute offering.
		# is_system: no
		# is_volatile: no
		# memory: # The total memory of the service offering in MB.
		# network_rate: # Data transfer rate in Mb/s allowed.
		# offer_ha: no
		# provisioning_type: thin|sparse|fat
		# service_offering_details: # Details for planner, used to store specific parameters.
		# state: #present|absent
		# storage_type: local|shared
		# system_vm_type: domainrouter|consoleproxy|secondarystoragevm
		# storage_tags: # The storage tags for this service offering.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_snapshot_policy "Manages volume snapshot policies on Apache CloudStack based clouds." b
- name: $1
	cs_snapshot_policy:
		# volume: # Name of the volume.
		# volume_type: DATADISK|ROOT
		# vm: # Name of the instance to select the volume from.
		# device_id: # ID of the device on a VM the volume is attached to.
		# vpc: # Name of the vpc the instance is deployed in.
		# interval_type: hourly|#daily|weekly|monthly
		# max_snaps: 8
		# schedule: # Time the snapshot is scheduled. Required if C(state=present).
		# time_zone: UTC
		# state: #present|absent
		# domain: # Domain the volume is related to.
		# account: # Account the volume is related to.
		# project: # Name of the project the volume is related to.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_network "Manages networks on Apache CloudStack based clouds." b
- name: $1
	cs_network:
		name: ${2:# Name (case sensitive) of the network.}
		# display_text: # Display text of the network.
		# network_offering: # Name of the offering for the network.
		# start_ip: # The beginning IPv4 address of the network belongs to.
		# end_ip: # The ending IPv4 address of the network belongs to.
		# gateway: # The gateway of the network.
		# netmask: # The netmask of the network.
		# start_ipv6: # The beginning IPv6 address of the network belongs to.
		# end_ipv6: # The ending IPv6 address of the network belongs to.
		# cidr_ipv6: # CIDR of IPv6 network, must be at least /64.
		# gateway_ipv6: # The gateway of the IPv6 network.
		# vlan: # The ID or VID of the network.
		# vpc: # Name of the VPC of the network.
		# isolated_pvlan: # The isolated private VLAN for this network.
		# clean_up: no
		# acl_type: #account|domain
		# acl: # The name of the access control list for the VPC network tier.
		# subdomain_access: # Defines whether to allow subdomains to use networks dedicated to their parent domain(s).
		# network_domain: # The network domain.
		# state: #present|absent|restarted
		# zone: # Name of the zone in which the network should be deployed.
		# project: # Name of the project the network to be deployed in.
		# domain: # Domain the network is related to.
		# account: # Account the network is related to.
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_ip_address "Manages public IP address associations on Apache CloudStack based clouds." b
- name: $1
	cs_ip_address:
		# ip_address: # Public IP address.
		# domain: # Domain the IP address is related to.
		# network: # Network the IP address is related to.
		# vpc: # VPC the IP address is related to.
		# account: # Account the IP address is related to.
		# project: # Name of the project the IP address is related to.
		# zone: # Name of the zone in which the IP address is in.
		# state: #present|absent
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_instance_nic "Manages NICs of an instance on Apache CloudStack based clouds." b
- name: $1
	cs_instance_nic:
		vm: ${2:# Name of instance.}
		network: ${3:# Name of the network.}
		# ip_address: # IP address to be used for the nic.
		# vpc: # Name of the VPC the C(vm) is related to.
		# domain: # Domain the instance is related to.
		# account: # Account the instance is related to.
		# project: # Name of the project the instance is deployed in.
		# zone: # Name of the zone in which the instance is deployed in.
		# state: #present|absent
		# poll_async: yes
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_vmsnapshot "Manages VM snapshots on Apache CloudStack based clouds." b
- name: $1
	cs_vmsnapshot:
		name: ${2:# Unique Name of the snapshot. In CloudStack terms display name.}
		vm: ${3:# Name of the virtual machine.}
		# description: # Description of the snapshot.
		# snapshot_memory: no
		# zone: # Name of the zone in which the VM is in. If not set, default zone is used.
		# project: # Name of the project the VM is assigned to.
		# state: #present|absent|revert
		# domain: # Domain the VM snapshot is related to.
		# account: # Account the VM snapshot is related to.
		# poll_async: yes
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet cs_instance "Manages instances and virtual machines on Apache CloudStack based clouds." b
- name: $1
	cs_instance:
		# name: # Host name of the instance. C(name) can only contain ASCII letters.
		# display_name: # Custom display name of the instances.
		# group: # Group in where the new instance should be in.
		# state: deployed|started|stopped|restarted|restored|destroyed|expunged|#present|absent
		# service_offering: # Name or id of the service offering of the new instance.
		# cpu: # The number of CPUs to allocate to the instance, used with custom service offerings
		# cpu_speed: # The clock speed/shares allocated to the instance, used with custom service offerings
		# memory: # The memory allocated to the instance, used with custom service offerings
		# template: # Name, display text or id of the template to be used for creating the new instance.
		# iso: # Name or id of the ISO to be used for creating the new instance.
		# template_filter: all|featured|self|selfexecutable|sharedexecutable|#executable|community
		# hypervisor: KVM|kvm|VMware|vmware|BareMetal|baremetal|XenServer|xenserver|LXC|lxc|HyperV|hyperv|UCS|ucs|OVM|ovm|Simulator|simulator
		# keyboard: de|de-ch|es|fi|fr|fr-be|fr-ch|is|it|jp|nl-be|no|pt|uk|us
		# networks: # List of networks to use for the new instance.
		# ip_address: # IPv4 address for default instance's network during creation.
		# ip6_address: # IPv6 address for default instance's network.
		# ip_to_networks: # List of mappings in the form I({'network': NetworkName, 'ip': 1.2.3.4})
		# disk_offering: # Name of the disk offering to be used.
		# disk_size: # Disk size in GByte required if deploying instance from ISO.
		# root_disk_size: # Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)
		# security_groups: # List of security groups the instance to be applied to.
		# host: # Host on which an instance should be deployed or started on.
		# domain: # Domain the instance is related to.
		# account: # Account the instance is related to.
		# project: # Name of the project the instance to be deployed in.
		# zone: # Name of the zone in which the instance should be deployed.
		# ssh_key: # Name of the SSH key to be deployed on the new instance.
		# affinity_groups: # Affinity groups names to be applied to the new instance.
		# user_data: # Optional data (ASCII) that can be sent to the instance upon a successful deployment.
		# force: no
		# allow_root_disk_shrink: no
		# tags: # List of tags. Tags are a list of dictionaries having keys C(key) and C(value).
		# poll_async: yes
		# details: # Map to specify custom parameters.
		# api_key: # API key of the CloudStack API.
		# api_secret: # Secret key of the CloudStack API.
		# api_url: # URL of the CloudStack API e.g. https://cloud.example.com/client/api.
		# api_http_method: get|post
		# api_timeout: # HTTP timeout in seconds.
		# api_region: cloudstack
$0
endsnippet

snippet clc_group "Create/delete Server Groups at Centurylink Cloud" b
- name: $1
	clc_group:
		name: ${2:# The name of the Server Group}
		# description: # A description of the Server Group
		# parent: # The parent group of the server group. If parent is not provided, it creates the group at top level.
		# location: # Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account
		# state: #present|absent
		# wait: yes
$0
endsnippet

snippet clc_firewall_policy "Create/delete/update firewall policies" b
- name: $1
	clc_firewall_policy:
		location: ${2:# Target datacenter for the firewall policy}
		source_account_alias: ${3:# CLC alias for the source account}
		# state: #present|absent
		# source: # The list  of source addresses for traffic on the originating firewall. This is required when state is 'present'
		# destination: # The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'
		# ports: any|icmp|TCP/123|UDP/123|TCP/123-456|UDP/123-456
		# firewall_policy_id: # Id of the firewall policy. This is required to update or delete an existing firewall policy
		# destination_account_alias: # CLC alias for the destination account
		# wait: yes
		# enabled: True|False
$0
endsnippet

snippet clc_loadbalancer "Create, Delete shared loadbalancers in CenturyLink Cloud." b
- name: $1
	clc_loadbalancer:
		name: ${2:# The name of the loadbalancer}
		alias: ${3:# The alias of your CLC Account}
		location: ${4:# The location of the datacenter where the load balancer resides in}
		# description: # A description for the loadbalancer
		# method: leastConnection|roundRobin
		# persistence: standard|sticky
		# port: 80|443
		# nodes: []
		# status: #enabled|disabled
		# state: #present|absent|port_absent|nodes_present|nodes_absent
$0
endsnippet

snippet clc_server "Create, Delete, Start and Stop servers in CenturyLink Cloud." b
- name: $1
	clc_server:
		# additional_disks: []
		# add_public_ip: no
		# alias: # The account alias to provision the servers under.
		# anti_affinity_policy_id: # The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.
		# anti_affinity_policy_name: # The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.
		# alert_policy_id: # The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.
		# alert_policy_name: # The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.
		# count: 1
		# count_group: # Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.
		# cpu: 1
		# cpu_autoscale_policy_id: # The autoscale policy to assign to the server.
		# custom_fields: []
		# description: # The description to set for the server.
		# exact_count: # Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.
		# group: Default Group
		# ip_address: # The IP Address for the server. One is assigned if not provided.
		# location: # The Datacenter to create servers in.
		# managed_os: no
		# memory: 1
		# name: # A 1 to 6 character identifier to use for the server. This is required when state is 'present'
		# network_id: # The network UUID on which to create servers.
		# packages: []
		# password: # Password for the administrator / root user
		# primary_dns: # Primary DNS used by the server.
		# public_ip_protocol: #TCP|UDP|ICMP
		# public_ip_ports: []
		# secondary_dns: # Secondary DNS used by the server.
		# server_ids: []
		# source_server_password: # The password for the source server if a clone is specified.
		# state: #present|absent|started|stopped
		# storage_type: #standard|hyperscale
		# template: # The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'
		# ttl: # The time to live for the server in seconds.  The server will be deleted when this time expires.
		# type: #standard|hyperscale|bareMetal
		# configuration_id: # Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.
		# os_type: redHat6_64Bit|centOS6_64Bit|windows2012R2Standard_64Bit|ubuntu14_64Bit
		# wait: yes
$0
endsnippet

snippet clc_aa_policy "Create or Delete Anti Affinity Policies at CenturyLink Cloud." b
- name: $1
	clc_aa_policy:
		name: ${2:# The name of the Anti Affinity Policy.}
		location: ${3:# Datacenter in which the policy lives/should live.}
		# state: #present|absent
		# wait: yes
$0
endsnippet

snippet clc_publicip "Add and Delete public ips on servers in CenturyLink Cloud." b
- name: $1
	clc_publicip:
		server_ids: ${2:# A list of servers to create public ips on.}
		# protocol: #TCP|UDP|ICMP
		# ports: # A list of ports to expose. This is required when state is 'present'
		# state: #present|absent
		# wait: yes
$0
endsnippet

snippet clc_server_snapshot "Create, Delete and Restore server snapshots in CenturyLink Cloud." b
- name: $1
	clc_server_snapshot:
		server_ids: ${2:# The list of CLC server Ids.}
		# expiration_days: 7
		# state: #present|absent|restore
		# wait: yes
$0
endsnippet

snippet clc_modify_server "modify servers in CenturyLink Cloud." b
- name: $1
	clc_modify_server:
		server_ids: ${2:# A list of server Ids to modify.}
		# cpu: # How many CPUs to update on the server
		# memory: # Memory (in GB) to set to the server.
		# anti_affinity_policy_id: # The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'
		# anti_affinity_policy_name: # The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'
		# alert_policy_id: # The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'
		# alert_policy_name: # The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'
		# state: #present|absent
		# wait: yes
$0
endsnippet

snippet clc_blueprint_package "deploys a blue print package on a set of servers in CenturyLink Cloud." b
- name: $1
	clc_blueprint_package:
		server_ids: ${2:# A list of server Ids to deploy the blue print package.}
		package_id: ${3:# The package id of the blue print.}
		# package_params: {}
		# state: #present
		# wait: yes
$0
endsnippet

snippet clc_alert_policy "Create or Delete Alert Policies at CenturyLink Cloud." b
- name: $1
	clc_alert_policy:
		alias: ${2:# The alias of your CLC Account}
		# name: # The name of the alert policy. This is mutually exclusive with id
		# id: # The alert policy id. This is mutually exclusive with name
		# alert_recipients: # A list of recipient email ids to notify the alert. This is required for state 'present'
		# metric: cpu|memory|disk
		# duration: # The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'
		# threshold: # The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0
		# state: #present|absent
$0
endsnippet

snippet atomic_image "Manage the container images on the atomic host platform" b
- name: $1
	atomic_image:
		name: ${2:# Name of the container image.}
		# backend: docker|ostree
		# state: absent|#latest|present
		# started: yes
$0
endsnippet

snippet atomic_container "Manage the containers on the atomic host platform" b
- name: $1
	atomic_container:
		backend: ${2:docker|ostree}
		name: ${3:# Name of the container}
		image: ${4:# The image to use to install the container}
		state: ${5:#latest|present|absent|rollback}
		mode: ${6:user|system}
		# rootfs: # Define the rootfs of the image
		# values: # Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'. The values specified here will be used at installation time as --set arguments for atomic install.
$0
endsnippet

snippet atomic_host "Manage the atomic host platform" b
- name: $1
	atomic_host:
		# revision: latest
$0
endsnippet

snippet digital_ocean_size_facts "Gather facts about DigitalOcean Droplet sizes" b
- name: $1
	digital_ocean_size_facts:
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_floating_ip_facts "DigitalOcean Floating IPs facts" b
- name: $1
	digital_ocean_floating_ip_facts:
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_load_balancer_facts "Gather facts about DigitalOcean load balancers" b
- name: $1
	digital_ocean_load_balancer_facts:
		# load_balancer_id: # Load balancer ID that can be used to identify and reference a load_balancer.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_snapshot_facts "Gather facts about DigitalOcean Snapshot" b
- name: $1
	digital_ocean_snapshot_facts:
		# snapshot_type: #all|droplet|volume|by_id
		# snapshot_id: # To retrieve information about a snapshot, please specify this as a snapshot id.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_tag "Create and remove tag(s) to DigitalOcean resource." b
- name: $1
	digital_ocean_tag:
		name: ${2:# The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.}
		# resource_id: # The ID of the resource to operate on.
		# resource_type: #droplet
		# state: #present|absent
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_block_storage "Create/destroy or attach/detach Block Storage volumes in DigitalOcean" b
- name: $1
	digital_ocean_block_storage:
		command: ${2:create|attach}
		state: ${3:present|absent}
		volume_name: ${4:# The name of the Block Storage volume.}
		region: ${5:# The slug of the region where your Block Storage volume should be located in. If snapshot_id is included, this will be ignored.}
		# block_size: # The size of the Block Storage volume in gigabytes. Required when command=create and state=present. If snapshot_id is included, this will be ignored.
		# description: # Description of the Block Storage volume.
		# snapshot_id: # The snapshot id you would like the Block Storage volume created with. If included, region and block_size will be ignored and changed to null.
		# droplet_id: # The droplet id you want to operate on. Required when command=attach.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_sshkey "Manage DigitalOcean SSH keys" b
- name: $1
	digital_ocean_sshkey:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# state: #present|absent
		# fingerprint: # This is a unique identifier for the SSH key used to delete a key
		# name: # The name for the SSH key
		# ssh_pub_key: # The Public SSH key to add.
$0
endsnippet

snippet digital_ocean_sshkey_facts "DigitalOcean SSH keys facts" b
- name: $1
	digital_ocean_sshkey_facts:
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_certificate "Manage certificates in DigitalOcean." b
- name: $1
	digital_ocean_certificate:
		name: ${2:# The name of the certificate.}
		# private_key: # A PEM-formatted private key content of SSL Certificate.
		# leaf_certificate: # A PEM-formatted public SSL Certificate.
		# certificate_chain: # The full PEM-formatted trust chain between the certificate authority's certificate and your domain's SSL certificate.
		# state: #present|absent
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_certificate_facts "Gather facts about DigitalOcean certificates" b
- name: $1
	digital_ocean_certificate_facts:
		# certificate_id: # Certificate ID that can be used to identify and reference a certificate.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_floating_ip "Manage DigitalOcean Floating IPs" b
- name: $1
	digital_ocean_floating_ip:
		oauth_token: ${2:# DigitalOcean OAuth token.}
		# state: #present|absent
		# ip: # Public IP address of the Floating IP. Used to remove an IP
		# region: # The region that the Floating IP is reserved to.
		# droplet_id: # The Droplet that the Floating IP has been assigned to.
$0
endsnippet

snippet digital_ocean_volume_facts "Gather facts about DigitalOcean volumes" b
- name: $1
	digital_ocean_volume_facts:
		# region_name: # Name of region to restrict results to volumes available in a specific region.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_account_facts "Gather facts about DigitalOcean User account" b
- name: $1
	digital_ocean_account_facts:
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean "Create/delete a droplet/SSH_key in DigitalOcean" b
- name: $1
	digital_ocean:
		# command: #droplet|ssh
		# state: #present|active|absent|deleted
		# api_token: # DigitalOcean api token.
		# id: # Numeric, the droplet id you want to operate on.
		# name: # String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.
		# unique_name: no
		# size_id: # This is the slug of the size you would like the droplet created with.
		# image_id: # This is the slug of the image you would like the droplet created with.
		# region_id: # This is the slug of the region you would like your server to be created in.
		# ssh_key_ids: # Optional, array of SSH key (numeric) ID that you would like to be added to the server.
		# virtio: yes
		# private_networking: no
		# backups_enabled: no
		# user_data: # opaque blob of data which is made available to the droplet
		# ipv6: no
		# wait: yes
		# wait_timeout: 300
		# ssh_pub_key: # The public SSH key you want to add to your account.
$0
endsnippet

snippet digital_ocean_domain_facts "Gather facts about DigitalOcean Domains" b
- name: $1
	digital_ocean_domain_facts:
		# domain_name: # Name of the domain to gather facts for.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_tag_facts "Gather facts about DigitalOcean tags" b
- name: $1
	digital_ocean_tag_facts:
		# tag_name: # Tag name that can be used to identify and reference a tag.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_region_facts "Gather facts about DigitalOcean regions" b
- name: $1
	digital_ocean_region_facts:
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_image_facts "Gather facts about DigitalOcean images" b
- name: $1
	digital_ocean_image_facts:
		# image_type: #all|application|distribution|private
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet digital_ocean_domain "Create/delete a DNS domain in DigitalOcean" b
- name: $1
	digital_ocean_domain:
		# state: #present|absent
		# id: # Numeric, the droplet id you want to operate on.
		# name: # String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.
		# ip: # An 'A' record for '@' ($ORIGIN) will be created with the value 'ip'.  'ip' is an IP version 4 address.
		# oauth_token: # DigitalOcean OAuth token.
		# timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet cloudscale_server "Manages servers on the cloudscale.ch IaaS service" b
- name: $1
	cloudscale_server:
		# state: #running|stopped|absent
		# name: # Name of the Server.
		# uuid: # UUID of the server.
		# flavor: # Flavor of the server.
		# image: # Image used to create the server.
		# volume_size_gb: 10
		# bulk_volume_size_gb: # Size of the bulk storage volume in GB.
		# ssh_keys: # List of SSH public keys.
		# use_public_network: yes
		# use_private_network: no
		# use_ipv6: yes
		# anti_affinity_with: # UUID of another server to create an anti-affinity group with.
		# user_data: # Cloud-init configuration (cloud-config) data to use for the server.
		# api_token: # cloudscale.ch API token.
		# api_timeout: 30
$0
endsnippet

snippet cloudscale_floating_ip "Manages floating IPs on the cloudscale.ch IaaS service" b
- name: $1
	cloudscale_floating_ip:
		# state: #present|absent
		# ip: # Floating IP address to change.
		# ip_version: 4|6
		# server: # UUID of the server assigned to this floating IP.
		# prefix_length: 56
		# reverse_ptr: # Reverse PTR entry for this address.
		# api_token: # cloudscale.ch API token.
		# api_timeout: 30
$0
endsnippet

snippet oneandone_public_ip "Configure 1&1 public IPs." b
- name: $1
	oneandone_public_ip:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		public_ip_id: ${3:# The ID of the public IP used with update and delete states.}
		# state: #present|absent|update
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# reverse_dns: # Reverse DNS name. maxLength=256
		# datacenter: # ID of the datacenter where the IP will be created (only for unassigned IPs).
		# type: #IPV4|IPV6
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
$0
endsnippet

snippet oneandone_monitoring_policy "Configure 1&1 monitoring policy." b
- name: $1
	oneandone_monitoring_policy:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		name: ${3:# Monitoring policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		monitoring_policy: ${4:# The identifier (id or name) of the monitoring policy used with update state.}
		agent: ${5:# Set true for using agent.}
		email: ${6:# User's email. maxLength=128}
		thresholds: ${7:# Monitoring policy thresholds. Each of the suboptions have warning and critical, which both have alert and value suboptions. Warning is used to set limits for warning alerts, critical is used to set critical alerts. alert enables alert, and value is used to advise when the value is exceeded.}
		ports: ${8:# Array of ports that will be monitoring.}
		processes: ${9:# Array of processes that will be monitoring.}
		# state: #present|absent|update
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# description: # Monitoring policy description. maxLength=256
		# add_ports: # Ports to add to the monitoring policy.
		# add_processes: # Processes to add to the monitoring policy.
		# add_servers: # Servers to add to the monitoring policy.
		# remove_ports: # Ports to remove from the monitoring policy.
		# remove_processes: # Processes to remove from the monitoring policy.
		# remove_servers: # Servers to remove from the monitoring policy.
		# update_ports: # Ports to be updated on the monitoring policy.
		# update_processes: # Processes to be updated on the monitoring policy.
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
$0
endsnippet

snippet oneandone_firewall_policy "Configure 1&1 firewall policy." b
- name: $1
	oneandone_firewall_policy:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		name: ${3:# Firewall policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		firewall_policy: ${4:# The identifier (id or name) of the firewall policy used with update state.}
		# state: #present|absent|update
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# rules: # A list of rules that will be set for the firewall policy. Each rule must contain protocol parameter, in addition to three optional parameters (port_from, port_to, and source)
		# add_server_ips: # A list of server identifiers (id or name) to be assigned to a firewall policy. Used in combination with update state.
		# remove_server_ips: # A list of server IP ids to be unassigned from a firewall policy. Used in combination with update state.
		# add_rules: # A list of rules that will be added to an existing firewall policy. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
		# remove_rules: # A list of rule ids that will be removed from an existing firewall policy. Used in combination with update state.
		# description: # Firewall policy description. maxLength=256
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
$0
endsnippet

snippet oneandone_server "Create, destroy, start, stop, and reboot a 1&1 Host server." b
- name: $1
	oneandone_server:
		auth_token: ${2:# Authenticating API token provided by 1&1. Overrides the ONEANDONE_AUTH_TOKEN environement variable.}
		fixed_instance_size: ${3:S|M|L|XL|XXL|3XL|4XL|5XL}
		# state: #present|absent|running|stopped
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# datacenter: #US|ES|DE|GB
		# hostname: # The hostname or ID of the server. Only used when state is 'present'.
		# description: # The description of the server.
		# appliance: # The operating system name or ID for the server. It is required only for 'present' state.
		# vcore: # The total number of processors. It must be provided with cores_per_processor, ram, and hdds parameters.
		# cores_per_processor: # The number of cores per processor. It must be provided with vcore, ram, and hdds parameters.
		# ram: # The amount of RAM memory. It must be provided with with vcore, cores_per_processor, and hdds parameters.
		# hdds: # A list of hard disks with nested "size" and "is_main" properties. It must be provided with vcore, cores_per_processor, and ram parameters.
		# private_network: # The private network name or ID.
		# firewall_policy: # The firewall policy name or ID.
		# load_balancer: # The load balancer name or ID.
		# monitoring_policy: # The monitoring policy name or ID.
		# server: # Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.
		# count: 1
		# ssh_key: # User's public SSH key (contents, not path).
		# server_type: #cloud|baremetal|k8s_node
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
		# auto_increment: yes
$0
endsnippet

snippet oneandone_private_network "Configure 1&1 private networking." b
- name: $1
	oneandone_private_network:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		private_network: ${3:# The identifier (id or name) of the network used with update state.}
		name: ${4:# Private network name used with present state. Used as identifier (id or name) when used with absent state.}
		# state: #present|absent|update
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# description: # Set a description for the network.
		# datacenter: # The identifier of the datacenter where the private network will be created
		# network_address: # Set a private network space, i.e. 192.168.1.0
		# subnet_mask: # Set the netmask for the private network, i.e. 255.255.255.0
		# add_members: # List of server identifiers (name or id) to be added to the private network.
		# remove_members: # List of server identifiers (name or id) to be removed from the private network.
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
$0
endsnippet

snippet oneandone_load_balancer "Configure 1&1 load balancer." b
- name: $1
	oneandone_load_balancer:
		auth_token: ${2:# Authenticating API token provided by 1&1.}
		load_balancer: ${3:# The identifier (id or name) of the load balancer used with update state.}
		name: ${4:# Load balancer name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
		health_check_test: ${5:NONE|TCP|HTTP|ICMP}
		health_check_interval: ${6:# Health check period in seconds. minimum=5, maximum=300, multipleOf=1}
		persistence: ${7:# Persistence.}
		persistence_time: ${8:# Persistence time in seconds. Required if persistence is enabled. minimum=30, maximum=1200, multipleOf=1}
		method: ${9:ROUND_ROBIN|LEAST_CONNECTIONS}
		rules: ${10:# A list of rule objects that will be set for the load balancer. Each rule must contain protocol, port_balancer, and port_server parameters, in addition to source parameter, which is optional.}
		# state: #present|absent|update
		# api_url: # Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
		# health_check_path: # Url to call for cheking. Required for HTTP health check. maxLength=1000
		# health_check_parse: # Regular expression to check. Required for HTTP health check. maxLength=64
		# datacenter: #US|ES|DE|GB
		# description: # Description of the load balancer. maxLength=256
		# add_server_ips: # A list of server identifiers (id or name) to be assigned to a load balancer. Used in combination with update state.
		# remove_server_ips: # A list of server IP ids to be unassigned from a load balancer. Used in combination with update state.
		# add_rules: # A list of rules that will be added to an existing load balancer. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
		# remove_rules: # A list of rule ids that will be removed from an existing load balancer. Used in combination with update state.
		# wait: yes
		# wait_timeout: 600
		# wait_interval: 5
$0
endsnippet

snippet lxc_container "Manage LXC Containers" b
- name: $1
	lxc_container:
		name: ${2:# Name of a container.}
		# backing_store: #dir|lvm|loop|btrfs|overlayfs|zfs
		# template: ubuntu
		# template_options: # Template options when building the container.
		# config: # Path to the LXC configuration file.
		# lv_name: $CONTAINER_NAME
		# vg_name: lxc
		# thinpool: # Use LVM thin pool called TP.
		# fs_type: ext4
		# fs_size: 5G
		# directory: # Place rootfs directory under DIR.
		# zfs_root: # Create zfs under given zfsroot.
		# container_command: # Run a command within a container.
		# lxc_path: # Place container under PATH
		# container_log: True|False
		# container_log_level: #INFO|ERROR|DEBUG
		# clone_name: no
		# clone_snapshot: True|False
		# archive: True|False
		# archive_path: # Path the save the archived container. If the path does not exist the archive method will attempt to create it.
		# archive_compression: #gzip|bzip2|none
		# state: #started|stopped|restarted|absent|frozen
		# container_config: # list of 'key=value' options to use when configuring a container.
$0
endsnippet

snippet lxd_container "Manage LXD Containers" b
- name: $1
	lxd_container:
		name: ${2:# Name of a container.}
		# architecture: # The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# config: # The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# devices: # The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# ephemeral: # Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# source: # The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
		# state: #started|stopped|restarted|absent|frozen
		# timeout: 30
		# wait_for_ipv4_addresses: no
		# force_stop: no
		# url: unix:/var/lib/lxd/unix.socket
		# key_file: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
		# cert_file: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
		# trust_password: # The client trusted password.
$0
endsnippet

snippet lxd_profile "Manage LXD profiles" b
- name: $1
	lxd_profile:
		name: ${2:# Name of a profile.}
		# description: # Description of the profile.
		# config: # The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
		# devices: # The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
		# new_name: # A new name of a profile.
		# state: #present|absent
		# url: unix:/var/lib/lxd/unix.socket
		# key_file: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
		# cert_file: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
		# trust_password: # The client trusted password.
$0
endsnippet

snippet spotinst_aws_elastigroup "Create, update or delete Spotinst AWS Elastigroups" b
- name: $1
	spotinst_aws_elastigroup:
		availability_vs_cost: ${2:availabilityOriented|costOriented|balanced}
		availability_zones: ${3:# (List of Objects) a list of hash/dictionaries of Availability Zones that are configured in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are name (String), subnet_id (String), placement_group_name (String),}
		image_id: ${4:# (String) The image Id used to launch the instance.; In case of conflict between Instance type and image type, an error will be returned}
		key_pair: ${5:# (String) Specify a Key Pair to attach to the instances}
		max_size: ${6:# (Integer) The upper limit number of instances that you can scale up to}
		min_size: ${7:# (Integer) The lower limit number of instances that you can scale down to}
		monitoring: ${8:# (Boolean) Describes whether instance Enhanced Monitoring is enabled}
		name: ${9:# (String) Unique name for elastigroup to be created, updated or deleted}
		on_demand_instance_type: ${10:# (String) On-demand instance type that will be provisioned}
		product: ${11:Linux/UNIX|SUSE Linux|Windows|Linux/UNIX (Amazon VPC)|SUSE Linux (Amazon VPC)|Windows}
		security_group_ids: ${12:# (List of Strings) One or more security group IDs. ; In case of update it will override the existing Security Group with the new given array}
		spot_instance_types: ${13:# (List of Strings) Spot instance type that will be provisioned.}
		target: ${14:# (Integer) The number of instances to launch}
		unit: ${15:instance|weight}
		# credentials_path: # (String) Optional parameter that allows to set a non-default credentials path. Default is ~/.spotinst/credentials
		# account_id: # (String) Optional parameter that allows to set an account-id inside the module configuration By default this is retrieved from the credentials path
		# block_device_mappings: # (List of Objects) a list of hash/dictionaries of Block Device Mappings for elastigroup instances; You can specify virtual devices and EBS volumes.; '[{"key":"value", "key":"value"}]'; keys allowed are device_name (List of Strings), virtual_name (String), no_device (String), ebs (Object, expects the following keys- delete_on_termination(Boolean), encrypted(Boolean), iops (Integer), snapshot_id(Integer), volume_type(String), volume_size(Integer))
		# chef: # (Object) The Chef integration configuration.; Expects the following keys - chef_server (String), organization (String), user (String), pem_key (String), chef_version (String)
		# draining_timeout: # (Integer) Time for instance to be drained from incoming requests and deregistered from ELB before termination.
		# ebs_optimized: # (Boolean) Enable EBS optimization for supported instances which are not enabled by default.; Note - additional charges will be applied.
		# ebs_volume_pool: # (List of Objects) a list of hash/dictionaries of EBS devices to reattach to the elastigroup when available; '[{"key":"value", "key":"value"}]'; keys allowed are - volume_ids (List of Strings), device_name (String)
		# ecs: # (Object) The ECS integration configuration.; Expects the following key - cluster_name (String)
		# elastic_ips: # (List of Strings) List of ElasticIps Allocation Ids (Example C(eipalloc-9d4e16f8)) to associate to the group instances
		# fallback_to_od: # (Boolean) In case of no spots available, Elastigroup will launch an On-demand instance instead
		# health_check_grace_period: 300
		# health_check_unhealthy_duration_before_replacement: # (Integer) Minimal mount of time instance should be unhealthy for us to consider it unhealthy.
		# health_check_type: ELB|HCS|TARGET_GROUP|MLB|EC2
		# iam_role_name: # (String) The instance profile iamRole name
		# iam_role_arn: # (String) The instance profile iamRole arn
		# id: # (String) The group id if it already exists and you want to update, or delete it. This will not work unless the uniqueness_by field is set to id. When this is set, and the uniqueness_by field is set, the group will either be updated or deleted, but not created.
		# ignore_changes: image_id|target
		# kubernetes: # (Object) The Kubernetes integration configuration. Expects the following keys - api_server (String), token (String)
		# lifetime_period: # (String) lifetime period
		# load_balancers: # (List of Strings) List of classic ELB names
		# mesosphere: # (Object) The Mesosphere integration configuration. Expects the following key - api_server (String)
		# network_interfaces: # (List of Objects) a list of hash/dictionaries of network interfaces to add to the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - description (String), device_index (Integer), secondary_private_ip_address_count (Integer), associate_public_ip_address (Boolean), delete_on_termination (Boolean), groups (List of Strings), network_interface_id (String), private_ip_address (String), subnet_id (String), associate_ipv6_address (Boolean), private_ip_addresses (List of Objects, Keys are privateIpAddress (String, required) and primary (Boolean))
		# on_demand_count: # (Integer) Required if risk is not set
		# opsworks: # (Object) The elastigroup OpsWorks integration configration.; Expects the following key - layer_id (String)
		# persistence: # (Object) The Stateful elastigroup configration.; Accepts the following keys - should_persist_root_device (Boolean), should_persist_block_devices (Boolean), should_persist_private_ip (Boolean)
		# rancher: # (Object) The Rancher integration configuration.; Expects the following keys - access_key (String), secret_key (String), master_host (String)
		# right_scale: # (Object) The Rightscale integration configuration.; Expects the following keys - account_id (String), refresh_token (String)
		# risk: # (Integer) required if on demand is not set. The percentage of Spot instances to launch (0 - 100).
		# roll_config: # (Object) Roll configuration.; If you would like the group to roll after updating, please use this feature. Accepts the following keys - batch_size_percentage(Integer, Required), grace_period - (Integer, Required), health_check_type(String, Optional)
		# scheduled_tasks: # (List of Objects) a list of hash/dictionaries of scheduled tasks to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - adjustment (Integer), scale_target_capacity (Integer), scale_min_capacity (Integer), scale_max_capacity (Integer), adjustment_percentage (Integer), batch_size_percentage (Integer), cron_expression (String), frequency (String), grace_period (Integer), task_type (String, required), is_enabled (Boolean)
		# shutdown_script: # (String) The Base64-encoded shutdown script that executes prior to instance termination. Encode before setting.
		# signals: # (List of Objects) a list of hash/dictionaries of signals to configure in the elastigroup; keys allowed are - name (String, required), timeout (Integer)
		# spin_up_time: # (Integer) spin up time, in seconds, for the instance
		# state: present|absent
		# tags: # (List of tagKey:tagValue paris) a list of tags to configure in the elastigroup. Please specify list of keys and values (key colon value);
		# target_group_arns: # (List of Strings) List of target group arns instances should be registered to
		# tenancy: default|dedicated
		# terminate_at_end_of_billing_hour: # (Boolean) terminate at the end of billing hour
		# up_scaling_policies: # (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions (List of Objects, Keys allowed are name (String, required) and value (String)), statistic (String, required) evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), min_target_capacity (String), target (String), maximum (String), minimum (String)
		# down_scaling_policies: # (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions ((List of Objects), Keys allowed are name (String, required) and value (String)), statistic (String, required), evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), max_target_capacity (String), target (String), maximum (String), minimum (String)
		# target_tracking_policies: # (List of Objects) a list of hash/dictionaries of target tracking policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), source (String, required), metric_name (String, required), statistic (String, required), unit (String, required), cooldown (String, required), target (String, required)
		# uniqueness_by: id|name
		# user_data: # (String) Base64-encoded MIME user data. Encode before setting the value.
		# utilize_reserved_instances: # (Boolean) In case of any available Reserved Instances, Elastigroup will utilize your reservations before purchasing Spot instances.
		# wait_for_instances: # (Boolean) Whether or not the elastigroup creation / update actions should wait for the instances to spin
		# wait_timeout: # (Integer) How long the module should wait for instances before failing the action.; Only works if wait_for_instances is True.
$0
endsnippet

snippet imgadm "Manage SmartOS images" b
- name: $1
	imgadm:
		state: ${2:present|absent|deleted|imported|updated|vacuumed}
		# force: # Force a given operation (where supported by imgadm(1M)).
		# pool: zones
		# source: # URI for the image source.
		# type: #imgapi|docker|dsapi
		# uuid: # Image UUID. Can either be a full UUID or C(*) for all images.
$0
endsnippet

snippet smartos_image_facts "Get SmartOS image details." b
- name: $1
	smartos_image_facts:
		# filters: # Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.
$0
endsnippet

snippet vmadm "Manage SmartOS virtual machines and zones." b
- name: $1
	vmadm:
		brand: ${2:#joyent|joyent-minimal|kvm|lx}
		state: ${3:present|absent|stopped|restarted}
		# archive_on_delete: # When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.
		# autoboot: # Whether or not a VM is booted when the system is rebooted.
		# boot: # Set the boot order for KVM VMs.
		# cpu_cap: # Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.
		# cpu_shares: # Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.
		# cpu_type: #qemu64|host
		# customer_metadata: # Metadata to be set and associated with this VM, this contain customer modifiable keys.
		# delegate_dataset: # Whether to delegate a ZFS dataset to an OS VM.
		# disk_driver: # Default value for a virtual disk model for KVM guests.
		# disks: # A list of disks to add, valid properties are documented in vmadm(1M).
		# dns_domain: # Domain value for C(/etc/hosts).
		# docker: # Docker images need this flag enabled along with the I(brand) set to C(lx).
		# filesystems: # Mount additional filesystems into an OS VM.
		# firewall_enabled: # Enables the firewall, allowing fwadm(1M) rules to be applied.
		# force: # Force a particular action (i.e. stop or delete a VM).
		# fs_allowed: # Comma separated list of filesystem types this zone is allowed to mount.
		# hostname: # Zone/VM hostname.
		# image_uuid: # Image UUID.
		# indestructible_delegated: # Adds an C(@indestructible) snapshot to delegated datasets.
		# indestructible_zoneroot: # Adds an C(@indestructible) snapshot to zoneroot.
		# internal_metadata: # Metadata to be set and associated with this VM, this contains operator generated keys.
		# internal_metadata_namespace: # List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata).
		# kernel_version: # Kernel version to emulate for LX VMs.
		# limit_priv: # Set (comma separated) list of privileges the zone is allowed to use.
		# maintain_resolvers: # Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.
		# max_locked_memory: # Total amount of memory (in MiBs) on the host that can be locked by this VM.
		# max_lwps: # Maximum number of lightweight processes this VM is allowed to have running.
		# max_physical_memory: # Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.
		# max_swap: # Maximum amount of virtual memory (in MiBs) the VM is allowed to use.
		# mdata_exec_timeout: # Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.
		# name: # Name of the VM. vmadm(1M) uses this as an optional name.
		# nic_driver: # Default value for a virtual NIC model for KVM guests.
		# nics: # A list of nics to add, valid properties are documented in vmadm(1M).
		# nowait: # Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.
		# qemu_opts: # Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.
		# qemu_extra_opts: # Additional qemu cmdline arguments for KVM guests.
		# quota: # Quota on zone filesystems (in MiBs).
		# ram: # Amount of virtual RAM for a KVM guest (in MiBs).
		# resolvers: # List of resolvers to be put into C(/etc/resolv.conf).
		# routes: # Dictionary that maps destinations to gateways, these will be set as static routes in the VM.
		# spice_opts: # Addition options for SPICE-enabled KVM VMs.
		# spice_password: # Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.
		# tmpfs: # Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.
		# uuid: # UUID of the VM. Can either be a full UUID or C(*) for all VMs.
		# vcpus: # Number of virtual CPUs for a KVM guest.
		# vga: # Specify VGA emulation used by KVM VMs.
		# virtio_txburst: # Number of packets that can be sent in a single flush of the tx queue of virtio NICs.
		# virtio_txtimer: # Timeout (in nanoseconds) for the TX timer of virtio NICs.
		# vnc_password: # Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.
		# vnc_port: # TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.
		# zfs_data_compression: # Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.
		# zfs_data_recsize: # Suggested block size (power of 2) for files in the delegated dataset's filesystem.
		# zfs_filesystem_limit: # Maximum number of filesystems the VM can have.
		# zfs_io_priority: # IO throttle priority value relative to other VMs.
		# zfs_root_compression: # Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.
		# zfs_root_recsize: # Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.
		# zfs_snapshot_limit: # Number of snapshots the VM can have.
		# zpool: # ZFS pool the VM's zone dataset will be created in.
$0
endsnippet

snippet scaleway_compute "Scaleway compute management module" b
- name: $1
	scaleway_compute:
		image: ${2:# Image identifier used to start the instance with}
		organization: ${3:# Organization identifier}
		region: ${4:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
		commercial_type: ${5:ARM64-2GB|ARM64-4GB|ARM64-8GB|ARM64-16GB|ARM64-32GB|ARM64-64GB|ARM64-128GB|C1|C2S|C2M|C2L|START1-XS|START1-S|START1-M|START1-L|X64-15GB|X64-30GB|X64-60GB|X64-120GB}
		# enable_ipv6: no
		# name: # Name of the instance
		# state: #present|absent|running|restarted|stopped
		# tags: []
		# wait: no
		# wait_timeout: 300
		# wait_sleep_time: 3
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_volume "Scaleway volumes management module" b
- name: $1
	scaleway_volume:
		region: ${2:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
		name: ${3:# Name used to identify the volume.}
		# state: #present|absent
		# organization: # ScaleWay organization ID to which volume belongs.
		# size: # Size of the volume in bytes.
		# volume_type: # Type of the volume (for example 'l_ssd').
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_sshkey "Scaleway SSH keys management module" b
- name: $1
	scaleway_sshkey:
		ssh_pub_key: ${2:# The public SSH key as a string to add.}
		# state: #present|absent
		# api_url: https://account.scaleway.com
		# api_token: # Scaleway OAuth token.
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_server_facts "Gather facts about the Scaleway servers available." b
- name: $1
	scaleway_server_facts:
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_organization_facts "Gather facts about the Scaleway organizations available." b
- name: $1
	scaleway_organization_facts:
		# api_url: https://account.scaleway.com
		# api_token: # Scaleway OAuth token.
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_image_facts "Gather facts about the Scaleway images available." b
- name: $1
	scaleway_image_facts:
		region: ${2:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_volume_facts "Gather facts about the Scaleway volumes available." b
- name: $1
	scaleway_volume_facts:
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_snapshot_facts "Gather facts about the Scaleway snapshots available." b
- name: $1
	scaleway_snapshot_facts:
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_ip_facts "Gather facts about the Scaleway ips available." b
- name: $1
	scaleway_ip_facts:
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet scaleway_security_group_facts "Gather facts about the Scaleway security groups available." b
- name: $1
	scaleway_security_group_facts:
		# api_token: # Scaleway OAuth token.
		# api_url: https://api.scaleway.com
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet vultr_account_facts "Gather facts about the Vultr account." b
- name: $1
	vultr_account_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_firewall_rule "Manages firewall rules on Vultr." b
- name: $1
	vultr_firewall_rule:
		group: ${2:# Name of the firewall group.}
		# ip_version: #v4|v6
		# protocol: icmp|#tcp|udp|gre
		# cidr: # Network in CIDR format
		# start_port: # Start port for the firewall rule.
		# end_port: # End port for the firewall rule.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_dns_domain "Manages DNS domains on Vultr." b
- name: $1
	vultr_dns_domain:
		name: ${2:# The domain name.}
		# server_ip: # The default server IP.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_plan_facts "Gather facts about the Vultr plans available." b
- name: $1
	vultr_plan_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_user "Manages users on Vultr." b
- name: $1
	vultr_user:
		name: ${2:# Name of the user}
		# email: # Email of the user.
		# password: # Password of the user.
		# force: no
		# api_enabled: yes
		# acls: manage_users|subscriptions|provisioning|billing|support|abuse|dns|upgrade
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_os_facts "Gather facts about the Vultr OSes available." b
- name: $1
	vultr_os_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_network "Manages networks on Vultr." b
- name: $1
	vultr_network:
		name: ${2:# Name of the network.}
		# cidr: # The CIDR IPv4 network block to be used when attaching servers to this network. Required if I(state=present).
		# region: # Region the network is deployed into. Required if I(state=present).
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_dns_domain_facts "Gather facts about the Vultr DNS domains available." b
- name: $1
	vultr_dns_domain_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_startup_script "Manages startup scripts on Vultr." b
- name: $1
	vultr_startup_script:
		name: ${2:# The script name.}
		# script_type: #boot|pxe
		# script: # The script source code.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_dns_record "Manages DNS records on Vultr." b
- name: $1
	vultr_dns_record:
		domain: ${2:# The domain the record is related to.}
		# name: 
		# record_type: #A|AAAA|CNAME|MX|SRV|CAA|TXT|NS|SSHFP
		# data: # Data of the record.
		# ttl: 300
		# multiple: no
		# priority: 0
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_firewall_rule "Manages firewall rules on Vultr." b
- name: $1
	vultr_firewall_rule:
		group: ${2:# Name of the firewall group.}
		# ip_version: #v4|v6
		# protocol: icmp|#tcp|udp|gre
		# cidr: # Network in CIDR format
		# start_port: # Start port for the firewall rule.
		# end_port: # End port for the firewall rule.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_server "Manages virtual servers on Vultr." b
- name: $1
	vultr_server:
		name: ${2:# Name of the server.}
		# hostname: # Hostname to assign to this server.
		# os: # The operating system.
		# firewall_group: # The firewall group to assign this server to.
		# plan: # Plan to use for the server.
		# force: # Force stop/start the server if required to apply changes
		# notify_activate: # Whether to send an activation email when the server is ready or not.
		# private_network_enabled: # Whether to enable private networking or not.
		# auto_backup_enabled: # Whether to enable automatic backups or not.
		# ipv6_enabled: # Whether to enable IPv6 or not.
		# tag: # Tag for the server.
		# user_data: # User data to be passed to the server.
		# startup_script: # Name of the startup script to execute on boot.
		# ssh_keys: # List of SSH keys passed to the server on creation.
		# reserved_ip_v4: # IP address of the floating IP to use as the main IP of this server.
		# region: # Region the server is deployed into.
		# state: #present|absent|restarted|reinstalled|started|stopped
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_account_facts "Gather facts about the Vultr account." b
- name: $1
	vultr_account_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_firewall_group "Manages firewall groups on Vultr." b
- name: $1
	vultr_firewall_group:
		name: ${2:# Name of the firewall group.}
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_region_facts "Gather facts about the Vultr regions available." b
- name: $1
	vultr_region_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_server "Manages virtual servers on Vultr." b
- name: $1
	vultr_server:
		name: ${2:# Name of the server.}
		# hostname: # Hostname to assign to this server.
		# os: # The operating system.
		# firewall_group: # The firewall group to assign this server to.
		# plan: # Plan to use for the server.
		# force: # Force stop/start the server if required to apply changes
		# notify_activate: # Whether to send an activation email when the server is ready or not.
		# private_network_enabled: # Whether to enable private networking or not.
		# auto_backup_enabled: # Whether to enable automatic backups or not.
		# ipv6_enabled: # Whether to enable IPv6 or not.
		# tag: # Tag for the server.
		# user_data: # User data to be passed to the server.
		# startup_script: # Name of the startup script to execute on boot.
		# ssh_keys: # List of SSH keys passed to the server on creation.
		# reserved_ip_v4: # IP address of the floating IP to use as the main IP of this server.
		# region: # Region the server is deployed into.
		# state: #present|absent|restarted|reinstalled|started|stopped
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_ssh_key "Manages ssh keys on Vultr." b
- name: $1
	vultr_ssh_key:
		name: ${2:# Name of the ssh key.}
		# ssh_key: # SSH public key.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_startup_script "Manages startup scripts on Vultr." b
- name: $1
	vultr_startup_script:
		name: ${2:# The script name.}
		# script_type: #boot|pxe
		# script: # The script source code.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_dns_record "Manages DNS records on Vultr." b
- name: $1
	vultr_dns_record:
		domain: ${2:# The domain the record is related to.}
		# name: 
		# record_type: #A|AAAA|CNAME|MX|SRV|CAA|TXT|NS|SSHFP
		# data: # Data of the record.
		# ttl: 300
		# multiple: no
		# priority: 0
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_block_storage_facts "Gather facts about the Vultr block storage volumes available." b
- name: $1
	vultr_block_storage_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_ssh_key_facts "Gather facts about the Vultr SSH keys available." b
- name: $1
	vultr_ssh_key_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_server_facts "Gather facts about the Vultr servers available." b
- name: $1
	vultr_server_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_startup_script_facts "Gather facts about the Vultr startup scripts available." b
- name: $1
	vultr_startup_script_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_user_facts "Gather facts about the Vultr user available." b
- name: $1
	vultr_user_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_firewall_group "Manages firewall groups on Vultr." b
- name: $1
	vultr_firewall_group:
		name: ${2:# Name of the firewall group.}
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_user "Manages users on Vultr." b
- name: $1
	vultr_user:
		name: ${2:# Name of the user}
		# email: # Email of the user.
		# password: # Password of the user.
		# force: no
		# api_enabled: yes
		# acls: manage_users|subscriptions|provisioning|billing|support|abuse|dns|upgrade
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_dns_domain "Manages DNS domains on Vultr." b
- name: $1
	vultr_dns_domain:
		name: ${2:# The domain name.}
		# server_ip: # The default server IP.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_firewall_group_facts "Gather facts about the Vultr firewall groups available." b
- name: $1
	vultr_firewall_group_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_ssh_key "Manages ssh keys on Vultr." b
- name: $1
	vultr_ssh_key:
		name: ${2:# Name of the ssh key.}
		# ssh_key: # SSH public key.
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_block_storage "Manages block storage volumes on Vultr." b
- name: $1
	vultr_block_storage:
		name: ${2:# Name of the block storage volume.}
		size: ${3:# Size of the block storage volume in GB.}
		region: ${4:# Region the block storage volume is deployed into.}
		# state: #present|absent
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet vultr_network_facts "Gather facts about the Vultr networks available." b
- name: $1
	vultr_network_facts:
		# api_key: # API key of the Vultr API.
		# api_timeout: # HTTP timeout to Vultr API.
		# api_retries: # Amount of retries in case of the Vultr API retuns an HTTP 503 code.
		# api_account: default
		# api_endpoint: # URL to API endpint (without trailing slash).
		# validate_certs: yes
$0
endsnippet

snippet online_user_facts "Gather facts about Online user." b
- name: $1
	online_user_facts:
		# api_token: # Online OAuth token.
		# api_url: https://api.online.net/api/v1
		# api_timeout: 30
		# validate_certs: yes
$0
endsnippet

snippet dimensiondata_network "Create, update, and delete MCP 1.0 & 2.0 networks" b
- name: $1
	dimensiondata_network:
		name: ${2:# The name of the network domain to create.}
		location: ${3:# The target datacenter.}
		# description: # Additional description of the network domain.
		# service_plan: #ESSENTIALS|ADVANCED
		# state: #present|absent
		# region: Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.
		# mcp_user: # The username used to authenticate to the CloudControl API.
		# mcp_password: # The password used to authenticate to the CloudControl API.
		# validate_certs: yes
		# wait: no
		# wait_time: 600
		# wait_poll_interval: 2
$0
endsnippet

snippet dimensiondata_vlan "Manage a VLAN in a Cloud Control network domain." b
- name: $1
	dimensiondata_vlan:
		network_domain: ${2:# The Id or name of the target network domain.}
		location: ${3:# The target datacenter.}
		# name: # The name of the target VLAN.
		# description: # A description of the VLAN.
		# private_ipv4_base_address: # The base address for the VLAN's IPv4 network (e.g. 192.168.1.0).
		# private_ipv4_prefix_size: # The size of the IPv4 address space, e.g 24.
		# state: #present|absent|readonly
		# allow_expand: no
		# region: Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.
		# mcp_user: # The username used to authenticate to the CloudControl API.
		# mcp_password: # The password used to authenticate to the CloudControl API.
		# validate_certs: yes
		# wait: no
		# wait_time: 600
		# wait_poll_interval: 2
$0
endsnippet

snippet ovirt_host_facts "Retrieve facts about one or more oVirt/RHV hosts" b
- name: $1
	ovirt_host_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# all_content: no
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_nic "Module to manage network interfaces of Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_nic:
		name: ${2:# Name of the network interface to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm: # Name of the Virtual Machine to manage.
		# template: # Name of the template to manage.
		# state: absent|plugged|#present|unplugged
		# network: # Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.
		# profile: # Virtual network interface profile to be attached to VM network interface.
		# interface: # Type of the network interface. For example e1000, pci_passthrough, rtl8139, rtl8139_virtio, spapr_vlan or virtio.
		# mac_address: # Custom MAC address of the network interface, by default it's obtained from MAC pool.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vm "Module to manage Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_vm:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the Virtual Machine to manage.
		# id: # ID of the Virtual Machine to manage.
		# state: absent|next_run|#present|registered|running|stopped|suspended
		# cluster: # Name of the cluster, where Virtual Machine should be created.
		# allow_partial_import: # Boolean indication whether to allow partial registration of Virtual Machine when C(state) is registered.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# cluster_mappings: # Mapper which maps cluster name between VM's OVF and the destination cluster this VM should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# role_mappings: # Mapper which maps role name between VM's OVF and the destination role this VM should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# domain_mappings: # Mapper which maps aaa domain name between VM's OVF and the destination aaa domain this VM should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# affinity_group_mappings: # Mapper which maps affinty name between VM's OVF and the destination affinity this VM should be registered to, relevant when C(state) is registered.
		# affinity_label_mappings: # Mappper which maps affinity label name between VM's OVF and the destination label this VM should be registered to, relevant when C(state) is registered.
		# lun_mappings: # Mapper which maps lun between VM's OVF and the destination lun this VM should contain, relevant when C(state) is registered. lun_mappings is described by the following dictionary: - C(logical_unit_id): The logical unit number to identify a logical unit, - C(logical_unit_port): The port being used to connect with the LUN disk. - C(logical_unit_portal): The portal being used to connect with the LUN disk. - C(logical_unit_address): The address of the block storage host. - C(logical_unit_target): The iSCSI specification located on an iSCSI server - C(logical_unit_username): Username to be used to connect to the block storage host. - C(logical_unit_password): Password to be used to connect to the block storage host. - C(storage_type): The storage type which the LUN reside on (iscsi or fcp)
		# reassign_bad_macs: # Boolean indication whether to reassign bad macs when C(state) is registered.
		# template: # Name of the template, which should be used to create Virtual Machine.
		# template_version: # Version number of the template to be used for VM.
		# use_latest_template_version: # Specify if latest template version should be used, when running a stateless VM.
		# storage_domain: # Name of the storage domain where all template disks should be created.
		# disk_format: #cow|raw
		# memory: # Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_guaranteed: # Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_max: # Upper bound of virtual machine memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# cpu_shares: # Set a CPU shares for this Virtual Machine.
		# cpu_cores: # Number of virtual CPUs cores of the Virtual Machine.
		# cpu_sockets: # Number of virtual CPUs sockets of the Virtual Machine.
		# cpu_threads: # Number of virtual CPUs sockets of the Virtual Machine.
		# type: desktop|server|high_performance
		# quota_id: # Virtual Machine quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# operating_system: # Operating system of the Virtual Machine.
		# boot_devices: cdrom|hd|network
		# boot_menu: # I(True) enable menu to select boot device, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# usb_support: # I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# serial_console: # I(True) enable VirtIO serial console, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# sso: # I(True) enable Single Sign On by Guest Agent, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# host: # Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.
		# high_availability: # If I(yes) Virtual Machine will be set as highly available.
		# high_availability_priority: # Indicates the priority of the virtual machine inside the run and migration queues. Virtual machines with higher priorities will be started and migrated before virtual machines with lower priorities. The value is an integer between 0 and 100. The higher the value, the higher the priority.
		# lease: # Name of the storage domain this virtual machine lease reside on.
		# custom_compatibility_version: # Enables a virtual machine to be customized to its own compatibility version. If 'C(custom_compatibility_version)' is set, it overrides the cluster's compatibility version for this particular virtual machine.
		# host_devices: # Single Root I/O Virtualization - technology that allows single device to expose multiple endpoints that can be passed to VMs
		# delete_protected: # If I(yes) Virtual Machine will be set as delete protected.
		# stateless: # If I(yes) Virtual Machine will be set as stateless.
		# clone: no
		# clone_permissions: no
		# cd_iso: # ISO file from ISO storage domain which should be attached to Virtual Machine.
		# force: no
		# nics: # List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.
		# disks: # List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary.
		# sysprep: # Dictionary with values for Windows Virtual Machine initialization using sysprep.
		# cloud_init: # Dictionary with values for Unix-like Virtual Machine initialization using cloud init.
		# cloud_init_nics: # List of dictionaries representing network interfaces to be setup by cloud init.
		# cloud_init_persist: # If I(true) the C(cloud_init) or C(sysprep) parameters will be saved for the virtual machine and won't be virtual machine won't be started as run-once.
		# kernel_path: # Path to a kernel image used to boot the virtual machine.
		# initrd_path: # Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.
		# kernel_params: # Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.
		# instance_type: # Name of virtual machine's hardware configuration.
		# description: # Description of the Virtual Machine.
		# comment: # Comment of the Virtual Machine.
		# timezone: # Sets time zone offset of the guest hardware clock.
		# serial_policy: vm|host|custom
		# serial_policy_value: # Allows you to specify a custom serial number.
		# vmware: # Dictionary of values to be used to connect to VMware and import a virtual machine to oVirt.
		# xen: # Dictionary of values to be used to connect to XEN and import a virtual machine to oVirt.
		# kvm: # Dictionary of values to be used to connect to kvm and import a virtual machine to oVirt.
		# cpu_mode: # CPU mode of the virtual machine. It can be some of the following: I(host_passthrough), I(host_model) or I(custom).
		# placement_policy: # The configuration of the virtual machine's placement policy.
		# ticket: # If I(true), in addition return I(remote_vv_file) inside I(vm) dictionary, which contains compatible content for remote-viewer application. Works only C(state) is I(running).
		# cpu_pinning: # CPU Pinning topology to map virtual machine CPU to host CPU.
		# soundcard_enabled: # If I(true), the sound card is added to the virtual machine.
		# smartcard_enabled: # If I(true), use smart card authentication.
		# io_threads: # Number of IO threads used by virtual machine. I(0) means IO threading disabled.
		# ballooning_enabled: # If I(true), use memory ballooning.
		# numa_tune_mode: interleave|preferred|strict
		# numa_nodes: # List of vNUMA Nodes to set for this VM and pin them to assigned host's physical NUMA node.
		# rng_device: # Random number generator (RNG). You can choose of one the following devices I(urandom), I(random) or I(hwrng).
		# custom_properties: # Properties sent to VDSM to configure various hooks.
		# watchdog: # Assign watchdog device for the virtual machine.
		# graphical_console: # Assign graphical console to the virtual machine.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_template_facts "Retrieve facts about one or more oVirt/RHV templates relate to a storage domain." b
- name: $1
	ovirt_storage_template_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: no
		# max: # Sets the maximum number of templates to return. If not specified all the templates are returned.
		# storage_domain: # The storage domain name where the templates should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_permission_facts "Retrieve facts about one or more oVirt/RHV permissions" b
- name: $1
	ovirt_permission_facts:
		authz_name: ${2:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
		# group_name: # Name of the group to manage.
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_user_facts "Retrieve facts about one or more oVirt/RHV users" b
- name: $1
	ovirt_user_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_snapshot "Module to manage Virtual Machine Snapshots in oVirt/RHV" b
- name: $1
	ovirt_snapshot:
		vm_name: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# snapshot_id: # ID of the snapshot to manage.
		# state: restore|#present|absent
		# description: # Description of the snapshot.
		# use_memory: # If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_domain "Module to manage storage domains in oVirt/RHV" b
- name: $1
	ovirt_storage_domain:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # Id of the storage domain to be imported.
		# name: # Name of the storage domain to manage. (Not required when state is I(imported))
		# state: #present|absent|maintenance|unattached|imported|update_ovf_store
		# description: # Description of the storage domain.
		# comment: # Comment of the storage domain.
		# data_center: # Data center name where storage domain should be attached.
		# domain_function: #data|iso|export
		# host: # Host to be used to mount storage.
		# localfs: # Dictionary with values for localfs storage type:
		# nfs: # Dictionary with values for NFS storage type:
		# iscsi: # Dictionary with values for iSCSI storage type:
		# posixfs: # Dictionary with values for PosixFS storage type:
		# glusterfs: # Dictionary with values for GlusterFS storage type:
		# fcp: # Dictionary with values for fibre channel storage type:
		# wipe_after_delete: # Boolean flag which indicates whether the storage domain should wipe the data after delete.
		# backup: # Boolean flag which indicates whether the storage domain is configured as backup or not.
		# critical_space_action_blocker: # Indicates the minimal free space the storage domain should contain in percentages.
		# warning_low_space: # Indicates the minimum percentage of a free space in a storage domain to present a warning.
		# destroy: # Logical remove of the storage domain. If I(true) retains the storage domain's data for import.
		# format: # If I(True) storage domain will be formatted after removing it from oVirt/RHV.
		# discard_after_delete: # If I(True) storage domain blocks will be discarded upon deletion. Enabled by default.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# description: # Description of the data center.
		# comment: # Comment of the data center.
		# local: # I(True) if the data center should be local, I(False) if should be shared.
		# compatibility_version: # Compatibility version of the data center.
		# quota_mode: disabled|audit|enabled
		# mac_pool: # MAC pool to be used by this datacenter.
		# force: no
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the affinity labels which should be listed.
		# vm: # Name of the VM, which affinity labels should be listed.
		# host: # Name of the host, which affinity labels should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_snapshot_facts "Retrieve facts about one or more oVirt/RHV virtual machine snapshots" b
- name: $1
	ovirt_snapshot_facts:
		vm: ${2:# Name of the VM with snapshot.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the snapshot, can be used as glob expression.
		# snapshot_id: # Id of the snapshot we want to retrieve facts about.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the external provider to manage.
		# state: #present|absent
		# description: # Description of the external provider.
		# type: os_image|network|os_volume|foreman
		# url: # URL where external provider is hosted.
		# username: # Username to be used for login to external provider.
		# password: # Password of the user specified in C(username) parameter.
		# tenant_name: # Name of the tenant.
		# authentication_url: # Keystone authentication URL of the openstack provider.
		# data_center: # Name of the data center where provider should be attached.
		# read_only: # Specify if the network should be read only.
		# network_type: [#'external', 'neutron'
		# authentication_keys: []
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_user_facts "Retrieve facts about one or more oVirt/RHV users" b
- name: $1
	ovirt_user_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_snapshot "Module to manage Virtual Machine Snapshots in oVirt/RHV" b
- name: $1
	ovirt_snapshot:
		vm_name: ${2:# Name of the Virtual Machine to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# snapshot_id: # ID of the snapshot to manage.
		# state: restore|#present|absent
		# description: # Description of the snapshot.
		# use_memory: # If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# namespace: # Namespace of the authorization provider, where group resides.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vm_facts "Retrieve facts about one or more oVirt/RHV virtual machines" b
- name: $1
	ovirt_vm_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# all_content: # If I(true) all the attributes of the virtual machines should be included in the response.
		# case_sensitive: yes
		# max: # The maximum number of results to return.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# cluster: # Name of the cluster where vms and hosts resides.
		# vms: # List of the VMs names, which should have assigned this affinity label.
		# hosts: # List of the hosts names, which should have assigned this affinity label.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
- name: $1
	ovirt_group:
		name: ${2:# Name of the group to manage.}
		authz_name: ${3:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# namespace: # Namespace of the authorization provider, where group resides.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_connection "Module to manage storage connections in oVirt" b
- name: $1
	ovirt_storage_connection:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # Id of the storage connection to manage.
		# state: #present|absent
		# storage: # Name of the storage domain to be used with storage connection.
		# address: # Address of the storage server. E.g.: myserver.mydomain.com
		# path: # Path of the mount point of the storage. E.g.: /path/to/my/data
		# nfs_version: # NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).
		# nfs_timeout: # The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.
		# nfs_retrans: # The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.
		# mount_options: # Option which will be passed when mounting storage.
		# password: # A CHAP password for logging into a target.
		# username: # A CHAP username for logging into a target.
		# port: # Port of the iSCSI storage server.
		# target: # The target IQN for the storage device.
		# type: # Storage type. For example: I(nfs), I(iscsi), etc.
		# vfs_type: # Virtual File System type.
		# force: # This parameter is relevant only when updating a connection.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_domain_facts "Retrieve facts about one or more oVirt/RHV storage domains" b
- name: $1
	ovirt_storage_domain_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_mac_pool "Module to manage MAC pools in oVirt/RHV" b
- name: $1
	ovirt_mac_pool:
		name: ${2:# Name of the MAC pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the MAC pool.
		# state: #present|absent
		# allow_duplicates: # If I(true) allow a MAC address to be used multiple times in a pool.
		# ranges: # List of MAC ranges. The from and to should be split by comma.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_nic_facts "Retrieve facts about one or more oVirt/RHV virtual machine network interfaces" b
- name: $1
	ovirt_nic_facts:
		vm: ${2:# Name of the VM where NIC is attached.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the NIC, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_permission "Module to manage permissions of users/groups in oVirt/RHV" b
- name: $1
	ovirt_permission:
		authz_name: ${2:# Authorization provider of the user/group.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# role: UserRole
		# state: absent|#present
		# object_id: # ID of the object where the permissions should be managed.
		# object_name: # Name of the object where the permissions should be managed.
		# object_type: cluster|cpu_profile|data_center|disk|disk_profile|host|network|storage_domain|system|template|#vm|vm_pool|vnic_profile
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
		# group_name: # Name of the group to manage.
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# quota_name: # Name of the quota to assign permission. Works only with C(object_type) I(data_center).
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host_storage_facts "Retrieve facts about one or more oVirt/RHV HostStorages (applicable only for block storage)" b
- name: $1
	ovirt_host_storage_facts:
		host: ${2:# Host to get device list from.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# iscsi: # Dictionary with values for iSCSI storage type:
		# fcp: # Dictionary with values for fibre channel storage type:
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_storage_vm_facts "Retrieve facts about one or more oVirt/RHV virtual machines relate to a storage domain." b
- name: $1
	ovirt_storage_vm_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: no
		# max: # Sets the maximum number of virtual machines to return. If not specified all the virtual machines are returned.
		# storage_domain: # The storage domain name where the virtual machines should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		name: ${2:# Name of the affinity group to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: absent|#present
		# cluster: # Name of the cluster of the affinity group.
		# description: # Description of the affinity group.
		# host_enforcing: # If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).
		# host_rule: negative|positive
		# vm_enforcing: # If I(yes) VM cannot start if it does not satisfy the C(vm_rule).
		# vm_rule: disabled|negative|positive
		# vms: # List of the VMs names, which should have assigned this affinity group.
		# hosts: # List of the hosts names, which should have assigned this affinity group.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_mac_pool "Module to manage MAC pools in oVirt/RHV" b
- name: $1
	ovirt_mac_pool:
		name: ${2:# Name of the MAC pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the MAC pool.
		# state: #present|absent
		# allow_duplicates: # If I(true) allow a MAC address to be used multiple times in a pool.
		# ranges: # List of MAC ranges. The from and to should be split by comma.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_domain_facts "Retrieve facts about one or more oVirt/RHV storage domains" b
- name: $1
	ovirt_storage_domain_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_vmpool "Module to manage VM pools in oVirt/RHV" b
- name: $1
	ovirt_vmpool:
		name: ${2:# Name of the VM pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the Virtual Machine pool.
		# state: #present|absent
		# template: # Name of the template, which will be used to create VM pool.
		# description: # Description of the VM pool.
		# cluster: # Name of the cluster, where VM pool should be created.
		# type: manual|automatic
		# vm_per_user: # Maximum number of VMs a single user can attach to from this pool.
		# prestarted: # Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.
		# vm_count: # Number of VMs in the pool.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		type: ${2:os_image|os_network|os_volume|foreman}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the external provider, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # ID of the disk to manage. Either C(id) or C(name) is required.
		# name: # Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.
		# description: # Description of the disk image to manage.
		# vm_name: # Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# vm_id: # ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# state: #present|absent|attached|detached
		# download_image_path: # Path on a file system where disk should be downloaded.
		# upload_image_path: # Path to disk image, which should be uploaded.
		# size: # Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.
		# interface: #virtio|ide|virtio_scsi
		# format: raw|cow
		# sparse: # I(True) if the disk should be sparse (also known as I(thin provision)). If the parameter is omitted, cow disks will be created as sparse and raw disks as I(preallocated)
		# storage_domain: # Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.
		# storage_domains: # Storage domain names where disk should be copied.
		# force: # Please take a look at C(image_path) documentation to see the correct usage of this parameter.
		# profile: # Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.
		# quota_id: # Disk quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# bootable: # I(True) if the disk should be bootable. By default when disk is created it isn't bootable.
		# shareable: # I(True) if the disk should be shareable. By default when disk is created it isn't shareable.
		# logical_unit: # Dictionary which describes LUN to be directly attached to VM:
		# sparsify: # I(True) if the disk should be sparsified.
		# openstack_volume_type: # Name of the openstack volume type. This is valid when working with cinder.
		# image_provider: # When C(state) is I(exported) disk is exported to given Glance image provider.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_api_facts "Retrieve facts about the oVirt/RHV API" b
- name: $1
	ovirt_api_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_storage_connection "Module to manage storage connections in oVirt" b
- name: $1
	ovirt_storage_connection:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # Id of the storage connection to manage.
		# state: #present|absent
		# storage: # Name of the storage domain to be used with storage connection.
		# address: # Address of the storage server. E.g.: myserver.mydomain.com
		# path: # Path of the mount point of the storage. E.g.: /path/to/my/data
		# nfs_version: # NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).
		# nfs_timeout: # The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.
		# nfs_retrans: # The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.
		# mount_options: # Option which will be passed when mounting storage.
		# password: # A CHAP password for logging into a target.
		# username: # A CHAP username for logging into a target.
		# port: # Port of the iSCSI storage server.
		# target: # The target IQN for the storage device.
		# type: # Storage type. For example: I(nfs), I(iscsi), etc.
		# vfs_type: # Virtual File System type.
		# force: # This parameter is relevant only when updating a connection.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_template_facts "Retrieve facts about one or more oVirt/RHV templates relate to a storage domain." b
- name: $1
	ovirt_storage_template_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: no
		# max: # Sets the maximum number of templates to return. If not specified all the templates are returned.
		# storage_domain: # The storage domain name where the templates should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_template "Module to manage virtual machine templates in oVirt/RHV" b
- name: $1
	ovirt_template:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the template to manage.
		# id: # ID of the template to be registered.
		# state: #present|absent|exported|imported|registered
		# vm: # Name of the VM, which will be used to create template.
		# description: # Description of the template.
		# cpu_profile: # CPU profile to be set to template.
		# cluster: # Name of the cluster, where template should be created/imported.
		# allow_partial_import: # Boolean indication whether to allow partial registration of a template when C(state) is registered.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# cluster_mappings: # Mapper which maps cluster name between Template's OVF and the destination cluster this Template should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# role_mappings: # Mapper which maps role name between Template's OVF and the destination role this Template should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# domain_mappings: # Mapper which maps aaa domain name between Template's OVF and the destination aaa domain this Template should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# exclusive: # When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.
		# export_domain: # When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.
		# image_provider: # When C(state) is I(imported) this parameter specifies the name of the image provider to be used.
		# image_disk: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.
		# io_threads: # Number of IO threads used by virtual machine. I(0) means IO threading disabled.
		# template_image_disk_name: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the new name for imported disk, if omitted then I(image_disk) name is used by default. This parameter is used only in case of importing disk image from Glance domain.
		# storage_domain: # When C(state) is I(imported) this parameter specifies the name of the destination data storage domain. When C(state) is I(registered) this parameter specifies the name of the data storage domain of the unregistered template.
		# clone_permissions: no
		# seal: no
		# operating_system: # Operating system of the template.
		# memory: # Amount of memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_guaranteed: # Amount of minimal guaranteed memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_max: # Upper bound of template memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_network "Module to manage logical networks in oVirt/RHV" b
- name: $1
	ovirt_network:
		name: ${2:# Name of the network to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# data_center: # Datacenter name where network reside.
		# description: # Description of the network.
		# comment: # Comment of the network.
		# vlan_tag: # Specify VLAN tag.
		# vm_network: # If I(True) network will be marked as network for VM.
		# mtu: # Maximum transmission unit (MTU) of the network.
		# clusters: # List of dictionaries describing how the network is managed in specific cluster.
		# label: # Name of the label to assign to the network.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_nic_facts "Retrieve facts about one or more oVirt/RHV virtual machine network interfaces" b
- name: $1
	ovirt_nic_facts:
		vm: ${2:# Name of the VM where NIC is attached.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the NIC, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_auth "Module to manage authentication to oVirt/RHV" b
- name: $1
	ovirt_auth:
		# state: #present|absent
		# username: # The name of the user. For example: I(admin@internal) Default value is set by I(OVIRT_USERNAME) environment variable.
		# password: # The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.
		# token: # SSO token to be used instead of login with username/password. Default value is set by I(OVIRT_TOKEN) environment variable.
		# url: # A string containing the API URL of the server. For example: I(https://server.example.com/ovirt-engine/api). Default value is set by I(OVIRT_URL) environment variable.
		# hostname: # A string containing the hostname of the server. For example: I(server.example.com). Default value is set by I(OVIRT_HOSTNAME) environment variable.
		# insecure: # A boolean flag that indicates if the server TLS certificate and host name should be checked.
		# ca_file: # A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used. Default value is set by I(OVIRT_CAFILE) environment variable.
		# timeout: # The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.
		# compress: # A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).
		# kerberos: # A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.
		# headers: # A dictionary of HTTP headers to be added to each API call.
$0
endsnippet

snippet ovirt_template_facts "Retrieve facts about one or more oVirt/RHV templates" b
- name: $1
	ovirt_template_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_cluster_facts "Retrieve facts about one or more oVirt/RHV clusters" b
- name: $1
	ovirt_cluster_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_host_network "Module to manage host networks in oVirt/RHV" b
- name: $1
	ovirt_host_network:
		name: ${2:# Name of the host to manage networks for.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# bond: # Dictionary describing network bond:
		# interface: # Name of the network interface where logical network should be attached.
		# networks: # List of dictionary describing networks to be attached to interface or bond:
		# labels: # List of names of the network label to be assigned to bond or interface.
		# check: # If I(true) verify connectivity between host and engine.
		# save: # If I(true) network configuration will be persistent, by default they are temporary.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host "Module to manage hosts in oVirt/RHV" b
- name: $1
	ovirt_host:
		name: ${2:# Name of the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled|iscsidiscover|iscsilogin
		# comment: # Description of the host.
		# timeout: 600
		# cluster: # Name of the cluster, where host should be created.
		# address: # Host address. It can be either FQDN (preferred) or IP address.
		# password: # Password of the root. It's required in case C(public_key) is set to I(False).
		# public_key: no
		# kdump_integration: enabled|disabled
		# spm_priority: # SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.
		# override_iptables: # If True host iptables will be overridden by host deploy script.
		# force: no
		# override_display: # Override the display address of all VMs on this host with specified address.
		# kernel_params: # List of kernel boot parameters.
		# hosted_engine: deploy|undeploy
		# power_management_enabled: # Enable or disable power management of the host.
		# activate: yes
		# iscsi: # If C(state) is I(iscsidiscover) it means that the iscsi attribute is being used to discover targets
		# check_upgrade: yes
		# reboot_after_upgrade: yes
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vm "Module to manage Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_vm:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the Virtual Machine to manage.
		# id: # ID of the Virtual Machine to manage.
		# state: absent|next_run|#present|registered|running|stopped|suspended
		# cluster: # Name of the cluster, where Virtual Machine should be created.
		# allow_partial_import: # Boolean indication whether to allow partial registration of Virtual Machine when C(state) is registered.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# cluster_mappings: # Mapper which maps cluster name between VM's OVF and the destination cluster this VM should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# role_mappings: # Mapper which maps role name between VM's OVF and the destination role this VM should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# domain_mappings: # Mapper which maps aaa domain name between VM's OVF and the destination aaa domain this VM should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# affinity_group_mappings: # Mapper which maps affinty name between VM's OVF and the destination affinity this VM should be registered to, relevant when C(state) is registered.
		# affinity_label_mappings: # Mappper which maps affinity label name between VM's OVF and the destination label this VM should be registered to, relevant when C(state) is registered.
		# lun_mappings: # Mapper which maps lun between VM's OVF and the destination lun this VM should contain, relevant when C(state) is registered. lun_mappings is described by the following dictionary: - C(logical_unit_id): The logical unit number to identify a logical unit, - C(logical_unit_port): The port being used to connect with the LUN disk. - C(logical_unit_portal): The portal being used to connect with the LUN disk. - C(logical_unit_address): The address of the block storage host. - C(logical_unit_target): The iSCSI specification located on an iSCSI server - C(logical_unit_username): Username to be used to connect to the block storage host. - C(logical_unit_password): Password to be used to connect to the block storage host. - C(storage_type): The storage type which the LUN reside on (iscsi or fcp)
		# reassign_bad_macs: # Boolean indication whether to reassign bad macs when C(state) is registered.
		# template: # Name of the template, which should be used to create Virtual Machine.
		# template_version: # Version number of the template to be used for VM.
		# use_latest_template_version: # Specify if latest template version should be used, when running a stateless VM.
		# storage_domain: # Name of the storage domain where all template disks should be created.
		# disk_format: #cow|raw
		# memory: # Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_guaranteed: # Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_max: # Upper bound of virtual machine memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# cpu_shares: # Set a CPU shares for this Virtual Machine.
		# cpu_cores: # Number of virtual CPUs cores of the Virtual Machine.
		# cpu_sockets: # Number of virtual CPUs sockets of the Virtual Machine.
		# cpu_threads: # Number of virtual CPUs sockets of the Virtual Machine.
		# type: desktop|server|high_performance
		# quota_id: # Virtual Machine quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# operating_system: # Operating system of the Virtual Machine.
		# boot_devices: cdrom|hd|network
		# boot_menu: # I(True) enable menu to select boot device, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# usb_support: # I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# serial_console: # I(True) enable VirtIO serial console, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# sso: # I(True) enable Single Sign On by Guest Agent, I(False) to disable it. By default is chosen by oVirt/RHV engine.
		# host: # Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.
		# high_availability: # If I(yes) Virtual Machine will be set as highly available.
		# high_availability_priority: # Indicates the priority of the virtual machine inside the run and migration queues. Virtual machines with higher priorities will be started and migrated before virtual machines with lower priorities. The value is an integer between 0 and 100. The higher the value, the higher the priority.
		# lease: # Name of the storage domain this virtual machine lease reside on.
		# custom_compatibility_version: # Enables a virtual machine to be customized to its own compatibility version. If 'C(custom_compatibility_version)' is set, it overrides the cluster's compatibility version for this particular virtual machine.
		# host_devices: # Single Root I/O Virtualization - technology that allows single device to expose multiple endpoints that can be passed to VMs
		# delete_protected: # If I(yes) Virtual Machine will be set as delete protected.
		# stateless: # If I(yes) Virtual Machine will be set as stateless.
		# clone: no
		# clone_permissions: no
		# cd_iso: # ISO file from ISO storage domain which should be attached to Virtual Machine.
		# force: no
		# nics: # List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.
		# disks: # List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary.
		# sysprep: # Dictionary with values for Windows Virtual Machine initialization using sysprep.
		# cloud_init: # Dictionary with values for Unix-like Virtual Machine initialization using cloud init.
		# cloud_init_nics: # List of dictionaries representing network interfaces to be setup by cloud init.
		# cloud_init_persist: # If I(true) the C(cloud_init) or C(sysprep) parameters will be saved for the virtual machine and won't be virtual machine won't be started as run-once.
		# kernel_path: # Path to a kernel image used to boot the virtual machine.
		# initrd_path: # Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.
		# kernel_params: # Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.
		# instance_type: # Name of virtual machine's hardware configuration.
		# description: # Description of the Virtual Machine.
		# comment: # Comment of the Virtual Machine.
		# timezone: # Sets time zone offset of the guest hardware clock.
		# serial_policy: vm|host|custom
		# serial_policy_value: # Allows you to specify a custom serial number.
		# vmware: # Dictionary of values to be used to connect to VMware and import a virtual machine to oVirt.
		# xen: # Dictionary of values to be used to connect to XEN and import a virtual machine to oVirt.
		# kvm: # Dictionary of values to be used to connect to kvm and import a virtual machine to oVirt.
		# cpu_mode: # CPU mode of the virtual machine. It can be some of the following: I(host_passthrough), I(host_model) or I(custom).
		# placement_policy: # The configuration of the virtual machine's placement policy.
		# ticket: # If I(true), in addition return I(remote_vv_file) inside I(vm) dictionary, which contains compatible content for remote-viewer application. Works only C(state) is I(running).
		# cpu_pinning: # CPU Pinning topology to map virtual machine CPU to host CPU.
		# soundcard_enabled: # If I(true), the sound card is added to the virtual machine.
		# smartcard_enabled: # If I(true), use smart card authentication.
		# io_threads: # Number of IO threads used by virtual machine. I(0) means IO threading disabled.
		# ballooning_enabled: # If I(true), use memory ballooning.
		# numa_tune_mode: interleave|preferred|strict
		# numa_nodes: # List of vNUMA Nodes to set for this VM and pin them to assigned host's physical NUMA node.
		# rng_device: # Random number generator (RNG). You can choose of one the following devices I(urandom), I(random) or I(hwrng).
		# custom_properties: # Properties sent to VDSM to configure various hooks.
		# watchdog: # Assign watchdog device for the virtual machine.
		# graphical_console: # Assign graphical console to the virtual machine.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_template_facts "Retrieve facts about one or more oVirt/RHV templates" b
- name: $1
	ovirt_template_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_template "Module to manage virtual machine templates in oVirt/RHV" b
- name: $1
	ovirt_template:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the template to manage.
		# id: # ID of the template to be registered.
		# state: #present|absent|exported|imported|registered
		# vm: # Name of the VM, which will be used to create template.
		# description: # Description of the template.
		# cpu_profile: # CPU profile to be set to template.
		# cluster: # Name of the cluster, where template should be created/imported.
		# allow_partial_import: # Boolean indication whether to allow partial registration of a template when C(state) is registered.
		# vnic_profile_mappings: # Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:
		# cluster_mappings: # Mapper which maps cluster name between Template's OVF and the destination cluster this Template should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:
		# role_mappings: # Mapper which maps role name between Template's OVF and the destination role this Template should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:
		# domain_mappings: # Mapper which maps aaa domain name between Template's OVF and the destination aaa domain this Template should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:
		# exclusive: # When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.
		# export_domain: # When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.
		# image_provider: # When C(state) is I(imported) this parameter specifies the name of the image provider to be used.
		# image_disk: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.
		# io_threads: # Number of IO threads used by virtual machine. I(0) means IO threading disabled.
		# template_image_disk_name: # When C(state) is I(imported) and C(image_provider) is used this parameter specifies the new name for imported disk, if omitted then I(image_disk) name is used by default. This parameter is used only in case of importing disk image from Glance domain.
		# storage_domain: # When C(state) is I(imported) this parameter specifies the name of the destination data storage domain. When C(state) is I(registered) this parameter specifies the name of the data storage domain of the unregistered template.
		# clone_permissions: no
		# seal: no
		# operating_system: # Operating system of the template.
		# memory: # Amount of memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_guaranteed: # Amount of minimal guaranteed memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# memory_max: # Upper bound of template memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host_facts "Retrieve facts about one or more oVirt/RHV hosts" b
- name: $1
	ovirt_host_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# all_content: no
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_group_facts "Retrieve facts about one or more oVirt/RHV groups" b
- name: $1
	ovirt_group_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_user "Module to manage users in oVirt/RHV" b
- name: $1
	ovirt_user:
		name: ${2:# Name of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		authz_name: ${3:# Authorization provider of the user. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# namespace: # Namespace where the user resides. When using the authorization provider that stores users in the LDAP server, this attribute equals the naming context of the LDAP server.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_domain "Module to manage storage domains in oVirt/RHV" b
- name: $1
	ovirt_storage_domain:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # Id of the storage domain to be imported.
		# name: # Name of the storage domain to manage. (Not required when state is I(imported))
		# state: #present|absent|maintenance|unattached|imported|update_ovf_store
		# description: # Description of the storage domain.
		# comment: # Comment of the storage domain.
		# data_center: # Data center name where storage domain should be attached.
		# domain_function: #data|iso|export
		# host: # Host to be used to mount storage.
		# localfs: # Dictionary with values for localfs storage type:
		# nfs: # Dictionary with values for NFS storage type:
		# iscsi: # Dictionary with values for iSCSI storage type:
		# posixfs: # Dictionary with values for PosixFS storage type:
		# glusterfs: # Dictionary with values for GlusterFS storage type:
		# fcp: # Dictionary with values for fibre channel storage type:
		# wipe_after_delete: # Boolean flag which indicates whether the storage domain should wipe the data after delete.
		# backup: # Boolean flag which indicates whether the storage domain is configured as backup or not.
		# critical_space_action_blocker: # Indicates the minimal free space the storage domain should contain in percentages.
		# warning_low_space: # Indicates the minimum percentage of a free space in a storage domain to present a warning.
		# destroy: # Logical remove of the storage domain. If I(true) retains the storage domain's data for import.
		# format: # If I(True) storage domain will be formatted after removing it from oVirt/RHV.
		# discard_after_delete: # If I(True) storage domain blocks will be discarded upon deletion. Enabled by default.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
- name: $1
	ovirt_disk:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# id: # ID of the disk to manage. Either C(id) or C(name) is required.
		# name: # Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.
		# description: # Description of the disk image to manage.
		# vm_name: # Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# vm_id: # ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).
		# state: #present|absent|attached|detached
		# download_image_path: # Path on a file system where disk should be downloaded.
		# upload_image_path: # Path to disk image, which should be uploaded.
		# size: # Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.
		# interface: #virtio|ide|virtio_scsi
		# format: raw|cow
		# sparse: # I(True) if the disk should be sparse (also known as I(thin provision)). If the parameter is omitted, cow disks will be created as sparse and raw disks as I(preallocated)
		# storage_domain: # Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.
		# storage_domains: # Storage domain names where disk should be copied.
		# force: # Please take a look at C(image_path) documentation to see the correct usage of this parameter.
		# profile: # Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.
		# quota_id: # Disk quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.
		# bootable: # I(True) if the disk should be bootable. By default when disk is created it isn't bootable.
		# shareable: # I(True) if the disk should be shareable. By default when disk is created it isn't shareable.
		# logical_unit: # Dictionary which describes LUN to be directly attached to VM:
		# sparsify: # I(True) if the disk should be sparsified.
		# openstack_volume_type: # Name of the openstack volume type. This is valid when working with cinder.
		# image_provider: # When C(state) is I(exported) disk is exported to given Glance image provider.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vmpool_facts "Retrieve facts about one or more oVirt/RHV vmpools" b
- name: $1
	ovirt_vmpool_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_datacenter_facts "Retrieve facts about one or more oVirt/RHV datacenters" b
- name: $1
	ovirt_datacenter_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
- name: $1
	ovirt_affinity_group:
		name: ${2:# Name of the affinity group to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: absent|#present
		# cluster: # Name of the cluster of the affinity group.
		# description: # Description of the affinity group.
		# host_enforcing: # If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).
		# host_rule: negative|positive
		# vm_enforcing: # If I(yes) VM cannot start if it does not satisfy the C(vm_rule).
		# vm_rule: disabled|negative|positive
		# vms: # List of the VMs names, which should have assigned this affinity group.
		# hosts: # List of the hosts names, which should have assigned this affinity group.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_scheduling_policy_facts "Retrieve facts about one or more oVirt scheduling policies" b
- name: $1
	ovirt_scheduling_policy_facts:
		id: ${2:# ID of the scheduling policy.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the scheduling policy, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_external_provider_facts "Retrieve facts about one or more oVirt/RHV external providers" b
- name: $1
	ovirt_external_provider_facts:
		type: ${2:os_image|os_network|os_volume|foreman}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the external provider, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_quota "Module to manage datacenter quotas in oVirt/RHV" b
- name: $1
	ovirt_quota:
		name: ${2:# Name of the quota to manage.}
		data_center: ${3:# Name of the datacenter where quota should be managed.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# description: # Description of the quota to manage.
		# cluster_threshold: # Cluster threshold(soft limit) defined in percentage (0-100).
		# cluster_grace: # Cluster grace(hard limit) defined in percentage (1-100).
		# storage_threshold: # Storage threshold(soft limit) defined in percentage (0-100).
		# storage_grace: # Storage grace(hard limit) defined in percentage (1-100).
		# clusters: # List of dictionary of cluster limits, which is valid to specific cluster.
		# storages: # List of dictionary of storage limits, which is valid to specific storage.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_quota_facts "Retrieve facts about one or more oVirt/RHV quotas" b
- name: $1
	ovirt_quota_facts:
		data_center: ${2:# Name of the datacenter where quota resides.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the quota, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_quota_facts "Retrieve facts about one or more oVirt/RHV quotas" b
- name: $1
	ovirt_quota_facts:
		data_center: ${2:# Name of the datacenter where quota resides.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the quota, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_vmpool "Module to manage VM pools in oVirt/RHV" b
- name: $1
	ovirt_vmpool:
		name: ${2:# Name of the VM pool to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# comment: # Comment of the Virtual Machine pool.
		# state: #present|absent
		# template: # Name of the template, which will be used to create VM pool.
		# description: # Description of the VM pool.
		# cluster: # Name of the cluster, where VM pool should be created.
		# type: manual|automatic
		# vm_per_user: # Maximum number of VMs a single user can attach to from this pool.
		# prestarted: # Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.
		# vm_count: # Number of VMs in the pool.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_quota "Module to manage datacenter quotas in oVirt/RHV" b
- name: $1
	ovirt_quota:
		name: ${2:# Name of the quota to manage.}
		data_center: ${3:# Name of the datacenter where quota should be managed.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# description: # Description of the quota to manage.
		# cluster_threshold: # Cluster threshold(soft limit) defined in percentage (0-100).
		# cluster_grace: # Cluster grace(hard limit) defined in percentage (1-100).
		# storage_threshold: # Storage threshold(soft limit) defined in percentage (0-100).
		# storage_grace: # Storage grace(hard limit) defined in percentage (1-100).
		# clusters: # List of dictionary of cluster limits, which is valid to specific cluster.
		# storages: # List of dictionary of storage limits, which is valid to specific storage.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
- name: $1
	ovirt_datacenter:
		name: ${2:# Name of the data center to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# description: # Description of the data center.
		# comment: # Comment of the data center.
		# local: # I(True) if the data center should be local, I(False) if should be shared.
		# compatibility_version: # Compatibility version of the data center.
		# quota_mode: disabled|audit|enabled
		# mac_pool: # MAC pool to be used by this datacenter.
		# force: no
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
- name: $1
	ovirt_affinity_label:
		name: ${2:# Name of the affinity label to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# cluster: # Name of the cluster where vms and hosts resides.
		# vms: # List of the VMs names, which should have assigned this affinity label.
		# hosts: # List of the hosts names, which should have assigned this affinity label.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vmpool_facts "Retrieve facts about one or more oVirt/RHV vmpools" b
- name: $1
	ovirt_vmpool_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_permission "Module to manage permissions of users/groups in oVirt/RHV" b
- name: $1
	ovirt_permission:
		authz_name: ${2:# Authorization provider of the user/group.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# role: UserRole
		# state: absent|#present
		# object_id: # ID of the object where the permissions should be managed.
		# object_name: # Name of the object where the permissions should be managed.
		# object_type: cluster|cpu_profile|data_center|disk|disk_profile|host|network|storage_domain|system|template|#vm|vm_pool|vnic_profile
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
		# group_name: # Name of the group to manage.
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# quota_name: # Name of the quota to assign permission. Works only with C(object_type) I(data_center).
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
- name: $1
	ovirt_external_provider:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the external provider to manage.
		# state: #present|absent
		# description: # Description of the external provider.
		# type: os_image|network|os_volume|foreman
		# url: # URL where external provider is hosted.
		# username: # Username to be used for login to external provider.
		# password: # Password of the user specified in C(username) parameter.
		# tenant_name: # Name of the tenant.
		# authentication_url: # Keystone authentication URL of the openstack provider.
		# data_center: # Name of the data center where provider should be attached.
		# read_only: # Specify if the network should be read only.
		# network_type: [#'external', 'neutron'
		# authentication_keys: []
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		name: ${2:# Name of the cluster to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# data_center: # Datacenter name where cluster reside.
		# description: # Description of the cluster.
		# comment: # Comment of the cluster.
		# network: # Management network of cluster to access cluster hosts.
		# ballooning: # If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.
		# virt: # If I(True), hosts in this cluster will be used to run virtual machines.
		# gluster: # If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.
		# threads_as_cores: # If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.
		# ksm: # I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.
		# ksm_numa: # If I(True) enables KSM C(ksm) for best performance inside NUMA nodes.
		# ha_reservation: # If I(True) enables the oVirt/RHV to monitor cluster capacity for highly available virtual machines.
		# trusted_service: # If I(True) enables integration with an OpenAttestation server.
		# vm_reason: # If I(True) enables an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# host_reason: # If I(True) enables an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# memory_policy: disabled|server|desktop
		# rng_sources: # List that specify the random number generator devices that all hosts in the cluster will use.
		# spice_proxy: # The proxy by which the SPICE client will connect to virtual machines.
		# fence_enabled: # If I(True) enables fencing on the cluster.
		# fence_skip_if_sd_active: # If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.
		# fence_skip_if_connectivity_broken: # If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.
		# fence_connectivity_threshold: # The threshold used by C(fence_skip_if_connectivity_broken).
		# resilience_policy: do_not_migrate|migrate|migrate_highly_available
		# migration_bandwidth: auto|hypervisor_default|custom
		# migration_bandwidth_limit: # Set the I(custom) migration bandwidth limit.
		# migration_auto_converge: true|false|inherit
		# migration_compressed: true|false|inherit
		# migration_policy: legacy|minimal_downtime|suspend_workload|post_copy
		# serial_policy: # Specify a serial number policy for the virtual machines in the cluster.
		# serial_policy_value: # Allows you to specify a custom serial number.
		# scheduling_policy: # Name of the scheduling policy to be used for cluster.
		# scheduling_policy_properties: # Custom scheduling policy properties of the cluster.
		# cpu_arch: x86_64|ppc64|undefined
		# cpu_type: # CPU codename. For example I(Intel SandyBridge Family).
		# switch_type: legacy|ovs
		# compatibility_version: # The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.
		# mac_pool: # MAC pool to be used by this cluster.
		# external_network_providers: # List of references to the external network providers available in the cluster. If the automatic deployment of the external network provider is supported, the networks of the referenced network provider are available on every host in the cluster.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_disk_facts "Retrieve facts about one or more oVirt/RHV disks" b
- name: $1
	ovirt_disk_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_network_facts "Retrieve facts about one or more oVirt/RHV networks" b
- name: $1
	ovirt_network_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_tag_facts "Retrieve facts about one or more oVirt/RHV tags" b
- name: $1
	ovirt_tag_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the tag which should be listed.
		# vm: # Name of the VM, which tags should be listed.
		# host: # Name of the host, which tags should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
- name: $1
	ovirt_cluster:
		name: ${2:# Name of the cluster to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# data_center: # Datacenter name where cluster reside.
		# description: # Description of the cluster.
		# comment: # Comment of the cluster.
		# network: # Management network of cluster to access cluster hosts.
		# ballooning: # If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.
		# virt: # If I(True), hosts in this cluster will be used to run virtual machines.
		# gluster: # If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.
		# threads_as_cores: # If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.
		# ksm: # I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.
		# ksm_numa: # If I(True) enables KSM C(ksm) for best performance inside NUMA nodes.
		# ha_reservation: # If I(True) enables the oVirt/RHV to monitor cluster capacity for highly available virtual machines.
		# trusted_service: # If I(True) enables integration with an OpenAttestation server.
		# vm_reason: # If I(True) enables an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# host_reason: # If I(True) enables an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.
		# memory_policy: disabled|server|desktop
		# rng_sources: # List that specify the random number generator devices that all hosts in the cluster will use.
		# spice_proxy: # The proxy by which the SPICE client will connect to virtual machines.
		# fence_enabled: # If I(True) enables fencing on the cluster.
		# fence_skip_if_sd_active: # If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.
		# fence_skip_if_connectivity_broken: # If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.
		# fence_connectivity_threshold: # The threshold used by C(fence_skip_if_connectivity_broken).
		# resilience_policy: do_not_migrate|migrate|migrate_highly_available
		# migration_bandwidth: auto|hypervisor_default|custom
		# migration_bandwidth_limit: # Set the I(custom) migration bandwidth limit.
		# migration_auto_converge: true|false|inherit
		# migration_compressed: true|false|inherit
		# migration_policy: legacy|minimal_downtime|suspend_workload|post_copy
		# serial_policy: # Specify a serial number policy for the virtual machines in the cluster.
		# serial_policy_value: # Allows you to specify a custom serial number.
		# scheduling_policy: # Name of the scheduling policy to be used for cluster.
		# scheduling_policy_properties: # Custom scheduling policy properties of the cluster.
		# cpu_arch: x86_64|ppc64|undefined
		# cpu_type: # CPU codename. For example I(Intel SandyBridge Family).
		# switch_type: legacy|ovs
		# compatibility_version: # The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.
		# mac_pool: # MAC pool to be used by this cluster.
		# external_network_providers: # List of references to the external network providers available in the cluster. If the automatic deployment of the external network provider is supported, the networks of the referenced network provider are available on every host in the cluster.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host "Module to manage hosts in oVirt/RHV" b
- name: $1
	ovirt_host:
		name: ${2:# Name of the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled|iscsidiscover|iscsilogin
		# comment: # Description of the host.
		# timeout: 600
		# cluster: # Name of the cluster, where host should be created.
		# address: # Host address. It can be either FQDN (preferred) or IP address.
		# password: # Password of the root. It's required in case C(public_key) is set to I(False).
		# public_key: no
		# kdump_integration: enabled|disabled
		# spm_priority: # SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.
		# override_iptables: # If True host iptables will be overridden by host deploy script.
		# force: no
		# override_display: # Override the display address of all VMs on this host with specified address.
		# kernel_params: # List of kernel boot parameters.
		# hosted_engine: deploy|undeploy
		# power_management_enabled: # Enable or disable power management of the host.
		# activate: yes
		# iscsi: # If C(state) is I(iscsidiscover) it means that the iscsi attribute is being used to discover targets
		# check_upgrade: yes
		# reboot_after_upgrade: yes
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host_pm "Module to manage power management of hosts in oVirt/RHV" b
- name: $1
	ovirt_host_pm:
		name: ${2:# Name of the host to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# address: # Address of the power management interface.
		# username: # Username to be used to connect to power management interface.
		# password: # Password of the user specified in C(username) parameter.
		# type: # Type of the power management. oVirt/RHV predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type.
		# port: # Power management interface port.
		# options: # Dictionary of additional fence agent options (including Power Management slot).
		# encrypt_options: # If I(true) options will be encrypted when send to agent.
		# order: # Integer value specifying, by default it's added at the end.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_host_network "Module to manage host networks in oVirt/RHV" b
- name: $1
	ovirt_host_network:
		name: ${2:# Name of the host to manage networks for.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# bond: # Dictionary describing network bond:
		# interface: # Name of the network interface where logical network should be attached.
		# networks: # List of dictionary describing networks to be attached to interface or bond:
		# labels: # List of names of the network label to be assigned to bond or interface.
		# check: # If I(true) verify connectivity between host and engine.
		# save: # If I(true) network configuration will be persistent, by default they are temporary.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_user "Module to manage users in oVirt/RHV" b
- name: $1
	ovirt_user:
		name: ${2:# Name of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
		authz_name: ${3:# Authorization provider of the user. In previous versions of oVirt/RHV known as domain.}
		auth: ${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# namespace: # Namespace where the user resides. When using the authorization provider that stores users in the LDAP server, this attribute equals the naming context of the LDAP server.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_permission_facts "Retrieve facts about one or more oVirt/RHV permissions" b
- name: $1
	ovirt_permission_facts:
		authz_name: ${2:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# user_name: # Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
		# group_name: # Name of the group to manage.
		# namespace: # Namespace of the authorization provider, where user/group resides.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_nic "Module to manage network interfaces of Virtual Machines in oVirt/RHV" b
- name: $1
	ovirt_nic:
		name: ${2:# Name of the network interface to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# vm: # Name of the Virtual Machine to manage.
		# template: # Name of the template to manage.
		# state: absent|plugged|#present|unplugged
		# network: # Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.
		# profile: # Virtual network interface profile to be attached to VM network interface.
		# interface: # Type of the network interface. For example e1000, pci_passthrough, rtl8139, rtl8139_virtio, spapr_vlan or virtio.
		# mac_address: # Custom MAC address of the network interface, by default it's obtained from MAC pool.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_storage_vm_facts "Retrieve facts about one or more oVirt/RHV virtual machines relate to a storage domain." b
- name: $1
	ovirt_storage_vm_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# unregistered: no
		# max: # Sets the maximum number of virtual machines to return. If not specified all the virtual machines are returned.
		# storage_domain: # The storage domain name where the virtual machines should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_tag "Module to manage tags in oVirt/RHV" b
- name: $1
	ovirt_tag:
		name: ${2:# Name of the tag to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent|attached|detached
		# description: # Description of the tag to manage.
		# parent: # Name of the parent tag.
		# vms: # List of the VMs names, which should have assigned this tag.
		# hosts: # List of the hosts names, which should have assigned this tag.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_network_facts "Retrieve facts about one or more oVirt/RHV networks" b
- name: $1
	ovirt_network_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_network "Module to manage logical networks in oVirt/RHV" b
- name: $1
	ovirt_network:
		name: ${2:# Name of the network to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent
		# data_center: # Datacenter name where network reside.
		# description: # Description of the network.
		# comment: # Comment of the network.
		# vlan_tag: # Specify VLAN tag.
		# vm_network: # If I(True) network will be marked as network for VM.
		# mtu: # Maximum transmission unit (MTU) of the network.
		# clusters: # List of dictionaries describing how the network is managed in specific cluster.
		# label: # Name of the label to assign to the network.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_tag_facts "Retrieve facts about one or more oVirt/RHV tags" b
- name: $1
	ovirt_tag_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the tag which should be listed.
		# vm: # Name of the VM, which tags should be listed.
		# host: # Name of the host, which tags should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_affinity_label_facts "Retrieve facts about one or more oVirt/RHV affinity labels" b
- name: $1
	ovirt_affinity_label_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the affinity labels which should be listed.
		# vm: # Name of the VM, which affinity labels should be listed.
		# host: # Name of the host, which affinity labels should be listed.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_tag "Module to manage tags in oVirt/RHV" b
- name: $1
	ovirt_tag:
		name: ${2:# Name of the tag to manage.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# state: #present|absent|attached|detached
		# description: # Description of the tag to manage.
		# parent: # Name of the parent tag.
		# vms: # List of the VMs names, which should have assigned this tag.
		# hosts: # List of the hosts names, which should have assigned this tag.
		# wait: yes
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
		# timeout: 180
		# poll_interval: 3
$0
endsnippet

snippet ovirt_vm_facts "Retrieve facts about one or more oVirt/RHV virtual machines" b
- name: $1
	ovirt_vm_facts:
		auth: ${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# pattern: # Search term which is accepted by oVirt/RHV search backend.
		# all_content: # If I(true) all the attributes of the virtual machines should be included in the response.
		# case_sensitive: yes
		# max: # The maximum number of results to return.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_snapshot_facts "Retrieve facts about one or more oVirt/RHV virtual machine snapshots" b
- name: $1
	ovirt_snapshot_facts:
		vm: ${2:# Name of the VM with snapshot.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# description: # Description of the snapshot, can be used as glob expression.
		# snapshot_id: # Id of the snapshot we want to retrieve facts about.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet ovirt_scheduling_policy_facts "Retrieve facts about one or more oVirt scheduling policies" b
- name: $1
	ovirt_scheduling_policy_facts:
		id: ${2:# ID of the scheduling policy.}
		auth: ${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}
		# name: # Name of the scheduling policy, can be used as glob expression.
		# fetch_nested: # If I(True) the module will fetch additional data from the API.
		# nested_attributes: # Specifies list of the attributes which should be fetched from the API.
$0
endsnippet

snippet packet_device "Manage a bare metal server in the Packet Host." b
- name: $1
	packet_device:
		project_id: ${2:# ID of project of the device.}
		# auth_token: # Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).
		# count: 1
		# count_offset: 1
		# device_ids: # List of device IDs on which to operate.
		# facility: # Facility slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/facilities/).
		# features: # Dict with "features" for device creation. See Packet API docs for details.
		# hostnames: # A hostname of a device, or a list of hostnames.
		# locked: no
		# operating_system: # OS slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/operatingsystems/).
		# plan: # Plan slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/plans/).
		# state: #present|absent|active|inactive|rebooted
		# user_data: # Userdata blob made available to the machine
		# wait_for_public_IPv: 4|6
		# wait_timeout: 900
		# ipxe_script_url: # URL of custom iPXE script for provisioning.
		# always_pxe: no
$0
endsnippet

snippet packet_sshkey "Create/delete an SSH key in Packet host." b
- name: $1
	packet_sshkey:
		# state: #present|absent
		# auth_token: # Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).
		# label: # Label for the key. If you keep it empty, it will be read from key string.
		# id: # UUID of the key which you want to remove.
		# fingerprint: # Fingerprint of the key which you want to remove.
		# key: # Public Key string ({type} {base64 encoded key} {description}).
		# key_file: # File with the public key.
$0
endsnippet

snippet udm_user "Manage posix users on a univention corporate server" b
- name: $1
	udm_user:
		username: ${2:# User name}
		# state: #present|absent
		# firstname: # First name. Required if C(state=present).
		# lastname: # Last name. Required if C(state=present).
		# password: # Password. Required if C(state=present).
		# birthday: # Birthday
		# city: # City of users business address.
		# country: # Country of users business address.
		# department_number: # Department number of users business address.
		# description: # Description (not gecos)
		# display_name: # Display name (not gecos)
		# email: []
		# employee_number: # Employee number
		# employee_type: # Employee type
		# gecos: # GECOS
		# groups: []
		# home_share: # Home NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com).
		# home_share_path: # Path to home NFS share, inside the homeShare.
		# home_telephone_number: []
		# homedrive: # Windows home drive, e.g. C("H:").
		# mail_alternative_address: []
		# mail_home_server: # FQDN of mail server
		# mail_primary_address: # Primary e-mail address
		# mobile_telephone_number: []
		# organisation: # Organisation
		# override_pw_history: no
		# override_pw_length: no
		# pager_telephonenumber: []
		# phone: # List of telephone numbers.
		# postcode: # Postal code of users business address.
		# primary_group: cn=Domain Users,cn=groups,$LDAP_BASE_DN
		# profilepath: # Windows profile directory
		# pwd_change_next_login: 0|1
		# room_number: # Room number of users business address.
		# samba_privileges: # Samba privilege, like allow printer administration, do domain join.
		# samba_user_workstations: # Allow the authentication only on this Microsoft Windows host.
		# sambahome: # Windows home path, e.g. C('\\$FQDN\$USERNAME').
		# scriptpath: # Windows logon script.
		# secretary: []
		# serviceprovider: []
		# shell: /bin/bash
		# street: # Street of users business address.
		# title: # Title, e.g. C(Prof.).
		# unixhome: /home/$USERNAME
		# userexpiry: Today + 1 year
		# position: 
		# update_password: always
		# ou: 
		# subpath: cn=users
$0
endsnippet

snippet udm_share "Manage samba shares on a univention corporate server" b
- name: $1
	udm_share:
		name: ${2:# Name}
		ou: ${3:# Organisational unit, inside the LDAP Base DN.}
		# state: #present|absent
		# host: # Host FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present).
		# path: # Directory on the providing server, e.g. C(/home). Required if C(state=present).
		# samba_name: # Windows name. Required if C(state=present).
		# owner: 0
		# group: 0
		# directorymode: 00755
		# root_squash: 0|#1
		# subtree_checking: 0|#1
		# sync: sync
		# writeable: 0|#1
		# samba_block_size: # Blocking size.
		# samba_blocking_locks: 0|#1
		# samba_browseable: 0|#1
		# samba_create_mode: 0744
		# samba_csc_policy: manual
		# samba_custom_settings: []
		# samba_directory_mode: 0755
		# samba_directory_security_mode: 0777
		# samba_dos_filemode: #0|1
		# samba_fake_oplocks: #0|1
		# samba_force_create_mode: #0|1
		# samba_force_directory_mode: #0|1
		# samba_force_directory_security_mode: #0|1
		# samba_force_group: # Force group.
		# samba_force_security_mode: #0|1
		# samba_force_user: # Force user.
		# samba_hide_files: # Hide files.
		# samba_hide_unreadable: #0|1
		# samba_hosts_allow: []
		# samba_hosts_deny: []
		# samba_inherit_acls: 0|#1
		# samba_inherit_owner: #0|1
		# samba_inherit_permissions: #0|1
		# samba_invalid_users: # Invalid users or groups.
		# samba_level_2_oplocks: 0|#1
		# samba_locking: 0|#1
		# samba_msdfs_root: #0|1
		# samba_nt_acl_support: 0|#1
		# samba_oplocks: 0|#1
		# samba_postexec: # Postexec script.
		# samba_preexec: # Preexec script.
		# samba_public: #0|1
		# samba_security_mode: 0777
		# samba_strict_locking: Auto
		# samba_vfs_objects: # VFS objects.
		# samba_valid_users: # Valid users or groups.
		# samba_write_list: # Restrict write access to these users/groups.
		# samba_writeable: 0|#1
		# nfs_hosts: []
		# nfs_custom_settings: []
$0
endsnippet

snippet udm_group "Manage of the posix group" b
- name: $1
	udm_group:
		name: ${2:# Name of the posix group.}
		# state: #present|absent
		# description: # Group description.
		# position: # define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).
		# ou: # LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).
		# subpath: # Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).
$0
endsnippet

snippet udm_dns_record "Manage dns entries on a univention corporate server" b
- name: $1
	udm_dns_record:
		name: ${2:# Name of the record, this is also the DNS record. E.g. www for www.example.com.}
		zone: ${3:# Corresponding DNS zone for this record, e.g. example.com.}
		type: ${4:host_record|alias|ptr_record|srv_record|txt_record}
		# state: #present|absent
		# data: []
$0
endsnippet

snippet udm_dns_zone "Manage dns zones on a univention corporate server" b
- name: $1
	udm_dns_zone:
		type: ${2:forward_zone|reverse_zone}
		zone: ${3:# DNS zone name, e.g. C(example.com).}
		# state: #present|absent
		# nameserver: # List of appropriate name servers. Required if C(state=present).
		# interfaces: # List of interface IP addresses, on which the server should response this zone. Required if C(state=present).
		# refresh: 3600
		# retry: 1800
		# expire: 604800
		# ttl: 600
		# contact: 
		# mx: []
$0
endsnippet

snippet one_image "Manages OpenNebula images" b
- name: $1
	one_image:
		# api_url: # URL of the OpenNebula RPC server.
		# api_username: # Name of the user to login into the OpenNebula RPC server. If not set
		# api_password: # Password of the user to login into OpenNebula RPC server. If not set
		# id: # A C(id) of the image you would like to manage.
		# name: # A C(name) of the image you would like to manage.
		# state: #present|absent|cloned|renamed
		# enabled: # Whether the image should be enabled or disabled.
		# new_name: # A name that will be assigned to the existing or new image.
$0
endsnippet

snippet one_image_facts "Gather facts about OpenNebula images" b
- name: $1
	one_image_facts:
		# api_url: # URL of the OpenNebula RPC server.
		# api_username: # Name of the user to login into the OpenNebula RPC server. If not set
		# api_password: # Password of the user to login into OpenNebula RPC server. If not set
		# ids: # A list of images ids whose facts you want to gather.
		# name: # A C(name) of the image whose facts will be gathered.
$0
endsnippet

snippet one_vm "Creates or terminates OpenNebula instances" b
- name: $1
	one_vm:
		# api_url: # URL of the OpenNebula RPC server.
		# api_username: # Name of the user to login into the OpenNebula RPC server. If not set
		# api_password: # Password of the user to login into OpenNebula RPC server. If not set
		# template_name: # Name of VM template to use to create a new instace
		# template_id: # ID of a VM template to use to create a new instance
		# instance_ids: # A list of instance ids used for states':' C(absent), C(running), C(rebooted), C(poweredoff)
		# state: #present|absent|running|rebooted|poweredoff
		# hard: no
		# wait: yes
		# wait_timeout: 300
		# attributes: {}
		# labels: []
		# count_attributes: # A dictionary of key/value attributes that can only be used with
		# count_labels: # A list of labels that can only be used with C(exact_count) to determine
		# count: 1
		# exact_count: # Indicates how many instances that match C(count_attributes) and
		# mode: # Set permission mode of the instance in octet format, e.g. C(600) to give owner C(use) and C(manage) and nothing to group and others.
		# owner_id: # ID of the user which will be set as the owner of the instance
		# group_id: # ID of the group which will be set as the group of the instance
		# memory: # The size of the memory for new instances (in MB, GB, ...)
		# disk_size: # The size of the disk created for new instances (in MB, GB, TB,...).
		# cpu: # Percentage of CPU divided by 100 required for the new instance. Half a
		# vcpu: # Number of CPUs (cores) new VM will have.
		# networks: []
		# disk_saveas: # Creates an image from a VM disk.
$0
endsnippet

snippet one_service "Deploy and manage OpenNebula services" b
- name: $1
	one_service:
		# api_url: # URL of the OpenNebula OneFlow API server.
		# api_username: # Name of the user to login into the OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_USERNAME) environment variable is used.
		# api_password: # Password of the user to login into OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_PASSWORD) environment variable is used.
		# template_name: # Name of service template to use to create a new instace of a service
		# template_id: # ID of a service template to use to create a new instance of a service
		# service_id: # ID of a service instance that you would like to manage
		# service_name: # Name of a service instance that you would like to manage
		# unique: no
		# state: #present|absent
		# mode: # Set permission mode of a service instance in octet format, e.g. C(600) to give owner C(use) and C(manage) and nothing to group and others.
		# owner_id: # ID of the user which will be set as the owner of the service
		# group_id: # ID of the group which will be set as the group of the service
		# wait: no
		# wait_timeout: 300
		# custom_attrs: {}
		# role: # Name of the role whose cardinality should be changed
		# cardinality: # Number of VMs for the specified role
		# force: no
$0
endsnippet

snippet one_host "Manages OpenNebula Hosts" b
- name: $1
	one_host:
		name: ${2:# Hostname of the machine to manage.}
		# state: absent|#present|enabled|disabled|offline
		# im_mad_name: kvm
		# vmm_mad_name: kvm
		# cluster_id: 0
		# cluster_name: # The cluster specified by name.
		# labels: # The labels for this host.
		# template: # The template or attribute changes to merge into the host template.
		# api_url: # The ENDPOINT URL of the XMLRPC server. If not specified then the value of the ONE_URL environment variable, if any, is used.
		# api_username: # The name of the user for XMLRPC authentication. If not specified then the value of the ONE_USERNAME environment variable, if any, is used.
		# api_password: # The password or token for XMLRPC authentication. If not specified then the value of the ONE_PASSWORD environment variable, if any, is used.
		# validate_certs: yes
		# wait_timeout: 300
$0
endsnippet

snippet vmware_host_capability_facts "Gathers facts about an ESXi host's capability information" b
- name: $1
	vmware_host_capability_facts:
		# cluster_name: # Name of the cluster from all host systems to be used for facts gathering.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_powerstate "Manages power states of virtual machines in vCenter" b
- name: $1
	vmware_guest_powerstate:
		# state: powered-off|powered-on|reboot-guest|restarted|shutdown-guest|suspended|#present
		# name: # Name of the virtual machine to work with.
		# name_match: #first|last
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# folder: /vm
		# scheduled_at: # Date and time in string format at which specificed task needs to be performed.
		# force: no
		# state_change_timeout: 0
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vca_fw "add remove firewall rules in a gateway  in a vca" b
- name: $1
	vca_fw:
		fw_rules: ${2:no}
		# username: # The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.
		# password: # The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.
		# org: # The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp.
		# host: # The authentication host to be used when service type is vcd.
		# api_version: 5.7
		# service_type: #vca|vchs|vcd
		# state: #present|absent
		# verify_certs: yes
		# vdc_name: # The name of the vdc where the gateway is located.
		# gateway_name: gateway
$0
endsnippet

snippet vmware_host_config_facts "Gathers facts about an ESXi host's advance configuration information" b
- name: $1
	vmware_host_config_facts:
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_datastore_maintenancemode "Place a datastore into maintenance mode" b
- name: $1
	vmware_datastore_maintenancemode:
		# datastore: # Name of datastore to manage.
		# datastore_cluster: # Name of the datastore cluster from all child datastores to be managed.
		# cluster_name: # Name of the cluster where datastore is connected to.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vswitch_facts "Gathers facts about an ESXi host's vswitch configurations" b
- name: $1
	vmware_vswitch_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_custom_attribute_defs "Manage custom attributes definitions for virtual machine from VMWare" b
- name: $1
	vmware_guest_custom_attribute_defs:
		state: ${2:#present|absent}
		# attribute_key: # Name of the custom attribute definition.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_boot_manager "Manage boot options for the given virtual machine" b
- name: $1
	vmware_guest_boot_manager:
		# name: # Name of the VM to work with.
		# uuid: # UUID of the instance to manage if known, this is VMware's BIOS UUID.
		# boot_order: []
		# name_match: #first|last
		# boot_delay: 0
		# enter_bios_setup: no
		# boot_retry_enabled: no
		# boot_retry_delay: 0
		# boot_firmware: bios|efi
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_target_canonical_facts "Return canonical (NAA) from an ESXi host system" b
- name: $1
	vmware_target_canonical_facts:
		# target_id: # The target id based on order of scsi device.
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # Name of the ESXi host system.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_snapshot_facts "Gather facts about virtual machine's snapshots in vCenter" b
- name: $1
	vmware_guest_snapshot_facts:
		datacenter: ${2:# Name of the datacenter.}
		# name: # Name of the VM to work with.
		# uuid: # UUID of the instance to manage if known, this value is VMware's unique identifier.
		# folder: # Destination folder, absolute or relative path to find an existing guest.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_powerstate "Manages power states of host systems in vCenter" b
- name: $1
	vmware_host_powerstate:
		# state: power-down-to-standby|power-up-from-standby|#shutdown-host|reboot-host
		# esxi_hostname: # Name of the host system to work with.
		# cluster_name: # Name of the cluster from which all host systems will be used.
		# force: no
		# timeout: 600
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion, and/or its vmdks using storage vMotion." b
- name: $1
	vmware_vmotion:
		# vm_name: # Name of the VM to perform a vMotion on.
		# vm_uuid: # UUID of the virtual machine to perform a vMotion operation on.
		# destination_host: # Name of the destination host the virtual machine should be running on.
		# destination_datastore: # Name of the destination datastore the virtual machine's vmdk should be moved on.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_local_user_facts "Gather facts about users on the given ESXi host" b
- name: $1
	vmware_local_user_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vsphere_copy "Copy a file to a vCenter datastore" b
- name: $1
	vsphere_copy:
		host: ${2:# The vCenter server on which the datastore is available.}
		login: ${3:# The login name to authenticate on the vCenter server.}
		password: ${4:# The password to authenticate on the vCenter server.}
		src: ${5:# The file to push to vCenter}
		datacenter: ${6:# The datacenter on the vCenter server that holds the datastore.}
		datastore: ${7:# The datastore on the vCenter server to push files to.}
		path: ${8:# The file to push to the datastore on the vCenter server.}
		# validate_certs: yes
$0
endsnippet

snippet vmware_host_service_facts "Gathers facts about an ESXi host's services" b
- name: $1
	vmware_host_service_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_tools_wait "Wait for VMware tools to become available" b
- name: $1
	vmware_guest_tools_wait:
		# name: # Name of the VM for which to wait until the tools become available.
		# name_match: #first|last
		# folder: # Destination folder, absolute or relative path to find an existing guest.
		# uuid: # UUID of the VM  for which to wait until the tools become available, if known. This is VMware's unique identifier.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_firewall_manager "Manage firewall configurations about an ESXi host" b
- name: $1
	vmware_host_firewall_manager:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# rules: []
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_facts "Gathers facts about remote ESXi hostsystem" b
- name: $1
	vmware_host_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup." b
- name: $1
	vmware_dvs_portgroup:
		portgroup_name: ${2:# The name of the portgroup that is to be created or deleted.}
		switch_name: ${3:# The name of the distributed vSwitch the port group should be created on.}
		vlan_id: ${4:# The VLAN ID that should be configured with the portgroup, use 0 for no VLAN.}
		num_ports: ${5:# The number of ports the portgroup should contain.}
		portgroup_type: ${6:earlyBinding|lateBinding|ephemeral}
		state: ${7:present|absent}
		# vlan_trunk: no
		# network_policy: {'promiscuous': False, 'forged_transmits': False, 'mac_changes': False}
		# teaming_policy: {'notify_switches': True, 'load_balance_policy': 'loadbalance_srcid', 'inbound_policy': False, 'rolling_order': False}
		# port_policy: {'traffic_filter_override': False, 'network_rp_override': False, 'live_port_move': False, 'security_override': False, 'vendor_config_override': False, 'port_config_reset_at_disconnect': True, 'uplink_teaming_override': False, 'block_override': True, 'shaping_override': False, 'vlan_override': False, 'ipfix_override': False}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_firewall_facts "Gathers facts about an ESXi host's firewall configuration information" b
- name: $1
	vmware_host_firewall_facts:
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_tag "Manage VMware tags" b
- name: $1
	vmware_tag:
		tag_name: ${2:# The name of tag to manage.}
		# tag_description: 
		# category_id: # The unique ID generated by vCenter should be used to.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter server.
		# username: # The username of the vSphere vCenter server.
		# password: # The password of the vSphere vCenter server.
		# validate_certs: yes
		# protocol: #https|http
$0
endsnippet

snippet vmware_cluster "Manage VMware vSphere clusters" b
- name: $1
	vmware_cluster:
		cluster_name: ${2:# The name of the cluster that will be created.}
		datacenter_name: ${3:# The name of the datacenter the cluster will be created in.}
		# enable_drs: no
		# enable_ha: no
		# enable_vsan: no
		# state: absent|#present
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_facts "Gather facts about a single VM" b
- name: $1
	vmware_guest_facts:
		datacenter: ${2:# Destination datacenter for the deploy operation}
		# name: # Name of the VM to work with
		# name_match: #first|last
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# folder: /vm
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vCenter" b
- name: $1
	vmware_guest_snapshot:
		state: ${2:#present|absent|revert|remove_all}
		datacenter: ${3:# Destination datacenter for the deploy operation.}
		# name: # Name of the virtual machine to work with.
		# name_match: #first|last
		# uuid: # UUID of the instance to manage if known, this is VMware's unique identifier.
		# folder: # Destination folder, absolute or relative path to find an existing guest.
		# snapshot_name: # Sets the snapshot name to manage.
		# description: 
		# quiesce: no
		# memory_dump: no
		# remove_children: no
		# new_snapshot_name: # Value to rename the existing snapshot to.
		# new_description: # Value to change the description of an existing snapshot to.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest "Manages virtual machines in vCenter" b
- name: $1
	vmware_guest:
		name: ${2:# Name of the virtual machine to work with.}
		# state: #present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest
		# name_match: #first|last
		# uuid: # UUID of the virtual machine to manage if known, this is VMware's unique identifier.
		# template: # Template or existing virtual machine used to create new virtual machine.
		# is_template: no
		# folder: # Destination folder, absolute path to find an existing guest or create the new guest.
		# hardware: # Manage virtual machine's hardware attributes.
		# guest_id: # Set the guest ID.
		# disk: # A list of disks to add.
		# cdrom: # A CD-ROM configuration for the virtual machine.
		# resource_pool: # Use the given resource pool for virtual machine operation.
		# wait_for_ip_address: no
		# state_change_timeout: 0
		# snapshot_src: # Name of the existing snapshot to use to create a clone of a virtual machine.
		# linked_clone: no
		# force: no
		# datacenter: ha-datacenter
		# cluster: # The cluster name where the virtual machine will run.
		# esxi_hostname: # The ESXi hostname where the virtual machine will run.
		# annotation: # A note or annotation to include in the virtual machine.
		# customvalues: # Define a list of custom values to set on virtual machine.
		# networks: # A list of networks (in the order of the NICs).
		# customization: # Parameters for OS customization when cloning from the template or the virtual machine.
		# vapp_properties: # A list of vApp properties
		# customization_spec: # Unique name identifying the requested customization specification.
		# datastore: # Specify datastore or datastore cluster to provision virtual machine.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vcenter_folder "Manage folders on given datacenter" b
- name: $1
	vcenter_folder:
		datacenter: ${2:# Name of the datacenter.}
		folder_name: ${3:# Name of folder to be managed.}
		# parent_folder: # Name of the parent folder under which new folder needs to be created.
		# folder_type: datastore|host|network|#vm
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_cfg_backup "Backup / Restore / Reset ESXi host configuration" b
- name: $1
	vmware_cfg_backup:
		# esxi_hostname: # Name of ESXi server. This is required only if authentication against a vCenter is done.
		# dest: # The destination where the ESXi configuration bundle will be saved. The I(dest) can be a folder or a file.
		# src: # The file containing the ESXi configuration that will be restored.
		# state: saved|absent|loaded
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed" b
- name: $1
	vmware_vm_vss_dvs_migrate:
		vm_name: ${2:# Name of the virtual machine to migrate to a dvSwitch}
		dvportgroup_name: ${3:# Name of the portgroup to migrate to the virtual machine to}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_drs_rule_facts "Gathers facts about DRS rule on the given cluster" b
- name: $1
	vmware_drs_rule_facts:
		# cluster_name: # Name of the cluster.
		# datacenter: # Name of the datacenter.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_dvswitch "Create or remove a distributed vSwitch" b
- name: $1
	vmware_dvswitch:
		datacenter_name: ${2:# The name of the datacenter that will contain the dvSwitch}
		switch_name: ${3:# The name of the switch to create or remove}
		mtu: ${4:# The switch maximum transmission unit}
		uplink_quantity: ${5:# Quantity of uplink per ESXi host added to the switch}
		discovery_proto: ${6:cdp|lldp}
		# switch_version: # The version of the switch to create. Can be 6.5.0, 6.0.0, 5.5.0, 5.1.0, 5.0.0 with a vcenter running vSphere 6.5
		# discovery_operation: both|none|advertise|listen
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_custom_attributes "Manage custom attributes from VMWare for the given virtual machine" b
- name: $1
	vmware_guest_custom_attributes:
		name: ${2:# Name of the virtual machine to work with.}
		datacenter: ${3:# Datacenter name where the virtual machine is located in.}
		# state: #present|absent
		# uuid: # UUID of the virtual machine to manage if known. This is VMware's unique identifier.
		# folder: # Absolute path to find an existing guest.
		# attributes: []
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_deploy_ovf "Deploys a VMware virtual machine from an OVF or OVA file" b
- name: $1
	vmware_deploy_ovf:
		# allow_duplicates: yes
		# datacenter: ha-datacenter
		# cluster: # Cluster to deploy to.
		# datastore: datastore1
		# deployment_option: # The key of the chosen deployment option.
		# disk_provisioning: flat|eagerZeroedThick|monolithicSparse|twoGbMaxExtentSparse|twoGbMaxExtentFlat|#thin|sparse|thick|seSparse|monolithicFlat
		# fail_on_spec_warnings: no
		# folder: # Absolute path of folder to place the virtual machine.
		# name: # Name of the VM to work with.
		# networks: {'VM Network': 'VM Network'}
		# ovf: # Path to OVF or OVA file to deploy.
		# power_on: yes
		# properties: # The assignment of values to the properties found in the OVF as key value pairs.
		# resource_pool: Resources
		# wait: yes
		# wait_for_ip_address: no
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_service_manager "Manage services on a given ESXi host" b
- name: $1
	vmware_host_service_manager:
		service_name: ${2:# Name of Service to be managed. This is brief identifier for the service, for example, ntpd, vxsyslogd etc.}
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# state: absent|present|restart|#start|stop
		# service_policy: automatic|off|on
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_dns_facts "Gathers facts about an ESXi host's DNS configuration information" b
- name: $1
	vmware_host_dns_facts:
		# cluster_name: # Name of the cluster from which the ESXi host belong to.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_tag_facts "Manage VMware tag facts" b
- name: $1
	vmware_tag_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter server.
		# username: # The username of the vSphere vCenter server.
		# password: # The password of the vSphere vCenter server.
		# validate_certs: yes
		# protocol: #https|http
$0
endsnippet

snippet vmware_local_role_manager "Manage local roles on an ESXi host" b
- name: $1
	vmware_local_role_manager:
		local_role_name: ${2:# The local role name to be managed.}
		# local_privilege_ids: []
		# state: #present|absent
		# force_remove: no
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_category_facts "Gather facts about VMware tag categories" b
- name: $1
	vmware_category_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter server.
		# username: # The username of the vSphere vCenter server.
		# password: # The password of the vSphere vCenter server.
		# validate_certs: yes
		# protocol: #https|http
$0
endsnippet

snippet vmware_host_ntp "Manage NTP configurations about an ESXi host" b
- name: $1
	vmware_host_ntp:
		ntp_servers: ${2:# IP or FQDN of NTP server/s.}
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_acceptance "Manage acceptance level of ESXi host" b
- name: $1
	vmware_host_acceptance:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# state: #list|present
		# acceptance_level: community|partner|vmware_accepted|vmware_certified
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_lockdown "Manage administrator permission for the local administrative account for the ESXi host" b
- name: $1
	vmware_host_lockdown:
		# cluster_name: # Name of cluster.
		# esxi_hostname: # List of ESXi hostname to manage lockdown.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vm_vm_drs_rule "Configure VMware DRS Affinity rule for virtual machine in given cluster" b
- name: $1
	vmware_vm_vm_drs_rule:
		cluster_name: ${2:# Desired cluster name where virtual machines are present for the DRS rule.}
		drs_rule_name: ${3:# The name of the DRS rule to manage.}
		# vms: # List of virtual machines name for which DRS rule needs to be applied.
		# enabled: no
		# mandatory: no
		# affinity_rule: yes
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_about_facts "Provides information about VMware server to which user is connecting to" b
- name: $1
	vmware_about_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_resource_pool "Add/remove resource pools to/from vCenter" b
- name: $1
	vmware_resource_pool:
		datacenter: ${2:# Name of the datacenter to add the host.}
		cluster: ${3:# Name of the cluster to add the host.}
		resource_pool: ${4:# Resource pool name to manage.}
		# cpu_expandable_reservations: yes
		# cpu_reservation: 0
		# cpu_limit: -1
		# cpu_shares: high|custom|low|#normal
		# mem_expandable_reservations: yes
		# mem_reservation: 0
		# mem_limit: -1
		# mem_shares: high|custom|low|#normal
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode" b
- name: $1
	vmware_maintenancemode:
		esxi_hostname: ${2:# Name of the host as defined in vCenter.}
		# vsan: ensureObjectAccessibility|evacuateAllData|noAction
		# evacuate: no
		# timeout: 0
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vmkernel "Manage a VMware VMkernel Interface aka. Virtual NICs of host system." b
- name: $1
	vmware_vmkernel:
		portgroup_name: ${2:# The name of the port group for the VMKernel interface.}
		esxi_hostname: ${3:# Name of ESXi host to which VMKernel is to be managed.}
		# vswitch_name: # The name of the vSwitch where to add the VMKernel interface.
		# network: # A dictionary of network details.
		# ip_address: # The IP Address for the VMKernel interface.
		# subnet_mask: # The Subnet Mask for the VMKernel interface.
		# vlan_id: # The VLAN ID for the VMKernel interface.
		# mtu: 1500
		# enable_vsan: # Enable the VMKernel interface for VSAN traffic.
		# enable_vmotion: # Enable the VMKernel interface for vMotion traffic.
		# enable_mgmt: # Enable the VMKernel interface for Management traffic.
		# enable_ft: # Enable the VMKernel interface for Fault Tolerance traffic.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_disk_facts "Gather facts about disks of given virtual machine" b
- name: $1
	vmware_guest_disk_facts:
		datacenter: ${2:# The datacenter name to which virtual machine belongs to.}
		# name: # Name of the virtual machine.
		# uuid: # UUID of the instance to gather facts if known, this is VMware's unique identifier.
		# folder: # Destination folder, absolute or relative path to find an existing guest.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_cluster_facts "Gather facts about clusters available in given vCenter" b
- name: $1
	vmware_cluster_facts:
		# datacenter: # Datacenter to search for cluster/s.
		# cluster_name: # Name of the cluster.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vswitch "Manage a VMware Standard Switch to an ESXi host." b
- name: $1
	vmware_vswitch:
		switch: ${2:# vSwitch name to add.}
		# nics: []
		# number_of_ports: 128
		# mtu: 1500
		# state: absent|#present
		# esxi_hostname: # Manage the vSwitch using this ESXi host system.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host" b
- name: $1
	vmware_vsan_cluster:
		# cluster_uuid: # Desired cluster UUID
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_boot_facts "Gather facts about boot options for the given virtual machine" b
- name: $1
	vmware_guest_boot_facts:
		# name: # Name of the VM to work with.
		# uuid: # UUID of the instance to manage if known, this is VMware's BIOS UUID.
		# name_match: #first|last
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vca_vapp "Manages vCloud Air vApp instances." b
- name: $1
	vca_vapp:
		vapp_name: ${2:# The name of the vCloud Air vApp instance}
		# template_name: # The name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)
		# network_name: # The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided.
		# network_mode: #pool|dhcp|static
		# vm_name: # The name of the virtual machine instance in the vApp to manage.
		# vm_cpus: # The number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.
		# vm_memory: # The amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp.
		# operation: #noop|poweron|poweroff|suspend|shutdown|reboot|reset
		# state: #present|absent|deployed|undeployed
		# username: # The vCloud Air username to use during authentication
		# password: # The vCloud Air password to use during authentication
		# org: # The org to login to for creating vapp, mostly set when the service_type is vdc.
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp
		# host: # The authentication host to be used when service type  is vcd.
		# api_version: 5.7
		# service_type: #vca|vchs|vcd
		# vdc_name: # The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.
		# verify_certs: yes
		# gateway_name: gateway
$0
endsnippet

snippet vmware_vm_shell "Run commands in a VMware guest operating system" b
- name: $1
	vmware_vm_shell:
		vm_id: ${2:# Name of the virtual machine to work with.}
		vm_username: ${3:# The user to login-in to the virtual machine.}
		vm_password: ${4:# The password used to login-in to the virtual machine.}
		vm_shell: ${5:# The absolute path to the program to start.}
		# datacenter: # The datacenter hosting the virtual machine.
		# cluster: # The cluster hosting the virtual machine.
		# folder: # Destination folder, absolute or relative path to find an existing guest or create the new guest.
		# vm_id_type: uuid|dns_name|inventory_path|#vm_name
		# vm_shell_args:  
		# vm_shell_env: # Comma separated list of environment variable, specified in the guest OS notation.
		# vm_shell_cwd: # The current working directory of the application from which it will be run.
		# wait_for_process: no
		# timeout: 3600
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_resource_pool_facts "Gathers facts about resource pool information" b
- name: $1
	vmware_resource_pool_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_ntp_facts "Gathers facts about NTP configuration on an ESXi host" b
- name: $1
	vmware_host_ntp_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_portgroup "Create a VMware portgroup" b
- name: $1
	vmware_portgroup:
		switch_name: ${2:# vSwitch to modify.}
		portgroup_name: ${3:# Portgroup name to add.}
		vlan_id: ${4:# VLAN ID to assign to portgroup.}
		# network_policy: {'mac_changes': False, 'promiscuous_mode': False, 'forged_transmits': False}
		# teaming_policy: {'notify_switches': True, 'load_balance_policy': 'loadbalance_srcid', 'inbound_policy': False, 'rolling_order': False}
		# cluster_name: # Name of cluster name for host membership.
		# hosts: # List of name of host or hosts on which portgroup needs to be added.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS" b
- name: $1
	vmware_migrate_vmk:
		esxi_hostname: ${2:# ESXi hostname to be managed}
		device: ${3:# VMK interface name}
		current_switch_name: ${4:# Switch VMK interface is currently on}
		current_portgroup_name: ${5:# Portgroup name VMK interface is currently on}
		migrate_switch_name: ${6:# Switch name to migrate VMK interface to}
		migrate_portgroup_name: ${7:# Portgroup name to migrate VMK interface to}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_ssl_facts "Gather facts of ESXi host system about SSL" b
- name: $1
	vmware_host_ssl_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_vmnic_facts "Gathers facts about vmnics available on the given ESXi host" b
- name: $1
	vmware_host_vmnic_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch" b
- name: $1
	vmware_dvs_host:
		esxi_hostname: ${2:# The ESXi hostname.}
		switch_name: ${3:# The name of the Distributed vSwitch.}
		vmnics: ${4:# The ESXi hosts vmnics to use with the Distributed vSwitch.}
		state: ${5:#present|absent}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_local_role_facts "Gather facts about local roles on an ESXi host" b
- name: $1
	vmware_local_role_facts:
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration" b
- name: $1
	vmware_dns_config:
		change_hostname_to: ${2:# The hostname that an ESXi host should be changed to.}
		domainname: ${3:# The domain the ESXi host should be apart of.}
		dns_servers: ${4:# The DNS servers that the host should be configured to use.}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vmkernel_facts "Gathers VMKernel facts about an ESXi host" b
- name: $1
	vmware_vmkernel_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_package_facts "Gathers facts about available packages on an ESXi host" b
- name: $1
	vmware_host_package_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host "Add / Remove ESXi host to / from vCenter" b
- name: $1
	vmware_host:
		datacenter_name: ${2:# Name of the datacenter to add the host.}
		esxi_hostname: ${3:# ESXi hostname to manage.}
		# cluster_name: # Name of the cluster to add the host.
		# folder: # Name of the folder under which host to add.
		# add_connected: yes
		# esxi_username: # ESXi username.
		# esxi_password: # ESXi password.
		# state: #present|absent|add_or_reconnect|reconnect
		# esxi_ssl_thumbprint: 
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_config_manager "Manage advance configurations about an ESXi host" b
- name: $1
	vmware_host_config_manager:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname.
		# options: {}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_file_operation "Files operation in a VMware guest operating system without network" b
- name: $1
	vmware_guest_file_operation:
		vm_id: ${2:# Name of the virtual machine to work with.}
		vm_username: ${3:# The user to login in to the virtual machine.}
		vm_password: ${4:# The password used to login-in to the virtual machine.}
		# datacenter: # The datacenter hosting the virtual machine.
		# cluster: # The cluster hosting the virtual machine.
		# folder: # Destination folder, absolute path to find an existing guest or create the new guest.
		# vm_id_type: uuid|dns_name|inventory_path|#vm_name
		# directory: # Create or delete directory.
		# copy: # Copy file to vm without requiring network.
		# fetch: # Get file from virtual machine without requiring network.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters" b
- name: $1
	vmware_datacenter:
		datacenter_name: ${2:# The name of the datacenter the cluster will be created in.}
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_portgroup_facts "Gathers facts about an ESXi host's portgroup configuration" b
- name: $1
	vmware_portgroup_facts:
		# cluster_name: # Name of the cluster.
		# esxi_hostname: # ESXi hostname to gather facts from.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_datastore_facts "Gather facts about datastores available in given vCenter" b
- name: $1
	vmware_datastore_facts:
		# name: # Name of the datastore to match.
		# datacenter: # Datacenter to search for datastores.
		# cluster: # Cluster to search for datastores.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_host_datastore "Manage a datastore on ESXi host" b
- name: $1
	vmware_host_datastore:
		datacenter_name: ${2:# Name of the datacenter to add the datastore.}
		datastore_name: ${3:# Name of the datastore to add/remove.}
		datastore_type: ${4:nfs|vmfs}
		esxi_hostname: ${5:# ESXi hostname to manage the datastore.}
		# nfs_server: # NFS host serving nfs datastore.
		# nfs_path: # Resource path on NFS host.
		# nfs_ro: no
		# vmfs_device_name: # Name of the device to be used as VMFS datastore.
		# vmfs_version: # VMFS version to use for datastore creation.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host" b
- name: $1
	vmware_local_user_manager:
		local_user_name: ${2:# The local user name to be changed.}
		# local_user_password: # The password to be set.
		# local_user_description: # Description for the user.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vca_nat "add remove nat rules in a gateway  in a vca" b
- name: $1
	vca_nat:
		nat_rules: ${2:no}
		# purge_rules: no
		# username: # The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.
		# password: # The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.
		# org: # The org to login to for creating vapp. This option is required when the C(service_type) is I(vdc).
		# instance_id: # The instance id in a vchs environment to be used for creating the vapp.
		# host: # The authentication host to be used when service type is vcd.
		# api_version: 5.7
		# service_type: #vca|vchs|vcd
		# state: #present|absent
		# verify_certs: yes
		# vdc_name: # The name of the vdc where the gateway is located.
		# gateway_name: gateway
$0
endsnippet

snippet vmware_guest_find "Find the folder path(s) for a virtual machine by name or UUID" b
- name: $1
	vmware_guest_find:
		# name: # Name of the VM to work with.
		# uuid: # UUID of the instance to manage if known, this is VMware's BIOS UUID.
		# datacenter: # Destination datacenter for the find operation.
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vm_facts "Return basic facts pertaining to a vSphere virtual machine guest" b
- name: $1
	vmware_vm_facts:
		# vm_type: #all|vm|template
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_datastore_cluster "Manage VMware vSphere datastore clusters" b
- name: $1
	vmware_datastore_cluster:
		datacenter_name: ${2:# The name of the datacenter.}
		datastore_cluster_name: ${3:# The name of the datastore cluster.}
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vcenter_license "Manage VMware vCenter license keys" b
- name: $1
	vcenter_license:
		license: ${2:# The license key to manage in vSphere vCenter.}
		# labels: {'source': 'ansible'}
		# state: absent|#present
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address" b
- name: $1
	vmware_vmkernel_ip_config:
		vmk_name: ${2:# VMkernel interface name}
		ip_address: ${3:# IP address to assign to VMkernel interface}
		subnet_mask: ${4:# Subnet Mask to assign to VMkernel interface}
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_guest_move "Moves virtual machines in vCenter" b
- name: $1
	vmware_guest_move:
		dest_folder: ${2:# Absolute path to move an existing guest}
		datacenter: ${3:# Destination datacenter for the move operation}
		# name: # Name of the existing virtual machine to move.
		# uuid: # UUID of the virtual machine to manage if known, this is VMware's unique identifier.
		# name_match: #first|last
		# hostname: # The hostname or IP address of the vSphere vCenter or ESXi server.
		# username: # The username of the vSphere vCenter or ESXi server.
		# password: # The password of the vSphere vCenter or ESXi server.
		# validate_certs: yes
		# port: 443
$0
endsnippet

snippet vmware_category "Manage VMware categories" b
- name: $1
	vmware_category:
		category_name: ${2:# The name of category to manage.}
		# category_description: 
		# category_cardinality: #multiple|single
		# new_category_name: # The new name for an existing category.
		# state: #present|absent
		# hostname: # The hostname or IP address of the vSphere vCenter server.
		# username: # The username of the vSphere vCenter server.
		# password: # The password of the vSphere vCenter server.
		# validate_certs: yes
		# protocol: #https|http
$0
endsnippet

snippet fetch "Fetches a file from remote nodes" b
- name: $1
	fetch:
		src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory. Recursive fetching may be supported in a later release.}
		dest: ${3:# A directory to save the file into. For example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile)}
		# fail_on_missing: yes
		# validate_checksum: yes
		# flat: no
$0
endsnippet

snippet tempfile "Creates temporary files and directories." b
- name: $1
	tempfile:
		# state: directory|#file
		# path: # Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.
		# prefix: ansible.
		# suffix: 
$0
endsnippet

snippet patch "Apply patch files using the GNU patch tool" b
- name: $1
	patch:
		src: ${2:# Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's I(files) directory.}
		# basedir: # Path of a base directory in which the patch file will be applied. May be omitted when C(dest) option is specified, otherwise required.
		# dest: # Path of the file on the remote machine to be patched.
		# state: absent|#present
		# remote_src: no
		# strip: 0
		# backup: no
		# binary: no
$0
endsnippet

snippet xml "Manage bits and pieces of XML files or strings" b
- name: $1
	xml:
		path: ${2:# Path to the file to operate on. File must exist ahead of time.}
		xmlstring: ${3:# A string containing XML on which to operate.}
		# xpath: # A valid XPath expression describing the item(s) you want to manipulate.
		# namespaces: # The namespace C(prefix:uri) mapping for the XPath expression.
		# state: absent|#present
		# attribute: # The attribute to select when using parameter C(value).
		# value: # Desired state of the selected attribute.
		# add_children: # Add additional child-element(s) to a selected element for a given C(xpath).
		# set_children: # Set the child-element(s) of a selected element for a given C(xpath).
		# count: no
		# print_match: no
		# pretty_print: no
		# content: attribute|text
		# input_type: xml|#yaml
		# backup: no
		# strip_cdata_tags: no
$0
endsnippet

snippet copy "Copies files to remote locations" b
- name: $1
	copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If I(src) is a directory, this must be a directory too. If I(dest) is a nonexistent path and if either I(dest) ends with "/" or I(src) is a directory, I(dest) is created. If I(src) and I(dest) are files, the parent directory of I(dest) isn't created: the task fails if it doesn't already exist.}
		# src: # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.
		# content: # When used instead of I(src), sets the contents of a file directly to the specified value. For anything advanced or with formatting also look at the template module.
		# backup: no
		# force: yes
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.  As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).  As of version 2.3, the mode may also be the special string C(preserve).  C(preserve) means that the file will be given the same permissions as the source file.
		# directory_mode: # When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.
		# remote_src: no
		# follow: no
		# local_follow: yes
		# checksum: # SHA1 checksum of the file being transferred. Used to validate that the copy of the file was successful.
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
		# decrypt: yes
$0
endsnippet

snippet assemble "Assembles a configuration file from fragments" b
- name: $1
	assemble:
		src: ${2:# An already existing directory full of source files.}
		dest: ${3:# A file to create using the concatenation of all of the source files.}
		# backup: no
		# delimiter: # A delimiter to separate the file contents.
		# remote_src: yes
		# regexp: # Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
		# ignore_hidden: no
		# validate: # The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# decrypt: yes
$0
endsnippet

snippet file "Sets attributes of files" b
- name: $1
	file:
		path: ${2:# Path to the file being managed.}
		# state: absent|directory|#file|hard|link|touch
		# src: # path of the file to link to (applies only to C(state=link) and C(state=hard)). Will accept absolute, relative and nonexisting paths. Relative paths are relative to the file being created (C(path)) which is how the UNIX command C(ln -s SRC DEST) treats relative paths.
		# recurse: no
		# force: no
		# follow: yes
		# modification_time: # This parameter indicates the time the file's modification time should be set to
		# modification_time_format: %Y%m%d%H%M.%S
		# access_time: # This parameter indicates the time the file's access time should be set to
		# access_time_format: %Y%m%d%H%M.%S
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet acl "Sets and retrieves file ACL information." b
- name: $1
	acl:
		path: ${2:# The full path of the file or object.}
		# state: absent|present|#query
		# follow: yes
		# default: no
		# entity: # actual user or group that the ACL applies to when matching entity types user or group are selected.
		# etype: group|mask|other|user
		# permissions: # Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)
		# entry: # DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '<etype>:<qualifier>:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields.
		# recursive: no
		# use_nfsv4_acls: no
		# recalculate_mask: #default|mask|no_mask
$0
endsnippet

snippet lineinfile "Manage lines in text files" b
- name: $1
	lineinfile:
		path: ${2:# The file to modify.}
		# regexp: # The regular expression to look for in every line of the file.
		# state: absent|#present
		# line: # Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.
		# backrefs: no
		# insertafter: #EOF|*regex*
		# insertbefore: BOF|*regex*
		# create: no
		# backup: no
		# firstmatch: no
		# others: # All arguments accepted by the M(file) module also work here.
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
$0
endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines" b
- name: $1
	blockinfile:
		path: ${2:# The file to modify.}
		# state: absent|#present
		# marker: # {mark} ANSIBLE MANAGED BLOCK
		# block: 
		# insertafter: #EOF|*regex*
		# insertbefore: BOF|*regex*
		# create: no
		# backup: no
		# marker_begin: BEGIN
		# marker_end: END
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
$0
endsnippet

snippet stat "Retrieve file or file system status" b
- name: $1
	stat:
		path: ${2:# The full path of the file/object to get the facts of.}
		# follow: no
		# get_md5: no
		# get_checksum: yes
		# checksum_algorithm: md5|#sha1|sha224|sha256|sha384|sha512
		# get_mime: yes
		# get_attributes: yes
$0
endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy." b
- name: $1
	synchronize:
		src: ${2:# Path on the source host that will be synchronized to the destination; The path can be absolute or relative.}
		dest: ${3:# Path on the destination host that will be synchronized from the source; The path can be absolute or relative.}
		# dest_port: Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set
		# mode: pull|#push
		# archive: yes
		# checksum: no
		# compress: yes
		# existing_only: no
		# delete: no
		# dirs: no
		# recursive: the value of the archive option
		# links: the value of the archive option
		# copy_links: no
		# perms: the value of the archive option
		# times: the value of the archive option
		# owner: the value of the archive option
		# group: the value of the archive option
		# rsync_path: # Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.
		# rsync_timeout: 0
		# set_remote_user: yes
		# use_ssh_args: no
		# rsync_opts: # Specify additional rsync options by passing in an array.
		# partial: no
		# verify_host: no
		# private_key: # Specify the private key to use for SSH-based rsync connections (e.g. C(~/.ssh/id_rsa))
		# link_dest: # add a destination to hard link against during the rsync.
$0
endsnippet

snippet xattr "Manage user defined extended attributes" b
- name: $1
	xattr:
		path: ${2:# The full path of the file/object to get the facts of.}
		# namespace: user
		# key: # The name of a specific Extended attribute key to set/retrieve.
		# value: # The value to set the named name/key to, it automatically sets the C(state) to 'set'.
		# state: absent|all|keys|present|#read
		# follow: yes
$0
endsnippet

snippet archive "Creates a compressed archive of one or more files or trees" b
- name: $1
	archive:
		path: ${2:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}
		# format: bz2|#gz|tar|xz|zip
		# dest: # The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.
		# exclude_path: # Remote absolute path, glob, or list of paths or globs for the file or files to exclude from the archive
		# remove: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet template "Templates a file out to a remote server" b
- name: $1
	template:
		src: ${2:# Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		# backup: no
		# newline_sequence: #\n|\r|\r\n
		# block_start_string: {%
		# block_end_string: %}
		# variable_start_string: {{
		# variable_end_string: }}
		# trim_blocks: yes
		# lstrip_blocks: no
		# force: yes
		# follow: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers.  You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.  As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).  As of version 2.6, the mode may also be the special string C(preserve).  C(preserve) means that the file will be given the same permissions as the source file.
		# output_encoding: utf-8
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
$0
endsnippet

snippet find "Return a list of files based on specific criteria" b
- name: $1
	find:
		paths: ${2:# List of paths of directories to search. All paths must be fully qualified.}
		# age: # Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., "1w").
		# patterns: *
		# excludes: # One or more (shell or regex) patterns, which type is controlled by C(use_regex) option.
		# contains: # One or more regex patterns which should be matched against the file content.
		# file_type: any|directory|#file|link
		# recurse: no
		# size: # Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.
		# age_stamp: atime|ctime|#mtime
		# hidden: no
		# follow: no
		# get_checksum: no
		# use_regex: no
		# depth: # Set the maximum number of levels to decend into. Setting recurse to false will override this value, which is effectively depth 1. Default is unlimited depth.
$0
endsnippet

snippet iso_extract "Extract files from an ISO image" b
- name: $1
	iso_extract:
		image: ${2:# The ISO image to extract files from.}
		dest: ${3:# The destination directory to extract files to.}
		files: ${4:# A list of files to extract from the image.}
		# force: yes
		# executable: 7z
$0
endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine." b
- name: $1
	unarchive:
		src: ${2:# If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.}
		dest: ${3:# Remote absolute path where the archive should be unpacked.}
		# copy: yes
		# creates: # If the specified absolute path (file or directory) already exists, this step will B(not) be run.
		# list_files: no
		# exclude: # List the directory and file entries that you would like to exclude from the unarchive action.
		# keep_newer: no
		# extra_opts: 
		# remote_src: no
		# validate_certs: yes
		# decrypt: yes
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet ini_file "Tweak settings in INI files" b
- name: $1
	ini_file:
		path: ${2:# Path to the INI-style file; this file is created if required.}
		section: ${3:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}
		# option: # If set (required for changing a I(value)), this is the name of the option.
		# value: # The string value to be associated with an I(option). May be omitted when removing an I(option).
		# backup: no
		# others: # All arguments accepted by the M(file) module also work here
		# state: absent|#present
		# no_extra_spaces: no
		# create: yes
		# allow_no_value: no
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression." b
- name: $1
	replace:
		path: ${2:# The file to modify.}
		regexp: ${3:# The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses MULTILINE mode, which means C(^) and C($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.}
		# replace: # The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.
		# after: # If specified, the line after the replace/remove will start. Can be used in combination with C(before). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
		# before: # If specified, the line before the replace/remove will occur. Can be used in combination with C(after). Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
		# backup: no
		# others: # All arguments accepted by the M(file) module also work here.
		# encoding: utf-8
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
		# validate: # The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.
$0
endsnippet

snippet telnet "Executes a low-down and dirty telnet command" b
- name: $1
	telnet:
		command: ${2:# List of commands to be executed in the telnet session.}
		# host: remote_addr
		# user: remote_user
		# password: # The password for login
		# port: 23
		# timeout: 120
		# prompts: ['$']
		# login_prompt: login: 
		# password_prompt: Password: 
		# pause: 1
		# send_newline: no
$0
endsnippet

snippet expect "Executes a command and responds to prompts." b
- name: $1
	expect:
		command: ${2:# The command module takes command to run.}
		responses: ${3:# Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.}
		# creates: # A filename, when it already exists, this step will B(not) be run.
		# removes: # A filename, when it does not exist, this step will B(not) be run.
		# chdir: # Change into this directory before running the command.
		# timeout: 30
		# echo: no
$0
endsnippet

snippet command "Executes a command on a remote node" b
- name: $1
	command: $2
	args:
		# argv: # Allows the user to provide the command as a list vs. a string.  Only the string or the list form can be provided, not both.  One or the other must be provided.
		# creates: # A filename or (since 2.0) glob pattern. If it already exists, this step B(won't) be run.
		# removes: # A filename or (since 2.0) glob pattern. If it already exists, this step B(will) be run.
		# chdir: # Change into this directory before running the command.
		# warn: yes
		# stdin: # Set the stdin of the command directly to the specified value.
$0
endsnippet

snippet raw "Executes a low-down and dirty SSH command" b
- name: $1
	raw: $2
	args:
		# executable: # change the shell used to execute the command. Should be an absolute path to the executable.
$0
endsnippet

snippet shell "Execute commands in nodes." b
- name: $1
	shell: $2
	args:
		# creates: # a filename, when it already exists, this step will B(not) be run.
		# removes: # a filename, when it does not exist, this step will B(not) be run.
		# chdir: # cd into this directory before running the command
		# executable: # change the shell used to execute the command. Should be an absolute path to the executable.
		# warn: yes
		# stdin: # Set the stdin of the command directly to the specified value.
$0
endsnippet

snippet script "Runs a local script on a remote node after transferring it" b
- name: $1
	script: $2
	args:
		# creates: # A filename on the remote node, when it already exists, this step will B(not) be run.
		# removes: # A filename on the remote node, when it does not exist, this step will B(not) be run.
		# chdir: # Change into this directory on the remote node before running the script.
		# executable: # Name or path of a executable to invoke the script with.
		# decrypt: yes
$0
endsnippet

snippet psexec "Runs commands on a remote Windows host based on the PsExec model" b
- name: $1
	psexec:
		hostname: ${2:# The remote Windows host to connect to, can be either an IP address or a hostname.}
		executable: ${3:# The executable to run on the Windows host.}
		# connection_username: # The username to use when connecting to the remote Windows host.
		# connection_password: # The password for I(connection_user).
		# port: 445
		# encrypt: yes
		# connection_timeout: 60
		# arguments: # Any arguments as a single string to use when running the executable.
		# working_directory: C:\Windows\System32
		# asynchronous: no
		# load_profile: yes
		# process_username: # The user to run the process as.
		# process_password: # The password for I(process_username).
		# integrity_level: limited|#default|elevated
		# interactive: no
		# interactive_session: 0
		# priority: above_normal|below_normal|high|idle|#normal|realtime
		# show_ui_on_logon_screen: no
		# process_timeout: 0
		# stdin: # Data to send on the stdin pipe once the process has started.
$0
endsnippet

snippet win_dsc "Invokes a PowerShell DSC configuration" b
- name: $1
	win_dsc: $2
	args:
		# module_version: latest
$0
endsnippet

snippet win_whoami "Get information about the current user and process" b
- name: $1
$0
endsnippet

snippet win_iis_webapppool "Configure IIS Web Application Pools" b
- name: $1
	win_iis_webapppool:
		name: ${2:# Name of the application pool.}
		# attributes: # This field is a free form dictionary value for the application pool attributes.
		# state: absent|#present|restarted|started|stopped
$0
endsnippet

snippet win_tempfile "Creates temporary files and directories" b
- name: $1
	win_tempfile:
		# state: directory|#file
		# path: %TEMP%
		# prefix: ansible.
		# suffix: 
$0
endsnippet

snippet win_stat "Get information about Windows files" b
- name: $1
	win_stat:
		path: ${2:# The full path of the file/object to get the facts of; both forward and back slashes are accepted.}
		# get_md5: no
		# get_checksum: yes
		# checksum_algorithm: md5|#sha1|sha256|sha384|sha512
$0
endsnippet

snippet win_disk_facts "Show the attached disks and disk information of the target host" b
- name: $1
$0
endsnippet

snippet win_chocolatey_config "Manages Chocolatey config settings" b
- name: $1
	win_chocolatey_config:
		name: ${2:# The name of the config setting to manage.}
		# state: absent|#present
		# value: # Used when C(state=present) that contains the value to set for the config setting.
$0
endsnippet

snippet win_find "Return a list of files based on specific criteria" b
- name: $1
	win_find:
		paths: ${2:# List of paths of directories to search for files or folders in. This can be supplied as a single path or a list of paths.}
		# age: # Select files or folders whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., "2s", "10d", 1w").
		# age_stamp: atime|ctime|#mtime
		# checksum_algorithm: md5|#sha1|sha256|sha384|sha512
		# file_type: directory|#file
		# follow: no
		# get_checksum: yes
		# hidden: no
		# patterns: # One or more (powershell or regex) patterns to compare filenames with. The type of pattern matching is controlled by C(use_regex) option. The patterns retrict the list of files or folders to be returned based on the filenames. For a file to be matched it only has to match with one pattern in a list provided.
		# recurse: no
		# size: # Select files or folders whose size is equal to or greater than the specified size. Use a negative value to find files equal to or less than the specified size. You can specify the size with a suffix of the byte type i.e. kilo = k, mega = m... Size is not evaluated for symbolic links.
		# use_regex: no
$0
endsnippet

snippet win_xml "Add XML fragment to an XML parent" b
- name: $1
	win_xml:
		path: ${2:# The path of remote servers XML.}
		fragment: ${3:# The string representation of the XML fragment to be added.}
		xpath: ${4:# The node of the remote server XML where the fragment will go.}
		type: ${5:#element|attribute|text}
		# backup: no
		# attribute: # The attribute name if the type is 'attribute'. Required if C(type=attribute).
$0
endsnippet

snippet win_scheduled_task_stat "Get information about Windows Scheduled Tasks" b
- name: $1
	win_scheduled_task_stat:
		# path: \
		# name: # T
$0
endsnippet

snippet win_owner "Set owner" b
- name: $1
	win_owner:
		path: ${2:# Path to be used for changing owner}
		user: ${3:# Name to be used for changing owner}
		# recurse: no
$0
endsnippet

snippet win_reboot "Reboot a windows machine" b
- name: $1
	win_reboot:
		# pre_reboot_delay: 2
		# post_reboot_delay: 0
		# shutdown_timeout: 600
		# reboot_timeout: 600
		# connect_timeout: 5
		# test_command: whoami
		# msg: Reboot initiated by Ansible
$0
endsnippet

snippet win_dns_client "Configures DNS lookup on Windows hosts" b
- name: $1
	win_dns_client:
		adapter_names: ${2:# Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value). The adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection).}
		ipv4_addresses: ${3:# Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.}
$0
endsnippet

snippet win_acl_inheritance "Change ACL inheritance" b
- name: $1
	win_acl_inheritance:
		path: ${2:# Path to be used for changing inheritance}
		# state: #absent|present
		# reorganize: no
$0
endsnippet

snippet win_wait_for "Waits for a condition before continuing" b
- name: $1
	win_wait_for:
		# connect_timeout: 5
		# delay: # The number of seconds to wait before starting to poll.
		# exclude_hosts: # The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained).
		# host: 127.0.0.1
		# path: # The path to a file on the filesystem to check.
		# port: # The port number to poll on C(host).
		# search_regex: # Can be used to match a string in a file.
		# sleep: 1
		# state: absent|drained|present|#started|stopped
		# timeout: 300
$0
endsnippet

snippet win_domain_controller "Manage domain controller/member server state for a Windows host" b
- name: $1
	win_domain_controller:
		domain_admin_user: ${2:# Username of a domain admin for the target domain (necessary to promote or demote a domain controller).}
		domain_admin_password: ${3:# Password for the specified C(domain_admin_user).}
		# dns_domain_name: # When C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC.
		# safe_mode_password: # Safe mode password for the domain controller (required when C(state) is C(domain_controller)).
		# local_admin_password: # Password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server)).
		# read_only: no
		# site_name: # Specifies the name of an existing site where you can place the new domain controller.
		# state: domain_controller|member_server
		# database_path: # The path to a directory on a fixed disk of the Windows host where the domain database will be created..
		# sysvol_path: # The path to a directory on a fixed disk of the Windows host where the Sysvol folder will be created.
$0
endsnippet

snippet win_unzip "Unzips compressed files and archives on the Windows node" b
- name: $1
	win_unzip:
		src: ${2:# File to be unzipped (provide absolute path).}
		dest: ${3:# Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.}
		# delete_archive: no
		# recurse: no
		# creates: # If this file or directory exists the specified src will not be extracted.
$0
endsnippet

snippet win_say "Text to speech module for Windows to speak messages and optionally play sounds" b
- name: $1
	win_say:
		# msg: # The text to be spoken.
		# msg_file: # Full path to a windows format text file containing the text to be spokend.
		# voice: system default voice
		# speech_speed: 0
		# start_sound_path: # Full path to a C(.wav) file containing a sound to play before the text is spoken.
		# end_sound_path: # Full path to a C(.wav) file containing a sound to play after the text has been spoken.
$0
endsnippet

snippet win_route "Add or remove a static route" b
- name: $1
	win_route:
		destination: ${2:# Destination IP address in CIDR format (ip address/prefix length)}
		# gateway: # The gateway used by the static route.
		# metric: 1
		# state: absent|#present
$0
endsnippet

snippet win_product_facts "Provides Windows product information (product id, product key)" b
- name: $1
	win_product_facts:
$0
endsnippet

snippet win_shell "Execute shell commands on target hosts" b
- name: $1
	win_shell: $2
	args:
		# creates: # A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.
		# removes: # A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.
		# chdir: # Set the specified path as the current working directory before executing a command
		# executable: # Change the shell used to execute the command (eg, C(cmd)).
		# stdin: # Set the stdin of the command directly to the specified value.
$0
endsnippet

snippet win_firewall_rule "Windows firewall automation" b
- name: $1
	win_firewall_rule:
		name: ${2:# The rules name}
		direction: ${3:in|out}
		action: ${4:allow|block}
		# enabled: yes
		# state: absent|#present
		# description: # Description for the firewall rule.
		# localip: any
		# remoteip: any
		# localport: # The local port this rule applies to.
		# remoteport: # The remote port this rule applies to.
		# program: # The program this rule applies to.
		# service: # The service this rule applies to.
		# protocol: any
		# profiles: domain,private,public
		# force: no
$0
endsnippet

snippet win_security_policy "Change local security policy settings" b
- name: $1
	win_security_policy:
		section: ${2:# The ini section the key exists in.}
		key: ${3:# The ini key of the section or policy name to modify.}
		value: ${4:# The value for the ini key or policy name.}
$0
endsnippet

snippet win_file "Creates, touches or removes files or directories" b
- name: $1
	win_file:
		path: ${2:# Path to the file being managed.}
		# state: absent|directory|file|touch
$0
endsnippet

snippet win_firewall "Enable or disable the Windows Firewall" b
- name: $1
	win_firewall:
		# profiles: [#'Domain', #'Private', #'Public'
		# state: enabled|disabled
$0
endsnippet

snippet win_get_url "Downloads file from HTTP, HTTPS, or FTP to node" b
- name: $1
	win_get_url:
		url: ${2:# The full URL of a file to download.}
		dest: ${3:# The location to save the file at the URL.}
		# force: yes
		# headers: # Add custom HTTP headers to a request (as a dictionary).
		# url_username: # Basic authentication username.
		# url_password: # Basic authentication password.
		# force_basic_auth: no
		# skip_certificate_validation: no
		# validate_certs: yes
		# proxy_url: # The full URL of the proxy server to download through.
		# proxy_username: # Proxy authentication username.
		# proxy_password: # Proxy authentication password.
		# use_proxy: yes
		# timeout: 10
$0
endsnippet

snippet win_nssm "NSSM - the Non-Sucking Service Manager" b
- name: $1
	win_nssm:
		name: ${2:# Name of the service to operate on.}
		# state: absent|present|#started|stopped|restarted
		# application: # The application binary to run as a service
		# stdout_file: # Path to receive output.
		# stderr_file: # Path to receive error output.
		# app_parameters: # A string representing a dictionary of parameters to be passed to the application when it starts.
		# app_parameters_free_form: # Single string of parameters to be passed to the service.
		# dependencies: # Service dependencies that has to be started to trigger startup, separated by comma.
		# user: # User to be used for service startup.
		# password: # Password to be used for service startup.
		# start_mode: #auto|delayed|disabled|manual
$0
endsnippet

snippet win_path "Manage Windows path environment variables" b
- name: $1
	win_path:
		elements: ${2:# A single path element, or a list of path elements (ie, directories) to add or remove.}
		# name: PATH
		# state: absent|present
		# scope: #machine|user
$0
endsnippet

snippet win_rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	win_rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# new_only: no
		# state: disabled|#enabled
		# prefix: # Specify a custom install prefix to a Rabbit.
$0
endsnippet

snippet win_psmodule "Adds or removes a Powershell Module" b
- name: $1
	win_psmodule:
		name: ${2:# Name of the powershell module that has to be installed.}
		# allow_clobber: no
		# repository: # Name of the custom repository to register or use.
		# url: # URL of the custom repository to register.
		# state: absent|#present
$0
endsnippet

snippet win_ping "A windows version of the classic ping module" b
- name: $1
	win_ping:
		# data: pong
$0
endsnippet

snippet win_defrag "Consolidate fragmented files on local volumes" b
- name: $1
	win_defrag:
		# include_volumes: # A list of drive letters or mount point paths of the volumes to be defragmented.
		# exclude_volumes: # A list of drive letters or mount point paths to exclude from defragmentation.
		# freespace_consolidation: # Perform free space consolidation on the specified volumes.
		# priority: #low|normal
		# parallel: no
$0
endsnippet

snippet win_pester "Run Pester tests on Windows hosts" b
- name: $1
	win_pester:
		path: ${2:# Path to a pester test file or a folder where tests can be found.}
		# version: # Minimum version of the pester module that has to be available on the remote host.
$0
endsnippet

snippet win_dotnet_ngen "Runs ngen to recompile DLLs after .NET  updates" b
- name: $1
	win_dotnet_ngen:
$0
endsnippet

snippet win_domain_computer "Manage computers in Active Directory" b
- name: $1
	win_domain_computer:
		name: ${2:# Specifies the name of the object. This parameter sets the Name property of the Active Directory object. The LDAP display name (ldapDisplayName) of this property is name.}
		# sam_account_name: # Specifies the Security Account Manager (SAM) account name of the computer. It maximum is 256 characters, 15 is advised for older operating systems compatibility. The LDAP display name (ldapDisplayName) for this property is sAMAccountName. If ommitted the value is the same as C(name). Note. All computer SAMAccountNames needs to end with a $.
		# enabled: yes
		# ou: # Specifies the X.500 path of the Organizational Unit (OU) or container where the new object is created. Required when I(state=present).
		# description: 
		# dns_hostname: # Specifies the fully qualified domain name (FQDN) of the computer. This parameter sets the DNSHostName property for a computer object. The LDAP display name for this property is dNSHostName. Required when I(state=present).
		# state: #present|absent
$0
endsnippet

snippet win_domain_user "Manages Windows Active Directory user accounts" b
- name: $1
	win_domain_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# state: absent|#present|query
		# enabled: yes
		# account_locked: no
		# description: # Description of the user
		# groups: # Adds or removes the user from this list of groups, depending on the value of I(groups_action). To remove all but the Principal Group, set C(groups=<principal group name>) and I(groups_action=replace). Note that users cannot be removed from their principal group (for example, "Domain Users").
		# groups_action: add|remove|#replace
		# password: # Optionally set the user's password to this (plain text) value. In order to enable an account - I(enabled) - a password must already be configured on the account, or you must provide a password here.
		# update_password: #always|on_create
		# password_expired: # C(yes) will require the user to change their password at next login.
		# password_never_expires: # C(yes) will set the password to never expire.
		# user_cannot_change_password: # C(yes) will prevent the user from changing their password.
		# firstname: # Configures the user's first name (given name).
		# surname: # Configures the user's last name (surname).
		# company: # Configures the user's company name.
		# upn: # Configures the User Principal Name (UPN) for the account.
		# email: # Configures the user's email address.
		# street: # Configures the user's street address.
		# city: # Configures the user's city.
		# state_province: # Configures the user's state or province.
		# postal_code: # Configures the user's postal code / zip code.
		# country: # Configures the user's country code.
		# path: # Container or OU for the new user; if you do not specify this, the user will be placed in the default container for users in the domain.
		# attributes: # A dict of custom LDAP attributes to set on the user.
		# domain_username: # The username to use when interacting with AD.
		# domain_password: # The password for I(username).
		# domain_server: # Specifies the Active Directory Domain Services instance to connect to.
$0
endsnippet

snippet win_eventlog "Manage Windows event logs" b
- name: $1
	win_eventlog:
		name: ${2:# Name of the event log to manage.}
		# state: absent|clear|#present
		# sources: # A list of one or more sources to ensure are present/absent in the log.
		# category_file: # For one or more sources specified, the path to a custom category resource file.
		# message_file: # For one or more sources specified, the path to a custom event message resource file.
		# parameter_file: # For one or more sources specified, the path to a custom parameter resource file.
		# maximum_size: # The maximum size of the event log.
		# overflow_action: OverwriteOlder|OverwriteAsNeeded|DoNotOverwrite
		# retention_days: # The minimum number of days event entries must remain in the log.
$0
endsnippet

snippet win_psexec "Runs commands (remotely) as another (privileged) user" b
- name: $1
	win_psexec:
		command: ${2:# The command line to run through PsExec (limited to 260 characters).}
		# executable: psexec.exe
		# hostnames: # The hostnames to run the command.
		# username: # The (remote) user to run the command as.
		# password: # The password for the (remote) user to run the command as.
		# chdir: # Run the command from this (remote) directory.
		# nobanner: no
		# noprofile: no
		# elevated: no
		# interactive: no
		# session: # Specifies the session ID to use.
		# limited: no
		# system: no
		# priority: background|low|belownormal|abovenormal|high|realtime
		# timeout: # The connection timeout in seconds
		# wait: yes
$0
endsnippet

snippet win_hotfix "Install and uninstalls Windows hotfixes" b
- name: $1
	win_hotfix:
		# hotfix_identifier: # The name of the hotfix as shown in DISM, see examples for details.
		# hotfix_kb: # The name of the KB the hotfix relates to, see examples for details.
		# state: absent|#present
		# source: # The path to the downloaded hotfix .msu file.
$0
endsnippet

snippet win_reg_stat "Get information about Windows registry keys" b
- name: $1
	win_reg_stat:
		path: ${2:# T}
		# name: # The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.
$0
endsnippet

snippet win_service "Manage and query Windows services" b
- name: $1
	win_service:
		name: ${2:# Name of the service.}
		# dependencies: # A list of service dependencies to set for this particular service.
		# dependency_action: add|remove|#set
		# desktop_interact: no
		# description: # The description to set for the service.
		# display_name: # The display name to set for the service.
		# force_dependent_services: no
		# path: # The path to the executable to set for the service.
		# password: # The password to set the service to start as.
		# start_mode: auto|delayed|disabled|manual
		# state: absent|paused|started|stopped|restarted
		# username: # The username to set the service to start as.
$0
endsnippet

snippet win_user_right "Manage Windows User Rights" b
- name: $1
	win_user_right:
		name: ${2:# The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).}
		users: ${3:# A list of users or groups to add/remove on the User Right.}
		# action: add|remove|#set
$0
endsnippet

snippet win_regedit "Add, change, or remove registry keys and values" b
- name: $1
	win_regedit:
		path: ${2:# Name of the registry path.}
		# name: # Name of the registry entry in the above C(path) parameters.
		# data: # Value of the registry entry C(name) in C(path).
		# type: binary|dword|expandstring|multistring|#string|qword
		# state: absent|#present
		# delete_key: yes
		# hive: # A path to a hive key like C:\Users\Default\NTUSER.DAT to load in the registry.
$0
endsnippet

snippet win_iis_webbinding "Configures a IIS Web site binding" b
- name: $1
	win_iis_webbinding:
		name: ${2:# Names of web site.}
		# state: absent|#present
		# port: 80
		# ip: *
		# host_header: # The host header to bind to / use for the new site.
		# protocol: http
		# certificate_hash: # Certificate hash (thumbprint) for the SSL binding. The certificate hash is the unique identifier for the certificate.
		# certificate_store_name: my
		# ssl_flags: # This parameter is only valid on Server 2012 and newer.
$0
endsnippet

snippet win_audit_policy_system "Used to make changes to the system wide Audit Policy" b
- name: $1
	win_audit_policy_system:
		audit_type: ${2:failure|none|success}
		# category: # Single string value for the category you would like to adjust the policy on.
		# subcategory: # Single string value for the subcategory you would like to adjust the policy on.
$0
endsnippet

snippet win_package "Installs/uninstalls an installable package" b
- name: $1
	win_package:
		# arguments: # Any arguments the installer needs to either install or uninstall the package.
		# creates_path: # Will check the existance of the path specified and use the result to determine whether the package is already installed.
		# creates_service: # Will check the existing of the service specified and use the result to determine whether the package is already installed.
		# creates_version: # Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.
		# expected_return_code: [0, 3010]
		# password: # The password for C(user_name), must be set when C(user_name) is.
		# path: # Location of the package to be installed or uninstalled.
		# product_id: # The product id of the installed packaged.
		# state: present
		# username: # Username of an account with access to the package if it is located on a file share.
		# validate_certs: yes
$0
endsnippet

snippet win_chocolatey_feature "Manages Chocolatey features" b
- name: $1
	win_chocolatey_feature:
		name: ${2:# The name of the feature to manage.}
		# state: disabled|#enabled
$0
endsnippet

snippet win_certificate_store "Manages the certificate store" b
- name: $1
	win_certificate_store:
		# state: absent|exported|#present
		# path: # The path to a certificate file.
		# thumbprint: # The thumbprint as a hex string to either export or remove.
		# store_name: AddressBook|AuthRoot|CertificateAuthority|Disallowed|#My|Root|TrustedPeople|TrustedPublisher
		# store_location: CurrentUser|#LocalMachine
		# password: # The password of the pkcs12 certificate key.
		# key_exportable: yes
		# key_storage: #default|machine|user
		# file_type: #der|pem|pkcs12
$0
endsnippet

snippet win_wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
- name: $1
	win_wakeonlan:
		mac: ${2:# MAC address to send Wake-on-LAN broadcast packet for.}
		# broadcast: 255.255.255.255
		# port: 7
$0
endsnippet

snippet win_domain_group "Creates, modifies or removes domain groups" b
- name: $1
	win_domain_group:
		name: ${2:# The name of the group to create, modify or remove.}
		# attributes: # A dict of custom LDAP attributes to set on the group.
		# category: distribution|security
		# description: # The value to be assigned to the LDAP C(description) attribute.
		# display_name: # The value to assign to the LDAP C(displayName) attribute.
		# domain_username: # The username to use when interacting with AD.
		# domain_password: # The password for C(username).
		# domain_server: # Specifies the Active Directory Domain Services instance to connect to.
		# ignore_protection: no
		# managed_by: # The value to be assigned to the LDAP C(managedBy) attribute.
		# organizational_unit: # The full LDAP path to create or move the group to.
		# protect: # Will set the C(ProtectedFromAccidentalDeletion) flag based on this value.
		# scope: domainlocal|global|universal
		# state: absent|#present
$0
endsnippet

snippet win_msg "Sends a message to logged in users on Windows hosts" b
- name: $1
	win_msg:
		# to: *
		# display_seconds: 10
		# wait: no
		# msg: Hello world!
$0
endsnippet

snippet win_eventlog_entry "Write entries to Windows event logs" b
- name: $1
	win_eventlog_entry:
		log: ${2:# Name of the event log to write an entry to.}
		source: ${3:# Name of the log source to indicate where the entry is from.}
		event_id: ${4:# The numeric event identifier for the entry.}
		message: ${5:# The message for the given log entry.}
		# entry_type: Error|FailureAudit|Information|SuccessAudit|Warning
		# category: # A numeric task category associated with the category message file for the log source.
		# raw_data: # Binary data associated with the log entry.
$0
endsnippet

snippet win_iis_webapplication "Configures IIS web applications" b
- name: $1
	win_iis_webapplication:
		name: ${2:# Name of the web application.}
		site: ${3:# Name of the site on which the application is created.}
		# state: absent|#present
		# physical_path: # The physical path on the remote host to use for the new application.
		# application_pool: # The application pool in which the new site executes.
$0
endsnippet

snippet win_chocolatey "Manage packages using chocolatey" b
- name: $1
	win_chocolatey:
		name: ${2:# Name of the package(s) to be installed.}
		# allow_empty_checksums: no
		# allow_prerelease: no
		# architecture: #default|x86
		# force: no
		# install_args: # Arguments to pass to the native installer.
		# ignore_checksums: no
		# ignore_dependencies: no
		# package_params: # Parameters to pass to the package.
		# proxy_url: # Proxy URL used to install chocolatey and the package.
		# proxy_username: # Proxy username used to install Chocolatey and the package.
		# proxy_password: # Proxy password used to install Chocolatey and the package.
		# skip_scripts: no
		# source: # Specify the source to retrieve the package from.
		# source_username: # A username to use with I(source) when accessing a feed that requires authentication.
		# source_password: # The password for I(source_username).
		# state: absent|downgrade|latest|#present|reinstalled
		# timeout: 2700
		# validate_certs: yes
		# version: # Specific version of the package to be installed.
$0
endsnippet

snippet win_pagefile "Query or change pagefile configuration" b
- name: $1
	win_pagefile:
		# drive: # The drive of the pagefile.
		# initial_size: # The initial size of the pagefile in megabytes.
		# maximum_size: # The maximum size of the pagefile in megabytes.
		# override: yes
		# system_managed: no
		# automatic: # Configures AutomaticManagedPagefile for the entire system.
		# remove_all: no
		# test_path: yes
		# state: absent|present|#query
$0
endsnippet

snippet win_scheduled_task "Manage scheduled tasks" b
- name: $1
	win_scheduled_task:
		name: ${2:# The name of the scheduled task without the path.}
		# path: \
		# state: absent|#present
		# actions: # A list of action to configure for the task.
		# triggers: # A list of triggers to configure for the task.
		# display_name: # The name of the user/group that is displayed in the Task Scheduler UI.
		# group: # The group that will run the task.
		# logon_type: none|password|s4u|interactive_token|group|service_account|token_or_password
		# run_level: limited|highest
		# username: # The user to run the scheduled task as.
		# password: # The password for the user account to run the scheduled task as.
		# update_password: yes
		# author: # The author of the task.
		# date: # The date when the task was registered.
		# description: # The description of the task.
		# source: # The source of the task.
		# version: # The version number of the task.
		# allow_demand_start: # Whether the task can be started by using either the Run command or the Context menu.
		# allow_hard_terminate: # Whether the task can be terminated by using TerminateProcess.
		# compatibility: 0|1|2
		# delete_expired_task_after: # The amount of time that the Task Scheduler will wait before deleting the task after it expires.
		# disallow_start_if_on_batteries: # Whether the task will not be started if the computer is running on battery power.
		# enabled: # Whether the task is enabled, the task can only run when C(yes).
		# execution_time_limit: # The amount of time allowed to complete the task.
		# hidden: # Whether the task will be hidden in the UI.
		# multiple_instances: 0|1|2|3
		# priority: # The priority level (0-10) of the task.
		# restart_count: # The number of times that the Task Scheduler will attempt to restart the task.
		# restart_interval: # How long the Task Scheduler will attempt to restart the task.
		# run_only_if_idle: # Whether the task will run the task only if the computer is in an idle state.
		# run_only_if_network_available: # Whether the task will run only when a network is available.
		# start_when_available: # Whether the task can start at any time after its scheduled time has passed.
		# stop_if_going_on_batteries: # Whether the task will be stopped if the computer begins to run on battery power.
		# wake_to_run: # Whether the task will wake the computer when it is time to run the task.
$0
endsnippet

snippet win_audit_rule "Adds an audit rule to files, folders, or registry keys" b
- name: $1
	win_audit_rule:
		path: ${2:# Path to the file, folder, or registry key.}
		user: ${3:# The user or group to adjust rules for.}
		rights: ${4:# Comma separated list of the rights desired. Only required for adding a rule.}
		audit_flags: ${5:Failure|Success}
		# inheritance_flags: ContainerInherit|ObjectInherit
		# propagation_flags: #None|InherityOnly|NoPropagateInherit
		# state: absent|#present
$0
endsnippet

snippet win_command "Executes a command on a remote Windows node" b
- name: $1
	win_command: $2
	args:
		# creates: # A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.
		# removes: # A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.
		# chdir: # Set the specified path as the current working directory before executing a command.
		# stdin: # Set the stdin of the command directly to the specified value.
$0
endsnippet

snippet win_power_plan "Changes the power plan of a Windows system" b
- name: $1
	win_power_plan:
		name: ${2:# String value that indicates the desired power plan.}
$0
endsnippet

snippet win_webpicmd "Installs packages using Web Platform Installer command-line" b
- name: $1
	win_webpicmd:
		name: ${2:# Name of the package to be installed.}
$0
endsnippet

snippet win_user "Manages local Windows user accounts" b
- name: $1
	win_user:
		name: ${2:# Name of the user to create, remove or modify.}
		# fullname: # Full name of the user.
		# description: # Description of the user.
		# password: # Optionally set the user's password to this (plain text) value.
		# update_password: #always|on_create
		# password_expired: # C(yes) will require the user to change their password at next login.
		# password_never_expires: # C(yes) will set the password to never expire.
		# user_cannot_change_password: # C(yes) will prevent the user from changing their password.
		# account_disabled: # C(yes) will disable the user account.
		# account_locked: no
		# groups: # Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.
		# groups_action: add|#replace|remove
		# state: absent|#present|query
$0
endsnippet

snippet win_domain "Ensures the existence of a Windows domain" b
- name: $1
	win_domain:
		dns_domain_name: ${2:# The DNS name of the domain which should exist and be reachable or reside on the target Windows host.}
		safe_mode_password: ${3:# Safe mode password for the domain controller.}
		# domain_netbios_name: # The netbios name of the domain.
		# database_path: # The path to a directory on a fixed disk of the Windows host where the domain database will be created.
		# sysvol_path: # The path to a directory on a fixed disk of the Windows host where the Sysvol file will be created.
$0
endsnippet

snippet win_group_membership "Manage Windows local group membership" b
- name: $1
	win_group_membership:
		name: ${2:# Name of the local group to manage membership on.}
		members: ${3:# A list of members to ensure are present/absent from the group.}
		# state: absent|#present
$0
endsnippet

snippet win_template "Templates a file out to a remote server" b
- name: $1
	win_template:
		src: ${2:# Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.}
		dest: ${3:# Location to render the template to on the remote machine.}
		# newline_sequence: \n|\r|#\r\n
		# block_start_string: {%
		# block_end_string: %}
		# variable_start_string: {{
		# variable_end_string: }}
		# trim_blocks: no
		# force: yes
$0
endsnippet

snippet win_robocopy "Synchronizes the contents of two directories using Robocopy" b
- name: $1
	win_robocopy:
		src: ${2:# Source file/directory to sync.}
		dest: ${3:# Destination file/directory to sync (Will receive contents of src).}
		# recurse: no
		# purge: no
		# flags: # Directly supply Robocopy flags. If set, C(purge) and C(recurse) will be ignored.
$0
endsnippet

snippet win_region "Set the region and format settings" b
- name: $1
	win_region:
		# location: # The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to. This needs to be set if C(format) or C(unicode_language) is not set.
		# format: # The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(unicode_language) is not set.
		# unicode_language: # The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use. This needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect.
		# copy_settings: no
$0
endsnippet

snippet win_environment "Modify environment variables on windows hosts" b
- name: $1
	win_environment:
		name: ${2:# The name of the environment variable.}
		level: ${3:machine|user|process}
		# state: absent|#present
		# value: # The value to store in the environment variable.
$0
endsnippet

snippet win_copy "Copies files to remote locations on windows hosts" b
- name: $1
	win_copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		src: ${3:# Local path to a file to copy to the remote server; can be absolute or relative.}
		# content: # When used instead of C(src), sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.
		# decrypt: yes
		# force: yes
		# local_follow: yes
		# remote_src: no
$0
endsnippet

snippet win_share "Manage Windows shares" b
- name: $1
	win_share:
		name: ${2:# Share name.}
		path: ${3:# Share directory.}
		# state: absent|#present
		# description: # Share description.
		# list: no
		# read: # Specify user list that should get read access on share, separated by comma.
		# change: # Specify user list that should get read and write access on share, separated by comma.
		# full: # Specify user list that should get full access on share, separated by comma.
		# deny: # Specify user list that should get no access, regardless of implied access on share, separated by comma.
		# caching_mode: BranchCache|Documents|#Manual|None|Programs|Unknown
		# encrypt: no
$0
endsnippet

snippet win_lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression" b
- name: $1
	win_lineinfile:
		path: ${2:# The path of the file to modify.}
		# regexp: # The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).
		# state: absent|#present
		# line: # Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.
		# backrefs: no
		# insertafter: #EOF|*regex*
		# insertbefore: BOF|*regex*
		# create: no
		# backup: no
		# validate: # Validation to run before copying into place. Use %s in the command to indicate the current file to validate.
		# encoding: auto
		# newline: unix|#windows
$0
endsnippet

snippet win_timezone "Sets Windows machine timezone" b
- name: $1
	win_timezone:
		timezone: ${2:# Timezone to set to.}
$0
endsnippet

snippet win_iis_virtualdirectory "Configures a virtual directory in IIS" b
- name: $1
	win_iis_virtualdirectory:
		name: ${2:# The name of the virtual directory to create or remove.}
		site: ${3:# The site name under which the virtual directory is created or exists.}
		# state: absent|#present
		# application: # The application under which the virtual directory is created or exists.
		# physical_path: # The physical path to the folder in which the new virtual directory is created.
$0
endsnippet

snippet win_shortcut "Manage shortcuts on Windows" b
- name: $1
	win_shortcut:
		dest: ${2:# Destination file for the shortcuting file.}
		# src: # Executable or URL the shortcut points to.
		# description: # Description for the shortcut.
		# args: # Additional arguments for the executable defined in C(src).
		# directory: # Working directory for executable defined in C(src).
		# icon: # Icon used for the shortcut.
		# hotkey: # Key combination for the shortcut.
		# windowstyle: maximized|minimized|normal
		# state: absent|#present
$0
endsnippet

snippet win_mapped_drive "Map network drives for users" b
- name: $1
	win_mapped_drive:
		letter: ${2:# The letter of the network path to map to.}
		# password: # The password for C(username).
		# path: # The UNC path to map the drive to.
		# state: absent|#present
		# username: # Credentials to map the drive with.
$0
endsnippet

snippet win_updates "Download and install Windows updates" b
- name: $1
	win_updates:
		# blacklist: # A list of update titles or KB numbers that can be used to specify which updates are to be excluded from installation.
		# category_names: ['Application', 'Connectors', #'CriticalUpdates', 'DefinitionUpdates', 'DeveloperKits', 'FeaturePacks', 'Guidance', #'SecurityUpdates', 'ServicePacks', 'Tools', #'UpdateRollups', 'Updates'
		# reboot: no
		# reboot_timeout: 1200
		# state: #installed|searched
		# log_path: # If set, C(win_updates) will append update progress to the specified file. The directory must already exist.
		# whitelist: # A list of update titles or KB numbers that can be used to specify which updates are to be searched or installed.
		# use_scheduled_task: no
$0
endsnippet

snippet win_uri "Interacts with webservices" b
- name: $1
	win_uri:
		url: ${2:# Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path.}
		# method: CONNECT|DELETE|#GET|HEAD|MERGE|OPTIONS|PATCH|POST|PUT|REFRESH|TRACE
		# content_type: # Sets the "Content-Type" header.
		# body: # The body of the HTTP request/response to the web service.
		# user: # Username to use for authentication.
		# password: # Password to use for authentication.
		# force_basic_auth: no
		# dest: # Output the response body to a file.
		# headers: # Extra headers to set on the request, see the examples for more details on how to set this.
		# creates: # A filename, when it already exists, this step will be skipped.
		# removes: # A filename, when it does not exist, this step will be skipped.
		# return_content: no
		# status_code: 200
		# timeout: 30
		# follow_redirects: all|none|#safe
		# maximum_redirection: 5
		# validate_certs: yes
		# client_cert: # Specifies the client certificate (.pfx) that is used for a secure web request.
		# client_cert_password: # The password for the client certificate (.pfx) file that is used for a secure web request.
$0
endsnippet

snippet win_file_version "Get DLL or EXE file build version" b
- name: $1
	win_file_version:
		path: ${2:# File to get version.}
$0
endsnippet

snippet win_regmerge "Merges the contents of a registry file into the windows registry" b
- name: $1
	win_regmerge:
		path: ${2:# The full path including file name to the registry file on the remote machine to be merged}
		# compare_key: # The parent key to use when comparing the contents of the registry to the contents of the file.  Needs to be in HKLM or HKCU part of registry. Use a PS-Drive style path for example HKLM:\SOFTWARE not HKEY_LOCAL_MACHINE\SOFTWARE If not supplied, or the registry key is not found, no comparison will be made, and the module will report changed.
$0
endsnippet

snippet win_group "Add and remove local groups" b
- name: $1
	win_group:
		name: ${2:# Name of the group.}
		# description: # Description of the group.
		# state: absent|#present
$0
endsnippet

snippet win_toast "Sends Toast windows notification to logged in users on Windows 10 or later hosts" b
- name: $1
	win_toast:
		# expire: 45
		# group: Powershell
		# msg: Hello, World!
		# popup: yes
		# tag: Ansible
		# title: Notification HH:mm
$0
endsnippet

snippet win_chocolatey_source "Manages Chocolatey sources" b
- name: $1
	win_chocolatey_source:
		name: ${2:# The name of the source to configure.}
		# admin_only: # Makes the source visible to Administrators only.
		# allow_self_service: # Allow the source to be used with self-service
		# bypass_proxy: # Bypass the proxy when using this source.
		# certificate: # The path to a .pfx file to use for X509 authenticated feeds.
		# certificate_password: # The password for I(certificate) if required.
		# priority: # The priority order of this source compared to other sources, lower is better.
		# source: # The file/folder/url of the source.
		# source_username: # The username used to access I(source).
		# source_password: # The password for I(source_username).
		# state: absent|disabled|#present
		# update_password: #always|on_create
$0
endsnippet

snippet win_feature "Installs and uninstalls Windows Features on Windows Server" b
- name: $1
	win_feature:
		name: ${2:# Names of roles or features to install as a single feature or a comma-separated list of features.}
		# state: absent|#present
		# include_sub_features: no
		# include_management_tools: no
		# source: # Specify a source to install the feature from.
$0
endsnippet

snippet win_acl "Set file/directory/registry permissions for a system user or group" b
- name: $1
	win_acl:
		path: ${2:# The path to the file or directory.}
		user: ${3:# User or Group to add specified rights to act on src file/folder or registry key.}
		type: ${4:allow|deny}
		rights: ${5:# The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).}
		# state: absent|#present
		# inherit: ContainerInherit|ObjectInherit
		# propagation: InheritOnly|#None|NoPropagateInherit
$0
endsnippet

snippet win_domain_membership "Manage domain/workgroup membership for a Windows host" b
- name: $1
	win_domain_membership:
		domain_admin_user: ${2:# Username of a domain admin for the target domain (required to join or leave the domain).}
		# dns_domain_name: # When C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined.
		# domain_admin_password: # Password for the specified C(domain_admin_user).
		# hostname: # The desired hostname for the Windows host.
		# domain_ou_path: # The desired OU path for adding the computer object.
		# state: domain|workgroup
		# workgroup_name: # When C(state) is C(workgroup), the name of the workgroup that the Windows host should be in.
$0
endsnippet

snippet win_disk_image "Manage ISO/VHD/VHDX mounts on Windows hosts" b
- name: $1
	win_disk_image:
		image_path: ${2:# Path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)}
		# state: absent|#present
$0
endsnippet

snippet win_iis_website "Configures a IIS Web site" b
- name: $1
	win_iis_website:
		name: ${2:# Names of web site.}
		# site_id: # Explicitly set the IIS numeric ID for a site.
		# state: absent|started|stopped|restarted
		# physical_path: # The physical path on the remote host to use for the new site.
		# application_pool: # The application pool in which the new site executes.
		# port: # The port to bind to / use for the new site.
		# ip: # The IP address to bind to / use for the new site.
		# hostname: # The host header to bind to / use for the new site.
		# ssl: # Enables HTTPS binding on the site..
		# parameters: # Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. "foo:1|bar:2"
$0
endsnippet

snippet win_wait_for_process "Waits for a process to exist or not exist before continuing." b
- name: $1
	win_wait_for_process:
		# process_name_exact: # The name of the process(es) for which to wait.
		# process_name_pattern: # RegEx pattern matching desired process(es).
		# sleep: 1
		# process_min_count: 1
		# pid: # The PID of the process.
		# owner: # The owner of the process.
		# pre_wait_delay: 0
		# post_wait_delay: 0
		# state: absent|#present
		# timeout: 300
$0
endsnippet

snippet win_hostname "Manages local Windows computer name." b
- name: $1
	win_hostname:
		name: ${2:# The hostname to set for the computer.}
$0
endsnippet

snippet sensu_check "Manage Sensu checks" b
- name: $1
	sensu_check:
		name: ${2:# The name of the check}
		command: ${3:# Path to the sensu check to run (not required when I(state=absent))}
		# state: #present|absent
		# path: /etc/sensu/conf.d/checks.json
		# backup: no
		# handlers: []
		# subscribers: []
		# interval: # Check interval in seconds
		# timeout: 10
		# ttl: # Time to live in seconds until the check is considered stale
		# handle: yes
		# subdue_begin: # When to disable handling of check failures
		# subdue_end: # When to enable handling of check failures
		# dependencies: []
		# metric: no
		# standalone: no
		# publish: yes
		# occurrences: 1
		# refresh: # Number of seconds handlers should wait before taking second action
		# aggregate: no
		# low_flap_threshold: # The low threshold for flap detection
		# high_flap_threshold: # The high threshold for flap detection
		# custom: {}
		# source: # The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).
$0
endsnippet

snippet nagios "Perform common tasks in Nagios related to downtime and notifications." b
- name: $1
	nagios:
		action: ${2:downtime|delete_downtime|enable_alerts|disable_alerts|silence|unsilence|silence_nagios|unsilence_nagios|command|servicegroup_service_downtime|servicegroup_host_downtime}
		services: ${3:# What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions.}
		command: ${4:# The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action.}
		# host: # Host to operate on in Nagios.
		# cmdfile: auto-detected
		# author: Ansible
		# comment: Scheduling downtime
		# minutes: 30
		# servicegroup: # The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime).
$0
endsnippet

snippet grafana_dashboard "Manage Grafana dashboards" b
- name: $1
	grafana_dashboard:
		url: ${2:# The Grafana URL.}
		state: ${3:absent|export|#present}
		# url_username: admin
		# url_password: admin
		# grafana_api_key: # The Grafana API key.
		# org_id: 1
		# slug: # Deprecated since Grafana 5. Use grafana dashboard uid instead.
		# uid: # uid of the dasboard to export when C(state) is C(export) or C(absent).
		# path: # The path to the json file containing the Grafana dashboard to import or export.
		# overwrite: no
		# message: # Set a commit message for the version history.
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client
		# use_proxy: yes
$0
endsnippet

snippet circonus_annotation "create an annotation in circonus" b
- name: $1
	circonus_annotation:
		api_key: ${2:# Circonus API key}
		category: ${3:# Annotation Category}
		description: ${4:# Description of annotation}
		title: ${5:# Title of annotation}
		# start: I(now)
		# stop: I(now) + I(duration)
		# duration: 0
$0
endsnippet

snippet datadog_monitor "Manages Datadog monitors" b
- name: $1
	datadog_monitor:
		api_key: ${2:# Your DataDog API key.}
		app_key: ${3:# Your DataDog app key.}
		state: ${4:present|absent|mute|unmute}
		name: ${5:# The name of the alert.}
		# tags: # A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.
		# type: metric alert|service check|event alert
		# query: # The monitor query to notify on with syntax varying depending on what type of monitor you are creating.
		# message: # A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.
		# silenced: 
		# notify_no_data: no
		# no_data_timeframe: 2x timeframe for metric, 2 minutes for service
		# timeout_h: # The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.
		# renotify_interval: # The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.
		# escalation_message: # A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None
		# notify_audit: no
		# thresholds: {'ok': 1, 'critical': 1, 'warning': 1}
		# locked: no
		# require_full_window: # A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.
		# new_host_delay: # A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts. This gives the host time to fully initialize.
		# evaluation_delay: # Time to delay evaluation (in seconds). It is effective for sparse values.
		# id: # The id of the alert. If set, will be used instead of the name to locate the alert.
$0
endsnippet

snippet bigpanda "Notify BigPanda about deployments" b
- name: $1
	bigpanda:
		component: ${2:# The name of the component being deployed. Ex: billing}
		version: ${3:# The deployment version.}
		token: ${4:# API token.}
		state: ${5:started|finished|failed}
		# hosts: machine's hostname
		# env: # The environment name, typically 'production', 'staging', etc.
		# owner: # The person responsible for the deployment.
		# description: # Free text description of the deployment.
		# url: https://api.bigpanda.io
		# validate_certs: yes
$0
endsnippet

snippet statusio_maintenance "Create maintenance windows for your status.io dashboard" b
- name: $1
	statusio_maintenance:
		api_id: ${2:# Your unique API ID from status.io}
		api_key: ${3:# Your unique API Key from status.io}
		statuspage: ${4:# Your unique StatusPage ID from status.io}
		# title: A new maintenance window
		# desc: Created by Ansible
		# state: #present|absent
		# url: https://api.status.io
		# components: # The given name of your component (server name)
		# containers: # The given name of your container (data center)
		# all_infrastructure_affected: no
		# automation: no
		# maintenance_notify_now: no
		# maintenance_notify_72_hr: no
		# maintenance_notify_24_hr: no
		# maintenance_notify_1_hr: no
		# maintenance_id: # The maintenance id number when deleting a maintenance window
		# minutes: 10
		# start_date: # Date maintenance is expected to start (Month/Day/Year) (UTC)
		# start_time: # Time maintenance is expected to start (Hour:Minutes) (UTC)
$0
endsnippet

snippet monit "Manage the state of a program monitored via Monit" b
- name: $1
	monit:
		name: ${2:# The name of the I(monit) program/process to manage}
		state: ${3:present|started|stopped|restarted|monitored|unmonitored|reloaded}
		# timeout: 300
$0
endsnippet

snippet honeybadger_deployment "Notify Honeybadger.io about app deployments" b
- name: $1
	honeybadger_deployment:
		token: ${2:# API token.}
		environment: ${3:# The environment name, typically 'production', 'staging', etc.}
		# user: # The username of the person doing the deployment
		# repo: # URL of the project repository
		# revision: # A hash, number, tag, or other identifier showing what revision was deployed
		# url: https://api.honeybadger.io/v1/deploys
		# validate_certs: yes
$0
endsnippet

snippet icinga2_host "Manage a host in Icinga2" b
- name: $1
	icinga2_host:
		url: ${2:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		name: ${3:# Name used to create / delete the host. This does not need to be the FQDN, but does needs to be unique.}
		ip: ${4:# The IP address of the host.}
		# use_proxy: yes
		# validate_certs: yes
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# state: #present|absent
		# zone: # The zone from where this host should be polled.
		# template: # The template used to define the host.
		# check_command: hostalive
		# display_name: if none is give it is the value of the <name> parameter
		# variables: # List of variables.
$0
endsnippet

snippet sensu_handler "Manages Sensu handler configuration" b
- name: $1
	sensu_handler:
		name: ${2:# A unique name for the handler. The name cannot contain special characters or spaces.}
		type: ${3:pipe|tcp|udp|transport|set}
		# state: #present|absent
		# filter: # The Sensu event filter (name) to use when filtering events for the handler.
		# filters: # An array of Sensu event filters (names) to use when filtering events for the handler.
		# severities: warning|critical|unknown
		# mutator: # The Sensu event mutator (name) to use to mutate event data for the handler.
		# timeout: 10
		# handle_silenced: no
		# handle_flapping: no
		# command: # The handler command to be executed.
		# socket: # The socket definition scope, used to configure the TCP/UDP handler socket.
		# pipe: # The pipe definition scope, used to configure the Sensu transport pipe.
		# handlers: # An array of Sensu event handlers (names) to use for events using the handler set.
$0
endsnippet

snippet datadog_event "Posts events to Datadog  service" b
- name: $1
	datadog_event:
		api_key: ${2:# Your DataDog API key.}
		app_key: ${3:# Your DataDog app key.}
		title: ${4:# The event title.}
		text: ${5:# The body of the event.}
		# date_happened: now
		# priority: #normal|low
		# host: {{ ansible_hostname }}
		# tags: # Comma separated list of tags to apply to the event.
		# alert_type: error|warning|#info|success
		# aggregation_key: # An arbitrary string to use for aggregation.
		# validate_certs: yes
$0
endsnippet

snippet grafana_datasource "Manage Grafana datasources" b
- name: $1
	grafana_datasource:
		grafana_url: ${2:# The Grafana URL.}
		name: ${3:# The name of the datasource.}
		ds_type: ${4:graphite|prometheus|elasticsearch|influxdb|opentsdb|mysql|postgres|alexanderzobnin-zabbix-datasource}
		url: ${5:# The URL of the datasource.}
		# access: direct|#proxy
		# grafana_user: admin
		# grafana_password: admin
		# grafana_api_key: # The Grafana API key.
		# database: # Name of the database for the datasource.
		# user: # The datasource login user for influxdb datasources.
		# password: # The datasource password
		# basic_auth_user: # The datasource basic auth user.
		# basic_auth_password: # The datasource basic auth password, when C(basic auth) is C(yes).
		# with_credentials: no
		# tls_client_cert: # The client TLS certificate.
		# tls_client_key: # The client TLS private key
		# tls_ca_cert: # The TLS CA certificate for self signed certificates.
		# tls_skip_verify: no
		# is_default: no
		# org_id: 1
		# state: absent|#present
		# es_version: 2|#5|56
		# max_concurrent_shard_requests: 256
		# time_field: timestamp
		# time_interval: # Minimum group by interval for C(influxdb) or C(elasticsearch) datasources.
		# interval: |Hourly|Daily|Weekly|Monthly|Yearly
		# tsdb_version: #1|2|3
		# tsdb_resolution: millisecond|#second
		# sslmode: disable|require|verify-ca|verify-full
		# trends: # Use trends or not for zabbix datasource type
		# validate_certs: yes
$0
endsnippet

snippet logstash_plugin "Manage Logstash plugins" b
- name: $1
	logstash_plugin:
		name: ${2:# Install plugin with that name.}
		# state: #present|absent
		# plugin_bin: /usr/share/logstash/bin/logstash-plugin
		# proxy_host: # Proxy host to use during plugin installation.
		# proxy_port: # Proxy port to use during plugin installation.
		# version: # Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.
$0
endsnippet

snippet logicmonitor "Manage your LogicMonitor account through Ansible Playbooks" b
- name: $1
	logicmonitor:
		target: ${2:collector|host|datsource|hostgroup}
		action: ${3:add|remove|update|sdt}
		company: ${4:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."}
		user: ${5:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${6:# The password of the specified LogicMonitor user}
		# collector: # The fully qualified domain name of a collector in your LogicMonitor account.
		# hostname: hostname -f
		# displayname: hostname -f
		# description: 
		# properties: {}
		# groups: []
		# id: # ID of the datasource to target.
		# fullpath: # The fullpath of the host group object you would like to manage.
		# alertenable: yes
		# starttime: Now
		# duration: 30
$0
endsnippet

snippet logicmonitor_facts "Collect facts about LogicMonitor objects" b
- name: $1
	logicmonitor_facts:
		target: ${2:host|hostgroup}
		company: ${3:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".}
		user: ${4:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
		password: ${5:# The password for the chosen LogicMonitor User.}
		# collector: # The fully qualified domain name of a collector in your LogicMonitor account.
		# hostname: hostname -f
		# displayname: hostname -f
		# fullpath: # The fullpath of the hostgroup object you would like to manage.
$0
endsnippet

snippet sensu_silence "Manage Sensu silence entries" b
- name: $1
	sensu_silence:
		state: ${2:#present|absent}
		subscription: ${3:[]}
		# check: # Specifies the check which the silence entry applies to.
		# creator: # Specifies the entity responsible for this entry.
		# expire: # If specified, the silence entry will be automatically cleared after this number of seconds.
		# expire_on_resolve: # If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.
		# reason: # If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.
		# url: http://127.0.01:4567
$0
endsnippet

snippet logentries "Module for tracking logs via logentries.com" b
- name: $1
	logentries:
		path: ${2:# path to a log file}
		# state: #present|absent
		# name: # name of the log
		# logtype: # type of the log
$0
endsnippet

snippet pagerduty_alert "Trigger, acknowledge or resolve PagerDuty incidents" b
- name: $1
	pagerduty_alert:
		service_id: ${2:# ID of PagerDuty service when incidents will be triggered, acknowledged or resolved.}
		integration_key: ${3:# The GUID of one of your "Generic API" services.}
		state: ${4:triggered|acknowledged|resolved}
		api_key: ${5:# The pagerduty API key (readonly access), generated on the pagerduty site.}
		# name: # PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.
		# service_key: # The GUID of one of your "Generic API" services. Obsolete. Please use I(integration_key).
		# desc: Created via Ansible
		# incident_key: # Identifies the incident to which this I(state) should be applied.
		# client: # The name of the monitoring client that is triggering this event.
		# client_url: # The URL of the monitoring client that is triggering this event.
$0
endsnippet

snippet grafana_plugin "Manage Grafana plugins via grafana-cli" b
- name: $1
	grafana_plugin:
		name: ${2:# Name of the plugin.}
		# version: # Version of the plugin to install.
		# grafana_plugins_dir: # Directory where Grafana plugin will be installed.
		# grafana_repo: # Grafana repository. If not set, gafana-cli will use the default value C(https://grafana.net/api/plugins).
		# grafana_plugin_url: # Custom Grafana plugin URL.
		# state: absent|#present
$0
endsnippet

snippet newrelic_deployment "Notify newrelic about app deployments" b
- name: $1
	newrelic_deployment:
		token: ${2:# API token, to place in the x-api-key header.}
		# app_name: # (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application
		# application_id: # (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM
		# changelog: # A list of changes for this deployment
		# description: # Text annotation for the deployment - notes for you
		# revision: # A revision number (e.g., git commit SHA)
		# user: # The name of the user/process that triggered this deployment
		# appname: # Name of the application
		# environment: # The environment for this deployment
		# validate_certs: yes
$0
endsnippet

snippet uptimerobot "Pause and start Uptime Robot monitoring" b
- name: $1
	uptimerobot:
		state: ${2:started|paused}
		monitorid: ${3:# ID of the monitor to check.}
		apikey: ${4:# Uptime Robot API key.}
$0
endsnippet

snippet sensu_client "Manages Sensu client configuration" b
- name: $1
	sensu_client:
		subscriptions: ${2:# An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).}
		# state: #present|absent
		# name: System hostname as determined by Ruby Socket.gethostname (provided by Sensu)
		# address: Non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu)
		# safe_mode: no
		# redact: # Client definition attributes to redact (values) when logging and sending client keepalives.
		# socket: # The socket definition scope, used to configure the Sensu client socket.
		# keepalives: yes
		# keepalive: # The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).
		# registration: # The registration definition scope, used to configure Sensu registration event handlers.
		# deregister: no
		# deregistration: # The deregistration definition scope, used to configure automated Sensu client de-registration.
		# ec2: # The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).
		# chef: # The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).
		# puppet: # The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).
		# servicenow: # The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).
$0
endsnippet

snippet librato_annotation "create an annotation in librato" b
- name: $1
	librato_annotation:
		user: ${2:# Librato account username}
		api_key: ${3:# Librato account api key}
		title: ${4:# The title of an annotation is a string and may contain spaces}
		links: ${5:# See examples}
		# name: # The annotation stream name
		# source: # A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population
		# description: # The description contains extra meta-data about a particular annotation
		# start_time: # The unix timestamp indicating the time at which the event referenced by this annotation started
		# end_time: # The unix timestamp indicating the time at which the event referenced by this annotation ended
$0
endsnippet

snippet sensu_subscription "Manage Sensu subscriptions" b
- name: $1
	sensu_subscription:
		name: ${2:# The name of the channel}
		# state: #present|absent
		# path: /etc/sensu/conf.d/subscriptions.json
		# backup: no
$0
endsnippet

snippet icinga2_feature "Manage Icinga2 feature" b
- name: $1
	icinga2_feature:
		name: ${2:# This is the feature name to enable or disable.}
		# state: #present|absent
$0
endsnippet

snippet rollbar_deployment "Notify Rollbar about app deployments" b
- name: $1
	rollbar_deployment:
		token: ${2:# Your project access token.}
		environment: ${3:# Name of the environment being deployed, e.g. 'production'.}
		revision: ${4:# Revision number/sha being deployed.}
		# user: # User who deployed.
		# rollbar_user: # Rollbar username of the user who deployed.
		# comment: # Deploy comment (e.g. what is being deployed).
		# url: https://api.rollbar.com/api/1/deploy/
		# validate_certs: yes
$0
endsnippet

snippet airbrake_deployment "Notify airbrake about app deployments" b
- name: $1
	airbrake_deployment:
		token: ${2:# API token.}
		environment: ${3:# The airbrake environment name, typically 'production', 'staging', etc.}
		# user: # The username of the person doing the deployment
		# repo: # URL of the project repository
		# revision: # A hash, number, tag, or other identifier showing what revision was deployed
		# url: https://airbrake.io/deploys.txt
		# validate_certs: yes
$0
endsnippet

snippet pingdom "Pause/unpause Pingdom alerts" b
- name: $1
	pingdom:
		state: ${2:running|paused}
		checkid: ${3:# Pingdom ID of the check.}
		uid: ${4:# Pingdom user ID.}
		passwd: ${5:# Pingdom user password.}
		key: ${6:# Pingdom API key.}
$0
endsnippet

snippet pagerduty "Create PagerDuty maintenance windows" b
- name: $1
	pagerduty:
		state: ${2:running|started|ongoing|absent}
		token: ${3:# A pagerduty token, generated on the pagerduty site. It is used for authorization.}
		# name: # PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.
		# user: # PagerDuty user ID. Obsolete. Please, use I(token) for authorization.
		# requester_id: # ID of user making the request. Only needed when creating a maintenance_window.
		# service: # A comma separated list of PagerDuty service IDs.
		# window_id: # ID of maintenance window. Only needed when absent a maintenance_window.
		# hours: 1
		# minutes: 0
		# desc: Created by Ansible
		# validate_certs: yes
$0
endsnippet

snippet stackdriver "Send code deploy and annotation events to stackdriver" b
- name: $1
	stackdriver:
		key: ${2:# API key.}
		# event: annotation|deploy
		# revision_id: # The revision of the code that was deployed. Required for deploy events
		# deployed_by: Ansible
		# deployed_to: # The environment code was deployed to. (ie: development, staging, production)
		# repository: # The repository (or project) deployed
		# msg: # The contents of the annotation message, in plain text.  Limited to 256 characters. Required for annotation.
		# annotated_by: Ansible
		# level: #INFO|WARN|ERROR
		# instance_id: # id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown
		# event_epoch: # Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.
$0
endsnippet

snippet spectrum_device "Creates/deletes devices in CA Spectrum." b
- name: $1
	spectrum_device:
		device: ${2:# IP address of the device.}
		landscape: ${3:# Landscape handle of the SpectroServer to which add or remove the device.}
		url: ${4:# HTTP, HTTPS URL of the Oneclick server in the form (http|https)://host.domain[:port]}
		url_username: ${5:# Oneclick user name.}
		url_password: ${6:# Oneclick user password.}
		# community: # SNMP community used for device discovery.
		# state: #present|absent
		# use_proxy: yes
		# validate_certs: yes
		# agentport: 161
$0
endsnippet

snippet zabbix_template "create/delete/dump zabbix template" b
- name: $1
	zabbix_template:
		template_name: ${2:# Name of zabbix template}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# template_json: # JSON dump of template to import
		# template_groups: # List of template groups to create or delete.
		# link_templates: # List of templates linked to the template.
		# clear_templates: # List of templates cleared from the template.
		# macros: # List of templates macro
		# state: #present|absent|dump
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_group "Zabbix host groups creates/deletes" b
- name: $1
	zabbix_group:
		host_groups: ${2:# List of host groups to create or delete.}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# state: #present|absent
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_host "Zabbix host creates/updates/deletes" b
- name: $1
	zabbix_host:
		host_name: ${2:# Name of the host in Zabbix.}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# visible_name: # Visible name of the host in Zabbix.
		# description: # Description of the host in Zabbix.
		# host_groups: # List of host groups the host is part of.
		# link_templates: # List of templates linked to the host.
		# inventory_mode: automatic|manual|disabled
		# inventory_zabbix: # Add Facts for a zabbix inventory (e.g. Tag) (see example below).
		# status: #enabled|disabled
		# state: #present|absent
		# proxy: # The name of the Zabbix proxy to be used.
		# interfaces: []
		# tls_connect: 1
		# tls_accept: 1
		# tls_psk_identity: # It is a unique name by which this specific PSK is referred to by Zabbix components
		# tls_psk: # PSK value is a hard to guess string of hexadecimal digits.
		# tls_issuer: # Required certificate issuer.
		# tls_subject: # Required certificate subject.
		# ipmi_authtype: # IPMI authentication algorithm.
		# ipmi_privilege: # IPMI privilege level.
		# ipmi_username: # IPMI username.
		# ipmi_password: # IPMI password.
		# force: yes
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_group_facts "Gather facts about Zabbix hostgroup" b
- name: $1
	zabbix_group_facts:
		hostgroup_name: ${2:# Name of the hostgroup in Zabbix.}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_hostmacro "Zabbix host macro creates/updates/deletes" b
- name: $1
	zabbix_hostmacro:
		host_name: ${2:# Name of the host.}
		macro_name: ${3:# Name of the host macro.}
		macro_value: ${4:# Value of the host macro.}
		server_url: ${5:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${6:# Zabbix user name.}
		login_password: ${7:# Zabbix user password.}
		# state: #present|absent
		# force: yes
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_maintenance "Create Zabbix maintenance windows" b
- name: $1
	zabbix_maintenance:
		name: ${2:# Unique name of maintenance window.}
		desc: ${3:Created by Ansible}
		server_url: ${4:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${5:# Zabbix user name.}
		login_password: ${6:# Zabbix user password.}
		# state: #present|absent
		# host_names: # Hosts to manage maintenance window for. Separate multiple hosts with commas. C(host_name) is an alias for C(host_names). B(Required) option when C(state) is I(present) and no C(host_groups) specified.
		# host_groups: # Host groups to manage maintenance window for. Separate multiple groups with commas. C(host_group) is an alias for C(host_groups). B(Required) option when C(state) is I(present) and no C(host_names) specified.
		# minutes: 10
		# collect_data: yes
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_proxy "Zabbix proxy creates/deletes/gets/updates" b
- name: $1
	zabbix_proxy:
		proxy_name: ${2:# Name of the proxy in Zabbix.}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# description: # Description of the proxy..
		# status: #active|passive
		# tls_connect: #no_encryption|PSK|certificate
		# tls_accept: #no_encryption|PSK|certificate
		# tls_issuer: # Certificate issuer.
		# tls_subject: # Certificate subject.
		# tls_psk_identity: # PSK identity. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.
		# tls_psk: # The preshared key, at least 32 hex digits. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.
		# state: #present|absent
		# interface: {}
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_host_facts "Gather facts about Zabbix host" b
- name: $1
	zabbix_host_facts:
		host_name: ${2:# Name of the host in Zabbix.}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# host_ip: # Host interface IP of the host in Zabbix.
		# exact_match: no
		# remove_duplicate: yes
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet zabbix_screen "Zabbix screen creates/updates/deletes" b
- name: $1
	zabbix_screen:
		screens: ${2:# List of screens to be created/updated/deleted(see example).}
		server_url: ${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
		login_user: ${4:# Zabbix user name.}
		login_password: ${5:# Zabbix user password.}
		# http_login_user: # Basic Auth login
		# http_login_password: # Basic Auth password
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet netcup_dns "manage Netcup DNS records" b
- name: $1
	netcup_dns:
		api_key: ${2:# API key for authentification, must be obtained via the netcup CCP (U(https://ccp.netcup.net))}
		api_password: ${3:# API password for authentification, must be obtained via the netcup CCP (https://ccp.netcup.net)}
		customer_id: ${4:# Netcup customer id}
		domain: ${5:# Domainname the records should be added / removed}
		type: ${6:A|AAAA|MX|CNAME|CAA|SRV|TXT|TLSA|NS|DS}
		value: ${7:# Record value}
		# record: @
		# solo: no
		# priority: # Record priority. Required for C(type=MX)
		# state: #present|absent
$0
endsnippet

snippet snmp_facts "Retrieve facts for a device using SNMP." b
- name: $1
	snmp_facts:
		host: ${2:# Set to target snmp server (normally {{inventory_hostname}})}
		version: ${3:v2|v2c|v3}
		# community: # The SNMP community string, required if version is v2/v2c
		# level: authPriv|authNoPriv
		# username: # Username for SNMPv3, required if version is v3
		# integrity: md5|sha
		# authkey: # Authentication key, required if version is v3
		# privacy: des|aes
		# privkey: # Encryption key, required if version is authPriv
$0
endsnippet

snippet ipinfoio_facts "Retrieve IP geolocation facts of a host's IP address" b
- name: $1
	ipinfoio_facts:
		# timeout: 10
		# http_agent: ansible-ipinfoio-module/0.0.1
$0
endsnippet

snippet ip_netns "Manage network namespaces" b
- name: $1
	ip_netns:
		# name: # Name of the namespace
		# state: #present|absent
$0
endsnippet

snippet cloudflare_dns "manage Cloudflare DNS records" b
- name: $1
	cloudflare_dns:
		account_api_token: ${2:# Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)
}
		account_email: ${3:# Account email.}
		zone: ${4:# The name of the Zone to work with (e.g. "example.com"). The Zone must already exist.}
		# algorithm: # Algorithm number. Required for C(type=DS) and C(type=SSHFP) when C(state=present).
		# cert_usage: 0|1|2|3
		# hash_type: 1|2
		# key_tag: # DNSSEC key tag. Needed for C(type=DS) when C(state=present).
		# port: # S
		# priority: 1
		# proto: # Service protocol. Required for C(type=SRV) and C(type=TLSA).
		# proxied: no
		# record: @
		# selector: 0|1
		# service: # R
		# solo: # Whether the record should be the only one for that record type and record name. Only use with C(state=present)
		# state: #present|absent
		# timeout: 30
		# ttl: 1 (automatic)
		# type: A|AAAA|CNAME|TXT|SRV|MX|NS|DS|SPF|SSHFP|TLSA
		# value: # The record value. Required for C(state=present)
		# weight: 1
$0
endsnippet

snippet haproxy "Enable, disable, and set weights for HAProxy backend servers using socket commands." b
- name: $1
	haproxy:
		host: ${2:# Name of the backend host to change.}
		state: ${3:enabled|disabled|drain}
		# backend: auto-detected
		# drain: # Wait until the server has no active connections or until the timeout determined by wait_interval and wait_retries is reached.  Continue only after the status changes to 'MAINT'.  This overrides the shutdown_sessions option.
		# shutdown_sessions: no
		# socket: /var/run/haproxy.sock
		# fail_on_not_found: no
		# wait: no
		# wait_interval: 5
		# wait_retries: 25
		# weight: # The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.
$0
endsnippet

snippet dnsimple "Interface with dnsimple.com (a DNS hosting service)" b
- name: $1
	dnsimple:
		# account_email: # Account email. If omitted, the environment variables C(DNSIMPLE_EMAIL) and C(DNSIMPLE_API_TOKEN) will be looked for.
		# account_api_token: # Account API token. See I(account_email) for more information.
		# domain: # Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple.
		# record: # Record to add, if blank a record for the domain will be created, supports the wildcard (*).
		# record_ids: # List of records to ensure they either exist or do not exist.
		# type: A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL
		# ttl: 3600
		# value: # Record value.
		# priority: # Record priority.
		# state: present|absent
		# solo: # Whether the record should be the only one for that record type and record name.
$0
endsnippet

snippet omapi_host "Setup OMAPI hosts." b
- name: $1
	omapi_host:
		state: ${2:present|absent}
		key_name: ${3:# Sets the TSIG key name for authenticating against OMAPI server.}
		key: ${4:# Sets the TSIG key content for authenticating against OMAPI server.}
		macaddr: ${5:# Sets the lease host MAC address.}
		# name: # Sets the host lease hostname (mandatory if state=present).
		# host: localhost
		# port: 7911
		# ip: # Sets the lease host IP address.
		# statements: []
		# ddns: no
$0
endsnippet

snippet lldp "get details reported by lldp" b
- name: $1
	lldp:
$0
endsnippet

snippet nsupdate "Manage DNS records." b
- name: $1
	nsupdate:
		server: ${2:# Apply DNS modification on this server.}
		record: ${3:# Sets the DNS record to modify. When zone is omitted this has to be absolute (ending with a dot).}
		# state: #present|absent
		# port: 53
		# key_name: # Use TSIG key name to authenticate against DNS C(server)
		# key_secret: # Use TSIG key secret, associated with C(key_name), to authenticate against C(server)
		# key_algorithm: HMAC-MD5.SIG-ALG.REG.INT|#hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hmac-sha384|hmac-sha512
		# zone: # DNS record will be modified on this C(zone).
		# type: A
		# ttl: 3600
		# value: # Sets the record value.
$0
endsnippet

snippet ipify_facts "Retrieve the public IP of your internet gateway." b
- name: $1
	ipify_facts:
		# api_url: https://api.ipify.org
		# timeout: 10
		# validate_certs: yes
$0
endsnippet

snippet nmcli "Manage Networking" b
- name: $1
	nmcli:
		state: ${2:present|absent}
		conn_name: ${3:# Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]}
		# autoconnect: yes
		# ifname: conn_name
		# type: ethernet|team|team-slave|bond|bond-slave|bridge|bridge-slave|vlan|generic
		# mode: #balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb
		# master: # master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.
		# ip4: # The IPv4 address to this interface using this format ie: "192.0.2.24/24"
		# gw4: # The IPv4 gateway for this interface using this format ie: "192.0.2.1"
		# dns4: # A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: "192.0.2.53 198.51.100.53"
		# dns4_search: # A list of DNS search domains.
		# ip6: # The IPv6 address to this interface using this format ie: "abbe::cafe"
		# gw6: # The IPv6 gateway for this interface using this format ie: "2001:db8::1"
		# dns6: # A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: "2001:4860:4860::8888 2001:4860:4860::8844"
		# dns6_search: # A list of DNS search domains.
		# mtu: 1500
		# dhcp_client_id: # DHCP Client Identifier sent to the DHCP server.
		# primary: # This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'
		# miimon: 100
		# downdelay: # This is only used with bond - downdelay
		# updelay: # This is only used with bond - updelay
		# arp_interval: # This is only used with bond - ARP interval
		# arp_ip_target: # This is only used with bond - ARP IP target
		# stp: # This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge
		# priority: 128
		# forwarddelay: 15
		# hellotime: 2
		# maxage: 20
		# ageingtime: 300
		# mac: # This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)

		# slavepriority: 32
		# path_cost: 100
		# hairpin: yes
		# vlanid: # This is only used with VLAN - VLAN ID in range <0-4095>
		# vlandev: # This is only used with VLAN - parent device this VLAN is on, can use ifname
		# flags: # This is only used with VLAN - flags
		# ingress: # This is only used with VLAN - VLAN ingress priority mapping
		# egress: # This is only used with VLAN - VLAN egress priority mapping
$0
endsnippet

snippet dnsmadeeasy "Interface with dnsmadeeasy.com (a DNS hosting service)." b
- name: $1
	dnsmadeeasy:
		account_key: ${2:# Account API Key.}
		account_secret: ${3:# Account Secret Key.}
		domain: ${4:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution}
		state: ${5:present|absent}
		systemDescription: ${6:}
		maxEmails: ${7:1}
		protocol: ${8:TCP|UDP|#HTTP|DNS|SMTP|HTTPS}
		port: ${9:80}
		sensitivity: ${10:Low|#Medium|High}
		contactList: ${11:}
		# sandbox: no
		# record_name: # Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.
		# record_type: A|AAAA|CNAME|ANAME|HTTPRED|MX|NS|PTR|SRV|TXT
		# record_value: # Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"

		# record_ttl: 1800
		# validate_certs: yes
		# monitor: no
		# httpFqdn: # The fully qualified domain name used by the monitor.
		# httpFile: # The file at the Fqdn that the monitor queries for HTTP or HTTPS.
		# httpQueryString: # The string in the httpFile that the monitor queries for HTTP or HTTPS.
		# failover: no
		# autoFailover: no
		# ip1: # Primary IP address for the failover.
		# ip2: # Secondary IP address for the failover.
		# ip3: # Tertiary IP address for the failover.
		# ip4: # Quaternary IP address for the failover.
		# ip5: # Quinary IP address for the failover.
$0
endsnippet

snippet slurp "Slurps a file from remote nodes" b
- name: $1
	slurp:
		src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory.}
$0
endsnippet

snippet uri "Interacts with webservices" b
- name: $1
	uri:
		url: ${2:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}
		# dest: # A path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.
		# user: # A username for the module to use for Digest, Basic or WSSE authentication.
		# password: # A password for the module to use for Digest, Basic or WSSE authentication.
		# body: # The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON. If C(body_format) is set to 'form-urlencoded' it will convert a dictionary or list of tuples into an 'application/x-www-form-urlencoded' string. (Added in v2.7)
		# body_format: form-urlencoded|json|#raw
		# method: #GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH
		# return_content: no
		# force_basic_auth: no
		# follow_redirects: all|none|#safe
		# creates: # A filename, when it already exists, this step will not be run.
		# removes: # A filename, when it does not exist, this step will not be run.
		# status_code: 200
		# timeout: 30
		# HEADER_: # Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and will be removed in Ansible-2.9. Use I(headers) instead.
		# headers: # Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) or C(form-urlencoded) for I(body_format).
		# others: # All arguments accepted by the M(file) module also work here
		# validate_certs: yes
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, I(client_key) is not required
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If I(client_cert) contains both the certificate and key, this option is not required.
		# src: # Path to file to be submitted to the remote server. Cannot be used with I(body).
		# remote_src: no
$0
endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node" b
- name: $1
	get_url:
		url: ${2:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
		dest: ${3:# Absolute path of where to download the file to.}
		# tmp_dest: # Absolute path of where temporary file is downloaded to.
		# force: no
		# backup: no
		# sha256sum: 
		# checksum: 
		# use_proxy: yes
		# validate_certs: yes
		# timeout: 10
		# headers: # Add custom HTTP headers to a request in hash/dict format. The hash/dict format was added in 2.6. Previous versions used a C("key:value,key:value") string format. The C("key:value,key:value") string format is deprecated and will be removed in version 2.10.
		# url_username: # The username for use in HTTP basic authentication.
		# url_password: # The password for use in HTTP basic authentication.
		# force_basic_auth: no
		# client_cert: # PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.
		# client_key: # PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.
		# others: # all arguments accepted by the M(file) module also work here
		# mode: # Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like C(0644) or C(01777)) or quote it (like C('644') or C('1777')) so Ansible receives a string and can do its own conversion from string into number.  Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).
		# owner: # Name of the user that should own the file/directory, as would be fed to I(chown).
		# group: # Name of the group that should own the file/directory, as would be fed to I(chown).
		# seuser: # User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.
		# serole: # Role part of SELinux file context, C(_default) feature works as for I(seuser).
		# setype: # Type part of SELinux file context, C(_default) feature works as for I(seuser).
		# selevel: s0
		# unsafe_writes: no
		# attributes: # Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).
$0
endsnippet

snippet exo_dns_domain "Manages domain records on Exoscale DNS API." b
- name: $1
	exo_dns_domain:
		name: ${2:# Name of the record.}
		# state: #present|absent
		# api_key: # API key of the Exoscale DNS API.
		# api_secret: # Secret key of the Exoscale DNS API.
		# api_timeout: 10
		# api_region: cloudstack
		# validate_certs: yes
$0
endsnippet

snippet exo_dns_record "Manages DNS records on Exoscale DNS." b
- name: $1
	exo_dns_record:
		domain: ${2:# Domain the record is related to.}
		# name: 
		# record_type: #A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL
		# content: # Content of the record.
		# ttl: 3600
		# prio: # Priority of the record.
		# multiple: no
		# state: #present|absent
		# api_key: # API key of the Exoscale DNS API.
		# api_secret: # Secret key of the Exoscale DNS API.
		# api_timeout: 10
		# api_region: cloudstack
		# validate_certs: yes
$0
endsnippet

snippet nios_dns_view "Configure Infoblox NIOS DNS views" b
- name: $1
	nios_dns_view:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}
		network_view: ${3:default}
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_zone "Configure Infoblox NIOS DNS zones" b
- name: $1
	nios_zone:
		fqdn: ${2:# Specifies the qualified domain name to either add or remove from the NIOS instance based on the configured C(state) value.}
		view: ${3:default}
		# grid_primary: # Configures the grid primary servers for this zone.
		# grid_secondaries: # Configures the grid secondary servers for this zone.
		# ns_group: # Configures the name server group for this zone. Name server group is mutually exclusive with grid primary and grid secondaries.
		# restart_if_needed: # If set to true, causes the NIOS DNS service to restart and load the new zone configuration
		# zone_format: FORWARD
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_network "Configure Infoblox NIOS network object" b
- name: $1
	nios_network:
		network: ${2:# Specifies the network to add or remove from the system.  The value should use CIDR notation.}
		network_view: ${3:default}
		# options: # Configures the set of DHCP options to be included as part of the configured network instance.  This argument accepts a list of values (see suboptions).  When configuring suboptions at least one of C(name) or C(num) must be specified.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_txt_record "Configure Infoblox NIOS txt records" b
- name: $1
	nios_txt_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		# text: # Text associated with the record. It can contain up to 255 bytes per substring, up to a total of 512 bytes. To enter leading, trailing, or embedded spaces in the text, add quotes around the text to preserve the spaces.
		# ttl: # Configures the TTL to be associated with this tst record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_naptr_record "Configure Infoblox NIOS NAPTR records" b
- name: $1
	nios_naptr_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		order: ${4:# Configures the order (0-65535) for this NAPTR record. This parameter specifies the order in which the NAPTR rules are applied when multiple rules are present.}
		preference: ${5:# Configures the preference (0-65535) for this NAPTR record. The preference field determines the order NAPTR records are processed when multiple records with the same order parameter are present.}
		replacement: ${6:# Configures the replacement field for this NAPTR record. For nonterminal NAPTR records, this field specifies the next domain name to look up.}
		# services: # Configures the services field (128 characters maximum) for this NAPTR record. The services field contains protocol and service identifiers, such as "http+E2U" or "SIPS+D2T".
		# flags: # Configures the flags field for this NAPTR record. These control the interpretation of the fields for an NAPTR record object. Supported values for the flags field are "U", "S", "P" and "A".
		# regexp: # Configures the regexp field for this NAPTR record. This is the regular expression-based rewriting rule of the NAPTR record. This should be a POSIX compliant regular expression, including the substitution rule and flags. Refer to RFC 2915 for the field syntax details.
		# ttl: # Configures the TTL to be associated with this NAPTR record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_ptr_record "Configure Infoblox NIOS PTR records" b
- name: $1
	nios_ptr_record:
		ipv4addr: ${2:# The IPv4 Address of the record. Mutually exclusive with the ipv6addr.}
		ipv6addr: ${3:# The IPv6 Address of the record. Mutually exclusive with the ipv4addr.}
		ptrdname: ${4:# The domain name of the DNS PTR record in FQDN format.}
		# name: # The name of the DNS PTR record in FQDN format to add or remove from the system. The field is required only for an PTR object in Forward Mapping Zone.
		# view: # Sets the DNS view to associate this a record with. The DNS view must already be configured on the system
		# ttl: # Time To Live (TTL) value for the record. A 32-bit unsigned integer that represents the duration, in seconds, that the record is valid (cached). Zero indicates that the record should not be cached.
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance. Maximum 256 characters.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_host_record "Configure Infoblox NIOS host records" b
- name: $1
	nios_host_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}
		view: ${3:default}
		# configure_for_dns: yes
		# ipv4addrs: # Configures the IPv4 addresses for this host record.  This argument accepts a list of values (see suboptions)
		# ipv6addrs: # Configures the IPv6 addresses for the host record.  This argument accepts a list of values (see options)
		# aliases: # Configures an optional list of additional aliases to add to the host record. These are equivalent to CNAMEs but held within a host record. Must be in list format.
		# ttl: # Configures the TTL to be associated with this host record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_network_view "Configure Infoblox NIOS network views" b
- name: $1
	nios_network_view:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_srv_record "Configure Infoblox NIOS SRV records" b
- name: $1
	nios_srv_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		port: ${4:# Configures the port (0-65535) of this SRV record.}
		priority: ${5:# Configures the priority (0-65535) for this SRV record.}
		target: ${6:# Configures the target FQDN for this SRV record.}
		weight: ${7:# Configures the weight (0-65535) for this SRV record.}
		# ttl: # Configures the TTL to be associated with this host record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_mx_record "Configure Infoblox NIOS MX records" b
- name: $1
	nios_mx_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		mail_exchanger: ${4:# Configures the mail exchanger FQDN for this MX record.}
		preference: ${5:# Configures the preference (0-65535) for this MX record.}
		# ttl: # Configures the TTL to be associated with this host record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_cname_record "Configure Infoblox NIOS CNAME records" b
- name: $1
	nios_cname_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		canonical: ${4:# Configures the canonical name for this CNAME record.}
		# ttl: # Configures the TTL to be associated with this CNAME record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_a_record "Configure Infoblox NIOS A records" b
- name: $1
	nios_a_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		ipv4addr: ${4:# Configures the IPv4 address for this A record.}
		# ttl: # Configures the TTL to be associated with this A record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet nios_aaaa_record "Configure Infoblox NIOS AAAA records" b
- name: $1
	nios_aaaa_record:
		name: ${2:# Specifies the fully qualified hostname to add or remove from the system}
		view: ${3:default}
		ipv6addr: ${4:# Configures the IPv6 address for this AAAA record.}
		# ttl: # Configures the TTL to be associated with this AAAA record
		# extattrs: # Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.
		# comment: # Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.
		# state: #present|absent
		# provider: # A dict object containing connection details.
$0
endsnippet

snippet ldap_passwd "Set passwords in LDAP." b
- name: $1
	ldap_passwd:
		passwd: ${2:# The (plaintext) password to be set for I(dn).}
		dn: ${3:# The DN of the entry to add or remove.}
		# bind_dn: # A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.
		# bind_pw: # The password to use with I(bind_dn).
		# server_uri: ldapi:///
		# start_tls: no
		# validate_certs: yes
$0
endsnippet

snippet ldap_attr "Add or remove LDAP attribute values." b
- name: $1
	ldap_attr:
		name: ${2:# The name of the attribute to modify.}
		values: ${3:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}
		dn: ${4:# The DN of the entry to add or remove.}
		# state: #present|absent|exact
		# bind_dn: # A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.
		# bind_pw: # The password to use with I(bind_dn).
		# server_uri: ldapi:///
		# start_tls: no
		# validate_certs: yes
$0
endsnippet

snippet ldap_entry "Add or remove LDAP entries." b
- name: $1
	ldap_entry:
		dn: ${2:# The DN of the entry to add or remove.}
		# attributes: # If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.
		# objectClass: # If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.
		# params: # List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).
		# state: #present|absent
		# bind_dn: # A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.
		# bind_pw: # The password to use with I(bind_dn).
		# server_uri: ldapi:///
		# start_tls: no
		# validate_certs: yes
$0
endsnippet

snippet infinity "manage Infinity IPAM using Rest API" b
- name: $1
	infinity:
		server_ip: ${2:# Infinity server_ip with IP address}
		username: ${3:# Username to access Infinity}
		password: ${4:# Infinity password}
		action: ${5:reserve_next_available_ip|release_ip|delete_network|add_network|reserve_network|release_network|get_network_id}
		# network_id: 
		# ip_address: 
		# network_address: 
		# network_size: 
		# network_name: 
		# network_location: -1
		# network_type: #lan|shared_lan|supernet
		# network_family: 4|6|dual
$0
endsnippet

snippet rabbitmq_exchange "This module manages rabbitMQ exchanges" b
- name: $1
	rabbitmq_exchange:
		name: ${2:# Name of the exchange to create}
		# state: #present|absent
		# login_user: guest
		# login_password: no
		# login_host: localhost
		# login_port: 15672
		# vhost: /
		# durable: yes
		# exchange_type: fanout|#direct|headers|topic
		# auto_delete: no
		# internal: no
		# arguments: {}
$0
endsnippet

snippet rabbitmq_policy "Manage the state of policies in RabbitMQ." b
- name: $1
	rabbitmq_policy:
		name: ${2:# The name of the policy to manage.}
		pattern: ${3:# A regex of queues to apply the policy to.}
		tags: ${4:# A dict or string describing the policy.}
		# vhost: /
		# apply_to: #all|exchanges|queues
		# priority: 0
		# node: rabbit
		# state: #present|absent
$0
endsnippet

snippet rabbitmq_user "Adds or removes users to RabbitMQ" b
- name: $1
	rabbitmq_user:
		user: ${2:# Name of user to add}
		# password: # Password of user to add.
		# tags: # User tags specified as comma delimited
		# permissions: []
		# vhost: /
		# node: rabbit
		# configure_priv: ^$
		# write_priv: ^$
		# read_priv: ^$
		# force: no
		# state: #present|absent
		# update_password: #on_create|always
$0
endsnippet

snippet rabbitmq_binding "This module manages rabbitMQ bindings" b
- name: $1
	rabbitmq_binding:
		name: ${2:# source exchange to create binding on.}
		destination: ${3:# destination exchange or queue for the binding.}
		destination_type: ${4:queue|exchange}
		# state: #present|absent
		# login_user: guest
		# login_password: no
		# login_host: localhost
		# login_port: 15672
		# vhost: /
		# routing_key: #
		# arguments: {}
$0
endsnippet

snippet rabbitmq_vhost "Manage the state of a virtual host in RabbitMQ" b
- name: $1
	rabbitmq_vhost:
		name: ${2:# The name of the vhost to manage}
		# node: rabbit
		# tracing: no
		# state: #present|absent
$0
endsnippet

snippet rabbitmq_queue "This module manages rabbitMQ queues" b
- name: $1
	rabbitmq_queue:
		name: ${2:# Name of the queue to create}
		# state: #present|absent
		# login_user: guest
		# login_password: no
		# login_host: localhost
		# login_port: 15672
		# vhost: /
		# durable: yes
		# auto_delete: no
		# message_ttl: forever
		# auto_expires: forever
		# max_length: no limit
		# dead_letter_exchange: # Optional name of an exchange to which messages will be republished if they
		# dead_letter_routing_key: # Optional replacement routing key to use when a message is dead-lettered.
		# max_priority: # Maximum number of priority levels for the queue to support.
		# arguments: {}
$0
endsnippet

snippet rabbitmq_parameter "Adds or removes parameters to RabbitMQ" b
- name: $1
	rabbitmq_parameter:
		component: ${2:# Name of the component of which the parameter is being set}
		name: ${3:# Name of the parameter being set}
		# value: # Value of the parameter, as a JSON term
		# vhost: /
		# node: rabbit
		# state: #present|absent
$0
endsnippet

snippet rabbitmq_plugin "Manage RabbitMQ plugins" b
- name: $1
	rabbitmq_plugin:
		names: ${2:# Comma-separated list of plugin names.}
		# new_only: no
		# state: #enabled|disabled
		# prefix: # Specify a custom install prefix to a Rabbit.
$0
endsnippet

snippet git "Deploy software (or files) from git checkouts" b
- name: $1
	git:
		repo: ${2:# git, SSH, or HTTP(S) protocol address of the git repository.}
		dest: ${3:# The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no).}
		# version: HEAD
		# accept_hostkey: no
		# ssh_opts: # Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"
		# key_file: # Specify an optional private key file path, on the target host, to use for the checkout.
		# reference: # Reference repository (see "git clone --reference ...")
		# remote: origin
		# refspec: # Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".
		# force: no
		# depth: # Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.
		# clone: yes
		# update: yes
		# executable: # Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# bare: no
		# umask: # The umask to set before doing any checkouts, or any other repository maintenance.
		# recursive: yes
		# track_submodules: no
		# verify_commit: no
		# archive: # Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats ["zip", "tar.gz", "tar", "tgz"]
		# separate_git_dir: # The path to place the cloned repository. If specified, Git repository can be separated from working tree.
$0
endsnippet

snippet github_deploy_key "Manages deploy keys for GitHub repositories." b
- name: $1
	github_deploy_key:
		owner: ${2:# The name of the individual account or organization that owns the GitHub repository.}
		repo: ${3:# The name of the GitHub repository.}
		name: ${4:# The name for the deploy key.}
		key: ${5:# The SSH public key to add to the repository as a deploy key.}
		# read_only: yes
		# state: #present|absent
		# force: no
		# username: # The username to authenticate with.
		# password: # The password to authenticate with. A personal access token can be used here in place of a password.
		# token: # The OAuth2 token or personal access token to authenticate with. Mutually exclusive with I(password).
		# otp: # The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password).
$0
endsnippet

snippet github_issue "View GitHub issue." b
- name: $1
	github_issue:
		repo: ${2:# Name of repository from which issue needs to be retrieved.}
		organization: ${3:# Name of the GitHub organization in which the repository is hosted.}
		issue: ${4:# Issue number for which information is required.}
		# action: ['get_status']
$0
endsnippet

snippet github_release "Interact with GitHub Releases" b
- name: $1
	github_release:
		user: ${2:# The GitHub account that owns the repository}
		repo: ${3:# Repository name}
		action: ${4:latest_release|create_release}
		# token: # GitHub Personal Access Token for authenticating
		# password: # The GitHub account password for the user
		# tag: # Tag name when creating a release. Required when using action is set to C(create_release).
		# target: # Target of release when creating a release
		# name: # Name of release when creating a release
		# body: # Description of the release when creating a release
		# draft: no
		# prerelease: no
$0
endsnippet

snippet gitlab_hooks "Manages GitLab project hooks." b
- name: $1
	gitlab_hooks:
		api_url: ${2:# GitLab API url, e.g. https://gitlab.example.com/api}
		project: ${3:# Numeric project id or name of project in the form of group/name}
		hook_url: ${4:# The url that you want GitLab to post to, this is used as the primary key for updates and deletion.}
		state: ${5:#present|absent}
		# access_token: # The oauth key provided by GitLab. One of access_token or private_token is required. See https://docs.gitlab.com/ee/api/oauth2.html
		# private_token: # Personal access token to use. One of private_token or access_token is required. See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
		# push_events: yes
		# issues_events: no
		# merge_requests_events: no
		# tag_push_events: no
		# note_events: no
		# job_events: no
		# pipeline_events: no
		# wiki_page_events: no
		# enable_ssl_verification: no
		# token: # Secret token to validate hook messages at the receiver.
$0
endsnippet

snippet bzr "Deploy software (or files) from bzr branches" b
- name: $1
	bzr:
		name: ${2:# SSH or HTTP protocol address of the parent branch.}
		dest: ${3:# Absolute path of where the branch should be cloned to.}
		# version: head
		# force: no
		# executable: # Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
$0
endsnippet

snippet gitlab_deploy_key "Manages GitLab project deploy keys." b
- name: $1
	gitlab_deploy_key:
		api_url: ${2:# GitLab API url, e.g. https://gitlab.example.com/api}
		project: ${3:# Numeric project id or name of project in the form of group/name}
		title: ${4:# Deploy key's title}
		key: ${5:# Deploy key}
		state: ${6:#present|absent}
		# access_token: # The oauth key provided by GitLab. One of access_token or private_token is required. See https://docs.gitlab.com/ee/api/oauth2.html
		# private_token: # Personal access token to use. One of private_token or access_token is required. See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
		# can_push: no
$0
endsnippet

snippet git_config "Read and write git configuration" b
- name: $1
	git_config:
		# list_all: no
		# name: # The name of the setting. If no value is supplied, the value will be read from the config if it has been set.
		# repo: # Path to a git repository for reading and writing values from a specific repo.
		# scope: local|global|system
		# value: # When specifying the name of a single setting, supply a value to set that setting to the given value.
$0
endsnippet

snippet gitlab_group "Creates/updates/deletes Gitlab Groups" b
- name: $1
	gitlab_group:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# Name of the group you want to create.}
		# validate_certs: yes
		# login_user: # Gitlab user name.
		# login_password: # Gitlab password for login_user
		# login_token: # Gitlab token for logging in.
		# path: # The path of the group you want to create, this will be server_url/group_path
		# description: # A description for the group.
		# state: #present|absent
$0
endsnippet

snippet github_key "Manage GitHub access keys." b
- name: $1
	github_key:
		token: ${2:# GitHub Access Token with permission to list and create public keys.}
		name: ${3:# SSH key name}
		# pubkey: # SSH public key value. Required when C(state=present).
		# state: #present|absent
		# force: yes
$0
endsnippet

snippet gitlab_user "Creates/updates/deletes Gitlab Users" b
- name: $1
	gitlab_user:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# Name of the user you want to create}
		username: ${4:# The username of the user.}
		password: ${5:# The password of the user.}
		email: ${6:# The email that belongs to the user.}
		# validate_certs: yes
		# login_user: # Gitlab user name.
		# login_password: # Gitlab password for login_user
		# login_token: # Gitlab token for logging in.
		# sshkey_name: # The name of the sshkey
		# sshkey_file: # The ssh key itself.
		# group: # Add user as an member to this group.
		# access_level: # The access level to the group. One of the following can be used.
		# state: #present|absent
		# confirm: yes
$0
endsnippet

snippet hg "Manages Mercurial (hg) repositories" b
- name: $1
	hg:
		repo: ${2:# The repository address.}
		dest: ${3:# Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no}
		# revision: # Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.
		# force: no
		# purge: no
		# update: yes
		# clone: yes
		# executable: # Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
$0
endsnippet

snippet subversion "Deploys a subversion repository" b
- name: $1
	subversion:
		repo: ${2:# The subversion URL to the repository.}
		dest: ${3:# Absolute path where the repository should be deployed.}
		# revision: HEAD
		# force: no
		# in_place: no
		# username: # C(--username) parameter passed to svn.
		# password: # C(--password) parameter passed to svn.
		# executable: # Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
		# checkout: yes
		# update: yes
		# export: no
		# switch: yes
$0
endsnippet

snippet github_hooks "Manages GitHub service hooks." b
- name: $1
	github_hooks:
		user: ${2:# Github username.}
		oauthkey: ${3:# The oauth key provided by GitHub. It can be found/generated on GitHub under "Edit Your Profile" >> "Developer settings" >> "Personal Access Tokens"}
		repo: ${4:# This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.
}
		action: ${5:create|cleanall|list|clean504}
		# hookurl: # When creating a new hook, this is the url that you want GitHub to post to. It is only required when creating a new hook.
		# validate_certs: yes
		# content_type: #json|form
$0
endsnippet

snippet gitlab_project "Creates/updates/deletes Gitlab Projects" b
- name: $1
	gitlab_project:
		server_url: ${2:# Url of Gitlab server, with protocol (http or https).}
		name: ${3:# The name of the project}
		# validate_certs: yes
		# login_user: # Gitlab user name.
		# login_password: # Gitlab password for login_user
		# login_token: # Gitlab token for logging in.
		# group: # The name of the group of which this projects belongs to.
		# path: # The path of the project you want to create, this will be server_url/<group>/path
		# description: # An description for the project.
		# issues_enabled: yes
		# merge_requests_enabled: yes
		# wiki_enabled: yes
		# snippets_enabled: yes
		# public: no
		# visibility_level: 0
		# import_url: no
		# state: #present|absent
$0
endsnippet

